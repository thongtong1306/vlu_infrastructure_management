/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkjs"] = self["webpackChunkjs"] || []).push([["vendors-node_modules_html5-qrcode_esm_index_js"],{

/***/ "../../../node_modules/html5-qrcode/esm/camera/core-impl.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/camera/core-impl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraImpl: () => (/* binding */ CameraImpl)\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar AbstractCameraCapability = (function () {\n    function AbstractCameraCapability(name, track) {\n        this.name = name;\n        this.track = track;\n    }\n    AbstractCameraCapability.prototype.isSupported = function () {\n        if (!this.track.getCapabilities) {\n            return false;\n        }\n        return this.name in this.track.getCapabilities();\n    };\n    AbstractCameraCapability.prototype.apply = function (value) {\n        var constraint = {};\n        constraint[this.name] = value;\n        var constraints = { advanced: [constraint] };\n        return this.track.applyConstraints(constraints);\n    };\n    AbstractCameraCapability.prototype.value = function () {\n        var settings = this.track.getSettings();\n        if (this.name in settings) {\n            var settingValue = settings[this.name];\n            return settingValue;\n        }\n        return null;\n    };\n    return AbstractCameraCapability;\n}());\nvar AbstractRangeCameraCapability = (function (_super) {\n    __extends(AbstractRangeCameraCapability, _super);\n    function AbstractRangeCameraCapability(name, track) {\n        return _super.call(this, name, track) || this;\n    }\n    AbstractRangeCameraCapability.prototype.min = function () {\n        return this.getCapabilities().min;\n    };\n    AbstractRangeCameraCapability.prototype.max = function () {\n        return this.getCapabilities().max;\n    };\n    AbstractRangeCameraCapability.prototype.step = function () {\n        return this.getCapabilities().step;\n    };\n    AbstractRangeCameraCapability.prototype.apply = function (value) {\n        var constraint = {};\n        constraint[this.name] = value;\n        var constraints = { advanced: [constraint] };\n        return this.track.applyConstraints(constraints);\n    };\n    AbstractRangeCameraCapability.prototype.getCapabilities = function () {\n        this.failIfNotSupported();\n        var capabilities = this.track.getCapabilities();\n        var capability = capabilities[this.name];\n        return {\n            min: capability.min,\n            max: capability.max,\n            step: capability.step,\n        };\n    };\n    AbstractRangeCameraCapability.prototype.failIfNotSupported = function () {\n        if (!this.isSupported()) {\n            throw new Error(\"\".concat(this.name, \" capability not supported\"));\n        }\n    };\n    return AbstractRangeCameraCapability;\n}(AbstractCameraCapability));\nvar ZoomFeatureImpl = (function (_super) {\n    __extends(ZoomFeatureImpl, _super);\n    function ZoomFeatureImpl(track) {\n        return _super.call(this, \"zoom\", track) || this;\n    }\n    return ZoomFeatureImpl;\n}(AbstractRangeCameraCapability));\nvar TorchFeatureImpl = (function (_super) {\n    __extends(TorchFeatureImpl, _super);\n    function TorchFeatureImpl(track) {\n        return _super.call(this, \"torch\", track) || this;\n    }\n    return TorchFeatureImpl;\n}(AbstractCameraCapability));\nvar CameraCapabilitiesImpl = (function () {\n    function CameraCapabilitiesImpl(track) {\n        this.track = track;\n    }\n    CameraCapabilitiesImpl.prototype.zoomFeature = function () {\n        return new ZoomFeatureImpl(this.track);\n    };\n    CameraCapabilitiesImpl.prototype.torchFeature = function () {\n        return new TorchFeatureImpl(this.track);\n    };\n    return CameraCapabilitiesImpl;\n}());\nvar RenderedCameraImpl = (function () {\n    function RenderedCameraImpl(parentElement, mediaStream, callbacks) {\n        this.isClosed = false;\n        this.parentElement = parentElement;\n        this.mediaStream = mediaStream;\n        this.callbacks = callbacks;\n        this.surface = this.createVideoElement(this.parentElement.clientWidth);\n        parentElement.append(this.surface);\n    }\n    RenderedCameraImpl.prototype.createVideoElement = function (width) {\n        var videoElement = document.createElement(\"video\");\n        videoElement.style.width = \"\".concat(width, \"px\");\n        videoElement.style.display = \"block\";\n        videoElement.muted = true;\n        videoElement.setAttribute(\"muted\", \"true\");\n        videoElement.playsInline = true;\n        return videoElement;\n    };\n    RenderedCameraImpl.prototype.setupSurface = function () {\n        var _this = this;\n        this.surface.onabort = function () {\n            throw \"RenderedCameraImpl video surface onabort() called\";\n        };\n        this.surface.onerror = function () {\n            throw \"RenderedCameraImpl video surface onerror() called\";\n        };\n        var onVideoStart = function () {\n            var videoWidth = _this.surface.clientWidth;\n            var videoHeight = _this.surface.clientHeight;\n            _this.callbacks.onRenderSurfaceReady(videoWidth, videoHeight);\n            _this.surface.removeEventListener(\"playing\", onVideoStart);\n        };\n        this.surface.addEventListener(\"playing\", onVideoStart);\n        this.surface.srcObject = this.mediaStream;\n        this.surface.play();\n    };\n    RenderedCameraImpl.create = function (parentElement, mediaStream, options, callbacks) {\n        return __awaiter(this, void 0, void 0, function () {\n            var renderedCamera, aspectRatioConstraint;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        renderedCamera = new RenderedCameraImpl(parentElement, mediaStream, callbacks);\n                        if (!options.aspectRatio) return [3, 2];\n                        aspectRatioConstraint = {\n                            aspectRatio: options.aspectRatio\n                        };\n                        return [4, renderedCamera.getFirstTrackOrFail().applyConstraints(aspectRatioConstraint)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        renderedCamera.setupSurface();\n                        return [2, renderedCamera];\n                }\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.failIfClosed = function () {\n        if (this.isClosed) {\n            throw \"The RenderedCamera has already been closed.\";\n        }\n    };\n    RenderedCameraImpl.prototype.getFirstTrackOrFail = function () {\n        this.failIfClosed();\n        if (this.mediaStream.getVideoTracks().length === 0) {\n            throw \"No video tracks found\";\n        }\n        return this.mediaStream.getVideoTracks()[0];\n    };\n    RenderedCameraImpl.prototype.pause = function () {\n        this.failIfClosed();\n        this.surface.pause();\n    };\n    RenderedCameraImpl.prototype.resume = function (onResumeCallback) {\n        this.failIfClosed();\n        var $this = this;\n        var onVideoResume = function () {\n            setTimeout(onResumeCallback, 200);\n            $this.surface.removeEventListener(\"playing\", onVideoResume);\n        };\n        this.surface.addEventListener(\"playing\", onVideoResume);\n        this.surface.play();\n    };\n    RenderedCameraImpl.prototype.isPaused = function () {\n        this.failIfClosed();\n        return this.surface.paused;\n    };\n    RenderedCameraImpl.prototype.getSurface = function () {\n        this.failIfClosed();\n        return this.surface;\n    };\n    RenderedCameraImpl.prototype.getRunningTrackCapabilities = function () {\n        return this.getFirstTrackOrFail().getCapabilities();\n    };\n    RenderedCameraImpl.prototype.getRunningTrackSettings = function () {\n        return this.getFirstTrackOrFail().getSettings();\n    };\n    RenderedCameraImpl.prototype.applyVideoConstraints = function (constraints) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (\"aspectRatio\" in constraints) {\n                    throw \"Changing 'aspectRatio' in run-time is not yet supported.\";\n                }\n                return [2, this.getFirstTrackOrFail().applyConstraints(constraints)];\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.close = function () {\n        if (this.isClosed) {\n            return Promise.resolve();\n        }\n        var $this = this;\n        return new Promise(function (resolve, _) {\n            var tracks = $this.mediaStream.getVideoTracks();\n            var tracksToClose = tracks.length;\n            var tracksClosed = 0;\n            $this.mediaStream.getVideoTracks().forEach(function (videoTrack) {\n                $this.mediaStream.removeTrack(videoTrack);\n                videoTrack.stop();\n                ++tracksClosed;\n                if (tracksClosed >= tracksToClose) {\n                    $this.isClosed = true;\n                    $this.parentElement.removeChild($this.surface);\n                    resolve();\n                }\n            });\n        });\n    };\n    RenderedCameraImpl.prototype.getCapabilities = function () {\n        return new CameraCapabilitiesImpl(this.getFirstTrackOrFail());\n    };\n    return RenderedCameraImpl;\n}());\nvar CameraImpl = (function () {\n    function CameraImpl(mediaStream) {\n        this.mediaStream = mediaStream;\n    }\n    CameraImpl.prototype.render = function (parentElement, options, callbacks) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2, RenderedCameraImpl.create(parentElement, this.mediaStream, options, callbacks)];\n            });\n        });\n    };\n    CameraImpl.create = function (videoConstraints) {\n        return __awaiter(this, void 0, void 0, function () {\n            var constraints, mediaStream;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!navigator.mediaDevices) {\n                            throw \"navigator.mediaDevices not supported\";\n                        }\n                        constraints = {\n                            audio: false,\n                            video: videoConstraints\n                        };\n                        return [4, navigator.mediaDevices.getUserMedia(constraints)];\n                    case 1:\n                        mediaStream = _a.sent();\n                        return [2, new CameraImpl(mediaStream)];\n                }\n            });\n        });\n    };\n    return CameraImpl;\n}());\n\n//# sourceMappingURL=core-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL2NvcmUtaW1wbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL2NhbWVyYS9jb3JlLWltcGwuanM/YWNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIEFic3RyYWN0Q2FtZXJhQ2FwYWJpbGl0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5KG5hbWUsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICB9XG4gICAgQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyYWNrLmdldENhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgaW4gdGhpcy50cmFjay5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2FtZXJhQ2FwYWJpbGl0eS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSB7fTtcbiAgICAgICAgY29uc3RyYWludFt0aGlzLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHsgYWR2YW5jZWQ6IFtjb25zdHJhaW50XSB9O1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjay5hcHBseUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2FtZXJhQ2FwYWJpbGl0eS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMudHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKHRoaXMubmFtZSBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdWYWx1ZSA9IHNldHRpbmdzW3RoaXMubmFtZV07XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0Q2FtZXJhQ2FwYWJpbGl0eTtcbn0oKSk7XG52YXIgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eShuYW1lLCB0cmFjaykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgdHJhY2spIHx8IHRoaXM7XG4gICAgfVxuICAgIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhcGFiaWxpdGllcygpLm1pbjtcbiAgICB9O1xuICAgIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhcGFiaWxpdGllcygpLm1heDtcbiAgICB9O1xuICAgIEFic3RyYWN0UmFuZ2VDYW1lcmFDYXBhYmlsaXR5LnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXBhYmlsaXRpZXMoKS5zdGVwO1xuICAgIH07XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50ID0ge307XG4gICAgICAgIGNvbnN0cmFpbnRbdGhpcy5uYW1lXSA9IHZhbHVlO1xuICAgICAgICB2YXIgY29uc3RyYWludHMgPSB7IGFkdmFuY2VkOiBbY29uc3RyYWludF0gfTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2suYXBwbHlDb25zdHJhaW50cyhjb25zdHJhaW50cyk7XG4gICAgfTtcbiAgICBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eS5wcm90b3R5cGUuZ2V0Q2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZhaWxJZk5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB2YXIgY2FwYWJpbGl0aWVzID0gdGhpcy50cmFjay5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICAgICAgdmFyIGNhcGFiaWxpdHkgPSBjYXBhYmlsaXRpZXNbdGhpcy5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogY2FwYWJpbGl0eS5taW4sXG4gICAgICAgICAgICBtYXg6IGNhcGFiaWxpdHkubWF4LFxuICAgICAgICAgICAgc3RlcDogY2FwYWJpbGl0eS5zdGVwLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQWJzdHJhY3RSYW5nZUNhbWVyYUNhcGFiaWxpdHkucHJvdG90eXBlLmZhaWxJZk5vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiIGNhcGFiaWxpdHkgbm90IHN1cHBvcnRlZFwiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eTtcbn0oQWJzdHJhY3RDYW1lcmFDYXBhYmlsaXR5KSk7XG52YXIgWm9vbUZlYXR1cmVJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWm9vbUZlYXR1cmVJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFpvb21GZWF0dXJlSW1wbCh0cmFjaykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJ6b29tXCIsIHRyYWNrKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gWm9vbUZlYXR1cmVJbXBsO1xufShBYnN0cmFjdFJhbmdlQ2FtZXJhQ2FwYWJpbGl0eSkpO1xudmFyIFRvcmNoRmVhdHVyZUltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb3JjaEZlYXR1cmVJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvcmNoRmVhdHVyZUltcGwodHJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwidG9yY2hcIiwgdHJhY2spIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUb3JjaEZlYXR1cmVJbXBsO1xufShBYnN0cmFjdENhbWVyYUNhcGFiaWxpdHkpKTtcbnZhciBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFDYXBhYmlsaXRpZXNJbXBsKHRyYWNrKSB7XG4gICAgICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICB9XG4gICAgQ2FtZXJhQ2FwYWJpbGl0aWVzSW1wbC5wcm90b3R5cGUuem9vbUZlYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9vbUZlYXR1cmVJbXBsKHRoaXMudHJhY2spO1xuICAgIH07XG4gICAgQ2FtZXJhQ2FwYWJpbGl0aWVzSW1wbC5wcm90b3R5cGUudG9yY2hGZWF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvcmNoRmVhdHVyZUltcGwodGhpcy50cmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhQ2FwYWJpbGl0aWVzSW1wbDtcbn0oKSk7XG52YXIgUmVuZGVyZWRDYW1lcmFJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlZENhbWVyYUltcGwocGFyZW50RWxlbWVudCwgbWVkaWFTdHJlYW0sIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW0gPSBtZWRpYVN0cmVhbTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMuc3VyZmFjZSA9IHRoaXMuY3JlYXRlVmlkZW9FbGVtZW50KHRoaXMucGFyZW50RWxlbWVudC5jbGllbnRXaWR0aCk7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kKHRoaXMuc3VyZmFjZSk7XG4gICAgfVxuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuY3JlYXRlVmlkZW9FbGVtZW50ID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICAgIHZhciB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgIHZpZGVvRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICAgICAgICB2aWRlb0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdmlkZW9FbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcIm11dGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZpZGVvRWxlbWVudDtcbiAgICB9O1xuICAgIFJlbmRlcmVkQ2FtZXJhSW1wbC5wcm90b3R5cGUuc2V0dXBTdXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN1cmZhY2Uub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IFwiUmVuZGVyZWRDYW1lcmFJbXBsIHZpZGVvIHN1cmZhY2Ugb25hYm9ydCgpIGNhbGxlZFwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1cmZhY2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IFwiUmVuZGVyZWRDYW1lcmFJbXBsIHZpZGVvIHN1cmZhY2Ugb25lcnJvcigpIGNhbGxlZFwiO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25WaWRlb1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZpZGVvV2lkdGggPSBfdGhpcy5zdXJmYWNlLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgdmFyIHZpZGVvSGVpZ2h0ID0gX3RoaXMuc3VyZmFjZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBfdGhpcy5jYWxsYmFja3Mub25SZW5kZXJTdXJmYWNlUmVhZHkodmlkZW9XaWR0aCwgdmlkZW9IZWlnaHQpO1xuICAgICAgICAgICAgX3RoaXMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLCBvblZpZGVvU3RhcnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgb25WaWRlb1N0YXJ0KTtcbiAgICAgICAgdGhpcy5zdXJmYWNlLnNyY09iamVjdCA9IHRoaXMubWVkaWFTdHJlYW07XG4gICAgICAgIHRoaXMuc3VyZmFjZS5wbGF5KCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG1lZGlhU3RyZWFtLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkQ2FtZXJhLCBhc3BlY3RSYXRpb0NvbnN0cmFpbnQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZENhbWVyYSA9IG5ldyBSZW5kZXJlZENhbWVyYUltcGwocGFyZW50RWxlbWVudCwgbWVkaWFTdHJlYW0sIGNhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuYXNwZWN0UmF0aW8pIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3BlY3RSYXRpb0NvbnN0cmFpbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IG9wdGlvbnMuYXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlbmRlcmVkQ2FtZXJhLmdldEZpcnN0VHJhY2tPckZhaWwoKS5hcHBseUNvbnN0cmFpbnRzKGFzcGVjdFJhdGlvQ29uc3RyYWludCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQ2FtZXJhLnNldHVwU3VyZmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZW5kZXJlZENhbWVyYV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5mYWlsSWZDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlRoZSBSZW5kZXJlZENhbWVyYSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5nZXRGaXJzdFRyYWNrT3JGYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZhaWxJZkNsb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5tZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgXCJObyB2aWRlbyB0cmFja3MgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mYWlsSWZDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5zdXJmYWNlLnBhdXNlKCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChvblJlc3VtZUNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZmFpbElmQ2xvc2VkKCk7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvblZpZGVvUmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChvblJlc3VtZUNhbGxiYWNrLCAyMDApO1xuICAgICAgICAgICAgJHRoaXMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLCBvblZpZGVvUmVzdW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdXJmYWNlLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIG9uVmlkZW9SZXN1bWUpO1xuICAgICAgICB0aGlzLnN1cmZhY2UucGxheSgpO1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mYWlsSWZDbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VyZmFjZS5wYXVzZWQ7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldFN1cmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmFpbElmQ2xvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cmZhY2U7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmdldFJ1bm5pbmdUcmFja0NhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RUcmFja09yRmFpbCgpLmdldENhcGFiaWxpdGllcygpO1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RUcmFja09yRmFpbCgpLmdldFNldHRpbmdzKCk7XG4gICAgfTtcbiAgICBSZW5kZXJlZENhbWVyYUltcGwucHJvdG90eXBlLmFwcGx5VmlkZW9Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiYXNwZWN0UmF0aW9cIiBpbiBjb25zdHJhaW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkNoYW5naW5nICdhc3BlY3RSYXRpbycgaW4gcnVuLXRpbWUgaXMgbm90IHlldCBzdXBwb3J0ZWQuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXRGaXJzdFRyYWNrT3JGYWlsKCkuYXBwbHlDb25zdHJhaW50cyhjb25zdHJhaW50cyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIF8pIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSAkdGhpcy5tZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICAgICAgdmFyIHRyYWNrc1RvQ2xvc2UgPSB0cmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRyYWNrc0Nsb3NlZCA9IDA7XG4gICAgICAgICAgICAkdGhpcy5tZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5tZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh2aWRlb1RyYWNrKTtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICArK3RyYWNrc0Nsb3NlZDtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tzQ2xvc2VkID49IHRyYWNrc1RvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKCR0aGlzLnN1cmZhY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVuZGVyZWRDYW1lcmFJbXBsLnByb3RvdHlwZS5nZXRDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FtZXJhQ2FwYWJpbGl0aWVzSW1wbCh0aGlzLmdldEZpcnN0VHJhY2tPckZhaWwoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVyZWRDYW1lcmFJbXBsO1xufSgpKTtcbnZhciBDYW1lcmFJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFJbXBsKG1lZGlhU3RyZWFtKSB7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW0gPSBtZWRpYVN0cmVhbTtcbiAgICB9XG4gICAgQ2FtZXJhSW1wbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBSZW5kZXJlZENhbWVyYUltcGwuY3JlYXRlKHBhcmVudEVsZW1lbnQsIHRoaXMubWVkaWFTdHJlYW0sIG9wdGlvbnMsIGNhbGxiYWNrcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FtZXJhSW1wbC5jcmVhdGUgPSBmdW5jdGlvbiAodmlkZW9Db25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludHMsIG1lZGlhU3RyZWFtO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIG5vdCBzdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlbzogdmlkZW9Db25zdHJhaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG5ldyBDYW1lcmFJbXBsKG1lZGlhU3RyZWFtKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbWVyYUltcGw7XG59KCkpO1xuZXhwb3J0IHsgQ2FtZXJhSW1wbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/camera/core-impl.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/camera/factories.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/camera/factories.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraFactory: () => (/* binding */ CameraFactory)\n/* harmony export */ });\n/* harmony import */ var _core_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-impl */ \"../../../node_modules/html5-qrcode/esm/camera/core-impl.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar CameraFactory = (function () {\n    function CameraFactory() {\n    }\n    CameraFactory.failIfNotSupported = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!navigator.mediaDevices) {\n                    throw \"navigator.mediaDevices not supported\";\n                }\n                return [2, new CameraFactory()];\n            });\n        });\n    };\n    CameraFactory.prototype.create = function (videoConstraints) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2, _core_impl__WEBPACK_IMPORTED_MODULE_0__.CameraImpl.create(videoConstraints)];\n            });\n        });\n    };\n    return CameraFactory;\n}());\n\n//# sourceMappingURL=factories.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL2ZhY3Rvcmllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL2ZhY3Rvcmllcy5qcz83M2ZkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IENhbWVyYUltcGwgfSBmcm9tIFwiLi9jb3JlLWltcGxcIjtcbnZhciBDYW1lcmFGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFGYWN0b3J5KCkge1xuICAgIH1cbiAgICBDYW1lcmFGYWN0b3J5LmZhaWxJZk5vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIm5hdmlnYXRvci5tZWRpYURldmljZXMgbm90IHN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG5ldyBDYW1lcmFGYWN0b3J5KCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FtZXJhRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgQ2FtZXJhSW1wbC5jcmVhdGUodmlkZW9Db25zdHJhaW50cyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbWVyYUZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0IHsgQ2FtZXJhRmFjdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFjdG9yaWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/camera/factories.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/camera/permissions.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/camera/permissions.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraPermissions: () => (/* binding */ CameraPermissions)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar CameraPermissions = (function () {\n    function CameraPermissions() {\n    }\n    CameraPermissions.hasPermissions = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var devices, _i, devices_1, device;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, navigator.mediaDevices.enumerateDevices()];\n                    case 1:\n                        devices = _a.sent();\n                        for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {\n                            device = devices_1[_i];\n                            if (device.kind === \"videoinput\" && device.label) {\n                                return [2, true];\n                            }\n                        }\n                        return [2, false];\n                }\n            });\n        });\n    };\n    return CameraPermissions;\n}());\n\n//# sourceMappingURL=permissions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL3Blcm1pc3Npb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL3Blcm1pc3Npb25zLmpzPzVjYWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIENhbWVyYVBlcm1pc3Npb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFQZXJtaXNzaW9ucygpIHtcbiAgICB9XG4gICAgQ2FtZXJhUGVybWlzc2lvbnMuaGFzUGVybWlzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VzLCBfaSwgZGV2aWNlc18xLCBkZXZpY2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIGRldmljZXNfMSA9IGRldmljZXM7IF9pIDwgZGV2aWNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS5raW5kID09PSBcInZpZGVvaW5wdXRcIiAmJiBkZXZpY2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGZhbHNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhUGVybWlzc2lvbnM7XG59KCkpO1xuZXhwb3J0IHsgQ2FtZXJhUGVybWlzc2lvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcm1pc3Npb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/camera/permissions.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/camera/retriever.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/camera/retriever.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraRetriever: () => (/* binding */ CameraRetriever)\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar CameraRetriever = (function () {\n    function CameraRetriever() {\n    }\n    CameraRetriever.retrieve = function () {\n        if (navigator.mediaDevices) {\n            return CameraRetriever.getCamerasFromMediaDevices();\n        }\n        var mst = MediaStreamTrack;\n        if (MediaStreamTrack && mst.getSources) {\n            return CameraRetriever.getCamerasFromMediaStreamTrack();\n        }\n        return CameraRetriever.rejectWithError();\n    };\n    CameraRetriever.rejectWithError = function () {\n        var errorMessage = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeStrings.unableToQuerySupportedDevices();\n        if (!CameraRetriever.isHttpsOrLocalhost()) {\n            errorMessage = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeStrings.insecureContextCameraQueryError();\n        }\n        return Promise.reject(errorMessage);\n    };\n    CameraRetriever.isHttpsOrLocalhost = function () {\n        if (location.protocol === \"https:\") {\n            return true;\n        }\n        var host = location.host.split(\":\")[0];\n        return host === \"127.0.0.1\" || host === \"localhost\";\n    };\n    CameraRetriever.getCamerasFromMediaDevices = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var closeActiveStreams, mediaStream, devices, results, _i, devices_1, device;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        closeActiveStreams = function (stream) {\n                            var tracks = stream.getVideoTracks();\n                            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {\n                                var track = tracks_1[_i];\n                                track.enabled = false;\n                                track.stop();\n                                stream.removeTrack(track);\n                            }\n                        };\n                        return [4, navigator.mediaDevices.getUserMedia({ audio: false, video: true })];\n                    case 1:\n                        mediaStream = _a.sent();\n                        return [4, navigator.mediaDevices.enumerateDevices()];\n                    case 2:\n                        devices = _a.sent();\n                        results = [];\n                        for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {\n                            device = devices_1[_i];\n                            if (device.kind === \"videoinput\") {\n                                results.push({\n                                    id: device.deviceId,\n                                    label: device.label\n                                });\n                            }\n                        }\n                        closeActiveStreams(mediaStream);\n                        return [2, results];\n                }\n            });\n        });\n    };\n    CameraRetriever.getCamerasFromMediaStreamTrack = function () {\n        return new Promise(function (resolve, _) {\n            var callback = function (sourceInfos) {\n                var results = [];\n                for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {\n                    var sourceInfo = sourceInfos_1[_i];\n                    if (sourceInfo.kind === \"video\") {\n                        results.push({\n                            id: sourceInfo.id,\n                            label: sourceInfo.label\n                        });\n                    }\n                }\n                resolve(results);\n            };\n            var mst = MediaStreamTrack;\n            mst.getSources(callback);\n        });\n    };\n    return CameraRetriever;\n}());\n\n//# sourceMappingURL=retriever.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL3JldHJpZXZlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY2FtZXJhL3JldHJpZXZlci5qcz81ZmQxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9IGZyb20gXCIuLi9zdHJpbmdzXCI7XG52YXIgQ2FtZXJhUmV0cmlldmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFSZXRyaWV2ZXIoKSB7XG4gICAgfVxuICAgIENhbWVyYVJldHJpZXZlci5yZXRyaWV2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBDYW1lcmFSZXRyaWV2ZXIuZ2V0Q2FtZXJhc0Zyb21NZWRpYURldmljZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXN0ID0gTWVkaWFTdHJlYW1UcmFjaztcbiAgICAgICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgbXN0LmdldFNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBDYW1lcmFSZXRyaWV2ZXIuZ2V0Q2FtZXJhc0Zyb21NZWRpYVN0cmVhbVRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbWVyYVJldHJpZXZlci5yZWplY3RXaXRoRXJyb3IoKTtcbiAgICB9O1xuICAgIENhbWVyYVJldHJpZXZlci5yZWplY3RXaXRoRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBIdG1sNVFyY29kZVN0cmluZ3MudW5hYmxlVG9RdWVyeVN1cHBvcnRlZERldmljZXMoKTtcbiAgICAgICAgaWYgKCFDYW1lcmFSZXRyaWV2ZXIuaXNIdHRwc09yTG9jYWxob3N0KCkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IEh0bWw1UXJjb2RlU3RyaW5ncy5pbnNlY3VyZUNvbnRleHRDYW1lcmFRdWVyeUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yTWVzc2FnZSk7XG4gICAgfTtcbiAgICBDYW1lcmFSZXRyaWV2ZXIuaXNIdHRwc09yTG9jYWxob3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob3N0ID0gbG9jYXRpb24uaG9zdC5zcGxpdChcIjpcIilbMF07XG4gICAgICAgIHJldHVybiBob3N0ID09PSBcIjEyNy4wLjAuMVwiIHx8IGhvc3QgPT09IFwibG9jYWxob3N0XCI7XG4gICAgfTtcbiAgICBDYW1lcmFSZXRyaWV2ZXIuZ2V0Q2FtZXJhc0Zyb21NZWRpYURldmljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZUFjdGl2ZVN0cmVhbXMsIG1lZGlhU3RyZWFtLCBkZXZpY2VzLCByZXN1bHRzLCBfaSwgZGV2aWNlc18xLCBkZXZpY2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUFjdGl2ZVN0cmVhbXMgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdHJhY2tzXzEgPSB0cmFja3M7IF9pIDwgdHJhY2tzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogZmFsc2UsIHZpZGVvOiB0cnVlIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWFTdHJlYW0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBkZXZpY2VzXzEgPSBkZXZpY2VzOyBfaSA8IGRldmljZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2UgPSBkZXZpY2VzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXZpY2Uua2luZCA9PT0gXCJ2aWRlb2lucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkZXZpY2UuZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZGV2aWNlLmxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWN0aXZlU3RyZWFtcyhtZWRpYVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3VsdHNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbWVyYVJldHJpZXZlci5nZXRDYW1lcmFzRnJvbU1lZGlhU3RyZWFtVHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgXykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHNvdXJjZUluZm9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZUluZm9zXzEgPSBzb3VyY2VJbmZvczsgX2kgPCBzb3VyY2VJbmZvc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHNvdXJjZUluZm9zXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlSW5mby5raW5kID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZUluZm8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHNvdXJjZUluZm8ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1zdCA9IE1lZGlhU3RyZWFtVHJhY2s7XG4gICAgICAgICAgICBtc3QuZ2V0U291cmNlcyhjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENhbWVyYVJldHJpZXZlcjtcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFSZXRyaWV2ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJpZXZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/camera/retriever.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/code-decoder.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/code-decoder.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeShim: () => (/* binding */ Html5QrcodeShim)\n/* harmony export */ });\n/* harmony import */ var _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zxing-html5-qrcode-decoder */ \"../../../node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js\");\n/* harmony import */ var _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./native-bar-code-detector */ \"../../../node_modules/html5-qrcode/esm/native-bar-code-detector.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\nvar Html5QrcodeShim = (function () {\n    function Html5QrcodeShim(requestedFormats, useBarCodeDetectorIfSupported, verbose, logger) {\n        this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;\n        this.executions = 0;\n        this.executionResults = [];\n        this.wasPrimaryDecoderUsedInLastDecode = false;\n        this.verbose = verbose;\n        if (useBarCodeDetectorIfSupported\n            && _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetectorDelegate.isSupported()) {\n            this.primaryDecoder = new _native_bar_code_detector__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetectorDelegate(requestedFormats, verbose, logger);\n            this.secondaryDecoder = new _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__.ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);\n        }\n        else {\n            this.primaryDecoder = new _zxing_html5_qrcode_decoder__WEBPACK_IMPORTED_MODULE_0__.ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);\n        }\n    }\n    Html5QrcodeShim.prototype.decodeAsync = function (canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var startTime;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        startTime = performance.now();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 3, 4]);\n                        return [4, this.getDecoder().decodeAsync(canvas)];\n                    case 2: return [2, _a.sent()];\n                    case 3:\n                        this.possiblyLogPerformance(startTime);\n                        return [7];\n                    case 4: return [2];\n                }\n            });\n        });\n    };\n    Html5QrcodeShim.prototype.decodeRobustlyAsync = function (canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var startTime, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        startTime = performance.now();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        return [4, this.primaryDecoder.decodeAsync(canvas)];\n                    case 2: return [2, _a.sent()];\n                    case 3:\n                        error_1 = _a.sent();\n                        if (this.secondaryDecoder) {\n                            return [2, this.secondaryDecoder.decodeAsync(canvas)];\n                        }\n                        throw error_1;\n                    case 4:\n                        this.possiblyLogPerformance(startTime);\n                        return [7];\n                    case 5: return [2];\n                }\n            });\n        });\n    };\n    Html5QrcodeShim.prototype.getDecoder = function () {\n        if (!this.secondaryDecoder) {\n            return this.primaryDecoder;\n        }\n        if (this.wasPrimaryDecoderUsedInLastDecode === false) {\n            this.wasPrimaryDecoderUsedInLastDecode = true;\n            return this.primaryDecoder;\n        }\n        this.wasPrimaryDecoderUsedInLastDecode = false;\n        return this.secondaryDecoder;\n    };\n    Html5QrcodeShim.prototype.possiblyLogPerformance = function (startTime) {\n        if (!this.verbose) {\n            return;\n        }\n        var executionTime = performance.now() - startTime;\n        this.executionResults.push(executionTime);\n        this.executions++;\n        this.possiblyFlushPerformanceReport();\n    };\n    Html5QrcodeShim.prototype.possiblyFlushPerformanceReport = function () {\n        if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {\n            return;\n        }\n        var sum = 0;\n        for (var _i = 0, _a = this.executionResults; _i < _a.length; _i++) {\n            var executionTime = _a[_i];\n            sum += executionTime;\n        }\n        var mean = sum / this.executionResults.length;\n        console.log(\"\".concat(mean, \" ms for \").concat(this.executionResults.length, \" last runs.\"));\n        this.executions = 0;\n        this.executionResults = [];\n    };\n    return Html5QrcodeShim;\n}());\n\n//# sourceMappingURL=code-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY29kZS1kZWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL2NvZGUtZGVjb2Rlci5qcz9iZDE2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IFpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyIH0gZnJvbSBcIi4venhpbmctaHRtbDUtcXJjb2RlLWRlY29kZXJcIjtcbmltcG9ydCB7IEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlIH0gZnJvbSBcIi4vbmF0aXZlLWJhci1jb2RlLWRldGVjdG9yXCI7XG52YXIgSHRtbDVRcmNvZGVTaGltID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZVNoaW0ocmVxdWVzdGVkRm9ybWF0cywgdXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQsIHZlcmJvc2UsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLkVYRUNVVElPTlNfVE9fUkVQT1JUX1BFUkZPUk1BTkNFID0gMTAwO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbnMgPSAwO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvblJlc3VsdHMgPSBbXTtcbiAgICAgICAgdGhpcy53YXNQcmltYXJ5RGVjb2RlclVzZWRJbkxhc3REZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcbiAgICAgICAgaWYgKHVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkXG4gICAgICAgICAgICAmJiBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnByaW1hcnlEZWNvZGVyID0gbmV3IEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlKHJlcXVlc3RlZEZvcm1hdHMsIHZlcmJvc2UsIGxvZ2dlcik7XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeURlY29kZXIgPSBuZXcgWlhpbmdIdG1sNVFyY29kZURlY29kZXIocmVxdWVzdGVkRm9ybWF0cywgdmVyYm9zZSwgbG9nZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeURlY29kZXIgPSBuZXcgWlhpbmdIdG1sNVFyY29kZURlY29kZXIocmVxdWVzdGVkRm9ybWF0cywgdmVyYm9zZSwgbG9nZ2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBIdG1sNVFyY29kZVNoaW0ucHJvdG90eXBlLmRlY29kZUFzeW5jID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRUaW1lO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgLCAzLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZ2V0RGVjb2RlcigpLmRlY29kZUFzeW5jKGNhbnZhcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NzaWJseUxvZ1BlcmZvcm1hbmNlKHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzddO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTaGltLnByb3RvdHlwZS5kZWNvZGVSb2J1c3RseUFzeW5jID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRUaW1lLCBlcnJvcl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgNCwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLnByaW1hcnlEZWNvZGVyLmRlY29kZUFzeW5jKGNhbnZhcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlY29uZGFyeURlY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuc2Vjb25kYXJ5RGVjb2Rlci5kZWNvZGVBc3luYyhjYW52YXMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zc2libHlMb2dQZXJmb3JtYW5jZShzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2hpbS5wcm90b3R5cGUuZ2V0RGVjb2RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlY29uZGFyeURlY29kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW1hcnlEZWNvZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndhc1ByaW1hcnlEZWNvZGVyVXNlZEluTGFzdERlY29kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMud2FzUHJpbWFyeURlY29kZXJVc2VkSW5MYXN0RGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW1hcnlEZWNvZGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FzUHJpbWFyeURlY29kZXJVc2VkSW5MYXN0RGVjb2RlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZGFyeURlY29kZXI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNoaW0ucHJvdG90eXBlLnBvc3NpYmx5TG9nUGVyZm9ybWFuY2UgPSBmdW5jdGlvbiAoc3RhcnRUaW1lKSB7XG4gICAgICAgIGlmICghdGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4ZWN1dGlvblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5leGVjdXRpb25SZXN1bHRzLnB1c2goZXhlY3V0aW9uVGltZSk7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9ucysrO1xuICAgICAgICB0aGlzLnBvc3NpYmx5Rmx1c2hQZXJmb3JtYW5jZVJlcG9ydCgpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTaGltLnByb3RvdHlwZS5wb3NzaWJseUZsdXNoUGVyZm9ybWFuY2VSZXBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvbnMgPCB0aGlzLkVYRUNVVElPTlNfVE9fUkVQT1JUX1BFUkZPUk1BTkNFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmV4ZWN1dGlvblJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXhlY3V0aW9uVGltZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHN1bSArPSBleGVjdXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZWFuID0gc3VtIC8gdGhpcy5leGVjdXRpb25SZXN1bHRzLmxlbmd0aDtcbiAgICAgICAgY29uc29sZS5sb2coXCJcIi5jb25jYXQobWVhbiwgXCIgbXMgZm9yIFwiKS5jb25jYXQodGhpcy5leGVjdXRpb25SZXN1bHRzLmxlbmd0aCwgXCIgbGFzdCBydW5zLlwiKSk7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uUmVzdWx0cyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlU2hpbTtcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNoaW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUtZGVjb2Rlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/code-decoder.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/core.js":
/*!******************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/core.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLoggger: () => (/* binding */ BaseLoggger),\n/* harmony export */   DecodedTextType: () => (/* binding */ DecodedTextType),\n/* harmony export */   Html5QrcodeConstants: () => (/* binding */ Html5QrcodeConstants),\n/* harmony export */   Html5QrcodeErrorFactory: () => (/* binding */ Html5QrcodeErrorFactory),\n/* harmony export */   Html5QrcodeErrorTypes: () => (/* binding */ Html5QrcodeErrorTypes),\n/* harmony export */   Html5QrcodeResultFactory: () => (/* binding */ Html5QrcodeResultFactory),\n/* harmony export */   Html5QrcodeScanType: () => (/* binding */ Html5QrcodeScanType),\n/* harmony export */   Html5QrcodeSupportedFormats: () => (/* binding */ Html5QrcodeSupportedFormats),\n/* harmony export */   QrcodeResultFormat: () => (/* binding */ QrcodeResultFormat),\n/* harmony export */   clip: () => (/* binding */ clip),\n/* harmony export */   isNullOrUndefined: () => (/* binding */ isNullOrUndefined),\n/* harmony export */   isValidHtml5QrcodeSupportedFormats: () => (/* binding */ isValidHtml5QrcodeSupportedFormats)\n/* harmony export */ });\nvar Html5QrcodeSupportedFormats;\n(function (Html5QrcodeSupportedFormats) {\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"QR_CODE\"] = 0] = \"QR_CODE\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"AZTEC\"] = 1] = \"AZTEC\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODABAR\"] = 2] = \"CODABAR\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_39\"] = 3] = \"CODE_39\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_93\"] = 4] = \"CODE_93\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"CODE_128\"] = 5] = \"CODE_128\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"DATA_MATRIX\"] = 6] = \"DATA_MATRIX\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"MAXICODE\"] = 7] = \"MAXICODE\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"ITF\"] = 8] = \"ITF\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"EAN_13\"] = 9] = \"EAN_13\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"EAN_8\"] = 10] = \"EAN_8\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"PDF_417\"] = 11] = \"PDF_417\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"RSS_14\"] = 12] = \"RSS_14\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"RSS_EXPANDED\"] = 13] = \"RSS_EXPANDED\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_A\"] = 14] = \"UPC_A\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_E\"] = 15] = \"UPC_E\";\n    Html5QrcodeSupportedFormats[Html5QrcodeSupportedFormats[\"UPC_EAN_EXTENSION\"] = 16] = \"UPC_EAN_EXTENSION\";\n})(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));\nvar html5QrcodeSupportedFormatsTextMap = new Map([\n    [Html5QrcodeSupportedFormats.QR_CODE, \"QR_CODE\"],\n    [Html5QrcodeSupportedFormats.AZTEC, \"AZTEC\"],\n    [Html5QrcodeSupportedFormats.CODABAR, \"CODABAR\"],\n    [Html5QrcodeSupportedFormats.CODE_39, \"CODE_39\"],\n    [Html5QrcodeSupportedFormats.CODE_93, \"CODE_93\"],\n    [Html5QrcodeSupportedFormats.CODE_128, \"CODE_128\"],\n    [Html5QrcodeSupportedFormats.DATA_MATRIX, \"DATA_MATRIX\"],\n    [Html5QrcodeSupportedFormats.MAXICODE, \"MAXICODE\"],\n    [Html5QrcodeSupportedFormats.ITF, \"ITF\"],\n    [Html5QrcodeSupportedFormats.EAN_13, \"EAN_13\"],\n    [Html5QrcodeSupportedFormats.EAN_8, \"EAN_8\"],\n    [Html5QrcodeSupportedFormats.PDF_417, \"PDF_417\"],\n    [Html5QrcodeSupportedFormats.RSS_14, \"RSS_14\"],\n    [Html5QrcodeSupportedFormats.RSS_EXPANDED, \"RSS_EXPANDED\"],\n    [Html5QrcodeSupportedFormats.UPC_A, \"UPC_A\"],\n    [Html5QrcodeSupportedFormats.UPC_E, \"UPC_E\"],\n    [Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION, \"UPC_EAN_EXTENSION\"]\n]);\nvar DecodedTextType;\n(function (DecodedTextType) {\n    DecodedTextType[DecodedTextType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    DecodedTextType[DecodedTextType[\"URL\"] = 1] = \"URL\";\n})(DecodedTextType || (DecodedTextType = {}));\nfunction isValidHtml5QrcodeSupportedFormats(format) {\n    return Object.values(Html5QrcodeSupportedFormats).includes(format);\n}\nvar Html5QrcodeScanType;\n(function (Html5QrcodeScanType) {\n    Html5QrcodeScanType[Html5QrcodeScanType[\"SCAN_TYPE_CAMERA\"] = 0] = \"SCAN_TYPE_CAMERA\";\n    Html5QrcodeScanType[Html5QrcodeScanType[\"SCAN_TYPE_FILE\"] = 1] = \"SCAN_TYPE_FILE\";\n})(Html5QrcodeScanType || (Html5QrcodeScanType = {}));\nvar Html5QrcodeConstants = (function () {\n    function Html5QrcodeConstants() {\n    }\n    Html5QrcodeConstants.GITHUB_PROJECT_URL = \"https://github.com/mebjas/html5-qrcode\";\n    Html5QrcodeConstants.SCAN_DEFAULT_FPS = 2;\n    Html5QrcodeConstants.DEFAULT_DISABLE_FLIP = false;\n    Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;\n    Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE = [\n        Html5QrcodeScanType.SCAN_TYPE_CAMERA,\n        Html5QrcodeScanType.SCAN_TYPE_FILE\n    ];\n    return Html5QrcodeConstants;\n}());\n\nvar QrcodeResultFormat = (function () {\n    function QrcodeResultFormat(format, formatName) {\n        this.format = format;\n        this.formatName = formatName;\n    }\n    QrcodeResultFormat.prototype.toString = function () {\n        return this.formatName;\n    };\n    QrcodeResultFormat.create = function (format) {\n        if (!html5QrcodeSupportedFormatsTextMap.has(format)) {\n            throw \"\".concat(format, \" not in html5QrcodeSupportedFormatsTextMap\");\n        }\n        return new QrcodeResultFormat(format, html5QrcodeSupportedFormatsTextMap.get(format));\n    };\n    return QrcodeResultFormat;\n}());\n\nvar Html5QrcodeResultFactory = (function () {\n    function Html5QrcodeResultFactory() {\n    }\n    Html5QrcodeResultFactory.createFromText = function (decodedText) {\n        var qrcodeResult = {\n            text: decodedText\n        };\n        return {\n            decodedText: decodedText,\n            result: qrcodeResult\n        };\n    };\n    Html5QrcodeResultFactory.createFromQrcodeResult = function (qrcodeResult) {\n        return {\n            decodedText: qrcodeResult.text,\n            result: qrcodeResult\n        };\n    };\n    return Html5QrcodeResultFactory;\n}());\n\nvar Html5QrcodeErrorTypes;\n(function (Html5QrcodeErrorTypes) {\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"UNKWOWN_ERROR\"] = 0] = \"UNKWOWN_ERROR\";\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"IMPLEMENTATION_ERROR\"] = 1] = \"IMPLEMENTATION_ERROR\";\n    Html5QrcodeErrorTypes[Html5QrcodeErrorTypes[\"NO_CODE_FOUND_ERROR\"] = 2] = \"NO_CODE_FOUND_ERROR\";\n})(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));\nvar Html5QrcodeErrorFactory = (function () {\n    function Html5QrcodeErrorFactory() {\n    }\n    Html5QrcodeErrorFactory.createFrom = function (error) {\n        return {\n            errorMessage: error,\n            type: Html5QrcodeErrorTypes.UNKWOWN_ERROR\n        };\n    };\n    return Html5QrcodeErrorFactory;\n}());\n\nvar BaseLoggger = (function () {\n    function BaseLoggger(verbose) {\n        this.verbose = verbose;\n    }\n    BaseLoggger.prototype.log = function (message) {\n        if (this.verbose) {\n            console.log(message);\n        }\n    };\n    BaseLoggger.prototype.warn = function (message) {\n        if (this.verbose) {\n            console.warn(message);\n        }\n    };\n    BaseLoggger.prototype.logError = function (message, isExperimental) {\n        if (this.verbose || isExperimental === true) {\n            console.error(message);\n        }\n    };\n    BaseLoggger.prototype.logErrors = function (errors) {\n        if (errors.length === 0) {\n            throw \"Logger#logError called without arguments\";\n        }\n        if (this.verbose) {\n            console.error(errors);\n        }\n    };\n    return BaseLoggger;\n}());\n\nfunction isNullOrUndefined(obj) {\n    return (typeof obj === \"undefined\") || obj === null;\n}\nfunction clip(value, minValue, maxValue) {\n    if (value > maxValue) {\n        return maxValue;\n    }\n    if (value < minValue) {\n        return minValue;\n    }\n    return value;\n}\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9jb3JlLmpzPzIyNTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHM7XG4oZnVuY3Rpb24gKEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cykge1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJRUl9DT0RFXCJdID0gMF0gPSBcIlFSX0NPREVcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiQVpURUNcIl0gPSAxXSA9IFwiQVpURUNcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiQ09EQUJBUlwiXSA9IDJdID0gXCJDT0RBQkFSXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIkNPREVfMzlcIl0gPSAzXSA9IFwiQ09ERV8zOVwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJDT0RFXzkzXCJdID0gNF0gPSBcIkNPREVfOTNcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiQ09ERV8xMjhcIl0gPSA1XSA9IFwiQ09ERV8xMjhcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiREFUQV9NQVRSSVhcIl0gPSA2XSA9IFwiREFUQV9NQVRSSVhcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiTUFYSUNPREVcIl0gPSA3XSA9IFwiTUFYSUNPREVcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiSVRGXCJdID0gOF0gPSBcIklURlwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJFQU5fMTNcIl0gPSA5XSA9IFwiRUFOXzEzXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIkVBTl84XCJdID0gMTBdID0gXCJFQU5fOFwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJQREZfNDE3XCJdID0gMTFdID0gXCJQREZfNDE3XCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlJTU18xNFwiXSA9IDEyXSA9IFwiUlNTXzE0XCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlJTU19FWFBBTkRFRFwiXSA9IDEzXSA9IFwiUlNTX0VYUEFOREVEXCI7XG4gICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tcIlVQQ19BXCJdID0gMTRdID0gXCJVUENfQVwiO1xuICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0c1tIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbXCJVUENfRVwiXSA9IDE1XSA9IFwiVVBDX0VcIjtcbiAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzW1wiVVBDX0VBTl9FWFRFTlNJT05cIl0gPSAxNl0gPSBcIlVQQ19FQU5fRVhURU5TSU9OXCI7XG59KShIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMgfHwgKEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyA9IHt9KSk7XG52YXIgaHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzVGV4dE1hcCA9IG5ldyBNYXAoW1xuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUVJfQ09ERSwgXCJRUl9DT0RFXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQVpURUMsIFwiQVpURUNcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RBQkFSLCBcIkNPREFCQVJcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzM5LCBcIkNPREVfMzlcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzkzLCBcIkNPREVfOTNcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzEyOCwgXCJDT0RFXzEyOFwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLCBcIkRBVEFfTUFUUklYXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuTUFYSUNPREUsIFwiTUFYSUNPREVcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5JVEYsIFwiSVRGXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzEzLCBcIkVBTl8xM1wiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkVBTl84LCBcIkVBTl84XCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUERGXzQxNywgXCJQREZfNDE3XCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTXzE0LCBcIlJTU18xNFwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlJTU19FWFBBTkRFRCwgXCJSU1NfRVhQQU5ERURcIl0sXG4gICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfQSwgXCJVUENfQVwiXSxcbiAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FLCBcIlVQQ19FXCJdLFxuICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0VBTl9FWFRFTlNJT04sIFwiVVBDX0VBTl9FWFRFTlNJT05cIl1cbl0pO1xuZXhwb3J0IHZhciBEZWNvZGVkVGV4dFR5cGU7XG4oZnVuY3Rpb24gKERlY29kZWRUZXh0VHlwZSkge1xuICAgIERlY29kZWRUZXh0VHlwZVtEZWNvZGVkVGV4dFR5cGVbXCJVTktOT1dOXCJdID0gMF0gPSBcIlVOS05PV05cIjtcbiAgICBEZWNvZGVkVGV4dFR5cGVbRGVjb2RlZFRleHRUeXBlW1wiVVJMXCJdID0gMV0gPSBcIlVSTFwiO1xufSkoRGVjb2RlZFRleHRUeXBlIHx8IChEZWNvZGVkVGV4dFR5cGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMoZm9ybWF0KSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzKS5pbmNsdWRlcyhmb3JtYXQpO1xufVxuZXhwb3J0IHZhciBIdG1sNVFyY29kZVNjYW5UeXBlO1xuKGZ1bmN0aW9uIChIdG1sNVFyY29kZVNjYW5UeXBlKSB7XG4gICAgSHRtbDVRcmNvZGVTY2FuVHlwZVtIdG1sNVFyY29kZVNjYW5UeXBlW1wiU0NBTl9UWVBFX0NBTUVSQVwiXSA9IDBdID0gXCJTQ0FOX1RZUEVfQ0FNRVJBXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FuVHlwZVtIdG1sNVFyY29kZVNjYW5UeXBlW1wiU0NBTl9UWVBFX0ZJTEVcIl0gPSAxXSA9IFwiU0NBTl9UWVBFX0ZJTEVcIjtcbn0pKEh0bWw1UXJjb2RlU2NhblR5cGUgfHwgKEh0bWw1UXJjb2RlU2NhblR5cGUgPSB7fSkpO1xudmFyIEh0bWw1UXJjb2RlQ29uc3RhbnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZUNvbnN0YW50cygpIHtcbiAgICB9XG4gICAgSHRtbDVRcmNvZGVDb25zdGFudHMuR0lUSFVCX1BST0pFQ1RfVVJMID0gXCJodHRwczovL2dpdGh1Yi5jb20vbWViamFzL2h0bWw1LXFyY29kZVwiO1xuICAgIEh0bWw1UXJjb2RlQ29uc3RhbnRzLlNDQU5fREVGQVVMVF9GUFMgPSAyO1xuICAgIEh0bWw1UXJjb2RlQ29uc3RhbnRzLkRFRkFVTFRfRElTQUJMRV9GTElQID0gZmFsc2U7XG4gICAgSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9SRU1FTUJFUl9MQVNUX0NBTUVSQV9VU0VEID0gdHJ1ZTtcbiAgICBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEUgPSBbXG4gICAgICAgIEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0NBTUVSQSxcbiAgICAgICAgSHRtbDVRcmNvZGVTY2FuVHlwZS5TQ0FOX1RZUEVfRklMRVxuICAgIF07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlQ29uc3RhbnRzO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlQ29uc3RhbnRzIH07XG52YXIgUXJjb2RlUmVzdWx0Rm9ybWF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRcmNvZGVSZXN1bHRGb3JtYXQoZm9ybWF0LCBmb3JtYXROYW1lKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLmZvcm1hdE5hbWUgPSBmb3JtYXROYW1lO1xuICAgIH1cbiAgICBRcmNvZGVSZXN1bHRGb3JtYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXROYW1lO1xuICAgIH07XG4gICAgUXJjb2RlUmVzdWx0Rm9ybWF0LmNyZWF0ZSA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFodG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNUZXh0TWFwLmhhcyhmb3JtYXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlwiLmNvbmNhdChmb3JtYXQsIFwiIG5vdCBpbiBodG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHNUZXh0TWFwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUXJjb2RlUmVzdWx0Rm9ybWF0KGZvcm1hdCwgaHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzVGV4dE1hcC5nZXQoZm9ybWF0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gUXJjb2RlUmVzdWx0Rm9ybWF0O1xufSgpKTtcbmV4cG9ydCB7IFFyY29kZVJlc3VsdEZvcm1hdCB9O1xudmFyIEh0bWw1UXJjb2RlUmVzdWx0RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5KCkge1xuICAgIH1cbiAgICBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkuY3JlYXRlRnJvbVRleHQgPSBmdW5jdGlvbiAoZGVjb2RlZFRleHQpIHtcbiAgICAgICAgdmFyIHFyY29kZVJlc3VsdCA9IHtcbiAgICAgICAgICAgIHRleHQ6IGRlY29kZWRUZXh0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVkVGV4dDogZGVjb2RlZFRleHQsXG4gICAgICAgICAgICByZXN1bHQ6IHFyY29kZVJlc3VsdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5LmNyZWF0ZUZyb21RcmNvZGVSZXN1bHQgPSBmdW5jdGlvbiAocXJjb2RlUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVkVGV4dDogcXJjb2RlUmVzdWx0LnRleHQsXG4gICAgICAgICAgICByZXN1bHQ6IHFyY29kZVJlc3VsdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlUmVzdWx0RmFjdG9yeTtcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkgfTtcbmV4cG9ydCB2YXIgSHRtbDVRcmNvZGVFcnJvclR5cGVzO1xuKGZ1bmN0aW9uIChIdG1sNVFyY29kZUVycm9yVHlwZXMpIHtcbiAgICBIdG1sNVFyY29kZUVycm9yVHlwZXNbSHRtbDVRcmNvZGVFcnJvclR5cGVzW1wiVU5LV09XTl9FUlJPUlwiXSA9IDBdID0gXCJVTktXT1dOX0VSUk9SXCI7XG4gICAgSHRtbDVRcmNvZGVFcnJvclR5cGVzW0h0bWw1UXJjb2RlRXJyb3JUeXBlc1tcIklNUExFTUVOVEFUSU9OX0VSUk9SXCJdID0gMV0gPSBcIklNUExFTUVOVEFUSU9OX0VSUk9SXCI7XG4gICAgSHRtbDVRcmNvZGVFcnJvclR5cGVzW0h0bWw1UXJjb2RlRXJyb3JUeXBlc1tcIk5PX0NPREVfRk9VTkRfRVJST1JcIl0gPSAyXSA9IFwiTk9fQ09ERV9GT1VORF9FUlJPUlwiO1xufSkoSHRtbDVRcmNvZGVFcnJvclR5cGVzIHx8IChIdG1sNVFyY29kZUVycm9yVHlwZXMgPSB7fSkpO1xudmFyIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZUVycm9yRmFjdG9yeSgpIHtcbiAgICB9XG4gICAgSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkuY3JlYXRlRnJvbSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBlcnJvcixcbiAgICAgICAgICAgIHR5cGU6IEh0bWw1UXJjb2RlRXJyb3JUeXBlcy5VTktXT1dOX0VSUk9SXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVFcnJvckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkgfTtcbnZhciBCYXNlTG9nZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZUxvZ2dnZXIodmVyYm9zZSkge1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xuICAgIH1cbiAgICBCYXNlTG9nZ2dlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VMb2dnZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlTG9nZ2dlci5wcm90b3R5cGUubG9nRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgaXNFeHBlcmltZW50YWwpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSB8fCBpc0V4cGVyaW1lbnRhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZUxvZ2dnZXIucHJvdG90eXBlLmxvZ0Vycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IFwiTG9nZ2VyI2xvZ0Vycm9yIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJhc2VMb2dnZ2VyO1xufSgpKTtcbmV4cG9ydCB7IEJhc2VMb2dnZ2VyIH07XG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiKSB8fCBvYmogPT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xpcCh2YWx1ZSwgbWluVmFsdWUsIG1heFZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWluVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/core.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/html5-qrcode-scanner.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/html5-qrcode-scanner.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScanner: () => (/* binding */ Html5QrcodeScanner)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"../../../node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html5-qrcode */ \"../../../node_modules/html5-qrcode/esm/html5-qrcode.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _image_assets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./image-assets */ \"../../../node_modules/html5-qrcode/esm/image-assets.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storage */ \"../../../node_modules/html5-qrcode/esm/storage.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui */ \"../../../node_modules/html5-qrcode/esm/ui.js\");\n/* harmony import */ var _camera_permissions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./camera/permissions */ \"../../../node_modules/html5-qrcode/esm/camera/permissions.js\");\n/* harmony import */ var _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/scanner/scan-type-selector */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js\");\n/* harmony import */ var _ui_scanner_torch_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ui/scanner/torch-button */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/torch-button.js\");\n/* harmony import */ var _ui_scanner_file_selection_ui__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ui/scanner/file-selection-ui */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js\");\n/* harmony import */ var _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ui/scanner/base */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _ui_scanner_camera_selection_ui__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ui/scanner/camera-selection-ui */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js\");\n/* harmony import */ var _ui_scanner_camera_zoom_ui__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ui/scanner/camera-zoom-ui */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Html5QrcodeScannerStatus;\n(function (Html5QrcodeScannerStatus) {\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_DEFAULT\"] = 0] = \"STATUS_DEFAULT\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_SUCCESS\"] = 1] = \"STATUS_SUCCESS\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_WARNING\"] = 2] = \"STATUS_WARNING\";\n    Html5QrcodeScannerStatus[Html5QrcodeScannerStatus[\"STATUS_REQUESTING_PERMISSION\"] = 3] = \"STATUS_REQUESTING_PERMISSION\";\n})(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));\nfunction toHtml5QrcodeCameraScanConfig(config) {\n    return {\n        fps: config.fps,\n        qrbox: config.qrbox,\n        aspectRatio: config.aspectRatio,\n        disableFlip: config.disableFlip,\n        videoConstraints: config.videoConstraints\n    };\n}\nfunction toHtml5QrcodeFullConfig(config, verbose) {\n    return {\n        formatsToSupport: config.formatsToSupport,\n        useBarCodeDetectorIfSupported: config.useBarCodeDetectorIfSupported,\n        experimentalFeatures: config.experimentalFeatures,\n        verbose: verbose\n    };\n}\nvar Html5QrcodeScanner = (function () {\n    function Html5QrcodeScanner(elementId, config, verbose) {\n        this.lastMatchFound = null;\n        this.cameraScanImage = null;\n        this.fileScanImage = null;\n        this.fileSelectionUi = null;\n        this.elementId = elementId;\n        this.config = this.createConfig(config);\n        this.verbose = verbose === true;\n        if (!document.getElementById(elementId)) {\n            throw \"HTML Element with id=\".concat(elementId, \" not found\");\n        }\n        this.scanTypeSelector = new _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector(this.config.supportedScanTypes);\n        this.currentScanType = this.scanTypeSelector.getDefaultScanType();\n        this.sectionSwapAllowed = true;\n        this.logger = new _core__WEBPACK_IMPORTED_MODULE_0__.BaseLoggger(this.verbose);\n        this.persistedDataManager = new _storage__WEBPACK_IMPORTED_MODULE_4__.PersistedDataManager();\n        if (config.rememberLastUsedCamera !== true) {\n            this.persistedDataManager.reset();\n        }\n    }\n    Html5QrcodeScanner.prototype.render = function (qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        this.lastMatchFound = null;\n        this.qrCodeSuccessCallback\n            = function (decodedText, result) {\n                if (qrCodeSuccessCallback) {\n                    qrCodeSuccessCallback(decodedText, result);\n                }\n                else {\n                    if (_this.lastMatchFound === decodedText) {\n                        return;\n                    }\n                    _this.lastMatchFound = decodedText;\n                    _this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.lastMatch(decodedText), Html5QrcodeScannerStatus.STATUS_SUCCESS);\n                }\n            };\n        this.qrCodeErrorCallback =\n            function (errorMessage, error) {\n                if (qrCodeErrorCallback) {\n                    qrCodeErrorCallback(errorMessage, error);\n                }\n            };\n        var container = document.getElementById(this.elementId);\n        if (!container) {\n            throw \"HTML Element with id=\".concat(this.elementId, \" not found\");\n        }\n        container.innerHTML = \"\";\n        this.createBasicLayout(container);\n        this.html5Qrcode = new _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__.Html5Qrcode(this.getScanRegionId(), toHtml5QrcodeFullConfig(this.config, this.verbose));\n    };\n    Html5QrcodeScanner.prototype.pause = function (shouldPauseVideo) {\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shouldPauseVideo) || shouldPauseVideo !== true) {\n            shouldPauseVideo = false;\n        }\n        this.getHtml5QrcodeOrFail().pause(shouldPauseVideo);\n    };\n    Html5QrcodeScanner.prototype.resume = function () {\n        this.getHtml5QrcodeOrFail().resume();\n    };\n    Html5QrcodeScanner.prototype.getState = function () {\n        return this.getHtml5QrcodeOrFail().getState();\n    };\n    Html5QrcodeScanner.prototype.clear = function () {\n        var _this = this;\n        var emptyHtmlContainer = function () {\n            var mainContainer = document.getElementById(_this.elementId);\n            if (mainContainer) {\n                mainContainer.innerHTML = \"\";\n                _this.resetBasicLayout(mainContainer);\n            }\n        };\n        if (this.html5Qrcode) {\n            return new Promise(function (resolve, reject) {\n                if (!_this.html5Qrcode) {\n                    resolve();\n                    return;\n                }\n                if (_this.html5Qrcode.isScanning) {\n                    _this.html5Qrcode.stop().then(function (_) {\n                        if (!_this.html5Qrcode) {\n                            resolve();\n                            return;\n                        }\n                        _this.html5Qrcode.clear();\n                        emptyHtmlContainer();\n                        resolve();\n                    }).catch(function (error) {\n                        if (_this.verbose) {\n                            _this.logger.logError(\"Unable to stop qrcode scanner\", error);\n                        }\n                        reject(error);\n                    });\n                }\n                else {\n                    _this.html5Qrcode.clear();\n                    emptyHtmlContainer();\n                    resolve();\n                }\n            });\n        }\n        return Promise.resolve();\n    };\n    Html5QrcodeScanner.prototype.getRunningTrackCapabilities = function () {\n        return this.getHtml5QrcodeOrFail().getRunningTrackCapabilities();\n    };\n    Html5QrcodeScanner.prototype.getRunningTrackSettings = function () {\n        return this.getHtml5QrcodeOrFail().getRunningTrackSettings();\n    };\n    Html5QrcodeScanner.prototype.applyVideoConstraints = function (videoConstaints) {\n        return this.getHtml5QrcodeOrFail().applyVideoConstraints(videoConstaints);\n    };\n    Html5QrcodeScanner.prototype.getHtml5QrcodeOrFail = function () {\n        if (!this.html5Qrcode) {\n            throw \"Code scanner not initialized.\";\n        }\n        return this.html5Qrcode;\n    };\n    Html5QrcodeScanner.prototype.createConfig = function (config) {\n        if (config) {\n            if (!config.fps) {\n                config.fps = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.SCAN_DEFAULT_FPS;\n            }\n            if (config.rememberLastUsedCamera !== (!_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED)) {\n                config.rememberLastUsedCamera\n                    = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED;\n            }\n            if (!config.supportedScanTypes) {\n                config.supportedScanTypes\n                    = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;\n            }\n            return config;\n        }\n        return {\n            fps: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.SCAN_DEFAULT_FPS,\n            rememberLastUsedCamera: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED,\n            supportedScanTypes: _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE\n        };\n    };\n    Html5QrcodeScanner.prototype.createBasicLayout = function (parent) {\n        parent.style.position = \"relative\";\n        parent.style.padding = \"0px\";\n        parent.style.border = \"1px solid silver\";\n        this.createHeader(parent);\n        var qrCodeScanRegion = document.createElement(\"div\");\n        var scanRegionId = this.getScanRegionId();\n        qrCodeScanRegion.id = scanRegionId;\n        qrCodeScanRegion.style.width = \"100%\";\n        qrCodeScanRegion.style.minHeight = \"100px\";\n        qrCodeScanRegion.style.textAlign = \"center\";\n        parent.appendChild(qrCodeScanRegion);\n        if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)) {\n            this.insertCameraScanImageToScanRegion();\n        }\n        else {\n            this.insertFileScanImageToScanRegion();\n        }\n        var qrCodeDashboard = document.createElement(\"div\");\n        var dashboardId = this.getDashboardId();\n        qrCodeDashboard.id = dashboardId;\n        qrCodeDashboard.style.width = \"100%\";\n        parent.appendChild(qrCodeDashboard);\n        this.setupInitialDashboard(qrCodeDashboard);\n    };\n    Html5QrcodeScanner.prototype.resetBasicLayout = function (mainContainer) {\n        mainContainer.style.border = \"none\";\n    };\n    Html5QrcodeScanner.prototype.setupInitialDashboard = function (dashboard) {\n        this.createSection(dashboard);\n        this.createSectionControlPanel();\n        if (this.scanTypeSelector.hasMoreThanOneScanType()) {\n            this.createSectionSwap();\n        }\n    };\n    Html5QrcodeScanner.prototype.createHeader = function (dashboard) {\n        var header = document.createElement(\"div\");\n        header.style.textAlign = \"left\";\n        header.style.margin = \"0px\";\n        dashboard.appendChild(header);\n        var libraryInfo = new _ui__WEBPACK_IMPORTED_MODULE_5__.LibraryInfoContainer();\n        libraryInfo.renderInto(header);\n        var headerMessageContainer = document.createElement(\"div\");\n        headerMessageContainer.id = this.getHeaderMessageContainerId();\n        headerMessageContainer.style.display = \"none\";\n        headerMessageContainer.style.textAlign = \"center\";\n        headerMessageContainer.style.fontSize = \"14px\";\n        headerMessageContainer.style.padding = \"2px 10px\";\n        headerMessageContainer.style.margin = \"4px\";\n        headerMessageContainer.style.borderTop = \"1px solid #f6f6f6\";\n        header.appendChild(headerMessageContainer);\n    };\n    Html5QrcodeScanner.prototype.createSection = function (dashboard) {\n        var section = document.createElement(\"div\");\n        section.id = this.getDashboardSectionId();\n        section.style.width = \"100%\";\n        section.style.padding = \"10px 0px 10px 0px\";\n        section.style.textAlign = \"left\";\n        dashboard.appendChild(section);\n    };\n    Html5QrcodeScanner.prototype.createCameraListUi = function (scpCameraScanRegion, requestPermissionContainer, requestPermissionButton) {\n        var $this = this;\n        $this.showHideScanTypeSwapLink(false);\n        $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraPermissionRequesting());\n        var createPermissionButtonIfNotExists = function () {\n            if (!requestPermissionButton) {\n                $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n            }\n        };\n        _html5_qrcode__WEBPACK_IMPORTED_MODULE_1__.Html5Qrcode.getCameras().then(function (cameras) {\n            $this.persistedDataManager.setHasPermission(true);\n            $this.showHideScanTypeSwapLink(true);\n            $this.resetHeaderMessage();\n            if (cameras && cameras.length > 0) {\n                scpCameraScanRegion.removeChild(requestPermissionContainer);\n                $this.renderCameraSelection(cameras);\n            }\n            else {\n                $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.noCameraFound(), Html5QrcodeScannerStatus.STATUS_WARNING);\n                createPermissionButtonIfNotExists();\n            }\n        }).catch(function (error) {\n            $this.persistedDataManager.setHasPermission(false);\n            if (requestPermissionButton) {\n                requestPermissionButton.disabled = false;\n            }\n            else {\n                createPermissionButtonIfNotExists();\n            }\n            $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            $this.showHideScanTypeSwapLink(true);\n        });\n    };\n    Html5QrcodeScanner.prototype.createPermissionButton = function (scpCameraScanRegion, requestPermissionContainer) {\n        var $this = this;\n        var requestPermissionButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory\n            .createElement(\"button\", this.getCameraPermissionButtonId());\n        requestPermissionButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraPermissionTitle();\n        requestPermissionButton.addEventListener(\"click\", function () {\n            requestPermissionButton.disabled = true;\n            $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton);\n        });\n        requestPermissionContainer.appendChild(requestPermissionButton);\n    };\n    Html5QrcodeScanner.prototype.createPermissionsUi = function (scpCameraScanRegion, requestPermissionContainer) {\n        var $this = this;\n        if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)\n            && this.persistedDataManager.hasCameraPermissions()) {\n            _camera_permissions__WEBPACK_IMPORTED_MODULE_6__.CameraPermissions.hasPermissions().then(function (hasPermissions) {\n                if (hasPermissions) {\n                    $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer);\n                }\n                else {\n                    $this.persistedDataManager.setHasPermission(false);\n                    $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n                }\n            }).catch(function (_) {\n                $this.persistedDataManager.setHasPermission(false);\n                $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n            });\n            return;\n        }\n        this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);\n    };\n    Html5QrcodeScanner.prototype.createSectionControlPanel = function () {\n        var section = document.getElementById(this.getDashboardSectionId());\n        var sectionControlPanel = document.createElement(\"div\");\n        section.appendChild(sectionControlPanel);\n        var scpCameraScanRegion = document.createElement(\"div\");\n        scpCameraScanRegion.id = this.getDashboardSectionCameraScanRegionId();\n        scpCameraScanRegion.style.display\n            = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)\n                ? \"block\" : \"none\";\n        sectionControlPanel.appendChild(scpCameraScanRegion);\n        var requestPermissionContainer = document.createElement(\"div\");\n        requestPermissionContainer.style.textAlign = \"center\";\n        scpCameraScanRegion.appendChild(requestPermissionContainer);\n        if (this.scanTypeSelector.isCameraScanRequired()) {\n            this.createPermissionsUi(scpCameraScanRegion, requestPermissionContainer);\n        }\n        this.renderFileScanUi(sectionControlPanel);\n    };\n    Html5QrcodeScanner.prototype.renderFileScanUi = function (parent) {\n        var showOnRender = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isFileScanType(this.currentScanType);\n        var $this = this;\n        var onFileSelected = function (file) {\n            if (!$this.html5Qrcode) {\n                throw \"html5Qrcode not defined\";\n            }\n            if (!_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isFileScanType($this.currentScanType)) {\n                return;\n            }\n            $this.setHeaderMessage(_strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.loadingImage());\n            $this.html5Qrcode.scanFileV2(file, true)\n                .then(function (html5qrcodeResult) {\n                $this.resetHeaderMessage();\n                $this.qrCodeSuccessCallback(html5qrcodeResult.decodedText, html5qrcodeResult);\n            })\n                .catch(function (error) {\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n                $this.qrCodeErrorCallback(error, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeErrorFactory.createFrom(error));\n            });\n        };\n        this.fileSelectionUi = _ui_scanner_file_selection_ui__WEBPACK_IMPORTED_MODULE_9__.FileSelectionUi.create(parent, showOnRender, onFileSelected);\n    };\n    Html5QrcodeScanner.prototype.renderCameraSelection = function (cameras) {\n        var _this = this;\n        var $this = this;\n        var scpCameraScanRegion = document.getElementById(this.getDashboardSectionCameraScanRegionId());\n        scpCameraScanRegion.style.textAlign = \"center\";\n        var cameraZoomUi = _ui_scanner_camera_zoom_ui__WEBPACK_IMPORTED_MODULE_12__.CameraZoomUi.create(scpCameraScanRegion, false);\n        var renderCameraZoomUiIfSupported = function (cameraCapabilities) {\n            var zoomCapability = cameraCapabilities.zoomFeature();\n            if (!zoomCapability.isSupported()) {\n                return;\n            }\n            cameraZoomUi.setOnCameraZoomValueChangeCallback(function (zoomValue) {\n                zoomCapability.apply(zoomValue);\n            });\n            var defaultZoom = 1;\n            if (_this.config.defaultZoomValueIfSupported) {\n                defaultZoom = _this.config.defaultZoomValueIfSupported;\n            }\n            defaultZoom = (0,_core__WEBPACK_IMPORTED_MODULE_0__.clip)(defaultZoom, zoomCapability.min(), zoomCapability.max());\n            cameraZoomUi.setValues(zoomCapability.min(), zoomCapability.max(), defaultZoom, zoomCapability.step());\n            cameraZoomUi.show();\n        };\n        var cameraSelectUi = _ui_scanner_camera_selection_ui__WEBPACK_IMPORTED_MODULE_11__.CameraSelectionUi.create(scpCameraScanRegion, cameras);\n        var cameraActionContainer = document.createElement(\"span\");\n        var cameraActionStartButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"button\", _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID);\n        cameraActionStartButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonStartScanningText();\n        cameraActionContainer.appendChild(cameraActionStartButton);\n        var cameraActionStopButton = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"button\", _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID);\n        cameraActionStopButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonStopScanningText();\n        cameraActionStopButton.style.display = \"none\";\n        cameraActionStopButton.disabled = true;\n        cameraActionContainer.appendChild(cameraActionStopButton);\n        var torchButton;\n        var createAndShowTorchButtonIfSupported = function (cameraCapabilities) {\n            if (!cameraCapabilities.torchFeature().isSupported()) {\n                if (torchButton) {\n                    torchButton.hide();\n                }\n                return;\n            }\n            if (!torchButton) {\n                torchButton = _ui_scanner_torch_button__WEBPACK_IMPORTED_MODULE_8__.TorchButton.create(cameraActionContainer, cameraCapabilities.torchFeature(), { display: \"none\", marginLeft: \"5px\" }, function (errorMessage) {\n                    $this.setHeaderMessage(errorMessage, Html5QrcodeScannerStatus.STATUS_WARNING);\n                });\n            }\n            else {\n                torchButton.updateTorchCapability(cameraCapabilities.torchFeature());\n            }\n            torchButton.show();\n        };\n        scpCameraScanRegion.appendChild(cameraActionContainer);\n        var resetCameraActionStartButton = function (shouldShow) {\n            if (!shouldShow) {\n                cameraActionStartButton.style.display = \"none\";\n            }\n            cameraActionStartButton.innerText\n                = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings\n                    .scanButtonStartScanningText();\n            cameraActionStartButton.style.opacity = \"1\";\n            cameraActionStartButton.disabled = false;\n            if (shouldShow) {\n                cameraActionStartButton.style.display = \"inline-block\";\n            }\n        };\n        cameraActionStartButton.addEventListener(\"click\", function (_) {\n            cameraActionStartButton.innerText\n                = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.scanButtonScanningStarting();\n            cameraSelectUi.disable();\n            cameraActionStartButton.disabled = true;\n            cameraActionStartButton.style.opacity = \"0.5\";\n            if (_this.scanTypeSelector.hasMoreThanOneScanType()) {\n                $this.showHideScanTypeSwapLink(false);\n            }\n            $this.resetHeaderMessage();\n            var cameraId = cameraSelectUi.getValue();\n            $this.persistedDataManager.setLastUsedCameraId(cameraId);\n            $this.html5Qrcode.start(cameraId, toHtml5QrcodeCameraScanConfig($this.config), $this.qrCodeSuccessCallback, $this.qrCodeErrorCallback)\n                .then(function (_) {\n                cameraActionStopButton.disabled = false;\n                cameraActionStopButton.style.display = \"inline-block\";\n                resetCameraActionStartButton(false);\n                var cameraCapabilities = $this.html5Qrcode.getRunningTrackCameraCapabilities();\n                if (_this.config.showTorchButtonIfSupported === true) {\n                    createAndShowTorchButtonIfSupported(cameraCapabilities);\n                }\n                if (_this.config.showZoomSliderIfSupported === true) {\n                    renderCameraZoomUiIfSupported(cameraCapabilities);\n                }\n            })\n                .catch(function (error) {\n                $this.showHideScanTypeSwapLink(true);\n                cameraSelectUi.enable();\n                resetCameraActionStartButton(true);\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            });\n        });\n        if (cameraSelectUi.hasSingleItem()) {\n            cameraActionStartButton.click();\n        }\n        cameraActionStopButton.addEventListener(\"click\", function (_) {\n            if (!$this.html5Qrcode) {\n                throw \"html5Qrcode not defined\";\n            }\n            cameraActionStopButton.disabled = true;\n            $this.html5Qrcode.stop()\n                .then(function (_) {\n                if (_this.scanTypeSelector.hasMoreThanOneScanType()) {\n                    $this.showHideScanTypeSwapLink(true);\n                }\n                cameraSelectUi.enable();\n                cameraActionStartButton.disabled = false;\n                cameraActionStopButton.style.display = \"none\";\n                cameraActionStartButton.style.display = \"inline-block\";\n                if (torchButton) {\n                    torchButton.reset();\n                    torchButton.hide();\n                }\n                cameraZoomUi.removeOnCameraZoomValueChangeCallback();\n                cameraZoomUi.hide();\n                $this.insertCameraScanImageToScanRegion();\n            }).catch(function (error) {\n                cameraActionStopButton.disabled = false;\n                $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);\n            });\n        });\n        if ($this.persistedDataManager.getLastUsedCameraId()) {\n            var cameraId = $this.persistedDataManager.getLastUsedCameraId();\n            if (cameraSelectUi.hasValue(cameraId)) {\n                cameraSelectUi.setValue(cameraId);\n                cameraActionStartButton.click();\n            }\n            else {\n                $this.persistedDataManager.resetLastUsedCameraId();\n            }\n        }\n    };\n    Html5QrcodeScanner.prototype.createSectionSwap = function () {\n        var $this = this;\n        var TEXT_IF_CAMERA_SCAN_SELECTED = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.textIfCameraScanSelected();\n        var TEXT_IF_FILE_SCAN_SELECTED = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.textIfFileScanSelected();\n        var section = document.getElementById(this.getDashboardSectionId());\n        var switchContainer = document.createElement(\"div\");\n        switchContainer.style.textAlign = \"center\";\n        var switchScanTypeLink = _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.BaseUiElementFactory.createElement(\"span\", this.getDashboardSectionSwapLinkId());\n        switchScanTypeLink.style.textDecoration = \"underline\";\n        switchScanTypeLink.style.cursor = \"pointer\";\n        switchScanTypeLink.innerText\n            = _ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType(this.currentScanType)\n                ? TEXT_IF_CAMERA_SCAN_SELECTED : TEXT_IF_FILE_SCAN_SELECTED;\n        switchScanTypeLink.addEventListener(\"click\", function () {\n            if (!$this.sectionSwapAllowed) {\n                if ($this.verbose) {\n                    $this.logger.logError(\"Section swap called when not allowed\");\n                }\n                return;\n            }\n            $this.resetHeaderMessage();\n            $this.fileSelectionUi.resetValue();\n            $this.sectionSwapAllowed = false;\n            if (_ui_scanner_scan_type_selector__WEBPACK_IMPORTED_MODULE_7__.ScanTypeSelector.isCameraScanType($this.currentScanType)) {\n                $this.clearScanRegion();\n                $this.getCameraScanRegion().style.display = \"none\";\n                $this.fileSelectionUi.show();\n                switchScanTypeLink.innerText = TEXT_IF_FILE_SCAN_SELECTED;\n                $this.currentScanType = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_FILE;\n                $this.insertFileScanImageToScanRegion();\n            }\n            else {\n                $this.clearScanRegion();\n                $this.getCameraScanRegion().style.display = \"block\";\n                $this.fileSelectionUi.hide();\n                switchScanTypeLink.innerText = TEXT_IF_CAMERA_SCAN_SELECTED;\n                $this.currentScanType = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_CAMERA;\n                $this.insertCameraScanImageToScanRegion();\n                $this.startCameraScanIfPermissionExistsOnSwap();\n            }\n            $this.sectionSwapAllowed = true;\n        });\n        switchContainer.appendChild(switchScanTypeLink);\n        section.appendChild(switchContainer);\n    };\n    Html5QrcodeScanner.prototype.startCameraScanIfPermissionExistsOnSwap = function () {\n        var _this = this;\n        var $this = this;\n        if (this.persistedDataManager.hasCameraPermissions()) {\n            _camera_permissions__WEBPACK_IMPORTED_MODULE_6__.CameraPermissions.hasPermissions().then(function (hasPermissions) {\n                if (hasPermissions) {\n                    var permissionButton = document.getElementById($this.getCameraPermissionButtonId());\n                    if (!permissionButton) {\n                        _this.logger.logError(\"Permission button not found, fail;\");\n                        throw \"Permission button not found\";\n                    }\n                    permissionButton.click();\n                }\n                else {\n                    $this.persistedDataManager.setHasPermission(false);\n                }\n            }).catch(function (_) {\n                $this.persistedDataManager.setHasPermission(false);\n            });\n            return;\n        }\n    };\n    Html5QrcodeScanner.prototype.resetHeaderMessage = function () {\n        var messageDiv = document.getElementById(this.getHeaderMessageContainerId());\n        messageDiv.style.display = \"none\";\n    };\n    Html5QrcodeScanner.prototype.setHeaderMessage = function (messageText, scannerStatus) {\n        if (!scannerStatus) {\n            scannerStatus = Html5QrcodeScannerStatus.STATUS_DEFAULT;\n        }\n        var messageDiv = this.getHeaderMessageDiv();\n        messageDiv.innerText = messageText;\n        messageDiv.style.display = \"block\";\n        switch (scannerStatus) {\n            case Html5QrcodeScannerStatus.STATUS_SUCCESS:\n                messageDiv.style.background = \"rgba(106, 175, 80, 0.26)\";\n                messageDiv.style.color = \"#477735\";\n                break;\n            case Html5QrcodeScannerStatus.STATUS_WARNING:\n                messageDiv.style.background = \"rgba(203, 36, 49, 0.14)\";\n                messageDiv.style.color = \"#cb2431\";\n                break;\n            case Html5QrcodeScannerStatus.STATUS_DEFAULT:\n            default:\n                messageDiv.style.background = \"rgba(0, 0, 0, 0)\";\n                messageDiv.style.color = \"rgb(17, 17, 17)\";\n                break;\n        }\n    };\n    Html5QrcodeScanner.prototype.showHideScanTypeSwapLink = function (shouldDisplay) {\n        if (this.scanTypeSelector.hasMoreThanOneScanType()) {\n            if (shouldDisplay !== true) {\n                shouldDisplay = false;\n            }\n            this.sectionSwapAllowed = shouldDisplay;\n            this.getDashboardSectionSwapLink().style.display\n                = shouldDisplay ? \"inline-block\" : \"none\";\n        }\n    };\n    Html5QrcodeScanner.prototype.insertCameraScanImageToScanRegion = function () {\n        var $this = this;\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        if (this.cameraScanImage) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild(this.cameraScanImage);\n            return;\n        }\n        this.cameraScanImage = new Image;\n        this.cameraScanImage.onload = function (_) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild($this.cameraScanImage);\n        };\n        this.cameraScanImage.width = 64;\n        this.cameraScanImage.style.opacity = \"0.8\";\n        this.cameraScanImage.src = _image_assets__WEBPACK_IMPORTED_MODULE_3__.ASSET_CAMERA_SCAN;\n        this.cameraScanImage.alt = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.cameraScanAltText();\n    };\n    Html5QrcodeScanner.prototype.insertFileScanImageToScanRegion = function () {\n        var $this = this;\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        if (this.fileScanImage) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild(this.fileScanImage);\n            return;\n        }\n        this.fileScanImage = new Image;\n        this.fileScanImage.onload = function (_) {\n            qrCodeScanRegion.innerHTML = \"<br>\";\n            qrCodeScanRegion.appendChild($this.fileScanImage);\n        };\n        this.fileScanImage.width = 64;\n        this.fileScanImage.style.opacity = \"0.8\";\n        this.fileScanImage.src = _image_assets__WEBPACK_IMPORTED_MODULE_3__.ASSET_FILE_SCAN;\n        this.fileScanImage.alt = _strings__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScannerStrings.fileScanAltText();\n    };\n    Html5QrcodeScanner.prototype.clearScanRegion = function () {\n        var qrCodeScanRegion = document.getElementById(this.getScanRegionId());\n        qrCodeScanRegion.innerHTML = \"\";\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionId = function () {\n        return \"\".concat(this.elementId, \"__dashboard_section\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionCameraScanRegionId = function () {\n        return \"\".concat(this.elementId, \"__dashboard_section_csr\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionSwapLinkId = function () {\n        return _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID;\n    };\n    Html5QrcodeScanner.prototype.getScanRegionId = function () {\n        return \"\".concat(this.elementId, \"__scan_region\");\n    };\n    Html5QrcodeScanner.prototype.getDashboardId = function () {\n        return \"\".concat(this.elementId, \"__dashboard\");\n    };\n    Html5QrcodeScanner.prototype.getHeaderMessageContainerId = function () {\n        return \"\".concat(this.elementId, \"__header_message\");\n    };\n    Html5QrcodeScanner.prototype.getCameraPermissionButtonId = function () {\n        return _ui_scanner_base__WEBPACK_IMPORTED_MODULE_10__.PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID;\n    };\n    Html5QrcodeScanner.prototype.getCameraScanRegion = function () {\n        return document.getElementById(this.getDashboardSectionCameraScanRegionId());\n    };\n    Html5QrcodeScanner.prototype.getDashboardSectionSwapLink = function () {\n        return document.getElementById(this.getDashboardSectionSwapLinkId());\n    };\n    Html5QrcodeScanner.prototype.getHeaderMessageDiv = function () {\n        return document.getElementById(this.getHeaderMessageContainerId());\n    };\n    return Html5QrcodeScanner;\n}());\n\n//# sourceMappingURL=html5-qrcode-scanner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaHRtbDUtcXJjb2RlLXNjYW5uZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL2h0bWw1LXFyY29kZS1zY2FubmVyLmpzP2E5N2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHRtbDVRcmNvZGVDb25zdGFudHMsIEh0bWw1UXJjb2RlU2NhblR5cGUsIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5LCBCYXNlTG9nZ2dlciwgaXNOdWxsT3JVbmRlZmluZWQsIGNsaXAsIH0gZnJvbSBcIi4vY29yZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGUsIH0gZnJvbSBcIi4vaHRtbDUtcXJjb2RlXCI7XG5pbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLCB9IGZyb20gXCIuL3N0cmluZ3NcIjtcbmltcG9ydCB7IEFTU0VUX0ZJTEVfU0NBTiwgQVNTRVRfQ0FNRVJBX1NDQU4sIH0gZnJvbSBcIi4vaW1hZ2UtYXNzZXRzXCI7XG5pbXBvcnQgeyBQZXJzaXN0ZWREYXRhTWFuYWdlciB9IGZyb20gXCIuL3N0b3JhZ2VcIjtcbmltcG9ydCB7IExpYnJhcnlJbmZvQ29udGFpbmVyIH0gZnJvbSBcIi4vdWlcIjtcbmltcG9ydCB7IENhbWVyYVBlcm1pc3Npb25zIH0gZnJvbSBcIi4vY2FtZXJhL3Blcm1pc3Npb25zXCI7XG5pbXBvcnQgeyBTY2FuVHlwZVNlbGVjdG9yIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci9zY2FuLXR5cGUtc2VsZWN0b3JcIjtcbmltcG9ydCB7IFRvcmNoQnV0dG9uIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci90b3JjaC1idXR0b25cIjtcbmltcG9ydCB7IEZpbGVTZWxlY3Rpb25VaSB9IGZyb20gXCIuL3VpL3NjYW5uZXIvZmlsZS1zZWxlY3Rpb24tdWlcIjtcbmltcG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5LCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMgfSBmcm9tIFwiLi91aS9zY2FubmVyL2Jhc2VcIjtcbmltcG9ydCB7IENhbWVyYVNlbGVjdGlvblVpIH0gZnJvbSBcIi4vdWkvc2Nhbm5lci9jYW1lcmEtc2VsZWN0aW9uLXVpXCI7XG5pbXBvcnQgeyBDYW1lcmFab29tVWkgfSBmcm9tIFwiLi91aS9zY2FubmVyL2NhbWVyYS16b29tLXVpXCI7XG52YXIgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzO1xuKGZ1bmN0aW9uIChIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMpIHtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX0RFRkFVTFRcIl0gPSAwXSA9IFwiU1RBVFVTX0RFRkFVTFRcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX1NVQ0NFU1NcIl0gPSAxXSA9IFwiU1RBVFVTX1NVQ0NFU1NcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX1dBUk5JTkdcIl0gPSAyXSA9IFwiU1RBVFVTX1dBUk5JTkdcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXNbSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzW1wiU1RBVFVTX1JFUVVFU1RJTkdfUEVSTUlTU0lPTlwiXSA9IDNdID0gXCJTVEFUVVNfUkVRVUVTVElOR19QRVJNSVNTSU9OXCI7XG59KShIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMgfHwgKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cyA9IHt9KSk7XG5mdW5jdGlvbiB0b0h0bWw1UXJjb2RlQ2FtZXJhU2NhbkNvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcHM6IGNvbmZpZy5mcHMsXG4gICAgICAgIHFyYm94OiBjb25maWcucXJib3gsXG4gICAgICAgIGFzcGVjdFJhdGlvOiBjb25maWcuYXNwZWN0UmF0aW8sXG4gICAgICAgIGRpc2FibGVGbGlwOiBjb25maWcuZGlzYWJsZUZsaXAsXG4gICAgICAgIHZpZGVvQ29uc3RyYWludHM6IGNvbmZpZy52aWRlb0NvbnN0cmFpbnRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvSHRtbDVRcmNvZGVGdWxsQ29uZmlnKGNvbmZpZywgdmVyYm9zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdHNUb1N1cHBvcnQ6IGNvbmZpZy5mb3JtYXRzVG9TdXBwb3J0LFxuICAgICAgICB1c2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZDogY29uZmlnLnVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkLFxuICAgICAgICBleHBlcmltZW50YWxGZWF0dXJlczogY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzLFxuICAgICAgICB2ZXJib3NlOiB2ZXJib3NlXG4gICAgfTtcbn1cbnZhciBIdG1sNVFyY29kZVNjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlU2Nhbm5lcihlbGVtZW50SWQsIGNvbmZpZywgdmVyYm9zZSkge1xuICAgICAgICB0aGlzLmxhc3RNYXRjaEZvdW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVTZWxlY3Rpb25VaSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxlbWVudElkID0gZWxlbWVudElkO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuY3JlYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2UgPT09IHRydWU7XG4gICAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJIVE1MIEVsZW1lbnQgd2l0aCBpZD1cIi5jb25jYXQoZWxlbWVudElkLCBcIiBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2FuVHlwZVNlbGVjdG9yID0gbmV3IFNjYW5UeXBlU2VsZWN0b3IodGhpcy5jb25maWcuc3VwcG9ydGVkU2NhblR5cGVzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U2NhblR5cGUgPSB0aGlzLnNjYW5UeXBlU2VsZWN0b3IuZ2V0RGVmYXVsdFNjYW5UeXBlKCk7XG4gICAgICAgIHRoaXMuc2VjdGlvblN3YXBBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgQmFzZUxvZ2dnZXIodGhpcy52ZXJib3NlKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlciA9IG5ldyBQZXJzaXN0ZWREYXRhTWFuYWdlcigpO1xuICAgICAgICBpZiAoY29uZmlnLnJlbWVtYmVyTGFzdFVzZWRDYW1lcmEgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChxckNvZGVTdWNjZXNzQ2FsbGJhY2ssIHFyQ29kZUVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hGb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucXJDb2RlU3VjY2Vzc0NhbGxiYWNrXG4gICAgICAgICAgICA9IGZ1bmN0aW9uIChkZWNvZGVkVGV4dCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBxckNvZGVTdWNjZXNzQ2FsbGJhY2soZGVjb2RlZFRleHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdE1hdGNoRm91bmQgPT09IGRlY29kZWRUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdE1hdGNoRm91bmQgPSBkZWNvZGVkVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGVhZGVyTWVzc2FnZShIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmxhc3RNYXRjaChkZWNvZGVkVGV4dCksIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfU1VDQ0VTUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xckNvZGVFcnJvckNhbGxiYWNrID1cbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHFyQ29kZUVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcXJDb2RlRXJyb3JDYWxsYmFjayhlcnJvck1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbGVtZW50SWQpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhyb3cgXCJIVE1MIEVsZW1lbnQgd2l0aCBpZD1cIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgdGhpcy5jcmVhdGVCYXNpY0xheW91dChjb250YWluZXIpO1xuICAgICAgICB0aGlzLmh0bWw1UXJjb2RlID0gbmV3IEh0bWw1UXJjb2RlKHRoaXMuZ2V0U2NhblJlZ2lvbklkKCksIHRvSHRtbDVRcmNvZGVGdWxsQ29uZmlnKHRoaXMuY29uZmlnLCB0aGlzLnZlcmJvc2UpKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoc2hvdWxkUGF1c2VWaWRlbykge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoc2hvdWxkUGF1c2VWaWRlbykgfHwgc2hvdWxkUGF1c2VWaWRlbyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2hvdWxkUGF1c2VWaWRlbyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0SHRtbDVRcmNvZGVPckZhaWwoKS5wYXVzZShzaG91bGRQYXVzZVZpZGVvKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEh0bWw1UXJjb2RlT3JGYWlsKCkucmVzdW1lKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIdG1sNVFyY29kZU9yRmFpbCgpLmdldFN0YXRlKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZW1wdHlIdG1sQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1haW5Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChfdGhpcy5lbGVtZW50SWQpO1xuICAgICAgICAgICAgaWYgKG1haW5Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBtYWluQ29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXRCYXNpY0xheW91dChtYWluQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5odG1sNVFyY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmh0bWw1UXJjb2RlLmlzU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaHRtbDVRcmNvZGUuc3RvcCgpLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaHRtbDVRcmNvZGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5SHRtbENvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiVW5hYmxlIHRvIHN0b3AgcXJjb2RlIHNjYW5uZXJcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5odG1sNVFyY29kZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBlbXB0eUh0bWxDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIdG1sNVFyY29kZU9yRmFpbCgpLmdldFJ1bm5pbmdUcmFja0NhcGFiaWxpdGllcygpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SHRtbDVRcmNvZGVPckZhaWwoKS5nZXRSdW5uaW5nVHJhY2tTZXR0aW5ncygpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5hcHBseVZpZGVvQ29uc3RyYWludHMgPSBmdW5jdGlvbiAodmlkZW9Db25zdGFpbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEh0bWw1UXJjb2RlT3JGYWlsKCkuYXBwbHlWaWRlb0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RhaW50cyk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmdldEh0bWw1UXJjb2RlT3JGYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaHRtbDVRcmNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IFwiQ29kZSBzY2FubmVyIG5vdCBpbml0aWFsaXplZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5odG1sNVFyY29kZTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5mcHMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZnBzID0gSHRtbDVRcmNvZGVDb25zdGFudHMuU0NBTl9ERUZBVUxUX0ZQUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcucmVtZW1iZXJMYXN0VXNlZENhbWVyYSAhPT0gKCFIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1JFTUVNQkVSX0xBU1RfQ0FNRVJBX1VTRUQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnJlbWVtYmVyTGFzdFVzZWRDYW1lcmFcbiAgICAgICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1JFTUVNQkVSX0xBU1RfQ0FNRVJBX1VTRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5zdXBwb3J0ZWRTY2FuVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcG9ydGVkU2NhblR5cGVzXG4gICAgICAgICAgICAgICAgICAgID0gSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9TVVBQT1JURURfU0NBTl9UWVBFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnBzOiBIdG1sNVFyY29kZUNvbnN0YW50cy5TQ0FOX0RFRkFVTFRfRlBTLFxuICAgICAgICAgICAgcmVtZW1iZXJMYXN0VXNlZENhbWVyYTogSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9SRU1FTUJFUl9MQVNUX0NBTUVSQV9VU0VELFxuICAgICAgICAgICAgc3VwcG9ydGVkU2NhblR5cGVzOiBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlQmFzaWNMYXlvdXQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgcGFyZW50LnN0eWxlLnBhZGRpbmcgPSBcIjBweFwiO1xuICAgICAgICBwYXJlbnQuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgc2lsdmVyXCI7XG4gICAgICAgIHRoaXMuY3JlYXRlSGVhZGVyKHBhcmVudCk7XG4gICAgICAgIHZhciBxckNvZGVTY2FuUmVnaW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIHNjYW5SZWdpb25JZCA9IHRoaXMuZ2V0U2NhblJlZ2lvbklkKCk7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uaWQgPSBzY2FuUmVnaW9uSWQ7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5zdHlsZS5taW5IZWlnaHQgPSBcIjEwMHB4XCI7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHFyQ29kZVNjYW5SZWdpb24pO1xuICAgICAgICBpZiAoU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHRoaXMuY3VycmVudFNjYW5UeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRDYW1lcmFTY2FuSW1hZ2VUb1NjYW5SZWdpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RmlsZVNjYW5JbWFnZVRvU2NhblJlZ2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxckNvZGVEYXNoYm9hcmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgZGFzaGJvYXJkSWQgPSB0aGlzLmdldERhc2hib2FyZElkKCk7XG4gICAgICAgIHFyQ29kZURhc2hib2FyZC5pZCA9IGRhc2hib2FyZElkO1xuICAgICAgICBxckNvZGVEYXNoYm9hcmQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHFyQ29kZURhc2hib2FyZCk7XG4gICAgICAgIHRoaXMuc2V0dXBJbml0aWFsRGFzaGJvYXJkKHFyQ29kZURhc2hib2FyZCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlc2V0QmFzaWNMYXlvdXQgPSBmdW5jdGlvbiAobWFpbkNvbnRhaW5lcikge1xuICAgICAgICBtYWluQ29udGFpbmVyLnN0eWxlLmJvcmRlciA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5zZXR1cEluaXRpYWxEYXNoYm9hcmQgPSBmdW5jdGlvbiAoZGFzaGJvYXJkKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlU2VjdGlvbihkYXNoYm9hcmQpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNlY3Rpb25Db250cm9sUGFuZWwoKTtcbiAgICAgICAgaWYgKHRoaXMuc2NhblR5cGVTZWxlY3Rvci5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2VjdGlvblN3YXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jcmVhdGVIZWFkZXIgPSBmdW5jdGlvbiAoZGFzaGJvYXJkKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBoZWFkZXIuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIGhlYWRlci5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICAgICAgICBkYXNoYm9hcmQuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgdmFyIGxpYnJhcnlJbmZvID0gbmV3IExpYnJhcnlJbmZvQ29udGFpbmVyKCk7XG4gICAgICAgIGxpYnJhcnlJbmZvLnJlbmRlckludG8oaGVhZGVyKTtcbiAgICAgICAgdmFyIGhlYWRlck1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBoZWFkZXJNZXNzYWdlQ29udGFpbmVyLmlkID0gdGhpcy5nZXRIZWFkZXJNZXNzYWdlQ29udGFpbmVySWQoKTtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGhlYWRlck1lc3NhZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5zdHlsZS5mb250U2l6ZSA9IFwiMTRweFwiO1xuICAgICAgICBoZWFkZXJNZXNzYWdlQ29udGFpbmVyLnN0eWxlLnBhZGRpbmcgPSBcIjJweCAxMHB4XCI7XG4gICAgICAgIGhlYWRlck1lc3NhZ2VDb250YWluZXIuc3R5bGUubWFyZ2luID0gXCI0cHhcIjtcbiAgICAgICAgaGVhZGVyTWVzc2FnZUNvbnRhaW5lci5zdHlsZS5ib3JkZXJUb3AgPSBcIjFweCBzb2xpZCAjZjZmNmY2XCI7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChoZWFkZXJNZXNzYWdlQ29udGFpbmVyKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlU2VjdGlvbiA9IGZ1bmN0aW9uIChkYXNoYm9hcmQpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzZWN0aW9uLmlkID0gdGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uSWQoKTtcbiAgICAgICAgc2VjdGlvbi5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICBzZWN0aW9uLnN0eWxlLnBhZGRpbmcgPSBcIjEwcHggMHB4IDEwcHggMHB4XCI7XG4gICAgICAgIHNlY3Rpb24uc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIGRhc2hib2FyZC5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhTGlzdFVpID0gZnVuY3Rpb24gKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyLCByZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbikge1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsoZmFsc2UpO1xuICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhUGVybWlzc2lvblJlcXVlc3RpbmcoKSk7XG4gICAgICAgIHZhciBjcmVhdGVQZXJtaXNzaW9uQnV0dG9uSWZOb3RFeGlzdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuY3JlYXRlUGVybWlzc2lvbkJ1dHRvbihzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEh0bWw1UXJjb2RlLmdldENhbWVyYXMoKS50aGVuKGZ1bmN0aW9uIChjYW1lcmFzKSB7XG4gICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRIYXNQZXJtaXNzaW9uKHRydWUpO1xuICAgICAgICAgICAgJHRoaXMuc2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rKHRydWUpO1xuICAgICAgICAgICAgJHRoaXMucmVzZXRIZWFkZXJNZXNzYWdlKCk7XG4gICAgICAgICAgICBpZiAoY2FtZXJhcyAmJiBjYW1lcmFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzY3BDYW1lcmFTY2FuUmVnaW9uLnJlbW92ZUNoaWxkKHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5yZW5kZXJDYW1lcmFTZWxlY3Rpb24oY2FtZXJhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZCgpLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1dBUk5JTkcpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVBlcm1pc3Npb25CdXR0b25JZk5vdEV4aXN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnNldEhhc1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVBlcm1pc3Npb25CdXR0b25JZk5vdEV4aXN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShlcnJvciwgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19XQVJOSU5HKTtcbiAgICAgICAgICAgICR0aGlzLnNob3dIaWRlU2NhblR5cGVTd2FwTGluayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZVBlcm1pc3Npb25CdXR0b24gPSBmdW5jdGlvbiAoc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uID0gQmFzZVVpRWxlbWVudEZhY3RvcnlcbiAgICAgICAgICAgIC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHRoaXMuZ2V0Q2FtZXJhUGVybWlzc2lvbkJ1dHRvbklkKCkpO1xuICAgICAgICByZXF1ZXN0UGVybWlzc2lvbkJ1dHRvbi5pbm5lclRleHRcbiAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jYW1lcmFQZXJtaXNzaW9uVGl0bGUoKTtcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICR0aGlzLmNyZWF0ZUNhbWVyYUxpc3RVaShzY3BDYW1lcmFTY2FuUmVnaW9uLCByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lciwgcmVxdWVzdFBlcm1pc3Npb25CdXR0b24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIuYXBwZW5kQ2hpbGQocmVxdWVzdFBlcm1pc3Npb25CdXR0b24pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jcmVhdGVQZXJtaXNzaW9uc1VpID0gZnVuY3Rpb24gKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChTY2FuVHlwZVNlbGVjdG9yLmlzQ2FtZXJhU2NhblR5cGUodGhpcy5jdXJyZW50U2NhblR5cGUpXG4gICAgICAgICAgICAmJiB0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLmhhc0NhbWVyYVBlcm1pc3Npb25zKCkpIHtcbiAgICAgICAgICAgIENhbWVyYVBlcm1pc3Npb25zLmhhc1Blcm1pc3Npb25zKCkudGhlbihmdW5jdGlvbiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuY3JlYXRlQ2FtZXJhTGlzdFVpKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnNldEhhc1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5jcmVhdGVQZXJtaXNzaW9uQnV0dG9uKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnNldEhhc1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICR0aGlzLmNyZWF0ZVBlcm1pc3Npb25CdXR0b24oc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVQZXJtaXNzaW9uQnV0dG9uKHNjcENhbWVyYVNjYW5SZWdpb24sIHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuY3JlYXRlU2VjdGlvbkNvbnRyb2xQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldERhc2hib2FyZFNlY3Rpb25JZCgpKTtcbiAgICAgICAgdmFyIHNlY3Rpb25Db250cm9sUGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKHNlY3Rpb25Db250cm9sUGFuZWwpO1xuICAgICAgICB2YXIgc2NwQ2FtZXJhU2NhblJlZ2lvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNjcENhbWVyYVNjYW5SZWdpb24uaWQgPSB0aGlzLmdldERhc2hib2FyZFNlY3Rpb25DYW1lcmFTY2FuUmVnaW9uSWQoKTtcbiAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5zdHlsZS5kaXNwbGF5XG4gICAgICAgICAgICA9IFNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuVHlwZSh0aGlzLmN1cnJlbnRTY2FuVHlwZSlcbiAgICAgICAgICAgICAgICA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICBzZWN0aW9uQ29udHJvbFBhbmVsLmFwcGVuZENoaWxkKHNjcENhbWVyYVNjYW5SZWdpb24pO1xuICAgICAgICB2YXIgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICByZXF1ZXN0UGVybWlzc2lvbkNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBzY3BDYW1lcmFTY2FuUmVnaW9uLmFwcGVuZENoaWxkKHJlcXVlc3RQZXJtaXNzaW9uQ29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuc2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5SZXF1aXJlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBlcm1pc3Npb25zVWkoc2NwQ2FtZXJhU2NhblJlZ2lvbiwgcmVxdWVzdFBlcm1pc3Npb25Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyRmlsZVNjYW5VaShzZWN0aW9uQ29udHJvbFBhbmVsKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUucmVuZGVyRmlsZVNjYW5VaSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIHNob3dPblJlbmRlciA9IFNjYW5UeXBlU2VsZWN0b3IuaXNGaWxlU2NhblR5cGUodGhpcy5jdXJyZW50U2NhblR5cGUpO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb25GaWxlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgaWYgKCEkdGhpcy5odG1sNVFyY29kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaHRtbDVRcmNvZGUgbm90IGRlZmluZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghU2NhblR5cGVTZWxlY3Rvci5pc0ZpbGVTY2FuVHlwZSgkdGhpcy5jdXJyZW50U2NhblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmxvYWRpbmdJbWFnZSgpKTtcbiAgICAgICAgICAgICR0aGlzLmh0bWw1UXJjb2RlLnNjYW5GaWxlVjIoZmlsZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaHRtbDVxcmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5yZXNldEhlYWRlck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5xckNvZGVTdWNjZXNzQ2FsbGJhY2soaHRtbDVxcmNvZGVSZXN1bHQuZGVjb2RlZFRleHQsIGh0bWw1cXJjb2RlUmVzdWx0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICR0aGlzLnNldEhlYWRlck1lc3NhZ2UoZXJyb3IsIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORyk7XG4gICAgICAgICAgICAgICAgJHRoaXMucXJDb2RlRXJyb3JDYWxsYmFjayhlcnJvciwgSHRtbDVRcmNvZGVFcnJvckZhY3RvcnkuY3JlYXRlRnJvbShlcnJvcikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsZVNlbGVjdGlvblVpID0gRmlsZVNlbGVjdGlvblVpLmNyZWF0ZShwYXJlbnQsIHNob3dPblJlbmRlciwgb25GaWxlU2VsZWN0ZWQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5yZW5kZXJDYW1lcmFTZWxlY3Rpb24gPSBmdW5jdGlvbiAoY2FtZXJhcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2NwQ2FtZXJhU2NhblJlZ2lvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvbkNhbWVyYVNjYW5SZWdpb25JZCgpKTtcbiAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB2YXIgY2FtZXJhWm9vbVVpID0gQ2FtZXJhWm9vbVVpLmNyZWF0ZShzY3BDYW1lcmFTY2FuUmVnaW9uLCBmYWxzZSk7XG4gICAgICAgIHZhciByZW5kZXJDYW1lcmFab29tVWlJZlN1cHBvcnRlZCA9IGZ1bmN0aW9uIChjYW1lcmFDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgIHZhciB6b29tQ2FwYWJpbGl0eSA9IGNhbWVyYUNhcGFiaWxpdGllcy56b29tRmVhdHVyZSgpO1xuICAgICAgICAgICAgaWYgKCF6b29tQ2FwYWJpbGl0eS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FtZXJhWm9vbVVpLnNldE9uQ2FtZXJhWm9vbVZhbHVlQ2hhbmdlQ2FsbGJhY2soZnVuY3Rpb24gKHpvb21WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHpvb21DYXBhYmlsaXR5LmFwcGx5KHpvb21WYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Wm9vbSA9IDE7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmRlZmF1bHRab29tVmFsdWVJZlN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRab29tID0gX3RoaXMuY29uZmlnLmRlZmF1bHRab29tVmFsdWVJZlN1cHBvcnRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHRab29tID0gY2xpcChkZWZhdWx0Wm9vbSwgem9vbUNhcGFiaWxpdHkubWluKCksIHpvb21DYXBhYmlsaXR5Lm1heCgpKTtcbiAgICAgICAgICAgIGNhbWVyYVpvb21VaS5zZXRWYWx1ZXMoem9vbUNhcGFiaWxpdHkubWluKCksIHpvb21DYXBhYmlsaXR5Lm1heCgpLCBkZWZhdWx0Wm9vbSwgem9vbUNhcGFiaWxpdHkuc3RlcCgpKTtcbiAgICAgICAgICAgIGNhbWVyYVpvb21VaS5zaG93KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYW1lcmFTZWxlY3RVaSA9IENhbWVyYVNlbGVjdGlvblVpLmNyZWF0ZShzY3BDYW1lcmFTY2FuUmVnaW9uLCBjYW1lcmFzKTtcbiAgICAgICAgdmFyIGNhbWVyYUFjdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB2YXIgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24gPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5DQU1FUkFfU1RBUlRfQlVUVE9OX0lEKTtcbiAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uaW5uZXJUZXh0XG4gICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muc2NhbkJ1dHRvblN0YXJ0U2Nhbm5pbmdUZXh0KCk7XG4gICAgICAgIGNhbWVyYUFjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbik7XG4gICAgICAgIHZhciBjYW1lcmFBY3Rpb25TdG9wQnV0dG9uID0gQmFzZVVpRWxlbWVudEZhY3RvcnkuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQ0FNRVJBX1NUT1BfQlVUVE9OX0lEKTtcbiAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5pbm5lclRleHRcbiAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zY2FuQnV0dG9uU3RvcFNjYW5uaW5nVGV4dCgpO1xuICAgICAgICBjYW1lcmFBY3Rpb25TdG9wQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGNhbWVyYUFjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW1lcmFBY3Rpb25TdG9wQnV0dG9uKTtcbiAgICAgICAgdmFyIHRvcmNoQnV0dG9uO1xuICAgICAgICB2YXIgY3JlYXRlQW5kU2hvd1RvcmNoQnV0dG9uSWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoY2FtZXJhQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICBpZiAoIWNhbWVyYUNhcGFiaWxpdGllcy50b3JjaEZlYXR1cmUoKS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcmNoQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0b3JjaEJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uID0gVG9yY2hCdXR0b24uY3JlYXRlKGNhbWVyYUFjdGlvbkNvbnRhaW5lciwgY2FtZXJhQ2FwYWJpbGl0aWVzLnRvcmNoRmVhdHVyZSgpLCB7IGRpc3BsYXk6IFwibm9uZVwiLCBtYXJnaW5MZWZ0OiBcIjVweFwiIH0sIGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuc2V0SGVhZGVyTWVzc2FnZShlcnJvck1lc3NhZ2UsIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3JjaEJ1dHRvbi51cGRhdGVUb3JjaENhcGFiaWxpdHkoY2FtZXJhQ2FwYWJpbGl0aWVzLnRvcmNoRmVhdHVyZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcmNoQnV0dG9uLnNob3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NwQ2FtZXJhU2NhblJlZ2lvbi5hcHBlbmRDaGlsZChjYW1lcmFBY3Rpb25Db250YWluZXIpO1xuICAgICAgICB2YXIgcmVzZXRDYW1lcmFBY3Rpb25TdGFydEJ1dHRvbiA9IGZ1bmN0aW9uIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFNob3cpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5pbm5lclRleHRcbiAgICAgICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgLnNjYW5CdXR0b25TdGFydFNjYW5uaW5nVGV4dCgpO1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uaW5uZXJUZXh0XG4gICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TY2FubmluZ1N0YXJ0aW5nKCk7XG4gICAgICAgICAgICBjYW1lcmFTZWxlY3RVaS5kaXNhYmxlKCk7XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gXCIwLjVcIjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY2FuVHlwZVNlbGVjdG9yLmhhc01vcmVUaGFuT25lU2NhblR5cGUoKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLnNob3dIaWRlU2NhblR5cGVTd2FwTGluayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdGhpcy5yZXNldEhlYWRlck1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHZhciBjYW1lcmFJZCA9IGNhbWVyYVNlbGVjdFVpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRMYXN0VXNlZENhbWVyYUlkKGNhbWVyYUlkKTtcbiAgICAgICAgICAgICR0aGlzLmh0bWw1UXJjb2RlLnN0YXJ0KGNhbWVyYUlkLCB0b0h0bWw1UXJjb2RlQ2FtZXJhU2NhbkNvbmZpZygkdGhpcy5jb25maWcpLCAkdGhpcy5xckNvZGVTdWNjZXNzQ2FsbGJhY2ssICR0aGlzLnFyQ29kZUVycm9yQ2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICBjYW1lcmFBY3Rpb25TdG9wQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICAgICAgICByZXNldENhbWVyYUFjdGlvblN0YXJ0QnV0dG9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FtZXJhQ2FwYWJpbGl0aWVzID0gJHRoaXMuaHRtbDVRcmNvZGUuZ2V0UnVubmluZ1RyYWNrQ2FtZXJhQ2FwYWJpbGl0aWVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5zaG93VG9yY2hCdXR0b25JZlN1cHBvcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVBbmRTaG93VG9yY2hCdXR0b25JZlN1cHBvcnRlZChjYW1lcmFDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLnNob3dab29tU2xpZGVySWZTdXBwb3J0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ2FtZXJhWm9vbVVpSWZTdXBwb3J0ZWQoY2FtZXJhQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsodHJ1ZSk7XG4gICAgICAgICAgICAgICAgY2FtZXJhU2VsZWN0VWkuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgcmVzZXRDYW1lcmFBY3Rpb25TdGFydEJ1dHRvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5zZXRIZWFkZXJNZXNzYWdlKGVycm9yLCBIdG1sNVFyY29kZVNjYW5uZXJTdGF0dXMuU1RBVFVTX1dBUk5JTkcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FtZXJhU2VsZWN0VWkuaGFzU2luZ2xlSXRlbSgpKSB7XG4gICAgICAgICAgICBjYW1lcmFBY3Rpb25TdGFydEJ1dHRvbi5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIGNhbWVyYUFjdGlvblN0b3BCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoISR0aGlzLmh0bWw1UXJjb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJodG1sNVFyY29kZSBub3QgZGVmaW5lZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAkdGhpcy5odG1sNVFyY29kZS5zdG9wKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY2FuVHlwZVNlbGVjdG9yLmhhc01vcmVUaGFuT25lU2NhblR5cGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5zaG93SGlkZVNjYW5UeXBlU3dhcExpbmsodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbWVyYVNlbGVjdFVpLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIGNhbWVyYUFjdGlvblN0YXJ0QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRvcmNoQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRvcmNoQnV0dG9uLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FtZXJhWm9vbVVpLnJlbW92ZU9uQ2FtZXJhWm9vbVZhbHVlQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBjYW1lcmFab29tVWkuaGlkZSgpO1xuICAgICAgICAgICAgICAgICR0aGlzLmluc2VydENhbWVyYVNjYW5JbWFnZVRvU2NhblJlZ2lvbigpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RvcEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICR0aGlzLnNldEhlYWRlck1lc3NhZ2UoZXJyb3IsIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfV0FSTklORyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5nZXRMYXN0VXNlZENhbWVyYUlkKCkpIHtcbiAgICAgICAgICAgIHZhciBjYW1lcmFJZCA9ICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLmdldExhc3RVc2VkQ2FtZXJhSWQoKTtcbiAgICAgICAgICAgIGlmIChjYW1lcmFTZWxlY3RVaS5oYXNWYWx1ZShjYW1lcmFJZCkpIHtcbiAgICAgICAgICAgICAgICBjYW1lcmFTZWxlY3RVaS5zZXRWYWx1ZShjYW1lcmFJZCk7XG4gICAgICAgICAgICAgICAgY2FtZXJhQWN0aW9uU3RhcnRCdXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICR0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLnJlc2V0TGFzdFVzZWRDYW1lcmFJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmNyZWF0ZVNlY3Rpb25Td2FwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgVEVYVF9JRl9DQU1FUkFfU0NBTl9TRUxFQ1RFRCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudGV4dElmQ2FtZXJhU2NhblNlbGVjdGVkKCk7XG4gICAgICAgIHZhciBURVhUX0lGX0ZJTEVfU0NBTl9TRUxFQ1RFRCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudGV4dElmRmlsZVNjYW5TZWxlY3RlZCgpO1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvbklkKCkpO1xuICAgICAgICB2YXIgc3dpdGNoQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgc3dpdGNoQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHZhciBzd2l0Y2hTY2FuVHlwZUxpbmsgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB0aGlzLmdldERhc2hib2FyZFNlY3Rpb25Td2FwTGlua0lkKCkpO1xuICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuc3R5bGUudGV4dERlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xuICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgIHN3aXRjaFNjYW5UeXBlTGluay5pbm5lclRleHRcbiAgICAgICAgICAgID0gU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHRoaXMuY3VycmVudFNjYW5UeXBlKVxuICAgICAgICAgICAgICAgID8gVEVYVF9JRl9DQU1FUkFfU0NBTl9TRUxFQ1RFRCA6IFRFWFRfSUZfRklMRV9TQ0FOX1NFTEVDVEVEO1xuICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghJHRoaXMuc2VjdGlvblN3YXBBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiU2VjdGlvbiBzd2FwIGNhbGxlZCB3aGVuIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdGhpcy5yZXNldEhlYWRlck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICR0aGlzLmZpbGVTZWxlY3Rpb25VaS5yZXNldFZhbHVlKCk7XG4gICAgICAgICAgICAkdGhpcy5zZWN0aW9uU3dhcEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChTY2FuVHlwZVNlbGVjdG9yLmlzQ2FtZXJhU2NhblR5cGUoJHRoaXMuY3VycmVudFNjYW5UeXBlKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmNsZWFyU2NhblJlZ2lvbigpO1xuICAgICAgICAgICAgICAgICR0aGlzLmdldENhbWVyYVNjYW5SZWdpb24oKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgJHRoaXMuZmlsZVNlbGVjdGlvblVpLnNob3coKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hTY2FuVHlwZUxpbmsuaW5uZXJUZXh0ID0gVEVYVF9JRl9GSUxFX1NDQU5fU0VMRUNURUQ7XG4gICAgICAgICAgICAgICAgJHRoaXMuY3VycmVudFNjYW5UeXBlID0gSHRtbDVRcmNvZGVTY2FuVHlwZS5TQ0FOX1RZUEVfRklMRTtcbiAgICAgICAgICAgICAgICAkdGhpcy5pbnNlcnRGaWxlU2NhbkltYWdlVG9TY2FuUmVnaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jbGVhclNjYW5SZWdpb24oKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5nZXRDYW1lcmFTY2FuUmVnaW9uKCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAkdGhpcy5maWxlU2VsZWN0aW9uVWkuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaFNjYW5UeXBlTGluay5pbm5lclRleHQgPSBURVhUX0lGX0NBTUVSQV9TQ0FOX1NFTEVDVEVEO1xuICAgICAgICAgICAgICAgICR0aGlzLmN1cnJlbnRTY2FuVHlwZSA9IEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0NBTUVSQTtcbiAgICAgICAgICAgICAgICAkdGhpcy5pbnNlcnRDYW1lcmFTY2FuSW1hZ2VUb1NjYW5SZWdpb24oKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5zdGFydENhbWVyYVNjYW5JZlBlcm1pc3Npb25FeGlzdHNPblN3YXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aGlzLnNlY3Rpb25Td2FwQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2hDb250YWluZXIuYXBwZW5kQ2hpbGQoc3dpdGNoU2NhblR5cGVMaW5rKTtcbiAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChzd2l0Y2hDb250YWluZXIpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5zdGFydENhbWVyYVNjYW5JZlBlcm1pc3Npb25FeGlzdHNPblN3YXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlZERhdGFNYW5hZ2VyLmhhc0NhbWVyYVBlcm1pc3Npb25zKCkpIHtcbiAgICAgICAgICAgIENhbWVyYVBlcm1pc3Npb25zLmhhc1Blcm1pc3Npb25zKCkudGhlbihmdW5jdGlvbiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcm1pc3Npb25CdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgkdGhpcy5nZXRDYW1lcmFQZXJtaXNzaW9uQnV0dG9uSWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGVybWlzc2lvbkJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiUGVybWlzc2lvbiBidXR0b24gbm90IGZvdW5kLCBmYWlsO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiUGVybWlzc2lvbiBidXR0b24gbm90IGZvdW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbkJ1dHRvbi5jbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucGVyc2lzdGVkRGF0YU1hbmFnZXIuc2V0SGFzUGVybWlzc2lvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5wZXJzaXN0ZWREYXRhTWFuYWdlci5zZXRIYXNQZXJtaXNzaW9uKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnJlc2V0SGVhZGVyTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldEhlYWRlck1lc3NhZ2VDb250YWluZXJJZCgpKTtcbiAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLnNldEhlYWRlck1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZVRleHQsIHNjYW5uZXJTdGF0dXMpIHtcbiAgICAgICAgaWYgKCFzY2FubmVyU3RhdHVzKSB7XG4gICAgICAgICAgICBzY2FubmVyU3RhdHVzID0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlRGl2ID0gdGhpcy5nZXRIZWFkZXJNZXNzYWdlRGl2KCk7XG4gICAgICAgIG1lc3NhZ2VEaXYuaW5uZXJUZXh0ID0gbWVzc2FnZVRleHQ7XG4gICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgc3dpdGNoIChzY2FubmVyU3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGl2LnN0eWxlLmJhY2tncm91bmQgPSBcInJnYmEoMTA2LCAxNzUsIDgwLCAwLjI2KVwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuY29sb3IgPSBcIiM0Nzc3MzVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSHRtbDVRcmNvZGVTY2FubmVyU3RhdHVzLlNUQVRVU19XQVJOSU5HOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VEaXYuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgyMDMsIDM2LCA0OSwgMC4xNClcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGl2LnN0eWxlLmNvbG9yID0gXCIjY2IyNDMxXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXR1cy5TVEFUVVNfREVGQVVMVDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5zdHlsZS5jb2xvciA9IFwicmdiKDE3LCAxNywgMTcpXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuc2hvd0hpZGVTY2FuVHlwZVN3YXBMaW5rID0gZnVuY3Rpb24gKHNob3VsZERpc3BsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NhblR5cGVTZWxlY3Rvci5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlKCkpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGREaXNwbGF5ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkRGlzcGxheSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWN0aW9uU3dhcEFsbG93ZWQgPSBzaG91bGREaXNwbGF5O1xuICAgICAgICAgICAgdGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uU3dhcExpbmsoKS5zdHlsZS5kaXNwbGF5XG4gICAgICAgICAgICAgICAgPSBzaG91bGREaXNwbGF5ID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXIucHJvdG90eXBlLmluc2VydENhbWVyYVNjYW5JbWFnZVRvU2NhblJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHFyQ29kZVNjYW5SZWdpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldFNjYW5SZWdpb25JZCgpKTtcbiAgICAgICAgaWYgKHRoaXMuY2FtZXJhU2NhbkltYWdlKSB7XG4gICAgICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmlubmVySFRNTCA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5hcHBlbmRDaGlsZCh0aGlzLmNhbWVyYVNjYW5JbWFnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2UgPSBuZXcgSW1hZ2U7XG4gICAgICAgIHRoaXMuY2FtZXJhU2NhbkltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBxckNvZGVTY2FuUmVnaW9uLmlubmVySFRNTCA9IFwiPGJyPlwiO1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5hcHBlbmRDaGlsZCgkdGhpcy5jYW1lcmFTY2FuSW1hZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbWVyYVNjYW5JbWFnZS53aWR0aCA9IDY0O1xuICAgICAgICB0aGlzLmNhbWVyYVNjYW5JbWFnZS5zdHlsZS5vcGFjaXR5ID0gXCIwLjhcIjtcbiAgICAgICAgdGhpcy5jYW1lcmFTY2FuSW1hZ2Uuc3JjID0gQVNTRVRfQ0FNRVJBX1NDQU47XG4gICAgICAgIHRoaXMuY2FtZXJhU2NhbkltYWdlLmFsdCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhU2NhbkFsdFRleHQoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuaW5zZXJ0RmlsZVNjYW5JbWFnZVRvU2NhblJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHFyQ29kZVNjYW5SZWdpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldFNjYW5SZWdpb25JZCgpKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsZVNjYW5JbWFnZSkge1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5pbm5lckhUTUwgPSBcIjxicj5cIjtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uYXBwZW5kQ2hpbGQodGhpcy5maWxlU2NhbkltYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2UgPSBuZXcgSW1hZ2U7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcXJDb2RlU2NhblJlZ2lvbi5pbm5lckhUTUwgPSBcIjxicj5cIjtcbiAgICAgICAgICAgIHFyQ29kZVNjYW5SZWdpb24uYXBwZW5kQ2hpbGQoJHRoaXMuZmlsZVNjYW5JbWFnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS53aWR0aCA9IDY0O1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW1hZ2Uuc3R5bGUub3BhY2l0eSA9IFwiMC44XCI7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS5zcmMgPSBBU1NFVF9GSUxFX1NDQU47XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbWFnZS5hbHQgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTY2FuQWx0VGV4dCgpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5jbGVhclNjYW5SZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxckNvZGVTY2FuUmVnaW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRTY2FuUmVnaW9uSWQoKSk7XG4gICAgICAgIHFyQ29kZVNjYW5SZWdpb24uaW5uZXJIVE1MID0gXCJcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkU2VjdGlvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiX19kYXNoYm9hcmRfc2VjdGlvblwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkU2VjdGlvbkNhbWVyYVNjYW5SZWdpb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuZWxlbWVudElkLCBcIl9fZGFzaGJvYXJkX3NlY3Rpb25fY3NyXCIpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyLnByb3RvdHlwZS5nZXREYXNoYm9hcmRTZWN0aW9uU3dhcExpbmtJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5TQ0FOX1RZUEVfQ0hBTkdFX0FOQ0hPUl9JRDtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0U2NhblJlZ2lvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiX19zY2FuX3JlZ2lvblwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmVsZW1lbnRJZCwgXCJfX2Rhc2hib2FyZFwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0SGVhZGVyTWVzc2FnZUNvbnRhaW5lcklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5lbGVtZW50SWQsIFwiX19oZWFkZXJfbWVzc2FnZVwiKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0Q2FtZXJhUGVybWlzc2lvbkJ1dHRvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9QRVJNSVNTSU9OX0JVVFRPTl9JRDtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0Q2FtZXJhU2NhblJlZ2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0RGFzaGJvYXJkU2VjdGlvbkNhbWVyYVNjYW5SZWdpb25JZCgpKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0RGFzaGJvYXJkU2VjdGlvblN3YXBMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXREYXNoYm9hcmRTZWN0aW9uU3dhcExpbmtJZCgpKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lci5wcm90b3R5cGUuZ2V0SGVhZGVyTWVzc2FnZURpdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0SGVhZGVyTWVzc2FnZUNvbnRhaW5lcklkKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlU2Nhbm5lcjtcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWw1LXFyY29kZS1zY2FubmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/html5-qrcode-scanner.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/html5-qrcode.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/html5-qrcode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5Qrcode: () => (/* binding */ Html5Qrcode)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"../../../node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"../../../node_modules/html5-qrcode/esm/utils.js\");\n/* harmony import */ var _code_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./code-decoder */ \"../../../node_modules/html5-qrcode/esm/code-decoder.js\");\n/* harmony import */ var _camera_factories__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./camera/factories */ \"../../../node_modules/html5-qrcode/esm/camera/factories.js\");\n/* harmony import */ var _camera_retriever__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./camera/retriever */ \"../../../node_modules/html5-qrcode/esm/camera/retriever.js\");\n/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./state-manager */ \"../../../node_modules/html5-qrcode/esm/state-manager.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\nvar Constants = (function (_super) {\n    __extends(Constants, _super);\n    function Constants() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Constants.DEFAULT_WIDTH = 300;\n    Constants.DEFAULT_WIDTH_OFFSET = 2;\n    Constants.FILE_SCAN_MIN_HEIGHT = 300;\n    Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100;\n    Constants.MIN_QR_BOX_SIZE = 50;\n    Constants.SHADED_LEFT = 1;\n    Constants.SHADED_RIGHT = 2;\n    Constants.SHADED_TOP = 3;\n    Constants.SHADED_BOTTOM = 4;\n    Constants.SHADED_REGION_ELEMENT_ID = \"qr-shaded-region\";\n    Constants.VERBOSE = false;\n    Constants.BORDER_SHADER_DEFAULT_COLOR = \"#ffffff\";\n    Constants.BORDER_SHADER_MATCH_COLOR = \"rgb(90, 193, 56)\";\n    return Constants;\n}(_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants));\nvar InternalHtml5QrcodeConfig = (function () {\n    function InternalHtml5QrcodeConfig(config, logger) {\n        this.logger = logger;\n        this.fps = Constants.SCAN_DEFAULT_FPS;\n        if (!config) {\n            this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;\n        }\n        else {\n            if (config.fps) {\n                this.fps = config.fps;\n            }\n            this.disableFlip = config.disableFlip === true;\n            this.qrbox = config.qrbox;\n            this.aspectRatio = config.aspectRatio;\n            this.videoConstraints = config.videoConstraints;\n        }\n    }\n    InternalHtml5QrcodeConfig.prototype.isMediaStreamConstraintsValid = function () {\n        if (!this.videoConstraints) {\n            this.logger.logError(\"Empty videoConstraints\", true);\n            return false;\n        }\n        return _utils__WEBPACK_IMPORTED_MODULE_2__.VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);\n    };\n    InternalHtml5QrcodeConfig.prototype.isShadedBoxEnabled = function () {\n        return !(0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(this.qrbox);\n    };\n    InternalHtml5QrcodeConfig.create = function (config, logger) {\n        return new InternalHtml5QrcodeConfig(config, logger);\n    };\n    return InternalHtml5QrcodeConfig;\n}());\nvar Html5Qrcode = (function () {\n    function Html5Qrcode(elementId, configOrVerbosityFlag) {\n        this.element = null;\n        this.canvasElement = null;\n        this.scannerPausedUiElement = null;\n        this.hasBorderShaders = null;\n        this.borderShaders = null;\n        this.qrMatch = null;\n        this.renderedCamera = null;\n        this.qrRegion = null;\n        this.context = null;\n        this.lastScanImageFile = null;\n        this.isScanning = false;\n        if (!document.getElementById(elementId)) {\n            throw \"HTML Element with id=\".concat(elementId, \" not found\");\n        }\n        this.elementId = elementId;\n        this.verbose = false;\n        var experimentalFeatureConfig;\n        var configObject;\n        if (typeof configOrVerbosityFlag == \"boolean\") {\n            this.verbose = configOrVerbosityFlag === true;\n        }\n        else if (configOrVerbosityFlag) {\n            configObject = configOrVerbosityFlag;\n            this.verbose = configObject.verbose === true;\n            experimentalFeatureConfig = configObject.experimentalFeatures;\n        }\n        this.logger = new _core__WEBPACK_IMPORTED_MODULE_0__.BaseLoggger(this.verbose);\n        this.qrcode = new _code_decoder__WEBPACK_IMPORTED_MODULE_3__.Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.getUseBarCodeDetectorIfSupported(configObject), this.verbose, this.logger);\n        this.foreverScanTimeout;\n        this.shouldScan = true;\n        this.stateManagerProxy = _state_manager__WEBPACK_IMPORTED_MODULE_6__.StateManagerFactory.create();\n    }\n    Html5Qrcode.prototype.start = function (cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (!cameraIdOrConfig) {\n            throw \"cameraIdOrConfig is required\";\n        }\n        if (!qrCodeSuccessCallback\n            || typeof qrCodeSuccessCallback != \"function\") {\n            throw \"qrCodeSuccessCallback is required and should be a function.\";\n        }\n        var qrCodeErrorCallbackInternal;\n        if (qrCodeErrorCallback) {\n            qrCodeErrorCallbackInternal = qrCodeErrorCallback;\n        }\n        else {\n            qrCodeErrorCallbackInternal\n                = this.verbose ? this.logger.log : function () { };\n        }\n        var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);\n        this.clearElement();\n        var videoConstraintsAvailableAndValid = false;\n        if (internalConfig.videoConstraints) {\n            if (!internalConfig.isMediaStreamConstraintsValid()) {\n                this.logger.logError(\"'videoConstraints' is not valid 'MediaStreamConstraints, \"\n                    + \"it will be ignored.'\", true);\n            }\n            else {\n                videoConstraintsAvailableAndValid = true;\n            }\n        }\n        var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;\n        var element = document.getElementById(this.elementId);\n        var rootElementWidth = element.clientWidth\n            ? element.clientWidth : Constants.DEFAULT_WIDTH;\n        element.style.position = \"relative\";\n        this.shouldScan = true;\n        this.element = element;\n        var $this = this;\n        var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.SCANNING);\n        return new Promise(function (resolve, reject) {\n            var videoConstraints = areVideoConstraintsEnabled\n                ? internalConfig.videoConstraints\n                : $this.createVideoConstraints(cameraIdOrConfig);\n            if (!videoConstraints) {\n                toScanningStateChangeTransaction.cancel();\n                reject(\"videoConstraints should be defined\");\n                return;\n            }\n            var cameraRenderingOptions = {};\n            if (!areVideoConstraintsEnabled || internalConfig.aspectRatio) {\n                cameraRenderingOptions.aspectRatio = internalConfig.aspectRatio;\n            }\n            var renderingCallbacks = {\n                onRenderSurfaceReady: function (viewfinderWidth, viewfinderHeight) {\n                    $this.setupUi(viewfinderWidth, viewfinderHeight, internalConfig);\n                    $this.isScanning = true;\n                    $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallbackInternal);\n                }\n            };\n            _camera_factories__WEBPACK_IMPORTED_MODULE_4__.CameraFactory.failIfNotSupported().then(function (factory) {\n                factory.create(videoConstraints).then(function (camera) {\n                    return camera.render(_this.element, cameraRenderingOptions, renderingCallbacks)\n                        .then(function (renderedCamera) {\n                        $this.renderedCamera = renderedCamera;\n                        toScanningStateChangeTransaction.execute();\n                        resolve(null);\n                    })\n                        .catch(function (error) {\n                        toScanningStateChangeTransaction.cancel();\n                        reject(error);\n                    });\n                }).catch(function (error) {\n                    toScanningStateChangeTransaction.cancel();\n                    reject(_strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.errorGettingUserMedia(error));\n                });\n            }).catch(function (_) {\n                toScanningStateChangeTransaction.cancel();\n                reject(_strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.cameraStreamingNotSupported());\n            });\n        });\n    };\n    Html5Qrcode.prototype.pause = function (shouldPauseVideo) {\n        if (!this.stateManagerProxy.isStrictlyScanning()) {\n            throw \"Cannot pause, scanner is not scanning.\";\n        }\n        this.stateManagerProxy.directTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.PAUSED);\n        this.showPausedState();\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(shouldPauseVideo) || shouldPauseVideo !== true) {\n            shouldPauseVideo = false;\n        }\n        if (shouldPauseVideo && this.renderedCamera) {\n            this.renderedCamera.pause();\n        }\n    };\n    Html5Qrcode.prototype.resume = function () {\n        if (!this.stateManagerProxy.isPaused()) {\n            throw \"Cannot result, scanner is not paused.\";\n        }\n        if (!this.renderedCamera) {\n            throw \"renderedCamera doesn't exist while trying resume()\";\n        }\n        var $this = this;\n        var transitionToScanning = function () {\n            $this.stateManagerProxy.directTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.SCANNING);\n            $this.hidePausedState();\n        };\n        if (!this.renderedCamera.isPaused()) {\n            transitionToScanning();\n            return;\n        }\n        this.renderedCamera.resume(function () {\n            transitionToScanning();\n        });\n    };\n    Html5Qrcode.prototype.getState = function () {\n        return this.stateManagerProxy.getState();\n    };\n    Html5Qrcode.prototype.stop = function () {\n        var _this = this;\n        if (!this.stateManagerProxy.isScanning()) {\n            throw \"Cannot stop, scanner is not running or paused.\";\n        }\n        var toStoppedStateTransaction = this.stateManagerProxy.startTransition(_state_manager__WEBPACK_IMPORTED_MODULE_6__.Html5QrcodeScannerState.NOT_STARTED);\n        this.shouldScan = false;\n        if (this.foreverScanTimeout) {\n            clearTimeout(this.foreverScanTimeout);\n        }\n        var removeQrRegion = function () {\n            if (!_this.element) {\n                return;\n            }\n            var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);\n            if (childElement) {\n                _this.element.removeChild(childElement);\n            }\n        };\n        var $this = this;\n        return this.renderedCamera.close().then(function () {\n            $this.renderedCamera = null;\n            if ($this.element) {\n                $this.element.removeChild($this.canvasElement);\n                $this.canvasElement = null;\n            }\n            removeQrRegion();\n            if ($this.qrRegion) {\n                $this.qrRegion = null;\n            }\n            if ($this.context) {\n                $this.context = null;\n            }\n            toStoppedStateTransaction.execute();\n            $this.hidePausedState();\n            $this.isScanning = false;\n            return Promise.resolve();\n        });\n    };\n    Html5Qrcode.prototype.scanFile = function (imageFile, showImage) {\n        return this.scanFileV2(imageFile, showImage)\n            .then(function (html5qrcodeResult) { return html5qrcodeResult.decodedText; });\n    };\n    Html5Qrcode.prototype.scanFileV2 = function (imageFile, showImage) {\n        var _this = this;\n        if (!imageFile || !(imageFile instanceof File)) {\n            throw \"imageFile argument is mandatory and should be instance \"\n                + \"of File. Use 'event.target.files[0]'.\";\n        }\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(showImage)) {\n            showImage = true;\n        }\n        if (!this.stateManagerProxy.canScanFile()) {\n            throw \"Cannot start file scan - ongoing camera scan\";\n        }\n        return new Promise(function (resolve, reject) {\n            _this.possiblyCloseLastScanImageFile();\n            _this.clearElement();\n            _this.lastScanImageFile = URL.createObjectURL(imageFile);\n            var inputImage = new Image;\n            inputImage.onload = function () {\n                var imageWidth = inputImage.width;\n                var imageHeight = inputImage.height;\n                var element = document.getElementById(_this.elementId);\n                var containerWidth = element.clientWidth\n                    ? element.clientWidth : Constants.DEFAULT_WIDTH;\n                var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);\n                var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n                if (showImage) {\n                    var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, \"qr-canvas-visible\");\n                    visibleCanvas.style.display = \"inline-block\";\n                    element.appendChild(visibleCanvas);\n                    var context_1 = visibleCanvas.getContext(\"2d\");\n                    if (!context_1) {\n                        throw \"Unable to get 2d context from canvas\";\n                    }\n                    context_1.canvas.width = containerWidth;\n                    context_1.canvas.height = containerHeight;\n                    context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);\n                }\n                var padding = Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING;\n                var hiddenImageWidth = Math.max(inputImage.width, config.width);\n                var hiddenImageHeight = Math.max(inputImage.height, config.height);\n                var hiddenCanvasWidth = hiddenImageWidth + 2 * padding;\n                var hiddenCanvasHeight = hiddenImageHeight + 2 * padding;\n                var hiddenCanvas = _this.createCanvasElement(hiddenCanvasWidth, hiddenCanvasHeight);\n                element.appendChild(hiddenCanvas);\n                var context = hiddenCanvas.getContext(\"2d\");\n                if (!context) {\n                    throw \"Unable to get 2d context from canvas\";\n                }\n                context.canvas.width = hiddenCanvasWidth;\n                context.canvas.height = hiddenCanvasHeight;\n                context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, padding, padding, hiddenImageWidth, hiddenImageHeight);\n                try {\n                    _this.qrcode.decodeRobustlyAsync(hiddenCanvas)\n                        .then(function (result) {\n                        resolve(_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeResultFactory.createFromQrcodeResult(result));\n                    })\n                        .catch(reject);\n                }\n                catch (exception) {\n                    reject(\"QR code parse error, error = \".concat(exception));\n                }\n            };\n            inputImage.onerror = reject;\n            inputImage.onabort = reject;\n            inputImage.onstalled = reject;\n            inputImage.onsuspend = reject;\n            inputImage.src = URL.createObjectURL(imageFile);\n        });\n    };\n    Html5Qrcode.prototype.clear = function () {\n        this.clearElement();\n    };\n    Html5Qrcode.getCameras = function () {\n        return _camera_retriever__WEBPACK_IMPORTED_MODULE_5__.CameraRetriever.retrieve();\n    };\n    Html5Qrcode.prototype.getRunningTrackCapabilities = function () {\n        return this.getRenderedCameraOrFail().getRunningTrackCapabilities();\n    };\n    Html5Qrcode.prototype.getRunningTrackSettings = function () {\n        return this.getRenderedCameraOrFail().getRunningTrackSettings();\n    };\n    Html5Qrcode.prototype.getRunningTrackCameraCapabilities = function () {\n        return this.getRenderedCameraOrFail().getCapabilities();\n    };\n    Html5Qrcode.prototype.applyVideoConstraints = function (videoConstaints) {\n        if (!videoConstaints) {\n            throw \"videoConstaints is required argument.\";\n        }\n        else if (!_utils__WEBPACK_IMPORTED_MODULE_2__.VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {\n            throw \"invalid videoConstaints passed, check logs for more details\";\n        }\n        return this.getRenderedCameraOrFail().applyVideoConstraints(videoConstaints);\n    };\n    Html5Qrcode.prototype.getRenderedCameraOrFail = function () {\n        if (this.renderedCamera == null) {\n            throw \"Scanning is not in running state, call this API only when\"\n                + \" QR code scanning using camera is in running state.\";\n        }\n        return this.renderedCamera;\n    };\n    Html5Qrcode.prototype.getSupportedFormats = function (configOrVerbosityFlag) {\n        var allFormats = [\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.QR_CODE,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.AZTEC,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODABAR,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_39,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_93,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_128,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.DATA_MATRIX,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.MAXICODE,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.ITF,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_13,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_8,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.PDF_417,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.RSS_14,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.RSS_EXPANDED,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_A,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_E,\n            _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,\n        ];\n        if (!configOrVerbosityFlag\n            || typeof configOrVerbosityFlag == \"boolean\") {\n            return allFormats;\n        }\n        if (!configOrVerbosityFlag.formatsToSupport) {\n            return allFormats;\n        }\n        if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {\n            throw \"configOrVerbosityFlag.formatsToSupport should be undefined \"\n                + \"or an array.\";\n        }\n        if (configOrVerbosityFlag.formatsToSupport.length === 0) {\n            throw \"Atleast 1 formatsToSupport is needed.\";\n        }\n        var supportedFormats = [];\n        for (var _i = 0, _a = configOrVerbosityFlag.formatsToSupport; _i < _a.length; _i++) {\n            var format = _a[_i];\n            if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isValidHtml5QrcodeSupportedFormats)(format)) {\n                supportedFormats.push(format);\n            }\n            else {\n                this.logger.warn(\"Invalid format: \".concat(format, \" passed in config, ignoring.\"));\n            }\n        }\n        if (supportedFormats.length === 0) {\n            throw \"None of formatsToSupport match supported values.\";\n        }\n        return supportedFormats;\n    };\n    Html5Qrcode.prototype.getUseBarCodeDetectorIfSupported = function (config) {\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config)) {\n            return true;\n        }\n        if (!(0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config.useBarCodeDetectorIfSupported)) {\n            return config.useBarCodeDetectorIfSupported !== false;\n        }\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config.experimentalFeatures)) {\n            return true;\n        }\n        var experimentalFeatures = config.experimentalFeatures;\n        if ((0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(experimentalFeatures.useBarCodeDetectorIfSupported)) {\n            return true;\n        }\n        return experimentalFeatures.useBarCodeDetectorIfSupported !== false;\n    };\n    Html5Qrcode.prototype.validateQrboxSize = function (viewfinderWidth, viewfinderHeight, internalConfig) {\n        var _this = this;\n        var qrboxSize = internalConfig.qrbox;\n        this.validateQrboxConfig(qrboxSize);\n        var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n        var validateMinSize = function (size) {\n            if (size < Constants.MIN_QR_BOX_SIZE) {\n                throw \"minimum size of 'config.qrbox' dimension value is\"\n                    + \" \".concat(Constants.MIN_QR_BOX_SIZE, \"px.\");\n            }\n        };\n        var correctWidthBasedOnRootElementSize = function (configWidth) {\n            if (configWidth > viewfinderWidth) {\n                _this.logger.warn(\"`qrbox.width` or `qrbox` is larger than the\"\n                    + \" width of the root element. The width will be truncated\"\n                    + \" to the width of root element.\");\n                configWidth = viewfinderWidth;\n            }\n            return configWidth;\n        };\n        validateMinSize(qrDimensions.width);\n        validateMinSize(qrDimensions.height);\n        qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);\n    };\n    Html5Qrcode.prototype.validateQrboxConfig = function (qrboxSize) {\n        if (typeof qrboxSize === \"number\") {\n            return;\n        }\n        if (typeof qrboxSize === \"function\") {\n            return;\n        }\n        if (qrboxSize.width === undefined || qrboxSize.height === undefined) {\n            throw \"Invalid instance of QrDimensions passed for \"\n                + \"'config.qrbox'. Both 'width' and 'height' should be set.\";\n        }\n    };\n    Html5Qrcode.prototype.toQrdimensions = function (viewfinderWidth, viewfinderHeight, qrboxSize) {\n        if (typeof qrboxSize === \"number\") {\n            return { width: qrboxSize, height: qrboxSize };\n        }\n        else if (typeof qrboxSize === \"function\") {\n            try {\n                return qrboxSize(viewfinderWidth, viewfinderHeight);\n            }\n            catch (error) {\n                throw new Error(\"qrbox config was passed as a function but it failed with \"\n                    + \"unknown error\" + error);\n            }\n        }\n        return qrboxSize;\n    };\n    Html5Qrcode.prototype.setupUi = function (viewfinderWidth, viewfinderHeight, internalConfig) {\n        if (internalConfig.isShadedBoxEnabled()) {\n            this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);\n        }\n        var qrboxSize = (0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(internalConfig.qrbox) ?\n            { width: viewfinderWidth, height: viewfinderHeight } : internalConfig.qrbox;\n        this.validateQrboxConfig(qrboxSize);\n        var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);\n        if (qrDimensions.height > viewfinderHeight) {\n            this.logger.warn(\"[Html5Qrcode] config.qrbox has height that is\"\n                + \"greater than the height of the video stream. Shading will be\"\n                + \" ignored\");\n        }\n        var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled()\n            && qrDimensions.height <= viewfinderHeight;\n        var defaultQrRegion = {\n            x: 0,\n            y: 0,\n            width: viewfinderWidth,\n            height: viewfinderHeight\n        };\n        var qrRegion = shouldShadingBeApplied\n            ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions)\n            : defaultQrRegion;\n        var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);\n        var contextAttributes = { willReadFrequently: true };\n        var context = canvasElement.getContext(\"2d\", contextAttributes);\n        context.canvas.width = qrRegion.width;\n        context.canvas.height = qrRegion.height;\n        this.element.append(canvasElement);\n        if (shouldShadingBeApplied) {\n            this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);\n        }\n        this.createScannerPausedUiElement(this.element);\n        this.qrRegion = qrRegion;\n        this.context = context;\n        this.canvasElement = canvasElement;\n    };\n    Html5Qrcode.prototype.createScannerPausedUiElement = function (rootElement) {\n        var scannerPausedUiElement = document.createElement(\"div\");\n        scannerPausedUiElement.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.scannerPaused();\n        scannerPausedUiElement.style.display = \"none\";\n        scannerPausedUiElement.style.position = \"absolute\";\n        scannerPausedUiElement.style.top = \"0px\";\n        scannerPausedUiElement.style.zIndex = \"1\";\n        scannerPausedUiElement.style.background = \"rgba(9, 9, 9, 0.46)\";\n        scannerPausedUiElement.style.color = \"#FFECEC\";\n        scannerPausedUiElement.style.textAlign = \"center\";\n        scannerPausedUiElement.style.width = \"100%\";\n        rootElement.appendChild(scannerPausedUiElement);\n        this.scannerPausedUiElement = scannerPausedUiElement;\n    };\n    Html5Qrcode.prototype.scanContext = function (qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (this.stateManagerProxy.isPaused()) {\n            return Promise.resolve(false);\n        }\n        return this.qrcode.decodeAsync(this.canvasElement)\n            .then(function (result) {\n            qrCodeSuccessCallback(result.text, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeResultFactory.createFromQrcodeResult(result));\n            _this.possiblyUpdateShaders(true);\n            return true;\n        }).catch(function (error) {\n            _this.possiblyUpdateShaders(false);\n            var errorMessage = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeStrings.codeParseError(error);\n            qrCodeErrorCallback(errorMessage, _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeErrorFactory.createFrom(errorMessage));\n            return false;\n        });\n    };\n    Html5Qrcode.prototype.foreverScan = function (internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {\n        var _this = this;\n        if (!this.shouldScan) {\n            return;\n        }\n        if (!this.renderedCamera) {\n            return;\n        }\n        var videoElement = this.renderedCamera.getSurface();\n        var widthRatio = videoElement.videoWidth / videoElement.clientWidth;\n        var heightRatio = videoElement.videoHeight / videoElement.clientHeight;\n        if (!this.qrRegion) {\n            throw \"qrRegion undefined when localMediaStream is ready.\";\n        }\n        var sWidthOffset = this.qrRegion.width * widthRatio;\n        var sHeightOffset = this.qrRegion.height * heightRatio;\n        var sxOffset = this.qrRegion.x * widthRatio;\n        var syOffset = this.qrRegion.y * heightRatio;\n        this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);\n        var triggerNextScan = function () {\n            _this.foreverScanTimeout = setTimeout(function () {\n                _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);\n            }, _this.getTimeoutFps(internalConfig.fps));\n        };\n        this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback)\n            .then(function (isSuccessfull) {\n            if (!isSuccessfull && internalConfig.disableFlip !== true) {\n                _this.context.translate(_this.context.canvas.width, 0);\n                _this.context.scale(-1, 1);\n                _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback)\n                    .finally(function () {\n                    triggerNextScan();\n                });\n            }\n            else {\n                triggerNextScan();\n            }\n        }).catch(function (error) {\n            _this.logger.logError(\"Error happend while scanning context\", error);\n            triggerNextScan();\n        });\n    };\n    Html5Qrcode.prototype.createVideoConstraints = function (cameraIdOrConfig) {\n        if (typeof cameraIdOrConfig == \"string\") {\n            return { deviceId: { exact: cameraIdOrConfig } };\n        }\n        else if (typeof cameraIdOrConfig == \"object\") {\n            var facingModeKey = \"facingMode\";\n            var deviceIdKey = \"deviceId\";\n            var allowedFacingModeValues_1 = { \"user\": true, \"environment\": true };\n            var exactKey = \"exact\";\n            var isValidFacingModeValue = function (value) {\n                if (value in allowedFacingModeValues_1) {\n                    return true;\n                }\n                else {\n                    throw \"config has invalid 'facingMode' value = \"\n                        + \"'\".concat(value, \"'\");\n                }\n            };\n            var keys = Object.keys(cameraIdOrConfig);\n            if (keys.length !== 1) {\n                throw \"'cameraIdOrConfig' object should have exactly 1 key,\"\n                    + \" if passed as an object, found \".concat(keys.length, \" keys\");\n            }\n            var key = Object.keys(cameraIdOrConfig)[0];\n            if (key !== facingModeKey && key !== deviceIdKey) {\n                throw \"Only '\".concat(facingModeKey, \"' and '\").concat(deviceIdKey, \"' \")\n                    + \" are supported for 'cameraIdOrConfig'\";\n            }\n            if (key === facingModeKey) {\n                var facingMode = cameraIdOrConfig.facingMode;\n                if (typeof facingMode == \"string\") {\n                    if (isValidFacingModeValue(facingMode)) {\n                        return { facingMode: facingMode };\n                    }\n                }\n                else if (typeof facingMode == \"object\") {\n                    if (exactKey in facingMode) {\n                        if (isValidFacingModeValue(facingMode[\"\".concat(exactKey)])) {\n                            return {\n                                facingMode: {\n                                    exact: facingMode[\"\".concat(exactKey)]\n                                }\n                            };\n                        }\n                    }\n                    else {\n                        throw \"'facingMode' should be string or object with\"\n                            + \" \".concat(exactKey, \" as key.\");\n                    }\n                }\n                else {\n                    var type_1 = (typeof facingMode);\n                    throw \"Invalid type of 'facingMode' = \".concat(type_1);\n                }\n            }\n            else {\n                var deviceId = cameraIdOrConfig.deviceId;\n                if (typeof deviceId == \"string\") {\n                    return { deviceId: deviceId };\n                }\n                else if (typeof deviceId == \"object\") {\n                    if (exactKey in deviceId) {\n                        return {\n                            deviceId: { exact: deviceId[\"\".concat(exactKey)] }\n                        };\n                    }\n                    else {\n                        throw \"'deviceId' should be string or object with\"\n                            + \" \".concat(exactKey, \" as key.\");\n                    }\n                }\n                else {\n                    var type_2 = (typeof deviceId);\n                    throw \"Invalid type of 'deviceId' = \".concat(type_2);\n                }\n            }\n        }\n        var type = (typeof cameraIdOrConfig);\n        throw \"Invalid type of 'cameraIdOrConfig' = \".concat(type);\n    };\n    Html5Qrcode.prototype.computeCanvasDrawConfig = function (imageWidth, imageHeight, containerWidth, containerHeight) {\n        if (imageWidth <= containerWidth\n            && imageHeight <= containerHeight) {\n            var xoffset = (containerWidth - imageWidth) / 2;\n            var yoffset = (containerHeight - imageHeight) / 2;\n            return {\n                x: xoffset,\n                y: yoffset,\n                width: imageWidth,\n                height: imageHeight\n            };\n        }\n        else {\n            var formerImageWidth = imageWidth;\n            var formerImageHeight = imageHeight;\n            if (imageWidth > containerWidth) {\n                imageHeight = (containerWidth / imageWidth) * imageHeight;\n                imageWidth = containerWidth;\n            }\n            if (imageHeight > containerHeight) {\n                imageWidth = (containerHeight / imageHeight) * imageWidth;\n                imageHeight = containerHeight;\n            }\n            this.logger.log(\"Image downsampled from \"\n                + \"\".concat(formerImageWidth, \"X\").concat(formerImageHeight)\n                + \" to \".concat(imageWidth, \"X\").concat(imageHeight, \".\"));\n            return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);\n        }\n    };\n    Html5Qrcode.prototype.clearElement = function () {\n        if (this.stateManagerProxy.isScanning()) {\n            throw \"Cannot clear while scan is ongoing, close it first.\";\n        }\n        var element = document.getElementById(this.elementId);\n        if (element) {\n            element.innerHTML = \"\";\n        }\n    };\n    Html5Qrcode.prototype.possiblyUpdateShaders = function (qrMatch) {\n        if (this.qrMatch === qrMatch) {\n            return;\n        }\n        if (this.hasBorderShaders\n            && this.borderShaders\n            && this.borderShaders.length) {\n            this.borderShaders.forEach(function (shader) {\n                shader.style.backgroundColor = qrMatch\n                    ? Constants.BORDER_SHADER_MATCH_COLOR\n                    : Constants.BORDER_SHADER_DEFAULT_COLOR;\n            });\n        }\n        this.qrMatch = qrMatch;\n    };\n    Html5Qrcode.prototype.possiblyCloseLastScanImageFile = function () {\n        if (this.lastScanImageFile) {\n            URL.revokeObjectURL(this.lastScanImageFile);\n            this.lastScanImageFile = null;\n        }\n    };\n    Html5Qrcode.prototype.createCanvasElement = function (width, height, customId) {\n        var canvasWidth = width;\n        var canvasHeight = height;\n        var canvasElement = document.createElement(\"canvas\");\n        canvasElement.style.width = \"\".concat(canvasWidth, \"px\");\n        canvasElement.style.height = \"\".concat(canvasHeight, \"px\");\n        canvasElement.style.display = \"none\";\n        canvasElement.id = (0,_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(customId)\n            ? \"qr-canvas\" : customId;\n        return canvasElement;\n    };\n    Html5Qrcode.prototype.getShadedRegionBounds = function (width, height, qrboxSize) {\n        if (qrboxSize.width > width || qrboxSize.height > height) {\n            throw \"'config.qrbox' dimensions should not be greater than the \"\n                + \"dimensions of the root HTML element.\";\n        }\n        return {\n            x: (width - qrboxSize.width) / 2,\n            y: (height - qrboxSize.height) / 2,\n            width: qrboxSize.width,\n            height: qrboxSize.height\n        };\n    };\n    Html5Qrcode.prototype.possiblyInsertShadingElement = function (element, width, height, qrboxSize) {\n        if ((width - qrboxSize.width) < 1 || (height - qrboxSize.height) < 1) {\n            return;\n        }\n        var shadingElement = document.createElement(\"div\");\n        shadingElement.style.position = \"absolute\";\n        var rightLeftBorderSize = (width - qrboxSize.width) / 2;\n        var topBottomBorderSize = (height - qrboxSize.height) / 2;\n        shadingElement.style.borderLeft\n            = \"\".concat(rightLeftBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderRight\n            = \"\".concat(rightLeftBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderTop\n            = \"\".concat(topBottomBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.borderBottom\n            = \"\".concat(topBottomBorderSize, \"px solid rgba(0, 0, 0, 0.48)\");\n        shadingElement.style.boxSizing = \"border-box\";\n        shadingElement.style.top = \"0px\";\n        shadingElement.style.bottom = \"0px\";\n        shadingElement.style.left = \"0px\";\n        shadingElement.style.right = \"0px\";\n        shadingElement.id = \"\".concat(Constants.SHADED_REGION_ELEMENT_ID);\n        if ((width - qrboxSize.width) < 11\n            || (height - qrboxSize.height) < 11) {\n            this.hasBorderShaders = false;\n        }\n        else {\n            var smallSize = 5;\n            var largeSize = 40;\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, true);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, false);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, true);\n            this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, false);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, true);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, true);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, false);\n            this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, false);\n            this.hasBorderShaders = true;\n        }\n        element.append(shadingElement);\n    };\n    Html5Qrcode.prototype.insertShaderBorders = function (shaderElem, width, height, top, bottom, side, isLeft) {\n        var elem = document.createElement(\"div\");\n        elem.style.position = \"absolute\";\n        elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;\n        elem.style.width = \"\".concat(width, \"px\");\n        elem.style.height = \"\".concat(height, \"px\");\n        if (top !== null) {\n            elem.style.top = \"\".concat(top, \"px\");\n        }\n        if (bottom !== null) {\n            elem.style.bottom = \"\".concat(bottom, \"px\");\n        }\n        if (isLeft) {\n            elem.style.left = \"\".concat(side, \"px\");\n        }\n        else {\n            elem.style.right = \"\".concat(side, \"px\");\n        }\n        if (!this.borderShaders) {\n            this.borderShaders = [];\n        }\n        this.borderShaders.push(elem);\n        shaderElem.appendChild(elem);\n    };\n    Html5Qrcode.prototype.showPausedState = function () {\n        if (!this.scannerPausedUiElement) {\n            throw \"[internal error] scanner paused UI element not found\";\n        }\n        this.scannerPausedUiElement.style.display = \"block\";\n    };\n    Html5Qrcode.prototype.hidePausedState = function () {\n        if (!this.scannerPausedUiElement) {\n            throw \"[internal error] scanner paused UI element not found\";\n        }\n        this.scannerPausedUiElement.style.display = \"none\";\n    };\n    Html5Qrcode.prototype.getTimeoutFps = function (fps) {\n        return 1000 / fps;\n    };\n    return Html5Qrcode;\n}());\n\n//# sourceMappingURL=html5-qrcode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaHRtbDUtcXJjb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaHRtbDUtcXJjb2RlLmpzP2IzZGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IEJhc2VMb2dnZ2VyLCBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnksIEh0bWw1UXJjb2RlRXJyb3JGYWN0b3J5LCBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMsIGlzVmFsaWRIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMsIEh0bWw1UXJjb2RlQ29uc3RhbnRzLCBpc051bGxPclVuZGVmaW5lZCB9IGZyb20gXCIuL2NvcmVcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9IGZyb20gXCIuL3N0cmluZ3NcIjtcbmltcG9ydCB7IFZpZGVvQ29uc3RyYWludHNVdGlsIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IEh0bWw1UXJjb2RlU2hpbSB9IGZyb20gXCIuL2NvZGUtZGVjb2RlclwiO1xuaW1wb3J0IHsgQ2FtZXJhRmFjdG9yeSB9IGZyb20gXCIuL2NhbWVyYS9mYWN0b3JpZXNcIjtcbmltcG9ydCB7IENhbWVyYVJldHJpZXZlciB9IGZyb20gXCIuL2NhbWVyYS9yZXRyaWV2ZXJcIjtcbmltcG9ydCB7IFN0YXRlTWFuYWdlckZhY3RvcnksIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlIH0gZnJvbSBcIi4vc3RhdGUtbWFuYWdlclwiO1xudmFyIENvbnN0YW50cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN0YW50cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29uc3RhbnRzLkRFRkFVTFRfV0lEVEggPSAzMDA7XG4gICAgQ29uc3RhbnRzLkRFRkFVTFRfV0lEVEhfT0ZGU0VUID0gMjtcbiAgICBDb25zdGFudHMuRklMRV9TQ0FOX01JTl9IRUlHSFQgPSAzMDA7XG4gICAgQ29uc3RhbnRzLkZJTEVfU0NBTl9ISURERU5fQ0FOVkFTX1BBRERJTkcgPSAxMDA7XG4gICAgQ29uc3RhbnRzLk1JTl9RUl9CT1hfU0laRSA9IDUwO1xuICAgIENvbnN0YW50cy5TSEFERURfTEVGVCA9IDE7XG4gICAgQ29uc3RhbnRzLlNIQURFRF9SSUdIVCA9IDI7XG4gICAgQ29uc3RhbnRzLlNIQURFRF9UT1AgPSAzO1xuICAgIENvbnN0YW50cy5TSEFERURfQk9UVE9NID0gNDtcbiAgICBDb25zdGFudHMuU0hBREVEX1JFR0lPTl9FTEVNRU5UX0lEID0gXCJxci1zaGFkZWQtcmVnaW9uXCI7XG4gICAgQ29uc3RhbnRzLlZFUkJPU0UgPSBmYWxzZTtcbiAgICBDb25zdGFudHMuQk9SREVSX1NIQURFUl9ERUZBVUxUX0NPTE9SID0gXCIjZmZmZmZmXCI7XG4gICAgQ29uc3RhbnRzLkJPUkRFUl9TSEFERVJfTUFUQ0hfQ09MT1IgPSBcInJnYig5MCwgMTkzLCA1NilcIjtcbiAgICByZXR1cm4gQ29uc3RhbnRzO1xufShIdG1sNVFyY29kZUNvbnN0YW50cykpO1xudmFyIEludGVybmFsSHRtbDVRcmNvZGVDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVybmFsSHRtbDVRcmNvZGVDb25maWcoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuZnBzID0gQ29uc3RhbnRzLlNDQU5fREVGQVVMVF9GUFM7XG4gICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVGbGlwID0gQ29uc3RhbnRzLkRFRkFVTFRfRElTQUJMRV9GTElQO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5mcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZwcyA9IGNvbmZpZy5mcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVGbGlwID0gY29uZmlnLmRpc2FibGVGbGlwID09PSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5xcmJveCA9IGNvbmZpZy5xcmJveDtcbiAgICAgICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBjb25maWcuYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB0aGlzLnZpZGVvQ29uc3RyYWludHMgPSBjb25maWcudmlkZW9Db25zdHJhaW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLnByb3RvdHlwZS5pc01lZGlhU3RyZWFtQ29uc3RyYWludHNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiRW1wdHkgdmlkZW9Db25zdHJhaW50c1wiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlkZW9Db25zdHJhaW50c1V0aWwuaXNNZWRpYVN0cmVhbUNvbnN0cmFpbnRzVmFsaWQodGhpcy52aWRlb0NvbnN0cmFpbnRzLCB0aGlzLmxvZ2dlcik7XG4gICAgfTtcbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLnByb3RvdHlwZS5pc1NoYWRlZEJveEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhaXNOdWxsT3JVbmRlZmluZWQodGhpcy5xcmJveCk7XG4gICAgfTtcbiAgICBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25maWcsIGxvZ2dlcikge1xuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsSHRtbDVRcmNvZGVDb25maWcoY29uZmlnLCBsb2dnZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVybmFsSHRtbDVRcmNvZGVDb25maWc7XG59KCkpO1xudmFyIEh0bWw1UXJjb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZShlbGVtZW50SWQsIGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0JvcmRlclNoYWRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnFyTWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgdGhpcy5xclJlZ2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNjYW5JbWFnZUZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2Nhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkhUTUwgRWxlbWVudCB3aXRoIGlkPVwiLmNvbmNhdChlbGVtZW50SWQsIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IGVsZW1lbnRJZDtcbiAgICAgICAgdGhpcy52ZXJib3NlID0gZmFsc2U7XG4gICAgICAgIHZhciBleHBlcmltZW50YWxGZWF0dXJlQ29uZmlnO1xuICAgICAgICB2YXIgY29uZmlnT2JqZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZ09yVmVyYm9zaXR5RmxhZyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gY29uZmlnT3JWZXJib3NpdHlGbGFnID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICAgICAgY29uZmlnT2JqZWN0ID0gY29uZmlnT3JWZXJib3NpdHlGbGFnO1xuICAgICAgICAgICAgdGhpcy52ZXJib3NlID0gY29uZmlnT2JqZWN0LnZlcmJvc2UgPT09IHRydWU7XG4gICAgICAgICAgICBleHBlcmltZW50YWxGZWF0dXJlQ29uZmlnID0gY29uZmlnT2JqZWN0LmV4cGVyaW1lbnRhbEZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IEJhc2VMb2dnZ2VyKHRoaXMudmVyYm9zZSk7XG4gICAgICAgIHRoaXMucXJjb2RlID0gbmV3IEh0bWw1UXJjb2RlU2hpbSh0aGlzLmdldFN1cHBvcnRlZEZvcm1hdHMoY29uZmlnT3JWZXJib3NpdHlGbGFnKSwgdGhpcy5nZXRVc2VCYXJDb2RlRGV0ZWN0b3JJZlN1cHBvcnRlZChjb25maWdPYmplY3QpLCB0aGlzLnZlcmJvc2UsIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgdGhpcy5mb3JldmVyU2NhblRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2hvdWxkU2NhbiA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGVNYW5hZ2VyUHJveHkgPSBTdGF0ZU1hbmFnZXJGYWN0b3J5LmNyZWF0ZSgpO1xuICAgIH1cbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoY2FtZXJhSWRPckNvbmZpZywgY29uZmlndXJhdGlvbiwgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY2FtZXJhSWRPckNvbmZpZykge1xuICAgICAgICAgICAgdGhyb3cgXCJjYW1lcmFJZE9yQ29uZmlnIGlzIHJlcXVpcmVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFxckNvZGVTdWNjZXNzQ2FsbGJhY2tcbiAgICAgICAgICAgIHx8IHR5cGVvZiBxckNvZGVTdWNjZXNzQ2FsbGJhY2sgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBcInFyQ29kZVN1Y2Nlc3NDYWxsYmFjayBpcyByZXF1aXJlZCBhbmQgc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbDtcbiAgICAgICAgaWYgKHFyQ29kZUVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbCA9IHFyQ29kZUVycm9yQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxckNvZGVFcnJvckNhbGxiYWNrSW50ZXJuYWxcbiAgICAgICAgICAgICAgICA9IHRoaXMudmVyYm9zZSA/IHRoaXMubG9nZ2VyLmxvZyA6IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJuYWxDb25maWcgPSBJbnRlcm5hbEh0bWw1UXJjb2RlQ29uZmlnLmNyZWF0ZShjb25maWd1cmF0aW9uLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIHRoaXMuY2xlYXJFbGVtZW50KCk7XG4gICAgICAgIHZhciB2aWRlb0NvbnN0cmFpbnRzQXZhaWxhYmxlQW5kVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGludGVybmFsQ29uZmlnLnZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxDb25maWcuaXNNZWRpYVN0cmVhbUNvbnN0cmFpbnRzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiJ3ZpZGVvQ29uc3RyYWludHMnIGlzIG5vdCB2YWxpZCAnTWVkaWFTdHJlYW1Db25zdHJhaW50cywgXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcIml0IHdpbGwgYmUgaWdub3JlZC4nXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50c0F2YWlsYWJsZUFuZFZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJlVmlkZW9Db25zdHJhaW50c0VuYWJsZWQgPSB2aWRlb0NvbnN0cmFpbnRzQXZhaWxhYmxlQW5kVmFsaWQ7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbGVtZW50SWQpO1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IENvbnN0YW50cy5ERUZBVUxUX1dJRFRIO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB0aGlzLnNob3VsZFNjYW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24gPSB0aGlzLnN0YXRlTWFuYWdlclByb3h5LnN0YXJ0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdmlkZW9Db25zdHJhaW50cyA9IGFyZVZpZGVvQ29uc3RyYWludHNFbmFibGVkXG4gICAgICAgICAgICAgICAgPyBpbnRlcm5hbENvbmZpZy52aWRlb0NvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgOiAkdGhpcy5jcmVhdGVWaWRlb0NvbnN0cmFpbnRzKGNhbWVyYUlkT3JDb25maWcpO1xuICAgICAgICAgICAgaWYgKCF2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwidmlkZW9Db25zdHJhaW50cyBzaG91bGQgYmUgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2FtZXJhUmVuZGVyaW5nT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFhcmVWaWRlb0NvbnN0cmFpbnRzRW5hYmxlZCB8fCBpbnRlcm5hbENvbmZpZy5hc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGNhbWVyYVJlbmRlcmluZ09wdGlvbnMuYXNwZWN0UmF0aW8gPSBpbnRlcm5hbENvbmZpZy5hc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAgICAgb25SZW5kZXJTdXJmYWNlUmVhZHk6IGZ1bmN0aW9uICh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuc2V0dXBVaSh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIGludGVybmFsQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuaXNTY2FubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmZvcmV2ZXJTY2FuKGludGVybmFsQ29uZmlnLCBxckNvZGVTdWNjZXNzQ2FsbGJhY2ssIHFyQ29kZUVycm9yQ2FsbGJhY2tJbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENhbWVyYUZhY3RvcnkuZmFpbElmTm90U3VwcG9ydGVkKCkudGhlbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkuY3JlYXRlKHZpZGVvQ29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKGNhbWVyYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FtZXJhLnJlbmRlcihfdGhpcy5lbGVtZW50LCBjYW1lcmFSZW5kZXJpbmdPcHRpb25zLCByZW5kZXJpbmdDYWxsYmFja3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVuZGVyZWRDYW1lcmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbmRlcmVkQ2FtZXJhID0gcmVuZGVyZWRDYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1NjYW5uaW5nU3RhdGVDaGFuZ2VUcmFuc2FjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9TY2FubmluZ1N0YXRlQ2hhbmdlVHJhbnNhY3Rpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChIdG1sNVFyY29kZVN0cmluZ3MuZXJyb3JHZXR0aW5nVXNlck1lZGlhKGVycm9yKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHRvU2Nhbm5pbmdTdGF0ZUNoYW5nZVRyYW5zYWN0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChIdG1sNVFyY29kZVN0cmluZ3MuY2FtZXJhU3RyZWFtaW5nTm90U3VwcG9ydGVkKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHNob3VsZFBhdXNlVmlkZW8pIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlTWFuYWdlclByb3h5LmlzU3RyaWN0bHlTY2FubmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBwYXVzZSwgc2Nhbm5lciBpcyBub3Qgc2Nhbm5pbmcuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5kaXJlY3RUcmFuc2l0aW9uKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlBBVVNFRCk7XG4gICAgICAgIHRoaXMuc2hvd1BhdXNlZFN0YXRlKCk7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzaG91bGRQYXVzZVZpZGVvKSB8fCBzaG91bGRQYXVzZVZpZGVvICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBzaG91bGRQYXVzZVZpZGVvID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFBhdXNlVmlkZW8gJiYgdGhpcy5yZW5kZXJlZENhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZENhbWVyYS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGVNYW5hZ2VyUHJveHkuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgcmVzdWx0LCBzY2FubmVyIGlzIG5vdCBwYXVzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhKSB7XG4gICAgICAgICAgICB0aHJvdyBcInJlbmRlcmVkQ2FtZXJhIGRvZXNuJ3QgZXhpc3Qgd2hpbGUgdHJ5aW5nIHJlc3VtZSgpXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYW5zaXRpb25Ub1NjYW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHRoaXMuc3RhdGVNYW5hZ2VyUHJveHkuZGlyZWN0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORyk7XG4gICAgICAgICAgICAkdGhpcy5oaWRlUGF1c2VkU3RhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25Ub1NjYW5uaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlZENhbWVyYS5yZXN1bWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvblRvU2Nhbm5pbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlclByb3h5LmdldFN0YXRlKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlTWFuYWdlclByb3h5LmlzU2Nhbm5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3Qgc3RvcCwgc2Nhbm5lciBpcyBub3QgcnVubmluZyBvciBwYXVzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvU3RvcHBlZFN0YXRlVHJhbnNhY3Rpb24gPSB0aGlzLnN0YXRlTWFuYWdlclByb3h5LnN0YXJ0VHJhbnNpdGlvbihIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5OT1RfU1RBUlRFRCk7XG4gICAgICAgIHRoaXMuc2hvdWxkU2NhbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mb3JldmVyU2NhblRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZvcmV2ZXJTY2FuVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW92ZVFyUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKENvbnN0YW50cy5TSEFERURfUkVHSU9OX0VMRU1FTlRfSUQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRDYW1lcmEuY2xvc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICR0aGlzLnJlbmRlcmVkQ2FtZXJhID0gbnVsbDtcbiAgICAgICAgICAgIGlmICgkdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCgkdGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAkdGhpcy5jYW52YXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZVFyUmVnaW9uKCk7XG4gICAgICAgICAgICBpZiAoJHRoaXMucXJSZWdpb24pIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5xclJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgICR0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9TdG9wcGVkU3RhdGVUcmFuc2FjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICAkdGhpcy5oaWRlUGF1c2VkU3RhdGUoKTtcbiAgICAgICAgICAgICR0aGlzLmlzU2Nhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuc2NhbkZpbGUgPSBmdW5jdGlvbiAoaW1hZ2VGaWxlLCBzaG93SW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkZpbGVWMihpbWFnZUZpbGUsIHNob3dJbWFnZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChodG1sNXFyY29kZVJlc3VsdCkgeyByZXR1cm4gaHRtbDVxcmNvZGVSZXN1bHQuZGVjb2RlZFRleHQ7IH0pO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNjYW5GaWxlVjIgPSBmdW5jdGlvbiAoaW1hZ2VGaWxlLCBzaG93SW1hZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpbWFnZUZpbGUgfHwgIShpbWFnZUZpbGUgaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJpbWFnZUZpbGUgYXJndW1lbnQgaXMgbWFuZGF0b3J5IGFuZCBzaG91bGQgYmUgaW5zdGFuY2UgXCJcbiAgICAgICAgICAgICAgICArIFwib2YgRmlsZS4gVXNlICdldmVudC50YXJnZXQuZmlsZXNbMF0nLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChzaG93SW1hZ2UpKSB7XG4gICAgICAgICAgICBzaG93SW1hZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5jYW5TY2FuRmlsZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCBzdGFydCBmaWxlIHNjYW4gLSBvbmdvaW5nIGNhbWVyYSBzY2FuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5Q2xvc2VMYXN0U2NhbkltYWdlRmlsZSgpO1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJFbGVtZW50KCk7XG4gICAgICAgICAgICBfdGhpcy5sYXN0U2NhbkltYWdlRmlsZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VGaWxlKTtcbiAgICAgICAgICAgIHZhciBpbnB1dEltYWdlID0gbmV3IEltYWdlO1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlV2lkdGggPSBpbnB1dEltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBpbWFnZUhlaWdodCA9IGlucHV0SW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoX3RoaXMuZWxlbWVudElkKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgICAgID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IENvbnN0YW50cy5ERUZBVUxUX1dJRFRIO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBNYXRoLm1heChlbGVtZW50LmNsaWVudEhlaWdodCA/IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDogaW1hZ2VIZWlnaHQsIENvbnN0YW50cy5GSUxFX1NDQU5fTUlOX0hFSUdIVCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IF90aGlzLmNvbXB1dGVDYW52YXNEcmF3Q29uZmlnKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvd0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlQ2FudmFzID0gX3RoaXMuY3JlYXRlQ2FudmFzRWxlbWVudChjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0LCBcInFyLWNhbnZhcy12aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHZpc2libGVDYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dF8xID0gdmlzaWJsZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlVuYWJsZSB0byBnZXQgMmQgY29udGV4dCBmcm9tIGNhbnZhc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5jYW52YXMud2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dF8xLmNhbnZhcy5oZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5kcmF3SW1hZ2UoaW5wdXRJbWFnZSwgMCwgMCwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIGNvbmZpZy54LCBjb25maWcueSwgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBDb25zdGFudHMuRklMRV9TQ0FOX0hJRERFTl9DQU5WQVNfUEFERElORztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuSW1hZ2VXaWR0aCA9IE1hdGgubWF4KGlucHV0SW1hZ2Uud2lkdGgsIGNvbmZpZy53aWR0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGhpZGRlbkltYWdlSGVpZ2h0ID0gTWF0aC5tYXgoaW5wdXRJbWFnZS5oZWlnaHQsIGNvbmZpZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHZhciBoaWRkZW5DYW52YXNXaWR0aCA9IGhpZGRlbkltYWdlV2lkdGggKyAyICogcGFkZGluZztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuQ2FudmFzSGVpZ2h0ID0gaGlkZGVuSW1hZ2VIZWlnaHQgKyAyICogcGFkZGluZztcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuQ2FudmFzID0gX3RoaXMuY3JlYXRlQ2FudmFzRWxlbWVudChoaWRkZW5DYW52YXNXaWR0aCwgaGlkZGVuQ2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGhpZGRlbkNhbnZhcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBoaWRkZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlVuYWJsZSB0byBnZXQgMmQgY29udGV4dCBmcm9tIGNhbnZhc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IGhpZGRlbkNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IGhpZGRlbkNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbnB1dEltYWdlLCAwLCAwLCBpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCwgcGFkZGluZywgcGFkZGluZywgaGlkZGVuSW1hZ2VXaWR0aCwgaGlkZGVuSW1hZ2VIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnFyY29kZS5kZWNvZGVSb2J1c3RseUFzeW5jKGhpZGRlbkNhbnZhcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoSHRtbDVRcmNvZGVSZXN1bHRGYWN0b3J5LmNyZWF0ZUZyb21RcmNvZGVSZXN1bHQocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJRUiBjb2RlIHBhcnNlIGVycm9yLCBlcnJvciA9IFwiLmNvbmNhdChleGNlcHRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbmFib3J0ID0gcmVqZWN0O1xuICAgICAgICAgICAgaW5wdXRJbWFnZS5vbnN0YWxsZWQgPSByZWplY3Q7XG4gICAgICAgICAgICBpbnB1dEltYWdlLm9uc3VzcGVuZCA9IHJlamVjdDtcbiAgICAgICAgICAgIGlucHV0SW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZUZpbGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckVsZW1lbnQoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLmdldENhbWVyYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDYW1lcmFSZXRyaWV2ZXIucmV0cmlldmUoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0UnVubmluZ1RyYWNrQ2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0UnVubmluZ1RyYWNrU2V0dGluZ3MoKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSdW5uaW5nVHJhY2tDYW1lcmFDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVkQ2FtZXJhT3JGYWlsKCkuZ2V0Q2FwYWJpbGl0aWVzKCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuYXBwbHlWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHZpZGVvQ29uc3RhaW50cykge1xuICAgICAgICBpZiAoIXZpZGVvQ29uc3RhaW50cykge1xuICAgICAgICAgICAgdGhyb3cgXCJ2aWRlb0NvbnN0YWludHMgaXMgcmVxdWlyZWQgYXJndW1lbnQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIVZpZGVvQ29uc3RyYWludHNVdGlsLmlzTWVkaWFTdHJlYW1Db25zdHJhaW50c1ZhbGlkKHZpZGVvQ29uc3RhaW50cywgdGhpcy5sb2dnZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBcImludmFsaWQgdmlkZW9Db25zdGFpbnRzIHBhc3NlZCwgY2hlY2sgbG9ncyBmb3IgbW9yZSBkZXRhaWxzXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZWRDYW1lcmFPckZhaWwoKS5hcHBseVZpZGVvQ29uc3RyYWludHModmlkZW9Db25zdGFpbnRzKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRSZW5kZXJlZENhbWVyYU9yRmFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRDYW1lcmEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgXCJTY2FubmluZyBpcyBub3QgaW4gcnVubmluZyBzdGF0ZSwgY2FsbCB0aGlzIEFQSSBvbmx5IHdoZW5cIlxuICAgICAgICAgICAgICAgICsgXCIgUVIgY29kZSBzY2FubmluZyB1c2luZyBjYW1lcmEgaXMgaW4gcnVubmluZyBzdGF0ZS5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZENhbWVyYTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRTdXBwb3J0ZWRGb3JtYXRzID0gZnVuY3Rpb24gKGNvbmZpZ09yVmVyYm9zaXR5RmxhZykge1xuICAgICAgICB2YXIgYWxsRm9ybWF0cyA9IFtcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5RUl9DT0RFLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkFaVEVDLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8zOSxcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzkzLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkRBVEFfTUFUUklYLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLk1BWElDT0RFLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLklURixcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fMTMsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUERGXzQxNyxcbiAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5SU1NfMTQsXG4gICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuUlNTX0VYUEFOREVELFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19BLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FLFxuICAgICAgICAgICAgSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19FQU5fRVhURU5TSU9OLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWNvbmZpZ09yVmVyYm9zaXR5RmxhZ1xuICAgICAgICAgICAgfHwgdHlwZW9mIGNvbmZpZ09yVmVyYm9zaXR5RmxhZyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEZvcm1hdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEZvcm1hdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ09yVmVyYm9zaXR5RmxhZy5mb3JtYXRzVG9TdXBwb3J0KSkge1xuICAgICAgICAgICAgdGhyb3cgXCJjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydCBzaG91bGQgYmUgdW5kZWZpbmVkIFwiXG4gICAgICAgICAgICAgICAgKyBcIm9yIGFuIGFycmF5LlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IFwiQXRsZWFzdCAxIGZvcm1hdHNUb1N1cHBvcnQgaXMgbmVlZGVkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdXBwb3J0ZWRGb3JtYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb25maWdPclZlcmJvc2l0eUZsYWcuZm9ybWF0c1RvU3VwcG9ydDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyhmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkRm9ybWF0cy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSW52YWxpZCBmb3JtYXQ6IFwiLmNvbmNhdChmb3JtYXQsIFwiIHBhc3NlZCBpbiBjb25maWcsIGlnbm9yaW5nLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRlZEZvcm1hdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBcIk5vbmUgb2YgZm9ybWF0c1RvU3VwcG9ydCBtYXRjaCBzdXBwb3J0ZWQgdmFsdWVzLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRGb3JtYXRzO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmdldFVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoY29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChjb25maWcudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnVzZUJhckNvZGVEZXRlY3RvcklmU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGVyaW1lbnRhbEZlYXR1cmVzID0gY29uZmlnLmV4cGVyaW1lbnRhbEZlYXR1cmVzO1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZXhwZXJpbWVudGFsRmVhdHVyZXMudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZXJpbWVudGFsRmVhdHVyZXMudXNlQmFyQ29kZURldGVjdG9ySWZTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnZhbGlkYXRlUXJib3hTaXplID0gZnVuY3Rpb24gKHZpZXdmaW5kZXJXaWR0aCwgdmlld2ZpbmRlckhlaWdodCwgaW50ZXJuYWxDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHFyYm94U2l6ZSA9IGludGVybmFsQ29uZmlnLnFyYm94O1xuICAgICAgICB0aGlzLnZhbGlkYXRlUXJib3hDb25maWcocXJib3hTaXplKTtcbiAgICAgICAgdmFyIHFyRGltZW5zaW9ucyA9IHRoaXMudG9RcmRpbWVuc2lvbnModmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBxcmJveFNpemUpO1xuICAgICAgICB2YXIgdmFsaWRhdGVNaW5TaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIGlmIChzaXplIDwgQ29uc3RhbnRzLk1JTl9RUl9CT1hfU0laRSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwibWluaW11bSBzaXplIG9mICdjb25maWcucXJib3gnIGRpbWVuc2lvbiB2YWx1ZSBpc1wiXG4gICAgICAgICAgICAgICAgICAgICsgXCIgXCIuY29uY2F0KENvbnN0YW50cy5NSU5fUVJfQk9YX1NJWkUsIFwicHguXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29ycmVjdFdpZHRoQmFzZWRPblJvb3RFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uIChjb25maWdXaWR0aCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1dpZHRoID4gdmlld2ZpbmRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJgcXJib3gud2lkdGhgIG9yIGBxcmJveGAgaXMgbGFyZ2VyIHRoYW4gdGhlXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcIiB3aWR0aCBvZiB0aGUgcm9vdCBlbGVtZW50LiBUaGUgd2lkdGggd2lsbCBiZSB0cnVuY2F0ZWRcIlxuICAgICAgICAgICAgICAgICAgICArIFwiIHRvIHRoZSB3aWR0aCBvZiByb290IGVsZW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbmZpZ1dpZHRoID0gdmlld2ZpbmRlcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ1dpZHRoO1xuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0ZU1pblNpemUocXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICAgICAgdmFsaWRhdGVNaW5TaXplKHFyRGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICBxckRpbWVuc2lvbnMud2lkdGggPSBjb3JyZWN0V2lkdGhCYXNlZE9uUm9vdEVsZW1lbnRTaXplKHFyRGltZW5zaW9ucy53aWR0aCk7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUudmFsaWRhdGVRcmJveENvbmZpZyA9IGZ1bmN0aW9uIChxcmJveFNpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBxcmJveFNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHFyYm94U2l6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHFyYm94U2l6ZS53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHFyYm94U2l6ZS5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGluc3RhbmNlIG9mIFFyRGltZW5zaW9ucyBwYXNzZWQgZm9yIFwiXG4gICAgICAgICAgICAgICAgKyBcIidjb25maWcucXJib3gnLiBCb3RoICd3aWR0aCcgYW5kICdoZWlnaHQnIHNob3VsZCBiZSBzZXQuXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS50b1FyZGltZW5zaW9ucyA9IGZ1bmN0aW9uICh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIHFyYm94U2l6ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHFyYm94U2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHFyYm94U2l6ZSwgaGVpZ2h0OiBxcmJveFNpemUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcXJib3hTaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFyYm94U2l6ZSh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXJib3ggY29uZmlnIHdhcyBwYXNzZWQgYXMgYSBmdW5jdGlvbiBidXQgaXQgZmFpbGVkIHdpdGggXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcInVua25vd24gZXJyb3JcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXJib3hTaXplO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNldHVwVWkgPSBmdW5jdGlvbiAodmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBpbnRlcm5hbENvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJuYWxDb25maWcuaXNTaGFkZWRCb3hFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVRcmJveFNpemUodmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBpbnRlcm5hbENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFyYm94U2l6ZSA9IGlzTnVsbE9yVW5kZWZpbmVkKGludGVybmFsQ29uZmlnLnFyYm94KSA/XG4gICAgICAgICAgICB7IHdpZHRoOiB2aWV3ZmluZGVyV2lkdGgsIGhlaWdodDogdmlld2ZpbmRlckhlaWdodCB9IDogaW50ZXJuYWxDb25maWcucXJib3g7XG4gICAgICAgIHRoaXMudmFsaWRhdGVRcmJveENvbmZpZyhxcmJveFNpemUpO1xuICAgICAgICB2YXIgcXJEaW1lbnNpb25zID0gdGhpcy50b1FyZGltZW5zaW9ucyh2aWV3ZmluZGVyV2lkdGgsIHZpZXdmaW5kZXJIZWlnaHQsIHFyYm94U2l6ZSk7XG4gICAgICAgIGlmIChxckRpbWVuc2lvbnMuaGVpZ2h0ID4gdmlld2ZpbmRlckhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIltIdG1sNVFyY29kZV0gY29uZmlnLnFyYm94IGhhcyBoZWlnaHQgdGhhdCBpc1wiXG4gICAgICAgICAgICAgICAgKyBcImdyZWF0ZXIgdGhhbiB0aGUgaGVpZ2h0IG9mIHRoZSB2aWRlbyBzdHJlYW0uIFNoYWRpbmcgd2lsbCBiZVwiXG4gICAgICAgICAgICAgICAgKyBcIiBpZ25vcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRTaGFkaW5nQmVBcHBsaWVkID0gaW50ZXJuYWxDb25maWcuaXNTaGFkZWRCb3hFbmFibGVkKClcbiAgICAgICAgICAgICYmIHFyRGltZW5zaW9ucy5oZWlnaHQgPD0gdmlld2ZpbmRlckhlaWdodDtcbiAgICAgICAgdmFyIGRlZmF1bHRRclJlZ2lvbiA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IHZpZXdmaW5kZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdmlld2ZpbmRlckhlaWdodFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcXJSZWdpb24gPSBzaG91bGRTaGFkaW5nQmVBcHBsaWVkXG4gICAgICAgICAgICA/IHRoaXMuZ2V0U2hhZGVkUmVnaW9uQm91bmRzKHZpZXdmaW5kZXJXaWR0aCwgdmlld2ZpbmRlckhlaWdodCwgcXJEaW1lbnNpb25zKVxuICAgICAgICAgICAgOiBkZWZhdWx0UXJSZWdpb247XG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy5jcmVhdGVDYW52YXNFbGVtZW50KHFyUmVnaW9uLndpZHRoLCBxclJlZ2lvbi5oZWlnaHQpO1xuICAgICAgICB2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSB7IHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSB9O1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICAgICAgY29udGV4dC5jYW52YXMud2lkdGggPSBxclJlZ2lvbi53aWR0aDtcbiAgICAgICAgY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gcXJSZWdpb24uaGVpZ2h0O1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKGNhbnZhc0VsZW1lbnQpO1xuICAgICAgICBpZiAoc2hvdWxkU2hhZGluZ0JlQXBwbGllZCkge1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJseUluc2VydFNoYWRpbmdFbGVtZW50KHRoaXMuZWxlbWVudCwgdmlld2ZpbmRlcldpZHRoLCB2aWV3ZmluZGVySGVpZ2h0LCBxckRpbWVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlU2Nhbm5lclBhdXNlZFVpRWxlbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLnFyUmVnaW9uID0gcXJSZWdpb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuY3JlYXRlU2Nhbm5lclBhdXNlZFVpRWxlbWVudCA9IGZ1bmN0aW9uIChyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgc2Nhbm5lclBhdXNlZFVpRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuaW5uZXJUZXh0ID0gSHRtbDVRcmNvZGVTdHJpbmdzLnNjYW5uZXJQYXVzZWQoKTtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS56SW5kZXggPSBcIjFcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDksIDksIDksIDAuNDYpXCI7XG4gICAgICAgIHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuY29sb3IgPSBcIiNGRkVDRUNcIjtcbiAgICAgICAgc2Nhbm5lclBhdXNlZFVpRWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBzY2FubmVyUGF1c2VkVWlFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHJvb3RFbGVtZW50LmFwcGVuZENoaWxkKHNjYW5uZXJQYXVzZWRVaUVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQgPSBzY2FubmVyUGF1c2VkVWlFbGVtZW50O1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnNjYW5Db250ZXh0ID0gZnVuY3Rpb24gKHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xcmNvZGUuZGVjb2RlQXN5bmModGhpcy5jYW52YXNFbGVtZW50KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrKHJlc3VsdC50ZXh0LCBIdG1sNVFyY29kZVJlc3VsdEZhY3RvcnkuY3JlYXRlRnJvbVFyY29kZVJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5VXBkYXRlU2hhZGVycyh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnBvc3NpYmx5VXBkYXRlU2hhZGVycyhmYWxzZSk7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gSHRtbDVRcmNvZGVTdHJpbmdzLmNvZGVQYXJzZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHFyQ29kZUVycm9yQ2FsbGJhY2soZXJyb3JNZXNzYWdlLCBIdG1sNVFyY29kZUVycm9yRmFjdG9yeS5jcmVhdGVGcm9tKGVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5mb3JldmVyU2NhbiA9IGZ1bmN0aW9uIChpbnRlcm5hbENvbmZpZywgcXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRTY2FuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkQ2FtZXJhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IHRoaXMucmVuZGVyZWRDYW1lcmEuZ2V0U3VyZmFjZSgpO1xuICAgICAgICB2YXIgd2lkdGhSYXRpbyA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIC8gdmlkZW9FbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0UmF0aW8gPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQgLyB2aWRlb0VsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoIXRoaXMucXJSZWdpb24pIHtcbiAgICAgICAgICAgIHRocm93IFwicXJSZWdpb24gdW5kZWZpbmVkIHdoZW4gbG9jYWxNZWRpYVN0cmVhbSBpcyByZWFkeS5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc1dpZHRoT2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi53aWR0aCAqIHdpZHRoUmF0aW87XG4gICAgICAgIHZhciBzSGVpZ2h0T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi5oZWlnaHQgKiBoZWlnaHRSYXRpbztcbiAgICAgICAgdmFyIHN4T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi54ICogd2lkdGhSYXRpbztcbiAgICAgICAgdmFyIHN5T2Zmc2V0ID0gdGhpcy5xclJlZ2lvbi55ICogaGVpZ2h0UmF0aW87XG4gICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCBzeE9mZnNldCwgc3lPZmZzZXQsIHNXaWR0aE9mZnNldCwgc0hlaWdodE9mZnNldCwgMCwgMCwgdGhpcy5xclJlZ2lvbi53aWR0aCwgdGhpcy5xclJlZ2lvbi5oZWlnaHQpO1xuICAgICAgICB2YXIgdHJpZ2dlck5leHRTY2FuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZm9yZXZlclNjYW5UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9yZXZlclNjYW4oaW50ZXJuYWxDb25maWcsIHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICB9LCBfdGhpcy5nZXRUaW1lb3V0RnBzKGludGVybmFsQ29uZmlnLmZwcykpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjYW5Db250ZXh0KHFyQ29kZVN1Y2Nlc3NDYWxsYmFjaywgcXJDb2RlRXJyb3JDYWxsYmFjaylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpc1N1Y2Nlc3NmdWxsKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3VjY2Vzc2Z1bGwgJiYgaW50ZXJuYWxDb25maWcuZGlzYWJsZUZsaXAgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnRyYW5zbGF0ZShfdGhpcy5jb250ZXh0LmNhbnZhcy53aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2NhbkNvbnRleHQocXJDb2RlU3VjY2Vzc0NhbGxiYWNrLCBxckNvZGVFcnJvckNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOZXh0U2NhbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5leHRTY2FuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiRXJyb3IgaGFwcGVuZCB3aGlsZSBzY2FubmluZyBjb250ZXh0XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRyaWdnZXJOZXh0U2NhbigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5jcmVhdGVWaWRlb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGNhbWVyYUlkT3JDb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYW1lcmFJZE9yQ29uZmlnID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRldmljZUlkOiB7IGV4YWN0OiBjYW1lcmFJZE9yQ29uZmlnIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FtZXJhSWRPckNvbmZpZyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgZmFjaW5nTW9kZUtleSA9IFwiZmFjaW5nTW9kZVwiO1xuICAgICAgICAgICAgdmFyIGRldmljZUlkS2V5ID0gXCJkZXZpY2VJZFwiO1xuICAgICAgICAgICAgdmFyIGFsbG93ZWRGYWNpbmdNb2RlVmFsdWVzXzEgPSB7IFwidXNlclwiOiB0cnVlLCBcImVudmlyb25tZW50XCI6IHRydWUgfTtcbiAgICAgICAgICAgIHZhciBleGFjdEtleSA9IFwiZXhhY3RcIjtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkRmFjaW5nTW9kZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluIGFsbG93ZWRGYWNpbmdNb2RlVmFsdWVzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcImNvbmZpZyBoYXMgaW52YWxpZCAnZmFjaW5nTW9kZScgdmFsdWUgPSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBcIidcIi5jb25jYXQodmFsdWUsIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjYW1lcmFJZE9yQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiJ2NhbWVyYUlkT3JDb25maWcnIG9iamVjdCBzaG91bGQgaGF2ZSBleGFjdGx5IDEga2V5LFwiXG4gICAgICAgICAgICAgICAgICAgICsgXCIgaWYgcGFzc2VkIGFzIGFuIG9iamVjdCwgZm91bmQgXCIuY29uY2F0KGtleXMubGVuZ3RoLCBcIiBrZXlzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKGNhbWVyYUlkT3JDb25maWcpWzBdO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gZmFjaW5nTW9kZUtleSAmJiBrZXkgIT09IGRldmljZUlkS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJPbmx5ICdcIi5jb25jYXQoZmFjaW5nTW9kZUtleSwgXCInIGFuZCAnXCIpLmNvbmNhdChkZXZpY2VJZEtleSwgXCInIFwiKVxuICAgICAgICAgICAgICAgICAgICArIFwiIGFyZSBzdXBwb3J0ZWQgZm9yICdjYW1lcmFJZE9yQ29uZmlnJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gZmFjaW5nTW9kZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBmYWNpbmdNb2RlID0gY2FtZXJhSWRPckNvbmZpZy5mYWNpbmdNb2RlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmFjaW5nTW9kZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRmFjaW5nTW9kZVZhbHVlKGZhY2luZ01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWNpbmdNb2RlOiBmYWNpbmdNb2RlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZhY2luZ01vZGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhhY3RLZXkgaW4gZmFjaW5nTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRGYWNpbmdNb2RlVmFsdWUoZmFjaW5nTW9kZVtcIlwiLmNvbmNhdChleGFjdEtleSldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2luZ01vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWNpbmdNb2RlW1wiXCIuY29uY2F0KGV4YWN0S2V5KV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIidmYWNpbmdNb2RlJyBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB3aXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiLmNvbmNhdChleGFjdEtleSwgXCIgYXMga2V5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMSA9ICh0eXBlb2YgZmFjaW5nTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0eXBlIG9mICdmYWNpbmdNb2RlJyA9IFwiLmNvbmNhdCh0eXBlXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGNhbWVyYUlkT3JDb25maWcuZGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRldmljZUlkOiBkZXZpY2VJZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGV2aWNlSWQgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhhY3RLZXkgaW4gZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkW1wiXCIuY29uY2F0KGV4YWN0S2V5KV0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiJ2RldmljZUlkJyBzaG91bGQgYmUgc3RyaW5nIG9yIG9iamVjdCB3aXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFwiIFwiLmNvbmNhdChleGFjdEtleSwgXCIgYXMga2V5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMiA9ICh0eXBlb2YgZGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdHlwZSBvZiAnZGV2aWNlSWQnID0gXCIuY29uY2F0KHR5cGVfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gKHR5cGVvZiBjYW1lcmFJZE9yQ29uZmlnKTtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHR5cGUgb2YgJ2NhbWVyYUlkT3JDb25maWcnID0gXCIuY29uY2F0KHR5cGUpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmNvbXB1dGVDYW52YXNEcmF3Q29uZmlnID0gZnVuY3Rpb24gKGltYWdlV2lkdGgsIGltYWdlSGVpZ2h0LCBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgIGlmIChpbWFnZVdpZHRoIDw9IGNvbnRhaW5lcldpZHRoXG4gICAgICAgICAgICAmJiBpbWFnZUhlaWdodCA8PSBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB4b2Zmc2V0ID0gKGNvbnRhaW5lcldpZHRoIC0gaW1hZ2VXaWR0aCkgLyAyO1xuICAgICAgICAgICAgdmFyIHlvZmZzZXQgPSAoY29udGFpbmVySGVpZ2h0IC0gaW1hZ2VIZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeG9mZnNldCxcbiAgICAgICAgICAgICAgICB5OiB5b2Zmc2V0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpbWFnZVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaW1hZ2VIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm9ybWVySW1hZ2VXaWR0aCA9IGltYWdlV2lkdGg7XG4gICAgICAgICAgICB2YXIgZm9ybWVySW1hZ2VIZWlnaHQgPSBpbWFnZUhlaWdodDtcbiAgICAgICAgICAgIGlmIChpbWFnZVdpZHRoID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUhlaWdodCA9IChjb250YWluZXJXaWR0aCAvIGltYWdlV2lkdGgpICogaW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltYWdlSGVpZ2h0ID4gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aCA9IChjb250YWluZXJIZWlnaHQgLyBpbWFnZUhlaWdodCkgKiBpbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIGltYWdlSGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSW1hZ2UgZG93bnNhbXBsZWQgZnJvbSBcIlxuICAgICAgICAgICAgICAgICsgXCJcIi5jb25jYXQoZm9ybWVySW1hZ2VXaWR0aCwgXCJYXCIpLmNvbmNhdChmb3JtZXJJbWFnZUhlaWdodClcbiAgICAgICAgICAgICAgICArIFwiIHRvIFwiLmNvbmNhdChpbWFnZVdpZHRoLCBcIlhcIikuY29uY2F0KGltYWdlSGVpZ2h0LCBcIi5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUNhbnZhc0RyYXdDb25maWcoaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUuY2xlYXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU1hbmFnZXJQcm94eS5pc1NjYW5uaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IGNsZWFyIHdoaWxlIHNjYW4gaXMgb25nb2luZywgY2xvc2UgaXQgZmlyc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsZW1lbnRJZCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5wb3NzaWJseVVwZGF0ZVNoYWRlcnMgPSBmdW5jdGlvbiAocXJNYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5xck1hdGNoID09PSBxck1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQm9yZGVyU2hhZGVyc1xuICAgICAgICAgICAgJiYgdGhpcy5ib3JkZXJTaGFkZXJzXG4gICAgICAgICAgICAmJiB0aGlzLmJvcmRlclNoYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHFyTWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgPyBDb25zdGFudHMuQk9SREVSX1NIQURFUl9NQVRDSF9DT0xPUlxuICAgICAgICAgICAgICAgICAgICA6IENvbnN0YW50cy5CT1JERVJfU0hBREVSX0RFRkFVTFRfQ09MT1I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnFyTWF0Y2ggPSBxck1hdGNoO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLnBvc3NpYmx5Q2xvc2VMYXN0U2NhbkltYWdlRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFNjYW5JbWFnZUZpbGUpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5sYXN0U2NhbkltYWdlRmlsZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RTY2FuSW1hZ2VGaWxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgY3VzdG9tSWQpIHtcbiAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGNhbnZhc1dpZHRoLCBcInB4XCIpO1xuICAgICAgICBjYW52YXNFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGNhbnZhc0hlaWdodCwgXCJweFwiKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuaWQgPSBpc051bGxPclVuZGVmaW5lZChjdXN0b21JZClcbiAgICAgICAgICAgID8gXCJxci1jYW52YXNcIiA6IGN1c3RvbUlkO1xuICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5nZXRTaGFkZWRSZWdpb25Cb3VuZHMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcXJib3hTaXplKSB7XG4gICAgICAgIGlmIChxcmJveFNpemUud2lkdGggPiB3aWR0aCB8fCBxcmJveFNpemUuaGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBcIidjb25maWcucXJib3gnIGRpbWVuc2lvbnMgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIFwiXG4gICAgICAgICAgICAgICAgKyBcImRpbWVuc2lvbnMgb2YgdGhlIHJvb3QgSFRNTCBlbGVtZW50LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAod2lkdGggLSBxcmJveFNpemUud2lkdGgpIC8gMixcbiAgICAgICAgICAgIHk6IChoZWlnaHQgLSBxcmJveFNpemUuaGVpZ2h0KSAvIDIsXG4gICAgICAgICAgICB3aWR0aDogcXJib3hTaXplLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBxcmJveFNpemUuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZS5wcm90b3R5cGUucG9zc2libHlJbnNlcnRTaGFkaW5nRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBxcmJveFNpemUpIHtcbiAgICAgICAgaWYgKCh3aWR0aCAtIHFyYm94U2l6ZS53aWR0aCkgPCAxIHx8IChoZWlnaHQgLSBxcmJveFNpemUuaGVpZ2h0KSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZGluZ0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdmFyIHJpZ2h0TGVmdEJvcmRlclNpemUgPSAod2lkdGggLSBxcmJveFNpemUud2lkdGgpIC8gMjtcbiAgICAgICAgdmFyIHRvcEJvdHRvbUJvcmRlclNpemUgPSAoaGVpZ2h0IC0gcXJib3hTaXplLmhlaWdodCkgLyAyO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJMZWZ0XG4gICAgICAgICAgICA9IFwiXCIuY29uY2F0KHJpZ2h0TGVmdEJvcmRlclNpemUsIFwicHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQ4KVwiKTtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUuYm9yZGVyUmlnaHRcbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQocmlnaHRMZWZ0Qm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJUb3BcbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQodG9wQm90dG9tQm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3JkZXJCb3R0b21cbiAgICAgICAgICAgID0gXCJcIi5jb25jYXQodG9wQm90dG9tQm9yZGVyU2l6ZSwgXCJweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuNDgpXCIpO1xuICAgICAgICBzaGFkaW5nRWxlbWVudC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHNoYWRpbmdFbGVtZW50LnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgc2hhZGluZ0VsZW1lbnQuaWQgPSBcIlwiLmNvbmNhdChDb25zdGFudHMuU0hBREVEX1JFR0lPTl9FTEVNRU5UX0lEKTtcbiAgICAgICAgaWYgKCh3aWR0aCAtIHFyYm94U2l6ZS53aWR0aCkgPCAxMVxuICAgICAgICAgICAgfHwgKGhlaWdodCAtIHFyYm94U2l6ZS5oZWlnaHQpIDwgMTEpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQm9yZGVyU2hhZGVycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNtYWxsU2l6ZSA9IDU7XG4gICAgICAgICAgICB2YXIgbGFyZ2VTaXplID0gNDA7XG4gICAgICAgICAgICB0aGlzLmluc2VydFNoYWRlckJvcmRlcnMoc2hhZGluZ0VsZW1lbnQsIGxhcmdlU2l6ZSwgc21hbGxTaXplLCAtc21hbGxTaXplLCBudWxsLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgbGFyZ2VTaXplLCBzbWFsbFNpemUsIC1zbWFsbFNpemUsIG51bGwsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgbGFyZ2VTaXplLCBzbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIDAsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFkZXJCb3JkZXJzKHNoYWRpbmdFbGVtZW50LCBsYXJnZVNpemUsIHNtYWxsU2l6ZSwgbnVsbCwgLXNtYWxsU2l6ZSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFkZXJCb3JkZXJzKHNoYWRpbmdFbGVtZW50LCBzbWFsbFNpemUsIGxhcmdlU2l6ZSArIHNtYWxsU2l6ZSwgLXNtYWxsU2l6ZSwgbnVsbCwgLXNtYWxsU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydFNoYWRlckJvcmRlcnMoc2hhZGluZ0VsZW1lbnQsIHNtYWxsU2l6ZSwgbGFyZ2VTaXplICsgc21hbGxTaXplLCBudWxsLCAtc21hbGxTaXplLCAtc21hbGxTaXplLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgc21hbGxTaXplLCBsYXJnZVNpemUgKyBzbWFsbFNpemUsIC1zbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhZGVyQm9yZGVycyhzaGFkaW5nRWxlbWVudCwgc21hbGxTaXplLCBsYXJnZVNpemUgKyBzbWFsbFNpemUsIG51bGwsIC1zbWFsbFNpemUsIC1zbWFsbFNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaGFzQm9yZGVyU2hhZGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hcHBlbmQoc2hhZGluZ0VsZW1lbnQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmluc2VydFNoYWRlckJvcmRlcnMgPSBmdW5jdGlvbiAoc2hhZGVyRWxlbSwgd2lkdGgsIGhlaWdodCwgdG9wLCBib3R0b20sIHNpZGUsIGlzTGVmdCkge1xuICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gQ29uc3RhbnRzLkJPUkRFUl9TSEFERVJfREVGQVVMVF9DT0xPUjtcbiAgICAgICAgZWxlbS5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICAgICAgICBlbGVtLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgaWYgKHRvcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdHRvbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSBcIlwiLmNvbmNhdChib3R0b20sIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQoc2lkZSwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSBcIlwiLmNvbmNhdChzaWRlLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ib3JkZXJTaGFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvcmRlclNoYWRlcnMucHVzaChlbGVtKTtcbiAgICAgICAgc2hhZGVyRWxlbS5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5zaG93UGF1c2VkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2FubmVyUGF1c2VkVWlFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBcIltpbnRlcm5hbCBlcnJvcl0gc2Nhbm5lciBwYXVzZWQgVUkgZWxlbWVudCBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlLnByb3RvdHlwZS5oaWRlUGF1c2VkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2FubmVyUGF1c2VkVWlFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBcIltpbnRlcm5hbCBlcnJvcl0gc2Nhbm5lciBwYXVzZWQgVUkgZWxlbWVudCBub3QgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW5uZXJQYXVzZWRVaUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGUucHJvdG90eXBlLmdldFRpbWVvdXRGcHMgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAgIHJldHVybiAxMDAwIC8gZnBzO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1UXJjb2RlO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sNS1xcmNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/html5-qrcode.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/image-assets.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/image-assets.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSET_CAMERA_SCAN: () => (/* binding */ ASSET_CAMERA_SCAN),\n/* harmony export */   ASSET_CLOSE_ICON_16PX: () => (/* binding */ ASSET_CLOSE_ICON_16PX),\n/* harmony export */   ASSET_FILE_SCAN: () => (/* binding */ ASSET_FILE_SCAN),\n/* harmony export */   ASSET_INFO_ICON_16PX: () => (/* binding */ ASSET_INFO_ICON_16PX)\n/* harmony export */ });\nvar SVG_XML_PREFIX = \"data:image/svg+xml;base64,\";\nvar ASSET_CAMERA_SCAN = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzNzEuNjQzIDM3MS42NDMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM3MS42NDMgMzcxLjY0MyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBhdGggZD0iTTEwNS4wODQgMzguMjcxaDE2My43Njh2MjBIMTA1LjA4NHoiLz48cGF0aCBkPSJNMzExLjU5NiAxOTAuMTg5Yy03LjQ0MS05LjM0Ny0xOC40MDMtMTYuMjA2LTMyLjc0My0yMC41MjJWMzBjMC0xNi41NDItMTMuNDU4LTMwLTMwLTMwSDEyNS4wODRjLTE2LjU0MiAwLTMwIDEzLjQ1OC0zMCAzMHYxMjAuMTQzaC04LjI5NmMtMTYuNTQyIDAtMzAgMTMuNDU4LTMwIDMwdjEuMzMzYTI5LjgwNCAyOS44MDQgMCAwIDAgNC42MDMgMTUuOTM5Yy03LjM0IDUuNDc0LTEyLjEwMyAxNC4yMjEtMTIuMTAzIDI0LjA2MXYxLjMzM2MwIDkuODQgNC43NjMgMTguNTg3IDEyLjEwMyAyNC4wNjJhMjkuODEgMjkuODEgMCAwIDAtNC42MDMgMTUuOTM4djEuMzMzYzAgMTYuNTQyIDEzLjQ1OCAzMCAzMCAzMGg4LjMyNGMuNDI3IDExLjYzMSA3LjUwMyAyMS41ODcgMTcuNTM0IDI2LjE3Ny45MzEgMTAuNTAzIDQuMDg0IDMwLjE4NyAxNC43NjggNDUuNTM3YTkuOTg4IDkuOTg4IDAgMCAwIDguMjE2IDQuMjg4IDkuOTU4IDkuOTU4IDAgMCAwIDUuNzA0LTEuNzkzYzQuNTMzLTMuMTU1IDUuNjUtOS4zODggMi40OTUtMTMuOTIxLTYuNzk4LTkuNzY3LTkuNjAyLTIyLjYwOC0xMC43Ni0zMS40aDgyLjY4NWMuMjcyLjQxNC41NDUuODE4LjgxNSAxLjIxIDMuMTQyIDQuNTQxIDkuMzcyIDUuNjc5IDEzLjkxMyAyLjUzNCA0LjU0Mi0zLjE0MiA1LjY3Ny05LjM3MSAyLjUzNS0xMy45MTMtMTEuOTE5LTE3LjIyOS04Ljc4Ny0zNS44ODQgOS41ODEtNTcuMDEyIDMuMDY3LTIuNjUyIDEyLjMwNy0xMS43MzIgMTEuMjE3LTI0LjAzMy0uODI4LTkuMzQzLTcuMTA5LTE3LjE5NC0xOC42NjktMjMuMzM3YTkuODU3IDkuODU3IDAgMCAwLTEuMDYxLS40ODZjLS40NjYtLjE4Mi0xMS40MDMtNC41NzktOS43NDEtMTUuNzA2IDEuMDA3LTYuNzM3IDE0Ljc2OC04LjI3MyAyMy43NjYtNy42NjYgMjMuMTU2IDEuNTY5IDM5LjY5OCA3LjgwMyA0Ny44MzYgMTguMDI2IDUuNzUyIDcuMjI1IDcuNjA3IDE2LjYyMyA1LjY3MyAyOC43MzMtLjQxMyAyLjU4NS0uODI0IDUuMjQxLTEuMjQ1IDcuOTU5LTUuNzU2IDM3LjE5NC0xMi45MTkgODMuNDgzLTQ5Ljg3IDExNC42NjEtNC4yMjEgMy41NjEtNC43NTYgOS44Ny0xLjE5NCAxNC4wOTJhOS45OCA5Ljk4IDAgMCAwIDcuNjQ4IDMuNTUxIDkuOTU1IDkuOTU1IDAgMCAwIDYuNDQ0LTIuMzU4YzQyLjY3Mi0zNi4wMDUgNTAuODAyLTg4LjUzMyA1Ni43MzctMTI2Ljg4OC40MTUtMi42ODQuODIxLTUuMzA5IDEuMjI5LTcuODYzIDIuODM0LTE3LjcyMS0uNDU1LTMyLjY0MS05Ljc3Mi00NC4zNDV6bS0yMzIuMzA4IDQyLjYyYy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM2MwLTUuNTE0IDQuNDg2LTEwIDEwLTEwaDE1djIxLjMzM2gtMTV6bS0yLjUtNTIuNjY2YzAtNS41MTQgNC40ODYtMTAgMTAtMTBoNy41djIxLjMzM2gtNy41Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM3ptMTcuNSA5My45OTloLTcuNWMtNS41MTQgMC0xMC00LjQ4Ni0xMC0xMHYtMS4zMzNjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGg3LjV2MjEuMzMzem0zMC43OTYgMjguODg3Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi04LjI3MWg5MS40NTdjLS44NTEgNi42NjgtLjQzNyAxMi43ODcuNzMxIDE4LjI3MWgtODIuMTg4em03OS40ODItMTEzLjY5OGMtMy4xMjQgMjAuOTA2IDEyLjQyNyAzMy4xODQgMjEuNjI1IDM3LjA0IDUuNDQxIDIuOTY4IDcuNTUxIDUuNjQ3IDcuNzAxIDcuMTg4LjIxIDIuMTUtMi41NTMgNS42ODQtNC40NzcgNy4yNTEtLjQ4Mi4zNzgtLjkyOS44LTEuMzM1IDEuMjYxLTYuOTg3IDcuOTM2LTExLjk4MiAxNS41Mi0xNS40MzIgMjIuNjg4aC05Ny41NjRWMzBjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGgxMjMuNzY5YzUuNTE0IDAgMTAgNC40ODYgMTAgMTB2MTM1LjU3OWMtMy4wMzItLjM4MS02LjE1LS42OTQtOS4zODktLjkxNC0yNS4xNTktMS42OTQtNDIuMzcgNy43NDgtNDQuODk4IDI0LjY2NnoiLz48cGF0aCBkPSJNMTc5LjEyOSA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXpNMTcyLjYyOSAxNDIuODZoLTEyLjU2VjEzMC44YTUgNSAwIDEgMC0xMCAwdjE3LjA2MWE1IDUgMCAwIDAgNSA1aDE3LjU2YTUgNSAwIDEgMCAwLTEwLjAwMXpNMjE2LjU2OCA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXptLTUgMjQuMDYxaC0xNC4wNlY5My4xNjdoMTQuMDZ2MTQuMDYxek0yMTEuNjY5IDEyNS45MzZIMTk3LjQxYTUgNSAwIDAgMC01IDV2MTQuMjU3YTUgNSAwIDAgMCA1IDVoMTQuMjU5YTUgNSAwIDAgMCA1LTV2LTE0LjI1N2E1IDUgMCAwIDAtNS01eiIvPjwvc3ZnPg==\";\nvar ASSET_FILE_SCAN = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1OS4wMTggNTkuMDE4IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1OS4wMTggNTkuMDE4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJtNTguNzQxIDU0LjgwOS01Ljk2OS02LjI0NGExMC43NCAxMC43NCAwIDAgMCAyLjgyLTcuMjVjMC01Ljk1My00Ljg0My0xMC43OTYtMTAuNzk2LTEwLjc5NlMzNCAzNS4zNjEgMzQgNDEuMzE0IDM4Ljg0MyA1Mi4xMSA0NC43OTYgNTIuMTFjMi40NDEgMCA0LjY4OC0uODI0IDYuNDk5LTIuMTk2bDYuMDAxIDYuMjc3YS45OTguOTk4IDAgMCAwIDEuNDE0LjAzMiAxIDEgMCAwIDAgLjAzMS0xLjQxNHpNMzYgNDEuMzE0YzAtNC44NSAzLjk0Ni04Ljc5NiA4Ljc5Ni04Ljc5NnM4Ljc5NiAzLjk0NiA4Ljc5NiA4Ljc5Ni0zLjk0NiA4Ljc5Ni04Ljc5NiA4Ljc5NlMzNiA0Ni4xNjQgMzYgNDEuMzE0ek0xMC40MzEgMTYuMDg4YzAgMy4wNyAyLjQ5OCA1LjU2OCA1LjU2OSA1LjU2OHM1LjU2OS0yLjQ5OCA1LjU2OS01LjU2OGMwLTMuMDcxLTIuNDk4LTUuNTY5LTUuNTY5LTUuNTY5cy01LjU2OSAyLjQ5OC01LjU2OSA1LjU2OXptOS4xMzggMGMwIDEuOTY4LTEuNjAyIDMuNTY4LTMuNTY5IDMuNTY4cy0zLjU2OS0xLjYwMS0zLjU2OS0zLjU2OCAxLjYwMi0zLjU2OSAzLjU2OS0zLjU2OSAzLjU2OSAxLjYwMSAzLjU2OSAzLjU2OXoiLz48cGF0aCBkPSJtMzAuODgyIDI4Ljk4NyA5LjE4LTEwLjA1NCAxMS4yNjIgMTAuMzIzYTEgMSAwIDAgMCAxLjM1MS0xLjQ3NWwtMTItMTFhMSAxIDAgMCAwLTEuNDE0LjA2M2wtOS43OTQgMTAuNzI3LTQuNzQzLTQuNzQzYTEuMDAzIDEuMDAzIDAgMCAwLTEuMzY4LS4wNDRMNi4zMzkgMzcuNzY4YTEgMSAwIDEgMCAxLjMyMiAxLjUwMWwxNi4zMTMtMTQuMzYyIDcuMzE5IDcuMzE4YS45OTkuOTk5IDAgMSAwIDEuNDE0LTEuNDE0bC0xLjgyNS0xLjgyNHoiLz48cGF0aCBkPSJNMzAgNDYuNTE4SDJ2LTQyaDU0djI4YTEgMSAwIDEgMCAyIDB2LTI5YTEgMSAwIDAgMC0xLTFIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoMjlhMSAxIDAgMSAwIDAtMnoiLz48L3N2Zz4=\";\nvar ASSET_INFO_ICON_16PX = SVG_XML_PREFIX + \"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NjAgNDYwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NjAgNDYwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNMjMwIDBDMTAyLjk3NSAwIDAgMTAyLjk3NSAwIDIzMHMxMDIuOTc1IDIzMCAyMzAgMjMwIDIzMC0xMDIuOTc0IDIzMC0yMzBTMzU3LjAyNSAwIDIzMCAwem0zOC4zMzMgMzc3LjM2YzAgOC42NzYtNy4wMzQgMTUuNzEtMTUuNzEgMTUuNzFoLTQzLjEwMWMtOC42NzYgMC0xNS43MS03LjAzNC0xNS43MS0xNS43MVYyMDIuNDc3YzAtOC42NzYgNy4wMzMtMTUuNzEgMTUuNzEtMTUuNzFoNDMuMTAxYzguNjc2IDAgMTUuNzEgNy4wMzMgMTUuNzEgMTUuNzFWMzc3LjM2ek0yMzAgMTU3Yy0yMS41MzkgMC0zOS0xNy40NjEtMzktMzlzMTcuNDYxLTM5IDM5LTM5IDM5IDE3LjQ2MSAzOSAzOS0xNy40NjEgMzktMzkgMzl6Ii8+PC9zdmc+\";\nvar ASSET_CLOSE_ICON_16PX = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAQgAAAEIBarqQRAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE1SURBVDiNfdI7S0NBEAXgLya1otFgpbYSbISAgpXYi6CmiH9KCAiChaVga6OiWPgfRDQ+0itaGVNosXtluWwcuMzePfM4M3sq8lbHBubwg1dc4m1E/J/N4ghDPOIsfk/4xiEao5KX0McFljN4C9d4QTPXuY99jP3DsIoDPGM6BY5i5yI5R7O4q+ImFkJY2DCh3cAH2klyB+9J1xUMMAG7eCh1a+Mr+k48b5diXrFVwwLuS+BJ9MfR7+G0FHOHhTHhnXNWS87VDF4pcnfQK4Ep7XScNLmPTZgURNKKYENYWDpzW1BhscS1WHS8CDgURFJQrWcoF3c13KKbgg1BYQfy8xZWEzTTw1QZbAoKu8FqJnktdu5hcVSHmchiILzzuaDQvjBzV2m8yohCE1jHfPx/xhU+y4G/D75ELlRJsSYAAAAASUVORK5CYII=\";\n//# sourceMappingURL=image-assets.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaW1hZ2UtYXNzZXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9pbWFnZS1hc3NldHMuanM/NmIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU1ZHX1hNTF9QUkVGSVggPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsXCI7XG5leHBvcnQgdmFyIEFTU0VUX0NBTUVSQV9TQ0FOID0gU1ZHX1hNTF9QUkVGSVggKyBcIlBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBek56RXVOalF6SURNM01TNDJORE1pSUhOMGVXeGxQU0psYm1GaWJHVXRZbUZqYTJkeWIzVnVaRHB1WlhjZ01DQXdJRE0zTVM0Mk5ETWdNemN4TGpZME15SWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0krUEhCaGRHZ2daRDBpVFRFd05TNHdPRFFnTXpndU1qY3hhREUyTXk0M05qaDJNakJJTVRBMUxqQTROSG9pTHo0OGNHRjBhQ0JrUFNKTk16RXhMalU1TmlBeE9UQXVNVGc1WXkwM0xqUTBNUzA1TGpNME55MHhPQzQwTURNdE1UWXVNakEyTFRNeUxqYzBNeTB5TUM0MU1qSldNekJqTUMweE5pNDFOREl0TVRNdU5EVTRMVE13TFRNd0xUTXdTREV5TlM0d09EUmpMVEUyTGpVME1pQXdMVE13SURFekxqUTFPQzB6TUNBek1IWXhNakF1TVRRemFDMDRMakk1Tm1NdE1UWXVOVFF5SURBdE16QWdNVE11TkRVNExUTXdJRE13ZGpFdU16TXpZVEk1TGpnd05DQXlPUzQ0TURRZ01DQXdJREFnTkM0Mk1ETWdNVFV1T1RNNVl5MDNMak0wSURVdU5EYzBMVEV5TGpFd015QXhOQzR5TWpFdE1USXVNVEF6SURJMExqQTJNWFl4TGpNek0yTXdJRGt1T0RRZ05DNDNOak1nTVRndU5UZzNJREV5TGpFd015QXlOQzR3TmpKaE1qa3VPREVnTWprdU9ERWdNQ0F3SURBdE5DNDJNRE1nTVRVdU9UTTRkakV1TXpNell6QWdNVFl1TlRReUlERXpMalExT0NBek1DQXpNQ0F6TUdnNExqTXlOR011TkRJM0lERXhMall6TVNBM0xqVXdNeUF5TVM0MU9EY2dNVGN1TlRNMElESTJMakUzTnk0NU16RWdNVEF1TlRBeklEUXVNRGcwSURNd0xqRTROeUF4TkM0M05qZ2dORFV1TlRNM1lUa3VPVGc0SURrdU9UZzRJREFnTUNBd0lEZ3VNakUySURRdU1qZzRJRGt1T1RVNElEa3VPVFU0SURBZ01DQXdJRFV1TnpBMExURXVOemt6WXpRdU5UTXpMVE11TVRVMUlEVXVOalV0T1M0ek9EZ2dNaTQwT1RVdE1UTXVPVEl4TFRZdU56azRMVGt1TnpZM0xUa3VOakF5TFRJeUxqWXdPQzB4TUM0M05pMHpNUzQwYURneUxqWTROV011TWpjeUxqUXhOQzQxTkRVdU9ERTRMamd4TlNBeExqSXhJRE11TVRReUlEUXVOVFF4SURrdU16Y3lJRFV1TmpjNUlERXpMamt4TXlBeUxqVXpOQ0EwTGpVME1pMHpMakUwTWlBMUxqWTNOeTA1TGpNM01TQXlMalV6TlMweE15NDVNVE10TVRFdU9URTVMVEUzTGpJeU9TMDRMamM0Tnkwek5TNDRPRFFnT1M0MU9ERXROVGN1TURFeUlETXVNRFkzTFRJdU5qVXlJREV5TGpNd055MHhNUzQzTXpJZ01URXVNakUzTFRJMExqQXpNeTB1T0RJNExUa3VNelF6TFRjdU1UQTVMVEUzTGpFNU5DMHhPQzQyTmprdE1qTXVNek0zWVRrdU9EVTNJRGt1T0RVM0lEQWdNQ0F3TFRFdU1EWXhMUzQwT0RaakxTNDBOall0TGpFNE1pMHhNUzQwTURNdE5DNDFOemt0T1M0M05ERXRNVFV1TnpBMklERXVNREEzTFRZdU56TTNJREUwTGpjMk9DMDRMakkzTXlBeU15NDNOall0Tnk0Mk5qWWdNak11TVRVMklERXVOVFk1SURNNUxqWTVPQ0EzTGpnd015QTBOeTQ0TXpZZ01UZ3VNREkySURVdU56VXlJRGN1TWpJMUlEY3VOakEzSURFMkxqWXlNeUExTGpZM015QXlPQzQzTXpNdExqUXhNeUF5TGpVNE5TMHVPREkwSURVdU1qUXhMVEV1TWpRMUlEY3VPVFU1TFRVdU56VTJJRE0zTGpFNU5DMHhNaTQ1TVRrZ09ETXVORGd6TFRRNUxqZzNJREV4TkM0Mk5qRXROQzR5TWpFZ015NDFOakV0TkM0M05UWWdPUzQ0TnkweExqRTVOQ0F4TkM0d09USmhPUzQ1T0NBNUxqazRJREFnTUNBd0lEY3VOalE0SURNdU5UVXhJRGt1T1RVMUlEa3VPVFUxSURBZ01DQXdJRFl1TkRRMExUSXVNelU0WXpReUxqWTNNaTB6Tmk0d01EVWdOVEF1T0RBeUxUZzRMalV6TXlBMU5pNDNNemN0TVRJMkxqZzRPQzQwTVRVdE1pNDJPRFF1T0RJeExUVXVNekE1SURFdU1qSTVMVGN1T0RZeklESXVPRE0wTFRFM0xqY3lNUzB1TkRVMUxUTXlMalkwTVMwNUxqYzNNaTAwTkM0ek5EVjZiUzB5TXpJdU16QTRJRFF5TGpZeVl5MDFMalV4TkNBd0xURXdMVFF1TkRnMkxURXdMVEV3ZGkweExqTXpNMk13TFRVdU5URTBJRFF1TkRnMkxURXdJREV3TFRFd2FERTFkakl4TGpNek0yZ3RNVFY2YlMweUxqVXROVEl1TmpZMll6QXROUzQxTVRRZ05DNDBPRFl0TVRBZ01UQXRNVEJvTnk0MWRqSXhMak16TTJndE55NDFZeTAxTGpVeE5DQXdMVEV3TFRRdU5EZzJMVEV3TFRFd2RpMHhMak16TTNwdE1UY3VOU0E1TXk0NU9UbG9MVGN1TldNdE5TNDFNVFFnTUMweE1DMDBMalE0TmkweE1DMHhNSFl0TVM0ek16TmpNQzAxTGpVeE5DQTBMalE0TmkweE1DQXhNQzB4TUdnM0xqVjJNakV1TXpNemVtMHpNQzQzT1RZZ01qZ3VPRGczWXkwMUxqVXhOQ0F3TFRFd0xUUXVORGcyTFRFd0xURXdkaTA0TGpJM01XZzVNUzQwTlRkakxTNDROVEVnTmk0Mk5qZ3RMalF6TnlBeE1pNDNPRGN1TnpNeElERTRMakkzTVdndE9ESXVNVGc0ZW0wM09TNDBPREl0TVRFekxqWTVPR010TXk0eE1qUWdNakF1T1RBMklERXlMalF5TnlBek15NHhPRFFnTWpFdU5qSTFJRE0zTGpBMElEVXVORFF4SURJdU9UWTRJRGN1TlRVeElEVXVOalEzSURjdU56QXhJRGN1TVRnNExqSXhJREl1TVRVdE1pNDFOVE1nTlM0Mk9EUXROQzQwTnpjZ055NHlOVEV0TGpRNE1pNHpOemd0TGpreU9TNDRMVEV1TXpNMUlERXVNall4TFRZdU9UZzNJRGN1T1RNMkxURXhMams0TWlBeE5TNDFNaTB4TlM0ME16SWdNakl1TmpnNGFDMDVOeTQxTmpSV016QmpNQzAxTGpVeE5DQTBMalE0TmkweE1DQXhNQzB4TUdneE1qTXVOelk1WXpVdU5URTBJREFnTVRBZ05DNDBPRFlnTVRBZ01UQjJNVE0xTGpVM09XTXRNeTR3TXpJdExqTTRNUzAyTGpFMUxTNDJPVFF0T1M0ek9Ea3RMamt4TkMweU5TNHhOVGt0TVM0Mk9UUXROREl1TXpjZ055NDNORGd0TkRRdU9EazRJREkwTGpZMk5ub2lMejQ4Y0dGMGFDQmtQU0pOTVRjNUxqRXlPU0E0TXk0eE5qZG9MVEkwTGpBMllUVWdOU0F3SURBZ01DMDFJRFYyTWpRdU1EWXhZVFVnTlNBd0lEQWdNQ0ExSURWb01qUXVNRFpoTlNBMUlEQWdNQ0F3SURVdE5WWTRPQzR4TmpkaE5TQTFJREFnTUNBd0xUVXROWHBOTVRjeUxqWXlPU0F4TkRJdU9EWm9MVEV5TGpVMlZqRXpNQzQ0WVRVZ05TQXdJREVnTUMweE1DQXdkakUzTGpBMk1XRTFJRFVnTUNBd0lEQWdOU0ExYURFM0xqVTJZVFVnTlNBd0lERWdNQ0F3TFRFd0xqQXdNWHBOTWpFMkxqVTJPQ0E0TXk0eE5qZG9MVEkwTGpBMllUVWdOU0F3SURBZ01DMDFJRFYyTWpRdU1EWXhZVFVnTlNBd0lEQWdNQ0ExSURWb01qUXVNRFpoTlNBMUlEQWdNQ0F3SURVdE5WWTRPQzR4TmpkaE5TQTFJREFnTUNBd0xUVXROWHB0TFRVZ01qUXVNRFl4YUMweE5DNHdObFk1TXk0eE5qZG9NVFF1TURaMk1UUXVNRFl4ZWsweU1URXVOalk1SURFeU5TNDVNelpJTVRrM0xqUXhZVFVnTlNBd0lEQWdNQzAxSURWMk1UUXVNalUzWVRVZ05TQXdJREFnTUNBMUlEVm9NVFF1TWpVNVlUVWdOU0F3SURBZ01DQTFMVFYyTFRFMExqSTFOMkUxSURVZ01DQXdJREF0TlMwMWVpSXZQand2YzNablBnPT1cIjtcbmV4cG9ydCB2YXIgQVNTRVRfRklMRV9TQ0FOID0gU1ZHX1hNTF9QUkVGSVggKyBcIlBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBMU9TNHdNVGdnTlRrdU1ERTRJaUJ6ZEhsc1pUMGlaVzVoWW14bExXSmhZMnRuY205MWJtUTZibVYzSURBZ01DQTFPUzR3TVRnZ05Ua3VNREU0SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNDhjR0YwYUNCa1BTSnROVGd1TnpReElEVTBMamd3T1MwMUxqazJPUzAyTGpJME5HRXhNQzQzTkNBeE1DNDNOQ0F3SURBZ01DQXlMamd5TFRjdU1qVmpNQzAxTGprMU15MDBMamcwTXkweE1DNDNPVFl0TVRBdU56azJMVEV3TGpjNU5sTXpOQ0F6TlM0ek5qRWdNelFnTkRFdU16RTBJRE00TGpnME15QTFNaTR4TVNBME5DNDNPVFlnTlRJdU1URmpNaTQwTkRFZ01DQTBMalk0T0MwdU9ESTBJRFl1TkRrNUxUSXVNVGsyYkRZdU1EQXhJRFl1TWpjM1lTNDVPVGd1T1RrNElEQWdNQ0F3SURFdU5ERTBMakF6TWlBeElERWdNQ0F3SURBZ0xqQXpNUzB4TGpReE5IcE5NellnTkRFdU16RTBZekF0TkM0NE5TQXpMamswTmkwNExqYzVOaUE0TGpjNU5pMDRMamM1Tm5NNExqYzVOaUF6TGprME5pQTRMamM1TmlBNExqYzVOaTB6TGprME5pQTRMamM1TmkwNExqYzVOaUE0TGpjNU5sTXpOaUEwTmk0eE5qUWdNellnTkRFdU16RTBlazB4TUM0ME16RWdNVFl1TURnNFl6QWdNeTR3TnlBeUxqUTVPQ0ExTGpVMk9DQTFMalUyT1NBMUxqVTJPSE0xTGpVMk9TMHlMalE1T0NBMUxqVTJPUzAxTGpVMk9HTXdMVE11TURjeExUSXVORGs0TFRVdU5UWTVMVFV1TlRZNUxUVXVOVFk1Y3kwMUxqVTJPU0F5TGpRNU9DMDFMalUyT1NBMUxqVTJPWHB0T1M0eE16Z2dNR013SURFdU9UWTRMVEV1TmpBeUlETXVOVFk0TFRNdU5UWTVJRE11TlRZNGN5MHpMalUyT1MweExqWXdNUzB6TGpVMk9TMHpMalUyT0NBeExqWXdNaTB6TGpVMk9TQXpMalUyT1MwekxqVTJPU0F6TGpVMk9TQXhMall3TVNBekxqVTJPU0F6TGpVMk9Yb2lMejQ4Y0dGMGFDQmtQU0p0TXpBdU9EZ3lJREk0TGprNE55QTVMakU0TFRFd0xqQTFOQ0F4TVM0eU5qSWdNVEF1TXpJellURWdNU0F3SURBZ01DQXhMak0xTVMweExqUTNOV3d0TVRJdE1URmhNU0F4SURBZ01DQXdMVEV1TkRFMExqQTJNMnd0T1M0M09UUWdNVEF1TnpJM0xUUXVOelF6TFRRdU56UXpZVEV1TURBeklERXVNREF6SURBZ01DQXdMVEV1TXpZNExTNHdORFJNTmk0ek16a2dNemN1TnpZNFlURWdNU0F3SURFZ01DQXhMak15TWlBeExqVXdNV3d4Tmk0ek1UTXRNVFF1TXpZeUlEY3VNekU1SURjdU16RTRZUzQ1T1RrdU9UazVJREFnTVNBd0lERXVOREUwTFRFdU5ERTBiQzB4TGpneU5TMHhMamd5TkhvaUx6NDhjR0YwYUNCa1BTSk5NekFnTkRZdU5URTRTREoyTFRReWFEVTBkakk0WVRFZ01TQXdJREVnTUNBeUlEQjJMVEk1WVRFZ01TQXdJREFnTUMweExURklNV0V4SURFZ01DQXdJREF0TVNBeGRqUTBZVEVnTVNBd0lEQWdNQ0F4SURGb01qbGhNU0F4SURBZ01TQXdJREF0TW5vaUx6NDhMM04yWno0PVwiO1xuZXhwb3J0IHZhciBBU1NFVF9JTkZPX0lDT05fMTZQWCA9IFNWR19YTUxfUFJFRklYICsgXCJQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQTBOakFnTkRZd0lpQnpkSGxzWlQwaVpXNWhZbXhsTFdKaFkydG5jbTkxYm1RNmJtVjNJREFnTUNBME5qQWdORFl3SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNDhjR0YwYUNCa1BTSk5Nak13SURCRE1UQXlMamszTlNBd0lEQWdNVEF5TGprM05TQXdJREl6TUhNeE1ESXVPVGMxSURJek1DQXlNekFnTWpNd0lESXpNQzB4TURJdU9UYzBJREl6TUMweU16QlRNelUzTGpBeU5TQXdJREl6TUNBd2VtMHpPQzR6TXpNZ016YzNMak0yWXpBZ09DNDJOell0Tnk0d016UWdNVFV1TnpFdE1UVXVOekVnTVRVdU56Rm9MVFF6TGpFd01XTXRPQzQyTnpZZ01DMHhOUzQzTVMwM0xqQXpOQzB4TlM0M01TMHhOUzQzTVZZeU1ESXVORGMzWXpBdE9DNDJOellnTnk0d016TXRNVFV1TnpFZ01UVXVOekV0TVRVdU56Rm9ORE11TVRBeFl6Z3VOamMySURBZ01UVXVOekVnTnk0d016TWdNVFV1TnpFZ01UVXVOekZXTXpjM0xqTTJlazB5TXpBZ01UVTNZeTB5TVM0MU16a2dNQzB6T1MweE55NDBOakV0TXprdE16bHpNVGN1TkRZeExUTTVJRE01TFRNNUlETTVJREUzTGpRMk1TQXpPU0F6T1MweE55NDBOakVnTXprdE16a2dNemw2SWk4K1BDOXpkbWMrXCI7XG5leHBvcnQgdmFyIEFTU0VUX0NMT1NFX0lDT05fMTZQWCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBQUFsd1NGbHpBQUFBUWdBQUFFSUJhcnFRUkFBQUFCbDBSVmgwVTI5bWRIZGhjbVVBZDNkM0xtbHVhM05qWVhCbExtOXlaNXZ1UEJvQUFBRTFTVVJCVkRpTmZkSTdTME5CRUFYZ0x5YTFvdEZncGJZU2JJU0FncFhZaTZDbWlIOUtDQWlDaGFWZ2E2T2lXUGdmUkRRKzBpdGFHVk5vc1h0bHVXd2N1TXplUGZNNE0zc3E4bGJIQnVid2cxZGM0bTFFL0ovTjRnaERQT0lzZmsvNHhpRWFvNUtYME1jRmxqTjRDOWQ0UVRQWHVZOTlqUDNEc0lvRFBHTTZCWTVpNXlJNVI3TzRxK0ltRmtKWTJEQ2gzY0FIMmtseUIrOUoxeFVNTUFHN2VDaDFhK01yK2s0OGI1ZGlYckZWd3dMdVMrQko5TWZSNytHMEZIT0hoVEhoblhOV1M4N1ZERjRwY25mUUs0RXA3WFNjTkxtUFRaZ1VSTktLWUVOWVdEcHpXMUJoc2NTMVdIUzhDRGdVUkZKUXJXY29GM2MxM0tLYmdnMUJZUWZ5OHhaV0V6VFR3MVFaYkFvS3U4RnFKbmt0ZHU1aGNWU0htY2hpSUx6enVhRFF2akJ6VjJtOHlvaENFMWpIZlB4L3hoVSt5NEcvRDc1RUxsUkpzU1lBQUFBQVNVVk9SSzVDWUlJPVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYXNzZXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/image-assets.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/index.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5Qrcode: () => (/* reexport safe */ _html5_qrcode__WEBPACK_IMPORTED_MODULE_0__.Html5Qrcode),\n/* harmony export */   Html5QrcodeScanType: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeScanType),\n/* harmony export */   Html5QrcodeScanner: () => (/* reexport safe */ _html5_qrcode_scanner__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScanner),\n/* harmony export */   Html5QrcodeScannerState: () => (/* reexport safe */ _state_manager__WEBPACK_IMPORTED_MODULE_3__.Html5QrcodeScannerState),\n/* harmony export */   Html5QrcodeSupportedFormats: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_2__.Html5QrcodeSupportedFormats)\n/* harmony export */ });\n/* harmony import */ var _html5_qrcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./html5-qrcode */ \"../../../node_modules/html5-qrcode/esm/html5-qrcode.js\");\n/* harmony import */ var _html5_qrcode_scanner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html5-qrcode-scanner */ \"../../../node_modules/html5-qrcode/esm/html5-qrcode-scanner.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core */ \"../../../node_modules/html5-qrcode/esm/core.js\");\n/* harmony import */ var _state_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state-manager */ \"../../../node_modules/html5-qrcode/esm/state-manager.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vaW5kZXguanM/MzkwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBIdG1sNVFyY29kZSB9IGZyb20gXCIuL2h0bWw1LXFyY29kZVwiO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyIH0gZnJvbSBcIi4vaHRtbDUtcXJjb2RlLXNjYW5uZXJcIjtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyB9IGZyb20gXCIuL2NvcmVcIjtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlIH0gZnJvbSBcIi4vc3RhdGUtbWFuYWdlclwiO1xuZXhwb3J0IHsgSHRtbDVRcmNvZGVTY2FuVHlwZSB9IGZyb20gXCIuL2NvcmVcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/index.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/native-bar-code-detector.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/native-bar-code-detector.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetectorDelegate: () => (/* binding */ BarcodeDetectorDelegate)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"../../../node_modules/html5-qrcode/esm/core.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar BarcodeDetectorDelegate = (function () {\n    function BarcodeDetectorDelegate(requestedFormats, verbose, logger) {\n        this.formatMap = new Map([\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.QR_CODE, \"qr_code\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.AZTEC, \"aztec\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODABAR, \"codabar\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_39, \"code_39\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_93, \"code_93\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.CODE_128, \"code_128\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.DATA_MATRIX, \"data_matrix\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.ITF, \"itf\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_13, \"ean_13\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.EAN_8, \"ean_8\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.PDF_417, \"pdf417\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_A, \"upc_a\"],\n            [_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeSupportedFormats.UPC_E, \"upc_e\"]\n        ]);\n        this.reverseFormatMap = this.createReverseFormatMap();\n        if (!BarcodeDetectorDelegate.isSupported()) {\n            throw \"Use html5qrcode.min.js without edit, Use \"\n                + \"BarcodeDetectorDelegate only if it isSupported();\";\n        }\n        this.verbose = verbose;\n        this.logger = logger;\n        var formats = this.createBarcodeDetectorFormats(requestedFormats);\n        this.detector = new BarcodeDetector(formats);\n        if (!this.detector) {\n            throw \"BarcodeDetector detector not supported\";\n        }\n    }\n    BarcodeDetectorDelegate.isSupported = function () {\n        if (!(\"BarcodeDetector\" in window)) {\n            return false;\n        }\n        var dummyDetector = new BarcodeDetector({ formats: [\"qr_code\"] });\n        return typeof dummyDetector !== \"undefined\";\n    };\n    BarcodeDetectorDelegate.prototype.decodeAsync = function (canvas) {\n        return __awaiter(this, void 0, void 0, function () {\n            var barcodes, largestBarcode;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this.detector.detect(canvas)];\n                    case 1:\n                        barcodes = _a.sent();\n                        if (!barcodes || barcodes.length === 0) {\n                            throw \"No barcode or QR code detected.\";\n                        }\n                        largestBarcode = this.selectLargestBarcode(barcodes);\n                        return [2, {\n                                text: largestBarcode.rawValue,\n                                format: _core__WEBPACK_IMPORTED_MODULE_0__.QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format)),\n                                debugData: this.createDebugData()\n                            }];\n                }\n            });\n        });\n    };\n    BarcodeDetectorDelegate.prototype.selectLargestBarcode = function (barcodes) {\n        var largestBarcode = null;\n        var maxArea = 0;\n        for (var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++) {\n            var barcode = barcodes_1[_i];\n            var area = barcode.boundingBox.width * barcode.boundingBox.height;\n            if (area > maxArea) {\n                maxArea = area;\n                largestBarcode = barcode;\n            }\n        }\n        if (!largestBarcode) {\n            throw \"No largest barcode found\";\n        }\n        return largestBarcode;\n    };\n    BarcodeDetectorDelegate.prototype.createBarcodeDetectorFormats = function (requestedFormats) {\n        var formats = [];\n        for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {\n            var requestedFormat = requestedFormats_1[_i];\n            if (this.formatMap.has(requestedFormat)) {\n                formats.push(this.formatMap.get(requestedFormat));\n            }\n            else {\n                this.logger.warn(\"\".concat(requestedFormat, \" is not supported by\")\n                    + \"BarcodeDetectorDelegate\");\n            }\n        }\n        return { formats: formats };\n    };\n    BarcodeDetectorDelegate.prototype.toHtml5QrcodeSupportedFormats = function (barcodeDetectorFormat) {\n        if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {\n            throw \"reverseFormatMap doesn't have \".concat(barcodeDetectorFormat);\n        }\n        return this.reverseFormatMap.get(barcodeDetectorFormat);\n    };\n    BarcodeDetectorDelegate.prototype.createReverseFormatMap = function () {\n        var result = new Map();\n        this.formatMap.forEach(function (value, key, _) {\n            result.set(value, key);\n        });\n        return result;\n    };\n    BarcodeDetectorDelegate.prototype.createDebugData = function () {\n        return { decoderName: \"BarcodeDetector\" };\n    };\n    return BarcodeDetectorDelegate;\n}());\n\n//# sourceMappingURL=native-bar-code-detector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vbmF0aXZlLWJhci1jb2RlLWRldGVjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9uYXRpdmUtYmFyLWNvZGUtZGV0ZWN0b3IuanM/YjE2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBRcmNvZGVSZXN1bHRGb3JtYXQsIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyB9IGZyb20gXCIuL2NvcmVcIjtcbnZhciBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFyY29kZURldGVjdG9yRGVsZWdhdGUocmVxdWVzdGVkRm9ybWF0cywgdmVyYm9zZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0TWFwID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlFSX0NPREUsIFwicXJfY29kZVwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQVpURUMsIFwiYXp0ZWNcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREFCQVIsIFwiY29kYWJhclwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8zOSwgXCJjb2RlXzM5XCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5DT0RFXzkzLCBcImNvZGVfOTNcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkNPREVfMTI4LCBcImNvZGVfMTI4XCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5EQVRBX01BVFJJWCwgXCJkYXRhX21hdHJpeFwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuSVRGLCBcIml0ZlwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzEzLCBcImVhbl8xM1wiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuRUFOXzgsIFwiZWFuXzhcIl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlBERl80MTcsIFwicGRmNDE3XCJdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfQSwgXCJ1cGNfYVwiXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0UsIFwidXBjX2VcIl1cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMucmV2ZXJzZUZvcm1hdE1hcCA9IHRoaXMuY3JlYXRlUmV2ZXJzZUZvcm1hdE1hcCgpO1xuICAgICAgICBpZiAoIUJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IFwiVXNlIGh0bWw1cXJjb2RlLm1pbi5qcyB3aXRob3V0IGVkaXQsIFVzZSBcIlxuICAgICAgICAgICAgICAgICsgXCJCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSBvbmx5IGlmIGl0IGlzU3VwcG9ydGVkKCk7XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5jcmVhdGVCYXJjb2RlRGV0ZWN0b3JGb3JtYXRzKHJlcXVlc3RlZEZvcm1hdHMpO1xuICAgICAgICB0aGlzLmRldGVjdG9yID0gbmV3IEJhcmNvZGVEZXRlY3Rvcihmb3JtYXRzKTtcbiAgICAgICAgaWYgKCF0aGlzLmRldGVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkJhcmNvZGVEZXRlY3RvciBkZXRlY3RvciBub3Qgc3VwcG9ydGVkXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghKFwiQmFyY29kZURldGVjdG9yXCIgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdW1teURldGVjdG9yID0gbmV3IEJhcmNvZGVEZXRlY3Rvcih7IGZvcm1hdHM6IFtcInFyX2NvZGVcIl0gfSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZHVtbXlEZXRlY3RvciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9O1xuICAgIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLnByb3RvdHlwZS5kZWNvZGVBc3luYyA9IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhcmNvZGVzLCBsYXJnZXN0QmFyY29kZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLmRldGVjdG9yLmRldGVjdChjYW52YXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhcmNvZGVzIHx8IGJhcmNvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiTm8gYmFyY29kZSBvciBRUiBjb2RlIGRldGVjdGVkLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFyZ2VzdEJhcmNvZGUgPSB0aGlzLnNlbGVjdExhcmdlc3RCYXJjb2RlKGJhcmNvZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYXJnZXN0QmFyY29kZS5yYXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBRcmNvZGVSZXN1bHRGb3JtYXQuY3JlYXRlKHRoaXMudG9IdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMobGFyZ2VzdEJhcmNvZGUuZm9ybWF0KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnRGF0YTogdGhpcy5jcmVhdGVEZWJ1Z0RhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhcmNvZGVEZXRlY3RvckRlbGVnYXRlLnByb3RvdHlwZS5zZWxlY3RMYXJnZXN0QmFyY29kZSA9IGZ1bmN0aW9uIChiYXJjb2Rlcykge1xuICAgICAgICB2YXIgbGFyZ2VzdEJhcmNvZGUgPSBudWxsO1xuICAgICAgICB2YXIgbWF4QXJlYSA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYmFyY29kZXNfMSA9IGJhcmNvZGVzOyBfaSA8IGJhcmNvZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyY29kZSA9IGJhcmNvZGVzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGFyZWEgPSBiYXJjb2RlLmJvdW5kaW5nQm94LndpZHRoICogYmFyY29kZS5ib3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICBsYXJnZXN0QmFyY29kZSA9IGJhcmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXJnZXN0QmFyY29kZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJObyBsYXJnZXN0IGJhcmNvZGUgZm91bmRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFyZ2VzdEJhcmNvZGU7XG4gICAgfTtcbiAgICBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZS5wcm90b3R5cGUuY3JlYXRlQmFyY29kZURldGVjdG9yRm9ybWF0cyA9IGZ1bmN0aW9uIChyZXF1ZXN0ZWRGb3JtYXRzKSB7XG4gICAgICAgIHZhciBmb3JtYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcmVxdWVzdGVkRm9ybWF0c18xID0gcmVxdWVzdGVkRm9ybWF0czsgX2kgPCByZXF1ZXN0ZWRGb3JtYXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdGVkRm9ybWF0ID0gcmVxdWVzdGVkRm9ybWF0c18xW19pXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdE1hcC5oYXMocmVxdWVzdGVkRm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMucHVzaCh0aGlzLmZvcm1hdE1hcC5nZXQocmVxdWVzdGVkRm9ybWF0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiXCIuY29uY2F0KHJlcXVlc3RlZEZvcm1hdCwgXCIgaXMgbm90IHN1cHBvcnRlZCBieVwiKVxuICAgICAgICAgICAgICAgICAgICArIFwiQmFyY29kZURldGVjdG9yRGVsZWdhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybWF0czogZm9ybWF0cyB9O1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLnRvSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzID0gZnVuY3Rpb24gKGJhcmNvZGVEZXRlY3RvckZvcm1hdCkge1xuICAgICAgICBpZiAoIXRoaXMucmV2ZXJzZUZvcm1hdE1hcC5oYXMoYmFyY29kZURldGVjdG9yRm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgXCJyZXZlcnNlRm9ybWF0TWFwIGRvZXNuJ3QgaGF2ZSBcIi5jb25jYXQoYmFyY29kZURldGVjdG9yRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlRm9ybWF0TWFwLmdldChiYXJjb2RlRGV0ZWN0b3JGb3JtYXQpO1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLmNyZWF0ZVJldmVyc2VGb3JtYXRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZm9ybWF0TWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXksIF8pIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQmFyY29kZURldGVjdG9yRGVsZWdhdGUucHJvdG90eXBlLmNyZWF0ZURlYnVnRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgZGVjb2Rlck5hbWU6IFwiQmFyY29kZURldGVjdG9yXCIgfTtcbiAgICB9O1xuICAgIHJldHVybiBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZTtcbn0oKSk7XG5leHBvcnQgeyBCYXJjb2RlRGV0ZWN0b3JEZWxlZ2F0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF0aXZlLWJhci1jb2RlLWRldGVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/native-bar-code-detector.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/state-manager.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/state-manager.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScannerState: () => (/* binding */ Html5QrcodeScannerState),\n/* harmony export */   StateManagerFactory: () => (/* binding */ StateManagerFactory),\n/* harmony export */   StateManagerProxy: () => (/* binding */ StateManagerProxy)\n/* harmony export */ });\nvar Html5QrcodeScannerState;\n(function (Html5QrcodeScannerState) {\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"NOT_STARTED\"] = 1] = \"NOT_STARTED\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"SCANNING\"] = 2] = \"SCANNING\";\n    Html5QrcodeScannerState[Html5QrcodeScannerState[\"PAUSED\"] = 3] = \"PAUSED\";\n})(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));\nvar StateManagerImpl = (function () {\n    function StateManagerImpl() {\n        this.state = Html5QrcodeScannerState.NOT_STARTED;\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n    }\n    StateManagerImpl.prototype.directTransition = function (newState) {\n        this.failIfTransitionOngoing();\n        this.validateTransition(newState);\n        this.state = newState;\n    };\n    StateManagerImpl.prototype.startTransition = function (newState) {\n        this.failIfTransitionOngoing();\n        this.validateTransition(newState);\n        this.onGoingTransactionNewState = newState;\n        return this;\n    };\n    StateManagerImpl.prototype.execute = function () {\n        if (this.onGoingTransactionNewState\n            === Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Transaction is already cancelled, cannot execute().\";\n        }\n        var tempNewState = this.onGoingTransactionNewState;\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n        this.directTransition(tempNewState);\n    };\n    StateManagerImpl.prototype.cancel = function () {\n        if (this.onGoingTransactionNewState\n            === Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Transaction is already cancelled, cannot cancel().\";\n        }\n        this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;\n    };\n    StateManagerImpl.prototype.getState = function () {\n        return this.state;\n    };\n    StateManagerImpl.prototype.failIfTransitionOngoing = function () {\n        if (this.onGoingTransactionNewState\n            !== Html5QrcodeScannerState.UNKNOWN) {\n            throw \"Cannot transition to a new state, already under transition\";\n        }\n    };\n    StateManagerImpl.prototype.validateTransition = function (newState) {\n        switch (this.state) {\n            case Html5QrcodeScannerState.UNKNOWN:\n                throw \"Transition from unknown is not allowed\";\n            case Html5QrcodeScannerState.NOT_STARTED:\n                this.failIfNewStateIs(newState, [Html5QrcodeScannerState.PAUSED]);\n                break;\n            case Html5QrcodeScannerState.SCANNING:\n                break;\n            case Html5QrcodeScannerState.PAUSED:\n                break;\n        }\n    };\n    StateManagerImpl.prototype.failIfNewStateIs = function (newState, disallowedStatesToTransition) {\n        for (var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++) {\n            var disallowedState = disallowedStatesToTransition_1[_i];\n            if (newState === disallowedState) {\n                throw \"Cannot transition from \".concat(this.state, \" to \").concat(newState);\n            }\n        }\n    };\n    return StateManagerImpl;\n}());\nvar StateManagerProxy = (function () {\n    function StateManagerProxy(stateManager) {\n        this.stateManager = stateManager;\n    }\n    StateManagerProxy.prototype.startTransition = function (newState) {\n        return this.stateManager.startTransition(newState);\n    };\n    StateManagerProxy.prototype.directTransition = function (newState) {\n        this.stateManager.directTransition(newState);\n    };\n    StateManagerProxy.prototype.getState = function () {\n        return this.stateManager.getState();\n    };\n    StateManagerProxy.prototype.canScanFile = function () {\n        return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;\n    };\n    StateManagerProxy.prototype.isScanning = function () {\n        return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;\n    };\n    StateManagerProxy.prototype.isStrictlyScanning = function () {\n        return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;\n    };\n    StateManagerProxy.prototype.isPaused = function () {\n        return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;\n    };\n    return StateManagerProxy;\n}());\n\nvar StateManagerFactory = (function () {\n    function StateManagerFactory() {\n    }\n    StateManagerFactory.create = function () {\n        return new StateManagerProxy(new StateManagerImpl());\n    };\n    return StateManagerFactory;\n}());\n\n//# sourceMappingURL=state-manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vc3RhdGUtbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3N0YXRlLW1hbmFnZXIuanM/MjE0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlO1xuKGZ1bmN0aW9uIChIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZSkge1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbSHRtbDVRcmNvZGVTY2FubmVyU3RhdGVbXCJOT1RfU1RBUlRFRFwiXSA9IDFdID0gXCJOT1RfU1RBUlRFRFwiO1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXRlW1wiU0NBTk5JTkdcIl0gPSAyXSA9IFwiU0NBTk5JTkdcIjtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZVtIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZVtcIlBBVVNFRFwiXSA9IDNdID0gXCJQQVVTRURcIjtcbn0pKEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlIHx8IChIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZSA9IHt9KSk7XG52YXIgU3RhdGVNYW5hZ2VySW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVNYW5hZ2VySW1wbCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLk5PVF9TVEFSVEVEO1xuICAgICAgICB0aGlzLm9uR29pbmdUcmFuc2FjdGlvbk5ld1N0YXRlID0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuVU5LTk9XTjtcbiAgICB9XG4gICAgU3RhdGVNYW5hZ2VySW1wbC5wcm90b3R5cGUuZGlyZWN0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLmZhaWxJZlRyYW5zaXRpb25PbmdvaW5nKCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVUcmFuc2l0aW9uKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VySW1wbC5wcm90b3R5cGUuc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZmFpbElmVHJhbnNpdGlvbk9uZ29pbmcoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVRyYW5zaXRpb24obmV3U3RhdGUpO1xuICAgICAgICB0aGlzLm9uR29pbmdUcmFuc2FjdGlvbk5ld1N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VySW1wbC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGVcbiAgICAgICAgICAgID09PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlRyYW5zYWN0aW9uIGlzIGFscmVhZHkgY2FuY2VsbGVkLCBjYW5ub3QgZXhlY3V0ZSgpLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wTmV3U3RhdGUgPSB0aGlzLm9uR29pbmdUcmFuc2FjdGlvbk5ld1N0YXRlO1xuICAgICAgICB0aGlzLm9uR29pbmdUcmFuc2FjdGlvbk5ld1N0YXRlID0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuVU5LTk9XTjtcbiAgICAgICAgdGhpcy5kaXJlY3RUcmFuc2l0aW9uKHRlbXBOZXdTdGF0ZSk7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9uR29pbmdUcmFuc2FjdGlvbk5ld1N0YXRlXG4gICAgICAgICAgICA9PT0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuVU5LTk9XTikge1xuICAgICAgICAgICAgdGhyb3cgXCJUcmFuc2FjdGlvbiBpcyBhbHJlYWR5IGNhbmNlbGxlZCwgY2Fubm90IGNhbmNlbCgpLlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Hb2luZ1RyYW5zYWN0aW9uTmV3U3RhdGUgPSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5VTktOT1dOO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VySW1wbC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgIH07XG4gICAgU3RhdGVNYW5hZ2VySW1wbC5wcm90b3R5cGUuZmFpbElmVHJhbnNpdGlvbk9uZ29pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9uR29pbmdUcmFuc2FjdGlvbk5ld1N0YXRlXG4gICAgICAgICAgICAhPT0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuVU5LTk9XTikge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgdHJhbnNpdGlvbiB0byBhIG5ldyBzdGF0ZSwgYWxyZWFkeSB1bmRlciB0cmFuc2l0aW9uXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlckltcGwucHJvdG90eXBlLnZhbGlkYXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuVU5LTk9XTjpcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlRyYW5zaXRpb24gZnJvbSB1bmtub3duIGlzIG5vdCBhbGxvd2VkXCI7XG4gICAgICAgICAgICBjYXNlIEh0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLk5PVF9TVEFSVEVEOlxuICAgICAgICAgICAgICAgIHRoaXMuZmFpbElmTmV3U3RhdGVJcyhuZXdTdGF0ZSwgW0h0bWw1UXJjb2RlU2Nhbm5lclN0YXRlLlBBVVNFRF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5TQ0FOTklORzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuUEFVU0VEOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJJbXBsLnByb3RvdHlwZS5mYWlsSWZOZXdTdGF0ZUlzID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGlzYWxsb3dlZFN0YXRlc1RvVHJhbnNpdGlvbl8xID0gZGlzYWxsb3dlZFN0YXRlc1RvVHJhbnNpdGlvbjsgX2kgPCBkaXNhbGxvd2VkU3RhdGVzVG9UcmFuc2l0aW9uXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlzYWxsb3dlZFN0YXRlID0gZGlzYWxsb3dlZFN0YXRlc1RvVHJhbnNpdGlvbl8xW19pXTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gZGlzYWxsb3dlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgdHJhbnNpdGlvbiBmcm9tIFwiLmNvbmNhdCh0aGlzLnN0YXRlLCBcIiB0byBcIikuY29uY2F0KG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlTWFuYWdlckltcGw7XG59KCkpO1xudmFyIFN0YXRlTWFuYWdlclByb3h5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZU1hbmFnZXJQcm94eShzdGF0ZU1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZU1hbmFnZXIgPSBzdGF0ZU1hbmFnZXI7XG4gICAgfVxuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5zdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVNYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvbihuZXdTdGF0ZSk7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJQcm94eS5wcm90b3R5cGUuZGlyZWN0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlTWFuYWdlci5kaXJlY3RUcmFuc2l0aW9uKG5ld1N0YXRlKTtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJQcm94eS5wcm90b3R5cGUuY2FuU2NhbkZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpID09PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5OT1RfU1RBUlRFRDtcbiAgICB9O1xuICAgIFN0YXRlTWFuYWdlclByb3h5LnByb3RvdHlwZS5pc1NjYW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKSAhPT0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuTk9UX1NUQVJURUQ7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJQcm94eS5wcm90b3R5cGUuaXNTdHJpY3RseVNjYW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKSA9PT0gSHRtbDVRcmNvZGVTY2FubmVyU3RhdGUuU0NBTk5JTkc7XG4gICAgfTtcbiAgICBTdGF0ZU1hbmFnZXJQcm94eS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlTWFuYWdlci5nZXRTdGF0ZSgpID09PSBIdG1sNVFyY29kZVNjYW5uZXJTdGF0ZS5QQVVTRUQ7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYW5hZ2VyUHJveHk7XG59KCkpO1xuZXhwb3J0IHsgU3RhdGVNYW5hZ2VyUHJveHkgfTtcbnZhciBTdGF0ZU1hbmFnZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZU1hbmFnZXJGYWN0b3J5KCkge1xuICAgIH1cbiAgICBTdGF0ZU1hbmFnZXJGYWN0b3J5LmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZU1hbmFnZXJQcm94eShuZXcgU3RhdGVNYW5hZ2VySW1wbCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hbmFnZXJGYWN0b3J5O1xufSgpKTtcbmV4cG9ydCB7IFN0YXRlTWFuYWdlckZhY3RvcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLW1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/state-manager.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/storage.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/storage.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PersistedDataManager: () => (/* binding */ PersistedDataManager)\n/* harmony export */ });\nvar PersistedDataFactory = (function () {\n    function PersistedDataFactory() {\n    }\n    PersistedDataFactory.createDefault = function () {\n        return {\n            hasPermission: false,\n            lastUsedCameraId: null\n        };\n    };\n    return PersistedDataFactory;\n}());\nvar PersistedDataManager = (function () {\n    function PersistedDataManager() {\n        this.data = PersistedDataFactory.createDefault();\n        var data = localStorage.getItem(PersistedDataManager.LOCAL_STORAGE_KEY);\n        if (!data) {\n            this.reset();\n        }\n        else {\n            this.data = JSON.parse(data);\n        }\n    }\n    PersistedDataManager.prototype.hasCameraPermissions = function () {\n        return this.data.hasPermission;\n    };\n    PersistedDataManager.prototype.getLastUsedCameraId = function () {\n        return this.data.lastUsedCameraId;\n    };\n    PersistedDataManager.prototype.setHasPermission = function (hasPermission) {\n        this.data.hasPermission = hasPermission;\n        this.flush();\n    };\n    PersistedDataManager.prototype.setLastUsedCameraId = function (lastUsedCameraId) {\n        this.data.lastUsedCameraId = lastUsedCameraId;\n        this.flush();\n    };\n    PersistedDataManager.prototype.resetLastUsedCameraId = function () {\n        this.data.lastUsedCameraId = null;\n        this.flush();\n    };\n    PersistedDataManager.prototype.reset = function () {\n        this.data = PersistedDataFactory.createDefault();\n        this.flush();\n    };\n    PersistedDataManager.prototype.flush = function () {\n        localStorage.setItem(PersistedDataManager.LOCAL_STORAGE_KEY, JSON.stringify(this.data));\n    };\n    PersistedDataManager.LOCAL_STORAGE_KEY = \"HTML5_QRCODE_DATA\";\n    return PersistedDataManager;\n}());\n\n//# sourceMappingURL=storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS9zdG9yYWdlLmpzP2Q1MzciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBlcnNpc3RlZERhdGFGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJzaXN0ZWREYXRhRmFjdG9yeSgpIHtcbiAgICB9XG4gICAgUGVyc2lzdGVkRGF0YUZhY3RvcnkuY3JlYXRlRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc1Blcm1pc3Npb246IGZhbHNlLFxuICAgICAgICAgICAgbGFzdFVzZWRDYW1lcmFJZDogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFBlcnNpc3RlZERhdGFGYWN0b3J5O1xufSgpKTtcbnZhciBQZXJzaXN0ZWREYXRhTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGVyc2lzdGVkRGF0YU1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFBlcnNpc3RlZERhdGFGYWN0b3J5LmNyZWF0ZURlZmF1bHQoKTtcbiAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShQZXJzaXN0ZWREYXRhTWFuYWdlci5MT0NBTF9TVE9SQUdFX0tFWSk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQZXJzaXN0ZWREYXRhTWFuYWdlci5wcm90b3R5cGUuaGFzQ2FtZXJhUGVybWlzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGFzUGVybWlzc2lvbjtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5nZXRMYXN0VXNlZENhbWVyYUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RVc2VkQ2FtZXJhSWQ7XG4gICAgfTtcbiAgICBQZXJzaXN0ZWREYXRhTWFuYWdlci5wcm90b3R5cGUuc2V0SGFzUGVybWlzc2lvbiA9IGZ1bmN0aW9uIChoYXNQZXJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMuZGF0YS5oYXNQZXJtaXNzaW9uID0gaGFzUGVybWlzc2lvbjtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH07XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIucHJvdG90eXBlLnNldExhc3RVc2VkQ2FtZXJhSWQgPSBmdW5jdGlvbiAobGFzdFVzZWRDYW1lcmFJZCkge1xuICAgICAgICB0aGlzLmRhdGEubGFzdFVzZWRDYW1lcmFJZCA9IGxhc3RVc2VkQ2FtZXJhSWQ7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5yZXNldExhc3RVc2VkQ2FtZXJhSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YS5sYXN0VXNlZENhbWVyYUlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH07XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBQZXJzaXN0ZWREYXRhRmFjdG9yeS5jcmVhdGVEZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlZERhdGFNYW5hZ2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUGVyc2lzdGVkRGF0YU1hbmFnZXIuTE9DQUxfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSkpO1xuICAgIH07XG4gICAgUGVyc2lzdGVkRGF0YU1hbmFnZXIuTE9DQUxfU1RPUkFHRV9LRVkgPSBcIkhUTUw1X1FSQ09ERV9EQVRBXCI7XG4gICAgcmV0dXJuIFBlcnNpc3RlZERhdGFNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydCB7IFBlcnNpc3RlZERhdGFNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/storage.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/strings.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/strings.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Html5QrcodeScannerStrings: () => (/* binding */ Html5QrcodeScannerStrings),\n/* harmony export */   Html5QrcodeStrings: () => (/* binding */ Html5QrcodeStrings),\n/* harmony export */   LibraryInfoStrings: () => (/* binding */ LibraryInfoStrings)\n/* harmony export */ });\nvar Html5QrcodeStrings = (function () {\n    function Html5QrcodeStrings() {\n    }\n    Html5QrcodeStrings.codeParseError = function (exception) {\n        return \"QR code parse error, error = \".concat(exception);\n    };\n    Html5QrcodeStrings.errorGettingUserMedia = function (error) {\n        return \"Error getting userMedia, error = \".concat(error);\n    };\n    Html5QrcodeStrings.onlyDeviceSupportedError = function () {\n        return \"The device doesn't support navigator.mediaDevices , only \"\n            + \"supported cameraIdOrConfig in this case is deviceId parameter \"\n            + \"(string).\";\n    };\n    Html5QrcodeStrings.cameraStreamingNotSupported = function () {\n        return \"Camera streaming not supported by the browser.\";\n    };\n    Html5QrcodeStrings.unableToQuerySupportedDevices = function () {\n        return \"Unable to query supported devices, unknown error.\";\n    };\n    Html5QrcodeStrings.insecureContextCameraQueryError = function () {\n        return \"Camera access is only supported in secure context like https \"\n            + \"or localhost.\";\n    };\n    Html5QrcodeStrings.scannerPaused = function () {\n        return \"Scanner paused\";\n    };\n    return Html5QrcodeStrings;\n}());\n\nvar Html5QrcodeScannerStrings = (function () {\n    function Html5QrcodeScannerStrings() {\n    }\n    Html5QrcodeScannerStrings.scanningStatus = function () {\n        return \"Scanning\";\n    };\n    Html5QrcodeScannerStrings.idleStatus = function () {\n        return \"Idle\";\n    };\n    Html5QrcodeScannerStrings.errorStatus = function () {\n        return \"Error\";\n    };\n    Html5QrcodeScannerStrings.permissionStatus = function () {\n        return \"Permission\";\n    };\n    Html5QrcodeScannerStrings.noCameraFoundErrorStatus = function () {\n        return \"No Cameras\";\n    };\n    Html5QrcodeScannerStrings.lastMatch = function (decodedText) {\n        return \"Last Match: \".concat(decodedText);\n    };\n    Html5QrcodeScannerStrings.codeScannerTitle = function () {\n        return \"Code Scanner\";\n    };\n    Html5QrcodeScannerStrings.cameraPermissionTitle = function () {\n        return \"Request Camera Permissions\";\n    };\n    Html5QrcodeScannerStrings.cameraPermissionRequesting = function () {\n        return \"Requesting camera permissions...\";\n    };\n    Html5QrcodeScannerStrings.noCameraFound = function () {\n        return \"No camera found\";\n    };\n    Html5QrcodeScannerStrings.scanButtonStopScanningText = function () {\n        return \"Stop Scanning\";\n    };\n    Html5QrcodeScannerStrings.scanButtonStartScanningText = function () {\n        return \"Start Scanning\";\n    };\n    Html5QrcodeScannerStrings.torchOnButton = function () {\n        return \"Switch On Torch\";\n    };\n    Html5QrcodeScannerStrings.torchOffButton = function () {\n        return \"Switch Off Torch\";\n    };\n    Html5QrcodeScannerStrings.torchOnFailedMessage = function () {\n        return \"Failed to turn on torch\";\n    };\n    Html5QrcodeScannerStrings.torchOffFailedMessage = function () {\n        return \"Failed to turn off torch\";\n    };\n    Html5QrcodeScannerStrings.scanButtonScanningStarting = function () {\n        return \"Launching Camera...\";\n    };\n    Html5QrcodeScannerStrings.textIfCameraScanSelected = function () {\n        return \"Scan an Image File\";\n    };\n    Html5QrcodeScannerStrings.textIfFileScanSelected = function () {\n        return \"Scan using camera directly\";\n    };\n    Html5QrcodeScannerStrings.selectCamera = function () {\n        return \"Select Camera\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionChooseImage = function () {\n        return \"Choose Image\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionChooseAnother = function () {\n        return \"Choose Another\";\n    };\n    Html5QrcodeScannerStrings.fileSelectionNoImageSelected = function () {\n        return \"No image choosen\";\n    };\n    Html5QrcodeScannerStrings.anonymousCameraPrefix = function () {\n        return \"Anonymous Camera\";\n    };\n    Html5QrcodeScannerStrings.dragAndDropMessage = function () {\n        return \"Or drop an image to scan\";\n    };\n    Html5QrcodeScannerStrings.dragAndDropMessageOnlyImages = function () {\n        return \"Or drop an image to scan (other files not supported)\";\n    };\n    Html5QrcodeScannerStrings.zoom = function () {\n        return \"zoom\";\n    };\n    Html5QrcodeScannerStrings.loadingImage = function () {\n        return \"Loading image...\";\n    };\n    Html5QrcodeScannerStrings.cameraScanAltText = function () {\n        return \"Camera based scan\";\n    };\n    Html5QrcodeScannerStrings.fileScanAltText = function () {\n        return \"Fule based scan\";\n    };\n    return Html5QrcodeScannerStrings;\n}());\n\nvar LibraryInfoStrings = (function () {\n    function LibraryInfoStrings() {\n    }\n    LibraryInfoStrings.poweredBy = function () {\n        return \"Powered by \";\n    };\n    LibraryInfoStrings.reportIssues = function () {\n        return \"Report issues\";\n    };\n    return LibraryInfoStrings;\n}());\n\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3N0cmluZ3MuanM/NWFkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSHRtbDVRcmNvZGVTdHJpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNVFyY29kZVN0cmluZ3MoKSB7XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5jb2RlUGFyc2VFcnJvciA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiUVIgY29kZSBwYXJzZSBlcnJvciwgZXJyb3IgPSBcIi5jb25jYXQoZXhjZXB0aW9uKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5lcnJvckdldHRpbmdVc2VyTWVkaWEgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFwiRXJyb3IgZ2V0dGluZyB1c2VyTWVkaWEsIGVycm9yID0gXCIuY29uY2F0KGVycm9yKTtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU3RyaW5ncy5vbmx5RGV2aWNlU3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlRoZSBkZXZpY2UgZG9lc24ndCBzdXBwb3J0IG5hdmlnYXRvci5tZWRpYURldmljZXMgLCBvbmx5IFwiXG4gICAgICAgICAgICArIFwic3VwcG9ydGVkIGNhbWVyYUlkT3JDb25maWcgaW4gdGhpcyBjYXNlIGlzIGRldmljZUlkIHBhcmFtZXRlciBcIlxuICAgICAgICAgICAgKyBcIihzdHJpbmcpLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLmNhbWVyYVN0cmVhbWluZ05vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2FtZXJhIHN0cmVhbWluZyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLnVuYWJsZVRvUXVlcnlTdXBwb3J0ZWREZXZpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJVbmFibGUgdG8gcXVlcnkgc3VwcG9ydGVkIGRldmljZXMsIHVua25vd24gZXJyb3IuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVN0cmluZ3MuaW5zZWN1cmVDb250ZXh0Q2FtZXJhUXVlcnlFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2FtZXJhIGFjY2VzcyBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzZWN1cmUgY29udGV4dCBsaWtlIGh0dHBzIFwiXG4gICAgICAgICAgICArIFwib3IgbG9jYWxob3N0LlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTdHJpbmdzLnNjYW5uZXJQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW5uZXIgcGF1c2VkXCI7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVTdHJpbmdzO1xufSgpKTtcbmV4cG9ydCB7IEh0bWw1UXJjb2RlU3RyaW5ncyB9O1xudmFyIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MoKSB7XG4gICAgfVxuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muc2Nhbm5pbmdTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW5uaW5nXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmlkbGVTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIklkbGVcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZXJyb3JTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkVycm9yXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnBlcm1pc3Npb25TdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlBlcm1pc3Npb25cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZEVycm9yU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJObyBDYW1lcmFzXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmxhc3RNYXRjaCA9IGZ1bmN0aW9uIChkZWNvZGVkVGV4dCkge1xuICAgICAgICByZXR1cm4gXCJMYXN0IE1hdGNoOiBcIi5jb25jYXQoZGVjb2RlZFRleHQpO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jb2RlU2Nhbm5lclRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJDb2RlIFNjYW5uZXJcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhUGVybWlzc2lvblRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXF1ZXN0IENhbWVyYSBQZXJtaXNzaW9uc1wiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5jYW1lcmFQZXJtaXNzaW9uUmVxdWVzdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiUmVxdWVzdGluZyBjYW1lcmEgcGVybWlzc2lvbnMuLi5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Mubm9DYW1lcmFGb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiTm8gY2FtZXJhIGZvdW5kXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TdG9wU2Nhbm5pbmdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTdG9wIFNjYW5uaW5nXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNjYW5CdXR0b25TdGFydFNjYW5uaW5nVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RhcnQgU2Nhbm5pbmdcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPbkJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3dpdGNoIE9uIFRvcmNoXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT2ZmQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTd2l0Y2ggT2ZmIFRvcmNoXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT25GYWlsZWRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJGYWlsZWQgdG8gdHVybiBvbiB0b3JjaFwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9mZkZhaWxlZE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkZhaWxlZCB0byB0dXJuIG9mZiB0b3JjaFwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zY2FuQnV0dG9uU2Nhbm5pbmdTdGFydGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiTGF1bmNoaW5nIENhbWVyYS4uLlwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50ZXh0SWZDYW1lcmFTY2FuU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNjYW4gYW4gSW1hZ2UgRmlsZVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50ZXh0SWZGaWxlU2NhblNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJTY2FuIHVzaW5nIGNhbWVyYSBkaXJlY3RseVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5zZWxlY3RDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNlbGVjdCBDYW1lcmFcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJDaG9vc2UgSW1hZ2VcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUFub3RoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkNob29zZSBBbm90aGVyXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTZWxlY3Rpb25Ob0ltYWdlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk5vIGltYWdlIGNob29zZW5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuYW5vbnltb3VzQ2FtZXJhUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJBbm9ueW1vdXMgQ2FtZXJhXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmRyYWdBbmREcm9wTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiT3IgZHJvcCBhbiBpbWFnZSB0byBzY2FuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmRyYWdBbmREcm9wTWVzc2FnZU9ubHlJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk9yIGRyb3AgYW4gaW1hZ2UgdG8gc2NhbiAob3RoZXIgZmlsZXMgbm90IHN1cHBvcnRlZClcIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muem9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiem9vbVwiO1xuICAgIH07XG4gICAgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5sb2FkaW5nSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkxvYWRpbmcgaW1hZ2UuLi5cIjtcbiAgICB9O1xuICAgIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuY2FtZXJhU2NhbkFsdFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIkNhbWVyYSBiYXNlZCBzY2FuXCI7XG4gICAgfTtcbiAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmZpbGVTY2FuQWx0VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVsZSBiYXNlZCBzY2FuXCI7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncztcbn0oKSk7XG5leHBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIH07XG52YXIgTGlicmFyeUluZm9TdHJpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaWJyYXJ5SW5mb1N0cmluZ3MoKSB7XG4gICAgfVxuICAgIExpYnJhcnlJbmZvU3RyaW5ncy5wb3dlcmVkQnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlBvd2VyZWQgYnkgXCI7XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb1N0cmluZ3MucmVwb3J0SXNzdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXBvcnQgaXNzdWVzXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9TdHJpbmdzO1xufSgpKTtcbmV4cG9ydCB7IExpYnJhcnlJbmZvU3RyaW5ncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/strings.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/ui.js":
/*!****************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/ui.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LibraryInfoContainer: () => (/* binding */ LibraryInfoContainer)\n/* harmony export */ });\n/* harmony import */ var _image_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-assets */ \"../../../node_modules/html5-qrcode/esm/image-assets.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar LibraryInfoDiv = (function () {\n    function LibraryInfoDiv() {\n        this.infoDiv = document.createElement(\"div\");\n    }\n    LibraryInfoDiv.prototype.renderInto = function (parent) {\n        this.infoDiv.style.position = \"absolute\";\n        this.infoDiv.style.top = \"10px\";\n        this.infoDiv.style.right = \"10px\";\n        this.infoDiv.style.zIndex = \"2\";\n        this.infoDiv.style.display = \"none\";\n        this.infoDiv.style.padding = \"5pt\";\n        this.infoDiv.style.border = \"1px solid #171717\";\n        this.infoDiv.style.fontSize = \"10pt\";\n        this.infoDiv.style.background = \"rgb(0 0 0 / 69%)\";\n        this.infoDiv.style.borderRadius = \"5px\";\n        this.infoDiv.style.textAlign = \"center\";\n        this.infoDiv.style.fontWeight = \"400\";\n        this.infoDiv.style.color = \"white\";\n        this.infoDiv.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.LibraryInfoStrings.poweredBy();\n        var projectLink = document.createElement(\"a\");\n        projectLink.innerText = \"ScanApp\";\n        projectLink.href = \"https://scanapp.org\";\n        projectLink.target = \"new\";\n        projectLink.style.color = \"white\";\n        this.infoDiv.appendChild(projectLink);\n        var breakElemFirst = document.createElement(\"br\");\n        var breakElemSecond = document.createElement(\"br\");\n        this.infoDiv.appendChild(breakElemFirst);\n        this.infoDiv.appendChild(breakElemSecond);\n        var reportIssueLink = document.createElement(\"a\");\n        reportIssueLink.innerText = _strings__WEBPACK_IMPORTED_MODULE_1__.LibraryInfoStrings.reportIssues();\n        reportIssueLink.href = \"https://github.com/mebjas/html5-qrcode/issues\";\n        reportIssueLink.target = \"new\";\n        reportIssueLink.style.color = \"white\";\n        this.infoDiv.appendChild(reportIssueLink);\n        parent.appendChild(this.infoDiv);\n    };\n    LibraryInfoDiv.prototype.show = function () {\n        this.infoDiv.style.display = \"block\";\n    };\n    LibraryInfoDiv.prototype.hide = function () {\n        this.infoDiv.style.display = \"none\";\n    };\n    return LibraryInfoDiv;\n}());\nvar LibraryInfoIcon = (function () {\n    function LibraryInfoIcon(onTapIn, onTapOut) {\n        this.isShowingInfoIcon = true;\n        this.onTapIn = onTapIn;\n        this.onTapOut = onTapOut;\n        this.infoIcon = document.createElement(\"img\");\n    }\n    LibraryInfoIcon.prototype.renderInto = function (parent) {\n        var _this = this;\n        this.infoIcon.alt = \"Info icon\";\n        this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_INFO_ICON_16PX;\n        this.infoIcon.style.position = \"absolute\";\n        this.infoIcon.style.top = \"4px\";\n        this.infoIcon.style.right = \"4px\";\n        this.infoIcon.style.opacity = \"0.6\";\n        this.infoIcon.style.cursor = \"pointer\";\n        this.infoIcon.style.zIndex = \"2\";\n        this.infoIcon.style.width = \"16px\";\n        this.infoIcon.style.height = \"16px\";\n        this.infoIcon.onmouseover = function (_) { return _this.onHoverIn(); };\n        this.infoIcon.onmouseout = function (_) { return _this.onHoverOut(); };\n        this.infoIcon.onclick = function (_) { return _this.onClick(); };\n        parent.appendChild(this.infoIcon);\n    };\n    LibraryInfoIcon.prototype.onHoverIn = function () {\n        if (this.isShowingInfoIcon) {\n            this.infoIcon.style.opacity = \"1\";\n        }\n    };\n    LibraryInfoIcon.prototype.onHoverOut = function () {\n        if (this.isShowingInfoIcon) {\n            this.infoIcon.style.opacity = \"0.6\";\n        }\n    };\n    LibraryInfoIcon.prototype.onClick = function () {\n        if (this.isShowingInfoIcon) {\n            this.isShowingInfoIcon = false;\n            this.onTapIn();\n            this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_CLOSE_ICON_16PX;\n            this.infoIcon.style.opacity = \"1\";\n        }\n        else {\n            this.isShowingInfoIcon = true;\n            this.onTapOut();\n            this.infoIcon.src = _image_assets__WEBPACK_IMPORTED_MODULE_0__.ASSET_INFO_ICON_16PX;\n            this.infoIcon.style.opacity = \"0.6\";\n        }\n    };\n    return LibraryInfoIcon;\n}());\nvar LibraryInfoContainer = (function () {\n    function LibraryInfoContainer() {\n        var _this = this;\n        this.infoDiv = new LibraryInfoDiv();\n        this.infoIcon = new LibraryInfoIcon(function () {\n            _this.infoDiv.show();\n        }, function () {\n            _this.infoDiv.hide();\n        });\n    }\n    LibraryInfoContainer.prototype.renderInto = function (parent) {\n        this.infoDiv.renderInto(parent);\n        this.infoIcon.renderInto(parent);\n    };\n    return LibraryInfoContainer;\n}());\n\n//# sourceMappingURL=ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS5qcz9mNzZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFTU0VUX0NMT1NFX0lDT05fMTZQWCwgQVNTRVRfSU5GT19JQ09OXzE2UFggfSBmcm9tIFwiLi9pbWFnZS1hc3NldHNcIjtcbmltcG9ydCB7IExpYnJhcnlJbmZvU3RyaW5ncyB9IGZyb20gXCIuL3N0cmluZ3NcIjtcbnZhciBMaWJyYXJ5SW5mb0RpdiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlicmFyeUluZm9EaXYoKSB7XG4gICAgICAgIHRoaXMuaW5mb0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfVxuICAgIExpYnJhcnlJbmZvRGl2LnByb3RvdHlwZS5yZW5kZXJJbnRvID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS50b3AgPSBcIjEwcHhcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLnJpZ2h0ID0gXCIxMHB4XCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS56SW5kZXggPSBcIjJcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLnBhZGRpbmcgPSBcIjVwdFwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgIzE3MTcxN1wiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuZm9udFNpemUgPSBcIjEwcHRcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmJhY2tncm91bmQgPSBcInJnYigwIDAgMCAvIDY5JSlcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnN0eWxlLmJvcmRlclJhZGl1cyA9IFwiNXB4XCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuc3R5bGUuZm9udFdlaWdodCA9IFwiNDAwXCI7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LmlubmVyVGV4dCA9IExpYnJhcnlJbmZvU3RyaW5ncy5wb3dlcmVkQnkoKTtcbiAgICAgICAgdmFyIHByb2plY3RMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHByb2plY3RMaW5rLmlubmVyVGV4dCA9IFwiU2NhbkFwcFwiO1xuICAgICAgICBwcm9qZWN0TGluay5ocmVmID0gXCJodHRwczovL3NjYW5hcHAub3JnXCI7XG4gICAgICAgIHByb2plY3RMaW5rLnRhcmdldCA9IFwibmV3XCI7XG4gICAgICAgIHByb2plY3RMaW5rLnN0eWxlLmNvbG9yID0gXCJ3aGl0ZVwiO1xuICAgICAgICB0aGlzLmluZm9EaXYuYXBwZW5kQ2hpbGQocHJvamVjdExpbmspO1xuICAgICAgICB2YXIgYnJlYWtFbGVtRmlyc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIHZhciBicmVha0VsZW1TZWNvbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5hcHBlbmRDaGlsZChicmVha0VsZW1GaXJzdCk7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5hcHBlbmRDaGlsZChicmVha0VsZW1TZWNvbmQpO1xuICAgICAgICB2YXIgcmVwb3J0SXNzdWVMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIHJlcG9ydElzc3VlTGluay5pbm5lclRleHQgPSBMaWJyYXJ5SW5mb1N0cmluZ3MucmVwb3J0SXNzdWVzKCk7XG4gICAgICAgIHJlcG9ydElzc3VlTGluay5ocmVmID0gXCJodHRwczovL2dpdGh1Yi5jb20vbWViamFzL2h0bWw1LXFyY29kZS9pc3N1ZXNcIjtcbiAgICAgICAgcmVwb3J0SXNzdWVMaW5rLnRhcmdldCA9IFwibmV3XCI7XG4gICAgICAgIHJlcG9ydElzc3VlTGluay5zdHlsZS5jb2xvciA9IFwid2hpdGVcIjtcbiAgICAgICAgdGhpcy5pbmZvRGl2LmFwcGVuZENoaWxkKHJlcG9ydElzc3VlTGluayk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmluZm9EaXYpO1xuICAgIH07XG4gICAgTGlicmFyeUluZm9EaXYucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH07XG4gICAgTGlicmFyeUluZm9EaXYucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5mb0Rpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9EaXY7XG59KCkpO1xudmFyIExpYnJhcnlJbmZvSWNvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlicmFyeUluZm9JY29uKG9uVGFwSW4sIG9uVGFwT3V0KSB7XG4gICAgICAgIHRoaXMuaXNTaG93aW5nSW5mb0ljb24gPSB0cnVlO1xuICAgICAgICB0aGlzLm9uVGFwSW4gPSBvblRhcEluO1xuICAgICAgICB0aGlzLm9uVGFwT3V0ID0gb25UYXBPdXQ7XG4gICAgICAgIHRoaXMuaW5mb0ljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIH1cbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLnJlbmRlckludG8gPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mb0ljb24uYWx0ID0gXCJJbmZvIGljb25cIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zcmMgPSBBU1NFVF9JTkZPX0lDT05fMTZQWDtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS50b3AgPSBcIjRweFwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLnJpZ2h0ID0gXCI0cHhcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5vcGFjaXR5ID0gXCIwLjZcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS56SW5kZXggPSBcIjJcIjtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS53aWR0aCA9IFwiMTZweFwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLmhlaWdodCA9IFwiMTZweFwiO1xuICAgICAgICB0aGlzLmluZm9JY29uLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLm9uSG92ZXJJbigpOyB9O1xuICAgICAgICB0aGlzLmluZm9JY29uLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMub25Ib3Zlck91dCgpOyB9O1xuICAgICAgICB0aGlzLmluZm9JY29uLm9uY2xpY2sgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gX3RoaXMub25DbGljaygpOyB9O1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5pbmZvSWNvbik7XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLm9uSG92ZXJJbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93aW5nSW5mb0ljb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLm9uSG92ZXJPdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd2luZ0luZm9JY29uKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLm9wYWNpdHkgPSBcIjAuNlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaWJyYXJ5SW5mb0ljb24ucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd2luZ0luZm9JY29uKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2hvd2luZ0luZm9JY29uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uVGFwSW4oKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3JjID0gQVNTRVRfQ0xPU0VfSUNPTl8xNlBYO1xuICAgICAgICAgICAgdGhpcy5pbmZvSWNvbi5zdHlsZS5vcGFjaXR5ID0gXCIxXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzU2hvd2luZ0luZm9JY29uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub25UYXBPdXQoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0ljb24uc3JjID0gQVNTRVRfSU5GT19JQ09OXzE2UFg7XG4gICAgICAgICAgICB0aGlzLmluZm9JY29uLnN0eWxlLm9wYWNpdHkgPSBcIjAuNlwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9JY29uO1xufSgpKTtcbnZhciBMaWJyYXJ5SW5mb0NvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlicmFyeUluZm9Db250YWluZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mb0RpdiA9IG5ldyBMaWJyYXJ5SW5mb0RpdigpO1xuICAgICAgICB0aGlzLmluZm9JY29uID0gbmV3IExpYnJhcnlJbmZvSWNvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbmZvRGl2LnNob3coKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW5mb0Rpdi5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBMaWJyYXJ5SW5mb0NvbnRhaW5lci5wcm90b3R5cGUucmVuZGVySW50byA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5pbmZvRGl2LnJlbmRlckludG8ocGFyZW50KTtcbiAgICAgICAgdGhpcy5pbmZvSWNvbi5yZW5kZXJJbnRvKHBhcmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlicmFyeUluZm9Db250YWluZXI7XG59KCkpO1xuZXhwb3J0IHsgTGlicmFyeUluZm9Db250YWluZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/ui.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/ui/scanner/base.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/ui/scanner/base.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseUiElementFactory: () => (/* binding */ BaseUiElementFactory),\n/* harmony export */   PublicUiElementIdAndClasses: () => (/* binding */ PublicUiElementIdAndClasses)\n/* harmony export */ });\nvar PublicUiElementIdAndClasses = (function () {\n    function PublicUiElementIdAndClasses() {\n    }\n    PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS = \"html5-qrcode-element\";\n    PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID = \"html5-qrcode-button-camera-permission\";\n    PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID = \"html5-qrcode-button-camera-start\";\n    PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID = \"html5-qrcode-button-camera-stop\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_ID = \"html5-qrcode-button-torch\";\n    PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID = \"html5-qrcode-select-camera\";\n    PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID = \"html5-qrcode-button-file-selection\";\n    PublicUiElementIdAndClasses.ZOOM_SLIDER_ID = \"html5-qrcode-input-range-zoom\";\n    PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID = \"html5-qrcode-anchor-scan-type-change\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON = \"html5-qrcode-button-torch-on\";\n    PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF = \"html5-qrcode-button-torch-off\";\n    return PublicUiElementIdAndClasses;\n}());\n\nvar BaseUiElementFactory = (function () {\n    function BaseUiElementFactory() {\n    }\n    BaseUiElementFactory.createElement = function (elementType, elementId) {\n        var element = (document.createElement(elementType));\n        element.id = elementId;\n        element.classList.add(PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS);\n        if (elementType === \"button\") {\n            element.setAttribute(\"type\", \"button\");\n        }\n        return element;\n    };\n    return BaseUiElementFactory;\n}());\n\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9iYXNlLmpzP2Y3NDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3NlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzKCkge1xuICAgIH1cbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQUxMX0VMRU1FTlRfQ0xBU1MgPSBcImh0bWw1LXFyY29kZS1lbGVtZW50XCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9QRVJNSVNTSU9OX0JVVFRPTl9JRCA9IFwiaHRtbDUtcXJjb2RlLWJ1dHRvbi1jYW1lcmEtcGVybWlzc2lvblwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5DQU1FUkFfU1RBUlRfQlVUVE9OX0lEID0gXCJodG1sNS1xcmNvZGUtYnV0dG9uLWNhbWVyYS1zdGFydFwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5DQU1FUkFfU1RPUF9CVVRUT05fSUQgPSBcImh0bWw1LXFyY29kZS1idXR0b24tY2FtZXJhLXN0b3BcIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuVE9SQ0hfQlVUVE9OX0lEID0gXCJodG1sNS1xcmNvZGUtYnV0dG9uLXRvcmNoXCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkNBTUVSQV9TRUxFQ1RJT05fU0VMRUNUX0lEID0gXCJodG1sNS1xcmNvZGUtc2VsZWN0LWNhbWVyYVwiO1xuICAgIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5GSUxFX1NFTEVDVElPTl9CVVRUT05fSUQgPSBcImh0bWw1LXFyY29kZS1idXR0b24tZmlsZS1zZWxlY3Rpb25cIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuWk9PTV9TTElERVJfSUQgPSBcImh0bWw1LXFyY29kZS1pbnB1dC1yYW5nZS16b29tXCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlNDQU5fVFlQRV9DSEFOR0VfQU5DSE9SX0lEID0gXCJodG1sNS1xcmNvZGUtYW5jaG9yLXNjYW4tdHlwZS1jaGFuZ2VcIjtcbiAgICBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuVE9SQ0hfQlVUVE9OX0NMQVNTX1RPUkNIX09OID0gXCJodG1sNS1xcmNvZGUtYnV0dG9uLXRvcmNoLW9uXCI7XG4gICAgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PRkYgPSBcImh0bWw1LXFyY29kZS1idXR0b24tdG9yY2gtb2ZmXCI7XG4gICAgcmV0dXJuIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcztcbn0oKSk7XG5leHBvcnQgeyBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMgfTtcbnZhciBCYXNlVWlFbGVtZW50RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVVpRWxlbWVudEZhY3RvcnkoKSB7XG4gICAgfVxuICAgIEJhc2VVaUVsZW1lbnRGYWN0b3J5LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudFR5cGUsIGVsZW1lbnRJZCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IChkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKSk7XG4gICAgICAgIGVsZW1lbnQuaWQgPSBlbGVtZW50SWQ7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMuQUxMX0VMRU1FTlRfQ0xBU1MpO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFwiYnV0dG9uXCIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlVWlFbGVtZW50RmFjdG9yeTtcbn0oKSk7XG5leHBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/ui/scanner/base.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSelectionUi: () => (/* binding */ CameraSelectionUi)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar CameraSelectionUi = (function () {\n    function CameraSelectionUi(cameras) {\n        this.selectElement = _base__WEBPACK_IMPORTED_MODULE_0__.BaseUiElementFactory\n            .createElement(\"select\", _base__WEBPACK_IMPORTED_MODULE_0__.PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID);\n        this.cameras = cameras;\n        this.options = [];\n    }\n    CameraSelectionUi.prototype.render = function (parentElement) {\n        var cameraSelectionContainer = document.createElement(\"span\");\n        cameraSelectionContainer.style.marginRight = \"10px\";\n        var numCameras = this.cameras.length;\n        if (numCameras === 0) {\n            throw new Error(\"No cameras found\");\n        }\n        if (numCameras === 1) {\n            cameraSelectionContainer.style.display = \"none\";\n        }\n        else {\n            var selectCameraString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.selectCamera();\n            cameraSelectionContainer.innerText\n                = \"\".concat(selectCameraString, \" (\").concat(this.cameras.length, \")  \");\n        }\n        var anonymousCameraId = 1;\n        for (var _i = 0, _a = this.cameras; _i < _a.length; _i++) {\n            var camera = _a[_i];\n            var value = camera.id;\n            var name_1 = camera.label == null ? value : camera.label;\n            if (!name_1 || name_1 === \"\") {\n                name_1 = [\n                    _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.anonymousCameraPrefix(),\n                    anonymousCameraId++\n                ].join(\" \");\n            }\n            var option = document.createElement(\"option\");\n            option.value = value;\n            option.innerText = name_1;\n            this.options.push(option);\n            this.selectElement.appendChild(option);\n        }\n        cameraSelectionContainer.appendChild(this.selectElement);\n        parentElement.appendChild(cameraSelectionContainer);\n    };\n    CameraSelectionUi.prototype.disable = function () {\n        this.selectElement.disabled = true;\n    };\n    CameraSelectionUi.prototype.isDisabled = function () {\n        return this.selectElement.disabled === true;\n    };\n    CameraSelectionUi.prototype.enable = function () {\n        this.selectElement.disabled = false;\n    };\n    CameraSelectionUi.prototype.getValue = function () {\n        return this.selectElement.value;\n    };\n    CameraSelectionUi.prototype.hasValue = function (value) {\n        for (var _i = 0, _a = this.options; _i < _a.length; _i++) {\n            var option = _a[_i];\n            if (option.value === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n    CameraSelectionUi.prototype.setValue = function (value) {\n        if (!this.hasValue(value)) {\n            throw new Error(\"\".concat(value, \" is not present in the camera list.\"));\n        }\n        this.selectElement.value = value;\n    };\n    CameraSelectionUi.prototype.hasSingleItem = function () {\n        return this.cameras.length === 1;\n    };\n    CameraSelectionUi.prototype.numCameras = function () {\n        return this.cameras.length;\n    };\n    CameraSelectionUi.create = function (parentElement, cameras) {\n        var cameraSelectUi = new CameraSelectionUi(cameras);\n        cameraSelectUi.render(parentElement);\n        return cameraSelectUi;\n    };\n    return CameraSelectionUi;\n}());\n\n//# sourceMappingURL=camera-selection-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9jYW1lcmEtc2VsZWN0aW9uLXVpLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL2NhbWVyYS1zZWxlY3Rpb24tdWkuanM/ZDlmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIH0gZnJvbSBcIi4vYmFzZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyB9IGZyb20gXCIuLi8uLi9zdHJpbmdzXCI7XG52YXIgQ2FtZXJhU2VsZWN0aW9uVWkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbWVyYVNlbGVjdGlvblVpKGNhbWVyYXMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50ID0gQmFzZVVpRWxlbWVudEZhY3RvcnlcbiAgICAgICAgICAgIC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5DQU1FUkFfU0VMRUNUSU9OX1NFTEVDVF9JRCk7XG4gICAgICAgIHRoaXMuY2FtZXJhcyA9IGNhbWVyYXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBjYW1lcmFTZWxlY3Rpb25Db250YWluZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjEwcHhcIjtcbiAgICAgICAgdmFyIG51bUNhbWVyYXMgPSB0aGlzLmNhbWVyYXMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQ2FtZXJhcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FtZXJhcyBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtQ2FtZXJhcyA9PT0gMSkge1xuICAgICAgICAgICAgY2FtZXJhU2VsZWN0aW9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RDYW1lcmFTdHJpbmcgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnNlbGVjdENhbWVyYSgpO1xuICAgICAgICAgICAgY2FtZXJhU2VsZWN0aW9uQ29udGFpbmVyLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgID0gXCJcIi5jb25jYXQoc2VsZWN0Q2FtZXJhU3RyaW5nLCBcIiAoXCIpLmNvbmNhdCh0aGlzLmNhbWVyYXMubGVuZ3RoLCBcIikgIFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5vbnltb3VzQ2FtZXJhSWQgPSAxO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jYW1lcmFzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNhbWVyYSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhbWVyYS5pZDtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBjYW1lcmEubGFiZWwgPT0gbnVsbCA/IHZhbHVlIDogY2FtZXJhLmxhYmVsO1xuICAgICAgICAgICAgaWYgKCFuYW1lXzEgfHwgbmFtZV8xID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZV8xID0gW1xuICAgICAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmFub255bW91c0NhbWVyYVByZWZpeCgpLFxuICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXNDYW1lcmFJZCsrXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBvcHRpb24uaW5uZXJUZXh0ID0gbmFtZV8xO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdEVsZW1lbnQpO1xuICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGNhbWVyYVNlbGVjdGlvbkNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLnByb3RvdHlwZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RFbGVtZW50LmRpc2FibGVkID09PSB0cnVlO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEVsZW1lbnQudmFsdWU7XG4gICAgfTtcbiAgICBDYW1lcmFTZWxlY3Rpb25VaS5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMub3B0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENhbWVyYVNlbGVjdGlvblVpLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQodmFsdWUsIFwiIGlzIG5vdCBwcmVzZW50IGluIHRoZSBjYW1lcmEgbGlzdC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLmhhc1NpbmdsZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXMubGVuZ3RoID09PSAxO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkucHJvdG90eXBlLm51bUNhbWVyYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXMubGVuZ3RoO1xuICAgIH07XG4gICAgQ2FtZXJhU2VsZWN0aW9uVWkuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIGNhbWVyYXMpIHtcbiAgICAgICAgdmFyIGNhbWVyYVNlbGVjdFVpID0gbmV3IENhbWVyYVNlbGVjdGlvblVpKGNhbWVyYXMpO1xuICAgICAgICBjYW1lcmFTZWxlY3RVaS5yZW5kZXIocGFyZW50RWxlbWVudCk7XG4gICAgICAgIHJldHVybiBjYW1lcmFTZWxlY3RVaTtcbiAgICB9O1xuICAgIHJldHVybiBDYW1lcmFTZWxlY3Rpb25VaTtcbn0oKSk7XG5leHBvcnQgeyBDYW1lcmFTZWxlY3Rpb25VaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FtZXJhLXNlbGVjdGlvbi11aS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraZoomUi: () => (/* binding */ CameraZoomUi)\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\n\n\nvar CameraZoomUi = (function () {\n    function CameraZoomUi() {\n        this.onChangeCallback = null;\n        this.zoomElementContainer = document.createElement(\"div\");\n        this.rangeInput = _base__WEBPACK_IMPORTED_MODULE_0__.BaseUiElementFactory.createElement(\"input\", _base__WEBPACK_IMPORTED_MODULE_0__.PublicUiElementIdAndClasses.ZOOM_SLIDER_ID);\n        this.rangeInput.type = \"range\";\n        this.rangeText = document.createElement(\"span\");\n        this.rangeInput.min = \"1\";\n        this.rangeInput.max = \"5\";\n        this.rangeInput.value = \"1\";\n        this.rangeInput.step = \"0.1\";\n    }\n    CameraZoomUi.prototype.render = function (parentElement, renderOnCreate) {\n        this.zoomElementContainer.style.display\n            = renderOnCreate ? \"block\" : \"none\";\n        this.zoomElementContainer.style.padding = \"5px 10px\";\n        this.zoomElementContainer.style.textAlign = \"center\";\n        parentElement.appendChild(this.zoomElementContainer);\n        this.rangeInput.style.display = \"inline-block\";\n        this.rangeInput.style.width = \"50%\";\n        this.rangeInput.style.height = \"5px\";\n        this.rangeInput.style.background = \"#d3d3d3\";\n        this.rangeInput.style.outline = \"none\";\n        this.rangeInput.style.opacity = \"0.7\";\n        var zoomString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.zoom();\n        this.rangeText.innerText = \"\".concat(this.rangeInput.value, \"x \").concat(zoomString);\n        this.rangeText.style.marginRight = \"10px\";\n        var $this = this;\n        this.rangeInput.addEventListener(\"input\", function () { return $this.onValueChange(); });\n        this.rangeInput.addEventListener(\"change\", function () { return $this.onValueChange(); });\n        this.zoomElementContainer.appendChild(this.rangeInput);\n        this.zoomElementContainer.appendChild(this.rangeText);\n    };\n    CameraZoomUi.prototype.onValueChange = function () {\n        var zoomString = _strings__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeScannerStrings.zoom();\n        this.rangeText.innerText = \"\".concat(this.rangeInput.value, \"x \").concat(zoomString);\n        if (this.onChangeCallback) {\n            this.onChangeCallback(parseFloat(this.rangeInput.value));\n        }\n    };\n    CameraZoomUi.prototype.setValues = function (minValue, maxValue, defaultValue, step) {\n        this.rangeInput.min = minValue.toString();\n        this.rangeInput.max = maxValue.toString();\n        this.rangeInput.step = step.toString();\n        this.rangeInput.value = defaultValue.toString();\n        this.onValueChange();\n    };\n    CameraZoomUi.prototype.show = function () {\n        this.zoomElementContainer.style.display = \"block\";\n    };\n    CameraZoomUi.prototype.hide = function () {\n        this.zoomElementContainer.style.display = \"none\";\n    };\n    CameraZoomUi.prototype.setOnCameraZoomValueChangeCallback = function (onChangeCallback) {\n        this.onChangeCallback = onChangeCallback;\n    };\n    CameraZoomUi.prototype.removeOnCameraZoomValueChangeCallback = function () {\n        this.onChangeCallback = null;\n    };\n    CameraZoomUi.create = function (parentElement, renderOnCreate) {\n        var cameraZoomUi = new CameraZoomUi();\n        cameraZoomUi.render(parentElement, renderOnCreate);\n        return cameraZoomUi;\n    };\n    return CameraZoomUi;\n}());\n\n//# sourceMappingURL=camera-zoom-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9jYW1lcmEtem9vbS11aS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9odG1sNS1xcmNvZGUvZXNtL3VpL3NjYW5uZXIvY2FtZXJhLXpvb20tdWkuanM/ZTE1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlVWlFbGVtZW50RmFjdG9yeSwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzIH0gZnJvbSBcIi4vYmFzZVwiO1xuaW1wb3J0IHsgSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncyB9IGZyb20gXCIuLi8uLi9zdHJpbmdzXCI7XG52YXIgQ2FtZXJhWm9vbVVpID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW1lcmFab29tVWkoKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQgPSBCYXNlVWlFbGVtZW50RmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlpPT01fU0xJREVSX0lEKTtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnR5cGUgPSBcInJhbmdlXCI7XG4gICAgICAgIHRoaXMucmFuZ2VUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5taW4gPSBcIjFcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0Lm1heCA9IFwiNVwiO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQudmFsdWUgPSBcIjFcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0ZXAgPSBcIjAuMVwiO1xuICAgIH1cbiAgICBDYW1lcmFab29tVWkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCByZW5kZXJPbkNyZWF0ZSkge1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLmRpc3BsYXlcbiAgICAgICAgICAgID0gcmVuZGVyT25DcmVhdGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy56b29tRWxlbWVudENvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gXCI1cHggMTBweFwiO1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy56b29tRWxlbWVudENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0eWxlLndpZHRoID0gXCI1MCVcIjtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnN0eWxlLmhlaWdodCA9IFwiNXB4XCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZDNkM2QzXCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5vdXRsaW5lID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5zdHlsZS5vcGFjaXR5ID0gXCIwLjdcIjtcbiAgICAgICAgdmFyIHpvb21TdHJpbmcgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnpvb20oKTtcbiAgICAgICAgdGhpcy5yYW5nZVRleHQuaW5uZXJUZXh0ID0gXCJcIi5jb25jYXQodGhpcy5yYW5nZUlucHV0LnZhbHVlLCBcInggXCIpLmNvbmNhdCh6b29tU3RyaW5nKTtcbiAgICAgICAgdGhpcy5yYW5nZVRleHQuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjEwcHhcIjtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAkdGhpcy5vblZhbHVlQ2hhbmdlKCk7IH0pO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAkdGhpcy5vblZhbHVlQ2hhbmdlKCk7IH0pO1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmFuZ2VJbnB1dCk7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yYW5nZVRleHQpO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgem9vbVN0cmluZyA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3Muem9vbSgpO1xuICAgICAgICB0aGlzLnJhbmdlVGV4dC5pbm5lclRleHQgPSBcIlwiLmNvbmNhdCh0aGlzLnJhbmdlSW5wdXQudmFsdWUsIFwieCBcIikuY29uY2F0KHpvb21TdHJpbmcpO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2socGFyc2VGbG9hdCh0aGlzLnJhbmdlSW5wdXQudmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAobWluVmFsdWUsIG1heFZhbHVlLCBkZWZhdWx0VmFsdWUsIHN0ZXApIHtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0Lm1pbiA9IG1pblZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMucmFuZ2VJbnB1dC5tYXggPSBtYXhWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnJhbmdlSW5wdXQuc3RlcCA9IHN0ZXAudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5yYW5nZUlucHV0LnZhbHVlID0gZGVmYXVsdFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSgpO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnpvb21FbGVtZW50Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfTtcbiAgICBDYW1lcmFab29tVWkucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuem9vbUVsZW1lbnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH07XG4gICAgQ2FtZXJhWm9vbVVpLnByb3RvdHlwZS5zZXRPbkNhbWVyYVpvb21WYWx1ZUNoYW5nZUNhbGxiYWNrID0gZnVuY3Rpb24gKG9uQ2hhbmdlQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2VDYWxsYmFjaztcbiAgICB9O1xuICAgIENhbWVyYVpvb21VaS5wcm90b3R5cGUucmVtb3ZlT25DYW1lcmFab29tVmFsdWVDaGFuZ2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gbnVsbDtcbiAgICB9O1xuICAgIENhbWVyYVpvb21VaS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgcmVuZGVyT25DcmVhdGUpIHtcbiAgICAgICAgdmFyIGNhbWVyYVpvb21VaSA9IG5ldyBDYW1lcmFab29tVWkoKTtcbiAgICAgICAgY2FtZXJhWm9vbVVpLnJlbmRlcihwYXJlbnRFbGVtZW50LCByZW5kZXJPbkNyZWF0ZSk7XG4gICAgICAgIHJldHVybiBjYW1lcmFab29tVWk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FtZXJhWm9vbVVpO1xufSgpKTtcbmV4cG9ydCB7IENhbWVyYVpvb21VaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FtZXJhLXpvb20tdWkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileSelectionUi: () => (/* binding */ FileSelectionUi)\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/base.js\");\n\n\nvar FileSelectionUi = (function () {\n    function FileSelectionUi(parentElement, showOnRender, onFileSelected) {\n        this.fileBasedScanRegion = this.createFileBasedScanRegion();\n        this.fileBasedScanRegion.style.display\n            = showOnRender ? \"block\" : \"none\";\n        parentElement.appendChild(this.fileBasedScanRegion);\n        var fileScanLabel = document.createElement(\"label\");\n        fileScanLabel.setAttribute(\"for\", this.getFileScanInputId());\n        fileScanLabel.style.display = \"inline-block\";\n        this.fileBasedScanRegion.appendChild(fileScanLabel);\n        this.fileSelectionButton\n            = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"button\", _base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID);\n        this.setInitialValueToButton();\n        this.fileSelectionButton.addEventListener(\"click\", function (_) {\n            fileScanLabel.click();\n        });\n        fileScanLabel.append(this.fileSelectionButton);\n        this.fileScanInput\n            = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"input\", this.getFileScanInputId());\n        this.fileScanInput.type = \"file\";\n        this.fileScanInput.accept = \"image/*\";\n        this.fileScanInput.style.display = \"none\";\n        fileScanLabel.appendChild(this.fileScanInput);\n        var $this = this;\n        this.fileScanInput.addEventListener(\"change\", function (e) {\n            if (e == null || e.target == null) {\n                return;\n            }\n            var target = e.target;\n            if (target.files && target.files.length === 0) {\n                return;\n            }\n            var fileList = target.files;\n            var file = fileList[0];\n            var fileName = file.name;\n            $this.setImageNameToButton(fileName);\n            onFileSelected(file);\n        });\n        var dragAndDropMessage = this.createDragAndDropMessage();\n        this.fileBasedScanRegion.appendChild(dragAndDropMessage);\n        this.fileBasedScanRegion.addEventListener(\"dragenter\", function (event) {\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionActiveBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"dragleave\", function (event) {\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionDefaultBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"dragover\", function (event) {\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionActiveBorder();\n            event.stopPropagation();\n            event.preventDefault();\n        });\n        this.fileBasedScanRegion.addEventListener(\"drop\", function (event) {\n            event.stopPropagation();\n            event.preventDefault();\n            $this.fileBasedScanRegion.style.border\n                = $this.fileBasedScanRegionDefaultBorder();\n            var dataTransfer = event.dataTransfer;\n            if (dataTransfer) {\n                var files = dataTransfer.files;\n                if (!files || files.length === 0) {\n                    return;\n                }\n                var isAnyFileImage = false;\n                for (var i = 0; i < files.length; ++i) {\n                    var file = files.item(i);\n                    if (!file) {\n                        continue;\n                    }\n                    var imageType = /image.*/;\n                    if (!file.type.match(imageType)) {\n                        continue;\n                    }\n                    isAnyFileImage = true;\n                    var fileName = file.name;\n                    $this.setImageNameToButton(fileName);\n                    onFileSelected(file);\n                    dragAndDropMessage.innerText\n                        = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.dragAndDropMessage();\n                    break;\n                }\n                if (!isAnyFileImage) {\n                    dragAndDropMessage.innerText\n                        = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings\n                            .dragAndDropMessageOnlyImages();\n                }\n            }\n        });\n    }\n    FileSelectionUi.prototype.hide = function () {\n        this.fileBasedScanRegion.style.display = \"none\";\n        this.fileScanInput.disabled = true;\n    };\n    FileSelectionUi.prototype.show = function () {\n        this.fileBasedScanRegion.style.display = \"block\";\n        this.fileScanInput.disabled = false;\n    };\n    FileSelectionUi.prototype.isShowing = function () {\n        return this.fileBasedScanRegion.style.display === \"block\";\n    };\n    FileSelectionUi.prototype.resetValue = function () {\n        this.fileScanInput.value = \"\";\n        this.setInitialValueToButton();\n    };\n    FileSelectionUi.prototype.createFileBasedScanRegion = function () {\n        var fileBasedScanRegion = document.createElement(\"div\");\n        fileBasedScanRegion.style.textAlign = \"center\";\n        fileBasedScanRegion.style.margin = \"auto\";\n        fileBasedScanRegion.style.width = \"80%\";\n        fileBasedScanRegion.style.maxWidth = \"600px\";\n        fileBasedScanRegion.style.border\n            = this.fileBasedScanRegionDefaultBorder();\n        fileBasedScanRegion.style.padding = \"10px\";\n        fileBasedScanRegion.style.marginBottom = \"10px\";\n        return fileBasedScanRegion;\n    };\n    FileSelectionUi.prototype.fileBasedScanRegionDefaultBorder = function () {\n        return \"6px dashed #ebebeb\";\n    };\n    FileSelectionUi.prototype.fileBasedScanRegionActiveBorder = function () {\n        return \"6px dashed rgb(153 151 151)\";\n    };\n    FileSelectionUi.prototype.createDragAndDropMessage = function () {\n        var dragAndDropMessage = document.createElement(\"div\");\n        dragAndDropMessage.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.dragAndDropMessage();\n        dragAndDropMessage.style.fontWeight = \"400\";\n        return dragAndDropMessage;\n    };\n    FileSelectionUi.prototype.setImageNameToButton = function (imageFileName) {\n        var MAX_CHARS = 20;\n        if (imageFileName.length > MAX_CHARS) {\n            var start8Chars = imageFileName.substring(0, 8);\n            var length_1 = imageFileName.length;\n            var last8Chars = imageFileName.substring(length_1 - 8, length_1);\n            imageFileName = \"\".concat(start8Chars, \"....\").concat(last8Chars);\n        }\n        var newText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionChooseAnother()\n            + \" - \"\n            + imageFileName;\n        this.fileSelectionButton.innerText = newText;\n    };\n    FileSelectionUi.prototype.setInitialValueToButton = function () {\n        var initialText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionChooseImage()\n            + \" - \"\n            + _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.fileSelectionNoImageSelected();\n        this.fileSelectionButton.innerText = initialText;\n    };\n    FileSelectionUi.prototype.getFileScanInputId = function () {\n        return \"html5-qrcode-private-filescan-input\";\n    };\n    FileSelectionUi.create = function (parentElement, showOnRender, onFileSelected) {\n        var button = new FileSelectionUi(parentElement, showOnRender, onFileSelected);\n        return button;\n    };\n    return FileSelectionUi;\n}());\n\n//# sourceMappingURL=file-selection-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9maWxlLXNlbGVjdGlvbi11aS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9maWxlLXNlbGVjdGlvbi11aS5qcz8zYmJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MgfSBmcm9tIFwiLi4vLi4vc3RyaW5nc1wiO1xuaW1wb3J0IHsgQmFzZVVpRWxlbWVudEZhY3RvcnksIFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3NlcyB9IGZyb20gXCIuL2Jhc2VcIjtcbnZhciBGaWxlU2VsZWN0aW9uVWkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbGVTZWxlY3Rpb25VaShwYXJlbnRFbGVtZW50LCBzaG93T25SZW5kZXIsIG9uRmlsZVNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbiA9IHRoaXMuY3JlYXRlRmlsZUJhc2VkU2NhblJlZ2lvbigpO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuZGlzcGxheVxuICAgICAgICAgICAgPSBzaG93T25SZW5kZXIgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24pO1xuICAgICAgICB2YXIgZmlsZVNjYW5MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgZmlsZVNjYW5MYWJlbC5zZXRBdHRyaWJ1dGUoXCJmb3JcIiwgdGhpcy5nZXRGaWxlU2NhbklucHV0SWQoKSk7XG4gICAgICAgIGZpbGVTY2FuTGFiZWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5hcHBlbmRDaGlsZChmaWxlU2NhbkxhYmVsKTtcbiAgICAgICAgdGhpcy5maWxlU2VsZWN0aW9uQnV0dG9uXG4gICAgICAgICAgICA9IEJhc2VVaUVsZW1lbnRGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLkZJTEVfU0VMRUNUSU9OX0JVVFRPTl9JRCk7XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbFZhbHVlVG9CdXR0b24oKTtcbiAgICAgICAgdGhpcy5maWxlU2VsZWN0aW9uQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgZmlsZVNjYW5MYWJlbC5jbGljaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVNjYW5MYWJlbC5hcHBlbmQodGhpcy5maWxlU2VsZWN0aW9uQnV0dG9uKTtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0XG4gICAgICAgICAgICA9IEJhc2VVaUVsZW1lbnRGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB0aGlzLmdldEZpbGVTY2FuSW5wdXRJZCgpKTtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0LmFjY2VwdCA9IFwiaW1hZ2UvKlwiO1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW5wdXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBmaWxlU2NhbkxhYmVsLmFwcGVuZENoaWxkKHRoaXMuZmlsZVNjYW5JbnB1dCk7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsIHx8IGUudGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmZpbGVzICYmIHRhcmdldC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlsZUxpc3QgPSB0YXJnZXQuZmlsZXM7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVMaXN0WzBdO1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gZmlsZS5uYW1lO1xuICAgICAgICAgICAgJHRoaXMuc2V0SW1hZ2VOYW1lVG9CdXR0b24oZmlsZU5hbWUpO1xuICAgICAgICAgICAgb25GaWxlU2VsZWN0ZWQoZmlsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZHJhZ0FuZERyb3BNZXNzYWdlID0gdGhpcy5jcmVhdGVEcmFnQW5kRHJvcE1lc3NhZ2UoKTtcbiAgICAgICAgdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLmFwcGVuZENoaWxkKGRyYWdBbmREcm9wTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgJHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5ib3JkZXJcbiAgICAgICAgICAgICAgICA9ICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb25BY3RpdmVCb3JkZXIoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgJHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5ib3JkZXJcbiAgICAgICAgICAgICAgICA9ICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb25EZWZhdWx0Qm9yZGVyKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgJHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5ib3JkZXJcbiAgICAgICAgICAgICAgICA9ICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb25BY3RpdmVCb3JkZXIoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsZUJhc2VkU2NhblJlZ2lvbi5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICR0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuYm9yZGVyXG4gICAgICAgICAgICAgICAgPSAkdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uRGVmYXVsdEJvcmRlcigpO1xuICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBkYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlcyB8fCBmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaXNBbnlGaWxlSW1hZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZXMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VUeXBlID0gL2ltYWdlLiovO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUudHlwZS5tYXRjaChpbWFnZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc0FueUZpbGVJbWFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuc2V0SW1hZ2VOYW1lVG9CdXR0b24oZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBvbkZpbGVTZWxlY3RlZChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0FuZERyb3BNZXNzYWdlLmlubmVyVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLmRyYWdBbmREcm9wTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FueUZpbGVJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnQW5kRHJvcE1lc3NhZ2UuaW5uZXJUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZHJhZ0FuZERyb3BNZXNzYWdlT25seUltYWdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5maWxlU2NhbklucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuZmlsZVNjYW5JbnB1dC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5pc1Nob3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVCYXNlZFNjYW5SZWdpb24uc3R5bGUuZGlzcGxheSA9PT0gXCJibG9ja1wiO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5yZXNldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpbGVTY2FuSW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLnNldEluaXRpYWxWYWx1ZVRvQnV0dG9uKCk7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmNyZWF0ZUZpbGVCYXNlZFNjYW5SZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxlQmFzZWRTY2FuUmVnaW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBmaWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLm1hcmdpbiA9IFwiYXV0b1wiO1xuICAgICAgICBmaWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLndpZHRoID0gXCI4MCVcIjtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5tYXhXaWR0aCA9IFwiNjAwcHhcIjtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5ib3JkZXJcbiAgICAgICAgICAgID0gdGhpcy5maWxlQmFzZWRTY2FuUmVnaW9uRGVmYXVsdEJvcmRlcigpO1xuICAgICAgICBmaWxlQmFzZWRTY2FuUmVnaW9uLnN0eWxlLnBhZGRpbmcgPSBcIjEwcHhcIjtcbiAgICAgICAgZmlsZUJhc2VkU2NhblJlZ2lvbi5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIjEwcHhcIjtcbiAgICAgICAgcmV0dXJuIGZpbGVCYXNlZFNjYW5SZWdpb247XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmZpbGVCYXNlZFNjYW5SZWdpb25EZWZhdWx0Qm9yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCI2cHggZGFzaGVkICNlYmViZWJcIjtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5wcm90b3R5cGUuZmlsZUJhc2VkU2NhblJlZ2lvbkFjdGl2ZUJvcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiNnB4IGRhc2hlZCByZ2IoMTUzIDE1MSAxNTEpXCI7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmNyZWF0ZURyYWdBbmREcm9wTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRyYWdBbmREcm9wTWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRyYWdBbmREcm9wTWVzc2FnZS5pbm5lclRleHRcbiAgICAgICAgICAgID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5kcmFnQW5kRHJvcE1lc3NhZ2UoKTtcbiAgICAgICAgZHJhZ0FuZERyb3BNZXNzYWdlLnN0eWxlLmZvbnRXZWlnaHQgPSBcIjQwMFwiO1xuICAgICAgICByZXR1cm4gZHJhZ0FuZERyb3BNZXNzYWdlO1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5zZXRJbWFnZU5hbWVUb0J1dHRvbiA9IGZ1bmN0aW9uIChpbWFnZUZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBNQVhfQ0hBUlMgPSAyMDtcbiAgICAgICAgaWYgKGltYWdlRmlsZU5hbWUubGVuZ3RoID4gTUFYX0NIQVJTKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQ4Q2hhcnMgPSBpbWFnZUZpbGVOYW1lLnN1YnN0cmluZygwLCA4KTtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IGltYWdlRmlsZU5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxhc3Q4Q2hhcnMgPSBpbWFnZUZpbGVOYW1lLnN1YnN0cmluZyhsZW5ndGhfMSAtIDgsIGxlbmd0aF8xKTtcbiAgICAgICAgICAgIGltYWdlRmlsZU5hbWUgPSBcIlwiLmNvbmNhdChzdGFydDhDaGFycywgXCIuLi4uXCIpLmNvbmNhdChsYXN0OENoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3VGV4dCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbkNob29zZUFub3RoZXIoKVxuICAgICAgICAgICAgKyBcIiAtIFwiXG4gICAgICAgICAgICArIGltYWdlRmlsZU5hbWU7XG4gICAgICAgIHRoaXMuZmlsZVNlbGVjdGlvbkJ1dHRvbi5pbm5lclRleHQgPSBuZXdUZXh0O1xuICAgIH07XG4gICAgRmlsZVNlbGVjdGlvblVpLnByb3RvdHlwZS5zZXRJbml0aWFsVmFsdWVUb0J1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxUZXh0ID0gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy5maWxlU2VsZWN0aW9uQ2hvb3NlSW1hZ2UoKVxuICAgICAgICAgICAgKyBcIiAtIFwiXG4gICAgICAgICAgICArIEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MuZmlsZVNlbGVjdGlvbk5vSW1hZ2VTZWxlY3RlZCgpO1xuICAgICAgICB0aGlzLmZpbGVTZWxlY3Rpb25CdXR0b24uaW5uZXJUZXh0ID0gaW5pdGlhbFRleHQ7XG4gICAgfTtcbiAgICBGaWxlU2VsZWN0aW9uVWkucHJvdG90eXBlLmdldEZpbGVTY2FuSW5wdXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHRtbDUtcXJjb2RlLXByaXZhdGUtZmlsZXNjYW4taW5wdXRcIjtcbiAgICB9O1xuICAgIEZpbGVTZWxlY3Rpb25VaS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgc2hvd09uUmVuZGVyLCBvbkZpbGVTZWxlY3RlZCkge1xuICAgICAgICB2YXIgYnV0dG9uID0gbmV3IEZpbGVTZWxlY3Rpb25VaShwYXJlbnRFbGVtZW50LCBzaG93T25SZW5kZXIsIG9uRmlsZVNlbGVjdGVkKTtcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9O1xuICAgIHJldHVybiBGaWxlU2VsZWN0aW9uVWk7XG59KCkpO1xuZXhwb3J0IHsgRmlsZVNlbGVjdGlvblVpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLXNlbGVjdGlvbi11aS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScanTypeSelector: () => (/* binding */ ScanTypeSelector)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ \"../../../node_modules/html5-qrcode/esm/core.js\");\n\nvar ScanTypeSelector = (function () {\n    function ScanTypeSelector(supportedScanTypes) {\n        this.supportedScanTypes = this.validateAndReturnScanTypes(supportedScanTypes);\n    }\n    ScanTypeSelector.prototype.getDefaultScanType = function () {\n        return this.supportedScanTypes[0];\n    };\n    ScanTypeSelector.prototype.hasMoreThanOneScanType = function () {\n        return this.supportedScanTypes.length > 1;\n    };\n    ScanTypeSelector.prototype.isCameraScanRequired = function () {\n        for (var _i = 0, _a = this.supportedScanTypes; _i < _a.length; _i++) {\n            var scanType = _a[_i];\n            if (ScanTypeSelector.isCameraScanType(scanType)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    ScanTypeSelector.isCameraScanType = function (scanType) {\n        return scanType === _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_CAMERA;\n    };\n    ScanTypeSelector.isFileScanType = function (scanType) {\n        return scanType === _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScanType.SCAN_TYPE_FILE;\n    };\n    ScanTypeSelector.prototype.validateAndReturnScanTypes = function (supportedScanTypes) {\n        if (!supportedScanTypes || supportedScanTypes.length === 0) {\n            return _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;\n        }\n        var maxExpectedValues = _core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.length;\n        if (supportedScanTypes.length > maxExpectedValues) {\n            throw \"Max \".concat(maxExpectedValues, \" values expected for \")\n                + \"supportedScanTypes\";\n        }\n        for (var _i = 0, supportedScanTypes_1 = supportedScanTypes; _i < supportedScanTypes_1.length; _i++) {\n            var scanType = supportedScanTypes_1[_i];\n            if (!_core__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE\n                .includes(scanType)) {\n                throw \"Unsupported scan type \".concat(scanType);\n            }\n        }\n        return supportedScanTypes;\n    };\n    return ScanTypeSelector;\n}());\n\n//# sourceMappingURL=scan-type-selector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci9zY2FuLXR5cGUtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91aS9zY2FubmVyL3NjYW4tdHlwZS1zZWxlY3Rvci5qcz9jMWRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0bWw1UXJjb2RlU2NhblR5cGUsIEh0bWw1UXJjb2RlQ29uc3RhbnRzIH0gZnJvbSBcIi4uLy4uL2NvcmVcIjtcbnZhciBTY2FuVHlwZVNlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2FuVHlwZVNlbGVjdG9yKHN1cHBvcnRlZFNjYW5UeXBlcykge1xuICAgICAgICB0aGlzLnN1cHBvcnRlZFNjYW5UeXBlcyA9IHRoaXMudmFsaWRhdGVBbmRSZXR1cm5TY2FuVHlwZXMoc3VwcG9ydGVkU2NhblR5cGVzKTtcbiAgICB9XG4gICAgU2NhblR5cGVTZWxlY3Rvci5wcm90b3R5cGUuZ2V0RGVmYXVsdFNjYW5UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXNbMF07XG4gICAgfTtcbiAgICBTY2FuVHlwZVNlbGVjdG9yLnByb3RvdHlwZS5oYXNNb3JlVGhhbk9uZVNjYW5UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXMubGVuZ3RoID4gMTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IucHJvdG90eXBlLmlzQ2FtZXJhU2NhblJlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zdXBwb3J0ZWRTY2FuVHlwZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2NhblR5cGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoU2NhblR5cGVTZWxlY3Rvci5pc0NhbWVyYVNjYW5UeXBlKHNjYW5UeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IuaXNDYW1lcmFTY2FuVHlwZSA9IGZ1bmN0aW9uIChzY2FuVHlwZSkge1xuICAgICAgICByZXR1cm4gc2NhblR5cGUgPT09IEh0bWw1UXJjb2RlU2NhblR5cGUuU0NBTl9UWVBFX0NBTUVSQTtcbiAgICB9O1xuICAgIFNjYW5UeXBlU2VsZWN0b3IuaXNGaWxlU2NhblR5cGUgPSBmdW5jdGlvbiAoc2NhblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNjYW5UeXBlID09PSBIdG1sNVFyY29kZVNjYW5UeXBlLlNDQU5fVFlQRV9GSUxFO1xuICAgIH07XG4gICAgU2NhblR5cGVTZWxlY3Rvci5wcm90b3R5cGUudmFsaWRhdGVBbmRSZXR1cm5TY2FuVHlwZXMgPSBmdW5jdGlvbiAoc3VwcG9ydGVkU2NhblR5cGVzKSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkU2NhblR5cGVzIHx8IHN1cHBvcnRlZFNjYW5UeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heEV4cGVjdGVkVmFsdWVzID0gSHRtbDVRcmNvZGVDb25zdGFudHMuREVGQVVMVF9TVVBQT1JURURfU0NBTl9UWVBFLmxlbmd0aDtcbiAgICAgICAgaWYgKHN1cHBvcnRlZFNjYW5UeXBlcy5sZW5ndGggPiBtYXhFeHBlY3RlZFZhbHVlcykge1xuICAgICAgICAgICAgdGhyb3cgXCJNYXggXCIuY29uY2F0KG1heEV4cGVjdGVkVmFsdWVzLCBcIiB2YWx1ZXMgZXhwZWN0ZWQgZm9yIFwiKVxuICAgICAgICAgICAgICAgICsgXCJzdXBwb3J0ZWRTY2FuVHlwZXNcIjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN1cHBvcnRlZFNjYW5UeXBlc18xID0gc3VwcG9ydGVkU2NhblR5cGVzOyBfaSA8IHN1cHBvcnRlZFNjYW5UeXBlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjYW5UeXBlID0gc3VwcG9ydGVkU2NhblR5cGVzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCFIdG1sNVFyY29kZUNvbnN0YW50cy5ERUZBVUxUX1NVUFBPUlRFRF9TQ0FOX1RZUEVcbiAgICAgICAgICAgICAgICAuaW5jbHVkZXMoc2NhblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJVbnN1cHBvcnRlZCBzY2FuIHR5cGUgXCIuY29uY2F0KHNjYW5UeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkU2NhblR5cGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5UeXBlU2VsZWN0b3I7XG59KCkpO1xuZXhwb3J0IHsgU2NhblR5cGVTZWxlY3RvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nhbi10eXBlLXNlbGVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/ui/scanner/torch-button.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/ui/scanner/torch-button.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TorchButton: () => (/* binding */ TorchButton)\n/* harmony export */ });\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../strings */ \"../../../node_modules/html5-qrcode/esm/strings.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"../../../node_modules/html5-qrcode/esm/ui/scanner/base.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\nvar TorchController = (function () {\n    function TorchController(torchCapability, buttonController, onTorchActionFailureCallback) {\n        this.isTorchOn = false;\n        this.torchCapability = torchCapability;\n        this.buttonController = buttonController;\n        this.onTorchActionFailureCallback = onTorchActionFailureCallback;\n    }\n    TorchController.prototype.isTorchEnabled = function () {\n        return this.isTorchOn;\n    };\n    TorchController.prototype.flipState = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var isTorchOnExpected, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.buttonController.disable();\n                        isTorchOnExpected = !this.isTorchOn;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4, this.torchCapability.apply(isTorchOnExpected)];\n                    case 2:\n                        _a.sent();\n                        this.updateUiBasedOnLatestSettings(this.torchCapability.value(), isTorchOnExpected);\n                        return [3, 4];\n                    case 3:\n                        error_1 = _a.sent();\n                        this.propagateFailure(isTorchOnExpected, error_1);\n                        this.buttonController.enable();\n                        return [3, 4];\n                    case 4: return [2];\n                }\n            });\n        });\n    };\n    TorchController.prototype.updateUiBasedOnLatestSettings = function (isTorchOn, isTorchOnExpected) {\n        if (isTorchOn === isTorchOnExpected) {\n            this.buttonController.setText(isTorchOnExpected\n                ? _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOffButton()\n                : _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton());\n            this.isTorchOn = isTorchOnExpected;\n        }\n        else {\n            this.propagateFailure(isTorchOnExpected);\n        }\n        this.buttonController.enable();\n    };\n    TorchController.prototype.propagateFailure = function (isTorchOnExpected, error) {\n        var errorMessage = isTorchOnExpected\n            ? _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnFailedMessage()\n            : _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOffFailedMessage();\n        if (error) {\n            errorMessage += \"; Error = \" + error;\n        }\n        this.onTorchActionFailureCallback(errorMessage);\n    };\n    TorchController.prototype.reset = function () {\n        this.isTorchOn = false;\n    };\n    return TorchController;\n}());\nvar TorchButton = (function () {\n    function TorchButton(torchCapability, onTorchActionFailureCallback) {\n        this.onTorchActionFailureCallback = onTorchActionFailureCallback;\n        this.torchButton\n            = _base__WEBPACK_IMPORTED_MODULE_1__.BaseUiElementFactory.createElement(\"button\", _base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_ID);\n        this.torchController = new TorchController(torchCapability, this, onTorchActionFailureCallback);\n    }\n    TorchButton.prototype.render = function (parentElement, torchButtonOptions) {\n        var _this = this;\n        this.torchButton.innerText\n            = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton();\n        this.torchButton.style.display = torchButtonOptions.display;\n        this.torchButton.style.marginLeft = torchButtonOptions.marginLeft;\n        var $this = this;\n        this.torchButton.addEventListener(\"click\", function (_) { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, $this.torchController.flipState()];\n                    case 1:\n                        _a.sent();\n                        if ($this.torchController.isTorchEnabled()) {\n                            $this.torchButton.classList.remove(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);\n                            $this.torchButton.classList.add(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);\n                        }\n                        else {\n                            $this.torchButton.classList.remove(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);\n                            $this.torchButton.classList.add(_base__WEBPACK_IMPORTED_MODULE_1__.PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);\n                        }\n                        return [2];\n                }\n            });\n        }); });\n        parentElement.appendChild(this.torchButton);\n    };\n    TorchButton.prototype.updateTorchCapability = function (torchCapability) {\n        this.torchController = new TorchController(torchCapability, this, this.onTorchActionFailureCallback);\n    };\n    TorchButton.prototype.getTorchButton = function () {\n        return this.torchButton;\n    };\n    TorchButton.prototype.hide = function () {\n        this.torchButton.style.display = \"none\";\n    };\n    TorchButton.prototype.show = function () {\n        this.torchButton.style.display = \"inline-block\";\n    };\n    TorchButton.prototype.disable = function () {\n        this.torchButton.disabled = true;\n    };\n    TorchButton.prototype.enable = function () {\n        this.torchButton.disabled = false;\n    };\n    TorchButton.prototype.setText = function (text) {\n        this.torchButton.innerText = text;\n    };\n    TorchButton.prototype.reset = function () {\n        this.torchButton.innerText = _strings__WEBPACK_IMPORTED_MODULE_0__.Html5QrcodeScannerStrings.torchOnButton();\n        this.torchController.reset();\n    };\n    TorchButton.create = function (parentElement, torchCapability, torchButtonOptions, onTorchActionFailureCallback) {\n        var button = new TorchButton(torchCapability, onTorchActionFailureCallback);\n        button.render(parentElement, torchButtonOptions);\n        return button;\n    };\n    return TorchButton;\n}());\n\n//# sourceMappingURL=torch-button.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci90b3JjaC1idXR0b24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdWkvc2Nhbm5lci90b3JjaC1idXR0b24uanM/NDcxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzIH0gZnJvbSBcIi4uLy4uL3N0cmluZ3NcIjtcbmltcG9ydCB7IEJhc2VVaUVsZW1lbnRGYWN0b3J5LCBQdWJsaWNVaUVsZW1lbnRJZEFuZENsYXNzZXMgfSBmcm9tIFwiLi9iYXNlXCI7XG52YXIgVG9yY2hDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb3JjaENvbnRyb2xsZXIodG9yY2hDYXBhYmlsaXR5LCBidXR0b25Db250cm9sbGVyLCBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaXNUb3JjaE9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG9yY2hDYXBhYmlsaXR5ID0gdG9yY2hDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLmJ1dHRvbkNvbnRyb2xsZXIgPSBidXR0b25Db250cm9sbGVyO1xuICAgICAgICB0aGlzLm9uVG9yY2hBY3Rpb25GYWlsdXJlQ2FsbGJhY2sgPSBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrO1xuICAgIH1cbiAgICBUb3JjaENvbnRyb2xsZXIucHJvdG90eXBlLmlzVG9yY2hFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1RvcmNoT247XG4gICAgfTtcbiAgICBUb3JjaENvbnRyb2xsZXIucHJvdG90eXBlLmZsaXBTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlzVG9yY2hPbkV4cGVjdGVkLCBlcnJvcl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG9yY2hPbkV4cGVjdGVkID0gIXRoaXMuaXNUb3JjaE9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLnRvcmNoQ2FwYWJpbGl0eS5hcHBseShpc1RvcmNoT25FeHBlY3RlZCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVVpQmFzZWRPbkxhdGVzdFNldHRpbmdzKHRoaXMudG9yY2hDYXBhYmlsaXR5LnZhbHVlKCksIGlzVG9yY2hPbkV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZUZhaWx1cmUoaXNUb3JjaE9uRXhwZWN0ZWQsIGVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvcmNoQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlVWlCYXNlZE9uTGF0ZXN0U2V0dGluZ3MgPSBmdW5jdGlvbiAoaXNUb3JjaE9uLCBpc1RvcmNoT25FeHBlY3RlZCkge1xuICAgICAgICBpZiAoaXNUb3JjaE9uID09PSBpc1RvcmNoT25FeHBlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLnNldFRleHQoaXNUb3JjaE9uRXhwZWN0ZWRcbiAgICAgICAgICAgICAgICA/IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPZmZCdXR0b24oKVxuICAgICAgICAgICAgICAgIDogSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9uQnV0dG9uKCkpO1xuICAgICAgICAgICAgdGhpcy5pc1RvcmNoT24gPSBpc1RvcmNoT25FeHBlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRmFpbHVyZShpc1RvcmNoT25FeHBlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b25Db250cm9sbGVyLmVuYWJsZSgpO1xuICAgIH07XG4gICAgVG9yY2hDb250cm9sbGVyLnByb3RvdHlwZS5wcm9wYWdhdGVGYWlsdXJlID0gZnVuY3Rpb24gKGlzVG9yY2hPbkV4cGVjdGVkLCBlcnJvcikge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gaXNUb3JjaE9uRXhwZWN0ZWRcbiAgICAgICAgICAgID8gSHRtbDVRcmNvZGVTY2FubmVyU3RyaW5ncy50b3JjaE9uRmFpbGVkTWVzc2FnZSgpXG4gICAgICAgICAgICA6IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPZmZGYWlsZWRNZXNzYWdlKCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiOyBFcnJvciA9IFwiICsgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKGVycm9yTWVzc2FnZSk7XG4gICAgfTtcbiAgICBUb3JjaENvbnRyb2xsZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVG9yY2hPbiA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFRvcmNoQ29udHJvbGxlcjtcbn0oKSk7XG52YXIgVG9yY2hCdXR0b24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvcmNoQnV0dG9uKHRvcmNoQ2FwYWJpbGl0eSwgb25Ub3JjaEFjdGlvbkZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uVG9yY2hBY3Rpb25GYWlsdXJlQ2FsbGJhY2sgPSBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uXG4gICAgICAgICAgICA9IEJhc2VVaUVsZW1lbnRGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9JRCk7XG4gICAgICAgIHRoaXMudG9yY2hDb250cm9sbGVyID0gbmV3IFRvcmNoQ29udHJvbGxlcih0b3JjaENhcGFiaWxpdHksIHRoaXMsIG9uVG9yY2hBY3Rpb25GYWlsdXJlQ2FsbGJhY2spO1xuICAgIH1cbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHRvcmNoQnV0dG9uT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmlubmVyVGV4dFxuICAgICAgICAgICAgPSBIdG1sNVFyY29kZVNjYW5uZXJTdHJpbmdzLnRvcmNoT25CdXR0b24oKTtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gdG9yY2hCdXR0b25PcHRpb25zLmRpc3BsYXk7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uc3R5bGUubWFyZ2luTGVmdCA9IHRvcmNoQnV0dG9uT3B0aW9ucy5tYXJnaW5MZWZ0O1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoXykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsICR0aGlzLnRvcmNoQ29udHJvbGxlci5mbGlwU3RhdGUoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdGhpcy50b3JjaENvbnRyb2xsZXIuaXNUb3JjaEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRvcmNoQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PRkYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRvcmNoQnV0dG9uLmNsYXNzTGlzdC5hZGQoUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PTik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50b3JjaEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFB1YmxpY1VpRWxlbWVudElkQW5kQ2xhc3Nlcy5UT1JDSF9CVVRUT05fQ0xBU1NfVE9SQ0hfT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRvcmNoQnV0dG9uLmNsYXNzTGlzdC5hZGQoUHVibGljVWlFbGVtZW50SWRBbmRDbGFzc2VzLlRPUkNIX0JVVFRPTl9DTEFTU19UT1JDSF9PRkYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudG9yY2hCdXR0b24pO1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24ucHJvdG90eXBlLnVwZGF0ZVRvcmNoQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICh0b3JjaENhcGFiaWxpdHkpIHtcbiAgICAgICAgdGhpcy50b3JjaENvbnRyb2xsZXIgPSBuZXcgVG9yY2hDb250cm9sbGVyKHRvcmNoQ2FwYWJpbGl0eSwgdGhpcywgdGhpcy5vblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5nZXRUb3JjaEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9yY2hCdXR0b247XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfTtcbiAgICBUb3JjaEJ1dHRvbi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9yY2hCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRvcmNoQnV0dG9uLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy50b3JjaEJ1dHRvbi5pbm5lclRleHQgPSB0ZXh0O1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvcmNoQnV0dG9uLmlubmVyVGV4dCA9IEh0bWw1UXJjb2RlU2Nhbm5lclN0cmluZ3MudG9yY2hPbkJ1dHRvbigpO1xuICAgICAgICB0aGlzLnRvcmNoQ29udHJvbGxlci5yZXNldCgpO1xuICAgIH07XG4gICAgVG9yY2hCdXR0b24uY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHRvcmNoQ2FwYWJpbGl0eSwgdG9yY2hCdXR0b25PcHRpb25zLCBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBidXR0b24gPSBuZXcgVG9yY2hCdXR0b24odG9yY2hDYXBhYmlsaXR5LCBvblRvcmNoQWN0aW9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICAgICAgYnV0dG9uLnJlbmRlcihwYXJlbnRFbGVtZW50LCB0b3JjaEJ1dHRvbk9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH07XG4gICAgcmV0dXJuIFRvcmNoQnV0dG9uO1xufSgpKTtcbmV4cG9ydCB7IFRvcmNoQnV0dG9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3JjaC1idXR0b24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/ui/scanner/torch-button.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/utils.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VideoConstraintsUtil: () => (/* binding */ VideoConstraintsUtil)\n/* harmony export */ });\nvar VideoConstraintsUtil = (function () {\n    function VideoConstraintsUtil() {\n    }\n    VideoConstraintsUtil.isMediaStreamConstraintsValid = function (videoConstraints, logger) {\n        if (typeof videoConstraints !== \"object\") {\n            var typeofVideoConstraints = typeof videoConstraints;\n            logger.logError(\"videoConstraints should be of type object, the \"\n                + \"object passed is of type \".concat(typeofVideoConstraints, \".\"), true);\n            return false;\n        }\n        var bannedKeys = [\n            \"autoGainControl\",\n            \"channelCount\",\n            \"echoCancellation\",\n            \"latency\",\n            \"noiseSuppression\",\n            \"sampleRate\",\n            \"sampleSize\",\n            \"volume\"\n        ];\n        var bannedkeysSet = new Set(bannedKeys);\n        var keysInVideoConstraints = Object.keys(videoConstraints);\n        for (var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++) {\n            var key = keysInVideoConstraints_1[_i];\n            if (bannedkeysSet.has(key)) {\n                logger.logError(\"\".concat(key, \" is not supported videoConstaints.\"), true);\n                return false;\n            }\n        }\n        return true;\n    };\n    return VideoConstraintsUtil;\n}());\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL2VzbS91dGlscy5qcz9iM2U0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBWaWRlb0NvbnN0cmFpbnRzVXRpbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlkZW9Db25zdHJhaW50c1V0aWwoKSB7XG4gICAgfVxuICAgIFZpZGVvQ29uc3RyYWludHNVdGlsLmlzTWVkaWFTdHJlYW1Db25zdHJhaW50c1ZhbGlkID0gZnVuY3Rpb24gKHZpZGVvQ29uc3RyYWludHMsIGxvZ2dlcikge1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciB0eXBlb2ZWaWRlb0NvbnN0cmFpbnRzID0gdHlwZW9mIHZpZGVvQ29uc3RyYWludHM7XG4gICAgICAgICAgICBsb2dnZXIubG9nRXJyb3IoXCJ2aWRlb0NvbnN0cmFpbnRzIHNob3VsZCBiZSBvZiB0eXBlIG9iamVjdCwgdGhlIFwiXG4gICAgICAgICAgICAgICAgKyBcIm9iamVjdCBwYXNzZWQgaXMgb2YgdHlwZSBcIi5jb25jYXQodHlwZW9mVmlkZW9Db25zdHJhaW50cywgXCIuXCIpLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFubmVkS2V5cyA9IFtcbiAgICAgICAgICAgIFwiYXV0b0dhaW5Db250cm9sXCIsXG4gICAgICAgICAgICBcImNoYW5uZWxDb3VudFwiLFxuICAgICAgICAgICAgXCJlY2hvQ2FuY2VsbGF0aW9uXCIsXG4gICAgICAgICAgICBcImxhdGVuY3lcIixcbiAgICAgICAgICAgIFwibm9pc2VTdXBwcmVzc2lvblwiLFxuICAgICAgICAgICAgXCJzYW1wbGVSYXRlXCIsXG4gICAgICAgICAgICBcInNhbXBsZVNpemVcIixcbiAgICAgICAgICAgIFwidm9sdW1lXCJcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGJhbm5lZGtleXNTZXQgPSBuZXcgU2V0KGJhbm5lZEtleXMpO1xuICAgICAgICB2YXIga2V5c0luVmlkZW9Db25zdHJhaW50cyA9IE9iamVjdC5rZXlzKHZpZGVvQ29uc3RyYWludHMpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNJblZpZGVvQ29uc3RyYWludHNfMSA9IGtleXNJblZpZGVvQ29uc3RyYWludHM7IF9pIDwga2V5c0luVmlkZW9Db25zdHJhaW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNJblZpZGVvQ29uc3RyYWludHNfMVtfaV07XG4gICAgICAgICAgICBpZiAoYmFubmVka2V5c1NldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2dFcnJvcihcIlwiLmNvbmNhdChrZXksIFwiIGlzIG5vdCBzdXBwb3J0ZWQgdmlkZW9Db25zdGFpbnRzLlwiKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZGVvQ29uc3RyYWludHNVdGlsO1xufSgpKTtcbmV4cG9ydCB7IFZpZGVvQ29uc3RyYWludHNVdGlsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/utils.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZXingHtml5QrcodeDecoder: () => (/* binding */ ZXingHtml5QrcodeDecoder)\n/* harmony export */ });\n/* harmony import */ var _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../third_party/zxing-js.umd */ \"../../../node_modules/html5-qrcode/third_party/zxing-js.umd.js\");\n/* harmony import */ var _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ \"../../../node_modules/html5-qrcode/esm/core.js\");\n\n\nvar ZXingHtml5QrcodeDecoder = (function () {\n    function ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger) {\n        this.formatMap = new Map([\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.QR_CODE, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.QR_CODE],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.AZTEC, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.AZTEC],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODABAR, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODABAR],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_39, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_39],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_93, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_93],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.CODE_128,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.CODE_128\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.DATA_MATRIX,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.DATA_MATRIX\n            ],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.MAXICODE,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.MAXICODE\n            ],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.ITF, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.ITF],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.EAN_13, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.EAN_13],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.EAN_8, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.EAN_8],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.PDF_417, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.PDF_417],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.RSS_14, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.RSS_14],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.RSS_EXPANDED,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.RSS_EXPANDED\n            ],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_A, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_A],\n            [_core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_E, _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_E],\n            [\n                _core__WEBPACK_IMPORTED_MODULE_1__.Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,\n                _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BarcodeFormat.UPC_EAN_EXTENSION\n            ]\n        ]);\n        this.reverseFormatMap = this.createReverseFormatMap();\n        if (!_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__) {\n            throw \"Use html5qrcode.min.js without edit, ZXing not found.\";\n        }\n        this.verbose = verbose;\n        this.logger = logger;\n        var formats = this.createZXingFormats(requestedFormats);\n        var hints = new Map();\n        hints.set(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.DecodeHintType.POSSIBLE_FORMATS, formats);\n        hints.set(_third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.DecodeHintType.TRY_HARDER, false);\n        this.hints = hints;\n    }\n    ZXingHtml5QrcodeDecoder.prototype.decodeAsync = function (canvas) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                resolve(_this.decode(canvas));\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    };\n    ZXingHtml5QrcodeDecoder.prototype.decode = function (canvas) {\n        var zxingDecoder = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.MultiFormatReader(this.verbose, this.hints);\n        var luminanceSource = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.HTMLCanvasElementLuminanceSource(canvas);\n        var binaryBitmap = new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.BinaryBitmap(new _third_party_zxing_js_umd__WEBPACK_IMPORTED_MODULE_0__.HybridBinarizer(luminanceSource));\n        var result = zxingDecoder.decode(binaryBitmap);\n        return {\n            text: result.text,\n            format: _core__WEBPACK_IMPORTED_MODULE_1__.QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format)),\n            debugData: this.createDebugData()\n        };\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createReverseFormatMap = function () {\n        var result = new Map();\n        this.formatMap.forEach(function (value, key, _) {\n            result.set(value, key);\n        });\n        return result;\n    };\n    ZXingHtml5QrcodeDecoder.prototype.toHtml5QrcodeSupportedFormats = function (zxingFormat) {\n        if (!this.reverseFormatMap.has(zxingFormat)) {\n            throw \"reverseFormatMap doesn't have \".concat(zxingFormat);\n        }\n        return this.reverseFormatMap.get(zxingFormat);\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createZXingFormats = function (requestedFormats) {\n        var zxingFormats = [];\n        for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {\n            var requestedFormat = requestedFormats_1[_i];\n            if (this.formatMap.has(requestedFormat)) {\n                zxingFormats.push(this.formatMap.get(requestedFormat));\n            }\n            else {\n                this.logger.logError(\"\".concat(requestedFormat, \" is not supported by\")\n                    + \"ZXingHtml5QrcodeShim\");\n            }\n        }\n        return zxingFormats;\n    };\n    ZXingHtml5QrcodeDecoder.prototype.createDebugData = function () {\n        return { decoderName: \"zxing-js\" };\n    };\n    return ZXingHtml5QrcodeDecoder;\n}());\n\n//# sourceMappingURL=zxing-html5-qrcode-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20venhpbmctaHRtbDUtcXJjb2RlLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS9lc20venhpbmctaHRtbDUtcXJjb2RlLWRlY29kZXIuanM/NmFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBaWGluZyBmcm9tIFwiLi4vdGhpcmRfcGFydHkvenhpbmctanMudW1kXCI7XG5pbXBvcnQgeyBRcmNvZGVSZXN1bHRGb3JtYXQsIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cyB9IGZyb20gXCIuL2NvcmVcIjtcbnZhciBaWGluZ0h0bWw1UXJjb2RlRGVjb2RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWlhpbmdIdG1sNVFyY29kZURlY29kZXIocmVxdWVzdGVkRm9ybWF0cywgdmVyYm9zZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0TWFwID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlFSX0NPREUsIFpYaW5nLkJhcmNvZGVGb3JtYXQuUVJfQ09ERV0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkFaVEVDLCBaWGluZy5CYXJjb2RlRm9ybWF0LkFaVEVDXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09EQUJBUiwgWlhpbmcuQmFyY29kZUZvcm1hdC5DT0RBQkFSXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8zOSwgWlhpbmcuQmFyY29kZUZvcm1hdC5DT0RFXzM5XSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV85MywgWlhpbmcuQmFyY29kZUZvcm1hdC5DT0RFXzkzXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuQ09ERV8xMjgsXG4gICAgICAgICAgICAgICAgWlhpbmcuQmFyY29kZUZvcm1hdC5DT0RFXzEyOFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuREFUQV9NQVRSSVgsXG4gICAgICAgICAgICAgICAgWlhpbmcuQmFyY29kZUZvcm1hdC5EQVRBX01BVFJJWFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuTUFYSUNPREUsXG4gICAgICAgICAgICAgICAgWlhpbmcuQmFyY29kZUZvcm1hdC5NQVhJQ09ERVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuSVRGLCBaWGluZy5CYXJjb2RlRm9ybWF0LklURl0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLkVBTl8xMywgWlhpbmcuQmFyY29kZUZvcm1hdC5FQU5fMTNdLFxuICAgICAgICAgICAgW0h0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5FQU5fOCwgWlhpbmcuQmFyY29kZUZvcm1hdC5FQU5fOF0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlBERl80MTcsIFpYaW5nLkJhcmNvZGVGb3JtYXQuUERGXzQxN10sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlJTU18xNCwgWlhpbmcuQmFyY29kZUZvcm1hdC5SU1NfMTRdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5SU1NfRVhQQU5ERUQsXG4gICAgICAgICAgICAgICAgWlhpbmcuQmFyY29kZUZvcm1hdC5SU1NfRVhQQU5ERURcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbSHRtbDVRcmNvZGVTdXBwb3J0ZWRGb3JtYXRzLlVQQ19BLCBaWGluZy5CYXJjb2RlRm9ybWF0LlVQQ19BXSxcbiAgICAgICAgICAgIFtIdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMuVVBDX0UsIFpYaW5nLkJhcmNvZGVGb3JtYXQuVVBDX0VdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIEh0bWw1UXJjb2RlU3VwcG9ydGVkRm9ybWF0cy5VUENfRUFOX0VYVEVOU0lPTixcbiAgICAgICAgICAgICAgICBaWGluZy5CYXJjb2RlRm9ybWF0LlVQQ19FQU5fRVhURU5TSU9OXG4gICAgICAgICAgICBdXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnJldmVyc2VGb3JtYXRNYXAgPSB0aGlzLmNyZWF0ZVJldmVyc2VGb3JtYXRNYXAoKTtcbiAgICAgICAgaWYgKCFaWGluZykge1xuICAgICAgICAgICAgdGhyb3cgXCJVc2UgaHRtbDVxcmNvZGUubWluLmpzIHdpdGhvdXQgZWRpdCwgWlhpbmcgbm90IGZvdW5kLlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB2YXIgZm9ybWF0cyA9IHRoaXMuY3JlYXRlWlhpbmdGb3JtYXRzKHJlcXVlc3RlZEZvcm1hdHMpO1xuICAgICAgICB2YXIgaGludHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGhpbnRzLnNldChaWGluZy5EZWNvZGVIaW50VHlwZS5QT1NTSUJMRV9GT1JNQVRTLCBmb3JtYXRzKTtcbiAgICAgICAgaGludHMuc2V0KFpYaW5nLkRlY29kZUhpbnRUeXBlLlRSWV9IQVJERVIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5oaW50cyA9IGhpbnRzO1xuICAgIH1cbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlQXN5bmMgPSBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuZGVjb2RlKGNhbnZhcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICB2YXIgenhpbmdEZWNvZGVyID0gbmV3IFpYaW5nLk11bHRpRm9ybWF0UmVhZGVyKHRoaXMudmVyYm9zZSwgdGhpcy5oaW50cyk7XG4gICAgICAgIHZhciBsdW1pbmFuY2VTb3VyY2UgPSBuZXcgWlhpbmcuSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UoY2FudmFzKTtcbiAgICAgICAgdmFyIGJpbmFyeUJpdG1hcCA9IG5ldyBaWGluZy5CaW5hcnlCaXRtYXAobmV3IFpYaW5nLkh5YnJpZEJpbmFyaXplcihsdW1pbmFuY2VTb3VyY2UpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHp4aW5nRGVjb2Rlci5kZWNvZGUoYmluYXJ5Qml0bWFwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHJlc3VsdC50ZXh0LFxuICAgICAgICAgICAgZm9ybWF0OiBRcmNvZGVSZXN1bHRGb3JtYXQuY3JlYXRlKHRoaXMudG9IdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMocmVzdWx0LmZvcm1hdCkpLFxuICAgICAgICAgICAgZGVidWdEYXRhOiB0aGlzLmNyZWF0ZURlYnVnRGF0YSgpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUuY3JlYXRlUmV2ZXJzZUZvcm1hdE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5mb3JtYXRNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSwgXykge1xuICAgICAgICAgICAgcmVzdWx0LnNldCh2YWx1ZSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlci5wcm90b3R5cGUudG9IdG1sNVFyY29kZVN1cHBvcnRlZEZvcm1hdHMgPSBmdW5jdGlvbiAoenhpbmdGb3JtYXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJldmVyc2VGb3JtYXRNYXAuaGFzKHp4aW5nRm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgXCJyZXZlcnNlRm9ybWF0TWFwIGRvZXNuJ3QgaGF2ZSBcIi5jb25jYXQoenhpbmdGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2VGb3JtYXRNYXAuZ2V0KHp4aW5nRm9ybWF0KTtcbiAgICB9O1xuICAgIFpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyLnByb3RvdHlwZS5jcmVhdGVaWGluZ0Zvcm1hdHMgPSBmdW5jdGlvbiAocmVxdWVzdGVkRm9ybWF0cykge1xuICAgICAgICB2YXIgenhpbmdGb3JtYXRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcmVxdWVzdGVkRm9ybWF0c18xID0gcmVxdWVzdGVkRm9ybWF0czsgX2kgPCByZXF1ZXN0ZWRGb3JtYXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdGVkRm9ybWF0ID0gcmVxdWVzdGVkRm9ybWF0c18xW19pXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdE1hcC5oYXMocmVxdWVzdGVkRm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHp4aW5nRm9ybWF0cy5wdXNoKHRoaXMuZm9ybWF0TWFwLmdldChyZXF1ZXN0ZWRGb3JtYXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKFwiXCIuY29uY2F0KHJlcXVlc3RlZEZvcm1hdCwgXCIgaXMgbm90IHN1cHBvcnRlZCBieVwiKVxuICAgICAgICAgICAgICAgICAgICArIFwiWlhpbmdIdG1sNVFyY29kZVNoaW1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHp4aW5nRm9ybWF0cztcbiAgICB9O1xuICAgIFpYaW5nSHRtbDVRcmNvZGVEZWNvZGVyLnByb3RvdHlwZS5jcmVhdGVEZWJ1Z0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGRlY29kZXJOYW1lOiBcInp4aW5nLWpzXCIgfTtcbiAgICB9O1xuICAgIHJldHVybiBaWGluZ0h0bWw1UXJjb2RlRGVjb2Rlcjtcbn0oKSk7XG5leHBvcnQgeyBaWGluZ0h0bWw1UXJjb2RlRGVjb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9enhpbmctaHRtbDUtcXJjb2RlLWRlY29kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js\n\n}");

/***/ }),

/***/ "../../../node_modules/html5-qrcode/third_party/zxing-js.umd.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/html5-qrcode/third_party/zxing-js.umd.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{(function (global, factory) {\n     true ? factory(exports) :\n    0;\n}(this, (function (exports) { 'use strict';\n\n    function isNullOrUndefined(obj) {\n        return obj === null || obj === undefined;\n    }\n\n    /*\n     * Copyright 2008 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /* global Reflect, Promise */\n\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\n    function __extends(d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n\n    function fixProto(target, prototype) {\n        var setPrototypeOf = Object.setPrototypeOf;\n        setPrototypeOf ? setPrototypeOf(target, prototype) : (target.__proto__ = prototype);\n    }\n\n    function fixStack(target, fn) {\n        if (fn === void 0) {\n            fn = target.constructor;\n        }\n        var captureStackTrace = Error.captureStackTrace;\n        captureStackTrace && captureStackTrace(target, fn);\n    }\n\n    var CustomError = (function (_super) {\n        __extends(CustomError, _super);\n        function CustomError(message) {\n            var _newTarget = this.constructor;\n            var _this = _super.call(this, message) || this;\n            Object.defineProperty(_this, 'name', {\n                value: _newTarget.name,\n                enumerable: false\n            });\n            fixProto(_this, _newTarget.prototype);\n            fixStack(_this);\n            return _this;\n        }\n        \n        return CustomError;\n    })(Error);\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class Exception extends CustomError {\n        /**\n         * Allows Exception to be constructed directly\n         * with some message and prototype definition.\n         */\n        constructor(message = undefined) {\n            super(message);\n            this.message = message;\n        }\n        getKind() {\n            const ex = this.constructor;\n            return ex.kind;\n        }\n    }\n    /**\n     * It's typed as string so it can be extended and overriden.\n     */\n    Exception.kind = 'Exception';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ArgumentException extends Exception {\n    }\n    ArgumentException.kind = 'ArgumentException';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class IllegalArgumentException extends Exception {\n    }\n    IllegalArgumentException.kind = 'IllegalArgumentException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    class BinaryBitmap {\n        constructor(binarizer) {\n            this.binarizer = binarizer;\n            if (binarizer === null) {\n                throw new IllegalArgumentException('Binarizer must be non-null.');\n            }\n        }\n        /**\n         * @return The width of the bitmap.\n         */\n        getWidth() {\n            return this.binarizer.getWidth();\n        }\n        /**\n         * @return The height of the bitmap.\n         */\n        getHeight() {\n            return this.binarizer.getHeight();\n        }\n        /**\n         * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return\n         * cached data. Callers should assume this method is expensive and call it as seldom as possible.\n         * This method is intended for decoding 1D barcodes and may choose to apply sharpening.\n         *\n         * @param y The row to fetch, which must be in [0, bitmap height)\n         * @param row An optional preallocated array. If null or too small, it will be ignored.\n         *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.\n         * @return The array of bits for this row (true means black).\n         * @throws NotFoundException if row can't be binarized\n         */\n        getBlackRow(y /*int*/, row) {\n            return this.binarizer.getBlackRow(y, row);\n        }\n        /**\n         * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive\n         * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or\n         * may not apply sharpening. Therefore, a row from this matrix may not be identical to one\n         * fetched using getBlackRow(), so don't mix and match between them.\n         *\n         * @return The 2D array of bits for the image (true means black).\n         * @throws NotFoundException if image can't be binarized to make a matrix\n         */\n        getBlackMatrix() {\n            // The matrix is created on demand the first time it is requested, then cached. There are two\n            // reasons for this:\n            // 1. This work will never be done if the caller only installs 1D Reader objects, or if a\n            //    1D Reader finds a barcode before the 2D Readers run.\n            // 2. This work will only be done once even if the caller installs multiple 2D Readers.\n            if (this.matrix === null || this.matrix === undefined) {\n                this.matrix = this.binarizer.getBlackMatrix();\n            }\n            return this.matrix;\n        }\n        /**\n         * @return Whether this bitmap can be cropped.\n         */\n        isCropSupported() {\n            return this.binarizer.getLuminanceSource().isCropSupported();\n        }\n        /**\n         * Returns a new object with cropped image data. Implementations may keep a reference to the\n         * original data rather than a copy. Only callable if isCropSupported() is true.\n         *\n         * @param left The left coordinate, which must be in [0,getWidth())\n         * @param top The top coordinate, which must be in [0,getHeight())\n         * @param width The width of the rectangle to crop.\n         * @param height The height of the rectangle to crop.\n         * @return A cropped version of this object.\n         */\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /**\n         * @return Whether this bitmap supports counter-clockwise rotation.\n         */\n        isRotateSupported() {\n            return this.binarizer.getLuminanceSource().isRotateSupported();\n        }\n        /**\n         * Returns a new object with rotated image data by 90 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise() {\n            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /**\n         * Returns a new object with rotated image data by 45 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise45() {\n            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();\n            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));\n        }\n        /*@Override*/\n        toString() {\n            try {\n                return this.getBlackMatrix().toString();\n            }\n            catch (e /*: NotFoundException*/) {\n                return '';\n            }\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ChecksumException extends Exception {\n        static getChecksumInstance() {\n            return new ChecksumException();\n        }\n    }\n    ChecksumException.kind = 'ChecksumException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.\n     * It allows the algorithm to vary polymorphically, for example allowing a very expensive\n     * thresholding technique for servers and a fast one for mobile. It also permits the implementation\n     * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class Binarizer {\n        constructor(source) {\n            this.source = source;\n        }\n        getLuminanceSource() {\n            return this.source;\n        }\n        getWidth() {\n            return this.source.getWidth();\n        }\n        getHeight() {\n            return this.source.getHeight();\n        }\n    }\n\n    class System {\n        // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\n        /**\n         * Makes a copy of a array.\n         */\n        static arraycopy(src, srcPos, dest, destPos, length) {\n            // TODO: better use split or set?\n            while (length--) {\n                dest[destPos++] = src[srcPos++];\n            }\n        }\n        /**\n         * Returns the current time in milliseconds.\n         */\n        static currentTimeMillis() {\n            return Date.now();\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class IndexOutOfBoundsException extends Exception {\n    }\n    IndexOutOfBoundsException.kind = 'IndexOutOfBoundsException';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {\n        constructor(index = undefined, message = undefined) {\n            super(message);\n            this.index = index;\n            this.message = message;\n        }\n    }\n    ArrayIndexOutOfBoundsException.kind = 'ArrayIndexOutOfBoundsException';\n\n    class Arrays {\n        /**\n         * Assigns the specified int value to each element of the specified array\n         * of ints.\n         *\n         * @param a the array to be filled\n         * @param val the value to be stored in all elements of the array\n         */\n        static fill(a, val) {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] = val;\n        }\n        /**\n         * Assigns the specified int value to each element of the specified\n         * range of the specified array of ints.  The range to be filled\n         * extends from index {@code fromIndex}, inclusive, to index\n         * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n         * range to be filled is empty.)\n         *\n         * @param a the array to be filled\n         * @param fromIndex the index of the first element (inclusive) to be\n         *        filled with the specified value\n         * @param toIndex the index of the last element (exclusive) to be\n         *        filled with the specified value\n         * @param val the value to be stored in all elements of the array\n         * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n         * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n         *         {@code toIndex > a.length}\n         */\n        static fillWithin(a, fromIndex, toIndex, val) {\n            Arrays.rangeCheck(a.length, fromIndex, toIndex);\n            for (let i = fromIndex; i < toIndex; i++)\n                a[i] = val;\n        }\n        /**\n         * Checks that {@code fromIndex} and {@code toIndex} are in\n         * the range and throws an exception if they aren't.\n         */\n        static rangeCheck(arrayLength, fromIndex, toIndex) {\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException('fromIndex(' + fromIndex + ') > toIndex(' + toIndex + ')');\n            }\n            if (fromIndex < 0) {\n                throw new ArrayIndexOutOfBoundsException(fromIndex);\n            }\n            if (toIndex > arrayLength) {\n                throw new ArrayIndexOutOfBoundsException(toIndex);\n            }\n        }\n        static asList(...args) {\n            return args;\n        }\n        static create(rows, cols, value) {\n            let arr = Array.from({ length: rows });\n            return arr.map(x => Array.from({ length: cols }).fill(value));\n        }\n        static createInt32Array(rows, cols, value) {\n            let arr = Array.from({ length: rows });\n            return arr.map(x => Int32Array.from({ length: cols }).fill(value));\n        }\n        static equals(first, second) {\n            if (!first) {\n                return false;\n            }\n            if (!second) {\n                return false;\n            }\n            if (!first.length) {\n                return false;\n            }\n            if (!second.length) {\n                return false;\n            }\n            if (first.length !== second.length) {\n                return false;\n            }\n            for (let i = 0, length = first.length; i < length; i++) {\n                if (first[i] !== second[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static hashCode(a) {\n            if (a === null) {\n                return 0;\n            }\n            let result = 1;\n            for (const element of a) {\n                result = 31 * result + element;\n            }\n            return result;\n        }\n        static fillUint8Array(a, value) {\n            for (let i = 0; i !== a.length; i++) {\n                a[i] = value;\n            }\n        }\n        static copyOf(original, newLength) {\n            return original.slice(0, newLength);\n        }\n        static copyOfUint8Array(original, newLength) {\n            if (original.length <= newLength) {\n                const newArray = new Uint8Array(newLength);\n                newArray.set(original);\n                return newArray;\n            }\n            return original.slice(0, newLength);\n        }\n        static copyOfRange(original, from, to) {\n            const newLength = to - from;\n            const copy = new Int32Array(newLength);\n            System.arraycopy(original, from, copy, 0, newLength);\n            return copy;\n        }\n        /*\n        * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point\n        * for the new element.\n        * Parameters:\n        *     ar - A sorted array\n        *     el - An element to search for\n        *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:\n        *        a negative number  if a is less than b;\n        *        0 if a is equal to b;\n        *        a positive number of a is greater than b.\n        * The array may contain duplicate elements. If there are more than one equal elements in the array,\n        * the returned value can be the index of any one of the equal elements.\n        *\n        * http://jsfiddle.net/aryzhov/pkfst550/\n        */\n        static binarySearch(ar, el, comparator) {\n            if (undefined === comparator) {\n                comparator = Arrays.numberComparator;\n            }\n            let m = 0;\n            let n = ar.length - 1;\n            while (m <= n) {\n                const k = (n + m) >> 1;\n                const cmp = comparator(el, ar[k]);\n                if (cmp > 0) {\n                    m = k + 1;\n                }\n                else if (cmp < 0) {\n                    n = k - 1;\n                }\n                else {\n                    return k;\n                }\n            }\n            return -m - 1;\n        }\n        static numberComparator(a, b) {\n            return a - b;\n        }\n    }\n\n    /**\n     * Ponyfill for Java's Integer class.\n     */\n    class Integer {\n        static numberOfTrailingZeros(i) {\n            let y;\n            if (i === 0)\n                return 32;\n            let n = 31;\n            y = i << 16;\n            if (y !== 0) {\n                n -= 16;\n                i = y;\n            }\n            y = i << 8;\n            if (y !== 0) {\n                n -= 8;\n                i = y;\n            }\n            y = i << 4;\n            if (y !== 0) {\n                n -= 4;\n                i = y;\n            }\n            y = i << 2;\n            if (y !== 0) {\n                n -= 2;\n                i = y;\n            }\n            return n - ((i << 1) >>> 31);\n        }\n        static numberOfLeadingZeros(i) {\n            // HD, Figure 5-6\n            if (i === 0) {\n                return 32;\n            }\n            let n = 1;\n            if (i >>> 16 === 0) {\n                n += 16;\n                i <<= 16;\n            }\n            if (i >>> 24 === 0) {\n                n += 8;\n                i <<= 8;\n            }\n            if (i >>> 28 === 0) {\n                n += 4;\n                i <<= 4;\n            }\n            if (i >>> 30 === 0) {\n                n += 2;\n                i <<= 2;\n            }\n            n -= i >>> 31;\n            return n;\n        }\n        static toHexString(i) {\n            return i.toString(16);\n        }\n        static toBinaryString(intNumber) {\n            return String(parseInt(String(intNumber), 2));\n        }\n        // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.\n        // Returns:\n        // the number of one-bits in the two's complement binary representation of the specified int value.\n        static bitCount(i) {\n            // HD, Figure 5-2\n            i = i - ((i >>> 1) & 0x55555555);\n            i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n            i = (i + (i >>> 4)) & 0x0f0f0f0f;\n            i = i + (i >>> 8);\n            i = i + (i >>> 16);\n            return i & 0x3f;\n        }\n        static truncDivision(dividend, divisor) {\n            return Math.trunc(dividend / divisor);\n        }\n        /**\n         * Converts A string to an integer.\n         * @param s A string to convert into a number.\n         * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.\n         */\n        static parseInt(num, radix = undefined) {\n            return parseInt(num, radix);\n        }\n    }\n    Integer.MIN_VALUE_32_BITS = -2147483648;\n    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n\n    /**\n     * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>\n     *\n     * @author Sean Owen\n     */\n    class BitArray /*implements Cloneable*/ {\n        // For testing only\n        constructor(size /*int*/, bits) {\n            if (undefined === size) {\n                this.size = 0;\n                this.bits = new Int32Array(1);\n            }\n            else {\n                this.size = size;\n                if (undefined === bits || null === bits) {\n                    this.bits = BitArray.makeArray(size);\n                }\n                else {\n                    this.bits = bits;\n                }\n            }\n        }\n        getSize() {\n            return this.size;\n        }\n        getSizeInBytes() {\n            return Math.floor((this.size + 7) / 8);\n        }\n        ensureCapacity(size /*int*/) {\n            if (size > this.bits.length * 32) {\n                const newBits = BitArray.makeArray(size);\n                System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);\n                this.bits = newBits;\n            }\n        }\n        /**\n         * @param i bit to get\n         * @return true iff bit i is set\n         */\n        get(i /*int*/) {\n            return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;\n        }\n        /**\n         * Sets bit i.\n         *\n         * @param i bit to set\n         */\n        set(i /*int*/) {\n            this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);\n        }\n        /**\n         * Flips bit i.\n         *\n         * @param i bit to set\n         */\n        flip(i /*int*/) {\n            this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);\n        }\n        /**\n         * @param from first bit to check\n         * @return index of first bit that is set, starting from the given index, or size if none are set\n         *  at or beyond this given index\n         * @see #getNextUnset(int)\n         */\n        getNextSet(from /*int*/) {\n            const size = this.size;\n            if (from >= size) {\n                return size;\n            }\n            const bits = this.bits;\n            let bitsOffset = Math.floor(from / 32);\n            let currentBits = bits[bitsOffset];\n            // mask off lesser bits first\n            currentBits &= ~((1 << (from & 0x1F)) - 1);\n            const length = bits.length;\n            while (currentBits === 0) {\n                if (++bitsOffset === length) {\n                    return size;\n                }\n                currentBits = bits[bitsOffset];\n            }\n            const result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);\n            return result > size ? size : result;\n        }\n        /**\n         * @param from index to start looking for unset bit\n         * @return index of next unset bit, or {@code size} if none are unset until the end\n         * @see #getNextSet(int)\n         */\n        getNextUnset(from /*int*/) {\n            const size = this.size;\n            if (from >= size) {\n                return size;\n            }\n            const bits = this.bits;\n            let bitsOffset = Math.floor(from / 32);\n            let currentBits = ~bits[bitsOffset];\n            // mask off lesser bits first\n            currentBits &= ~((1 << (from & 0x1F)) - 1);\n            const length = bits.length;\n            while (currentBits === 0) {\n                if (++bitsOffset === length) {\n                    return size;\n                }\n                currentBits = ~bits[bitsOffset];\n            }\n            const result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);\n            return result > size ? size : result;\n        }\n        /**\n         * Sets a block of 32 bits, starting at bit i.\n         *\n         * @param i first bit to set\n         * @param newBits the new value of the next 32 bits. Note again that the least-significant bit\n         * corresponds to bit i, the next-least-significant to i+1, and so on.\n         */\n        setBulk(i /*int*/, newBits /*int*/) {\n            this.bits[Math.floor(i / 32)] = newBits;\n        }\n        /**\n         * Sets a range of bits.\n         *\n         * @param start start of range, inclusive.\n         * @param end end of range, exclusive\n         */\n        setRange(start /*int*/, end /*int*/) {\n            if (end < start || start < 0 || end > this.size) {\n                throw new IllegalArgumentException();\n            }\n            if (end === start) {\n                return;\n            }\n            end--; // will be easier to treat this as the last actually set bit -- inclusive\n            const firstInt = Math.floor(start / 32);\n            const lastInt = Math.floor(end / 32);\n            const bits = this.bits;\n            for (let i = firstInt; i <= lastInt; i++) {\n                const firstBit = i > firstInt ? 0 : start & 0x1F;\n                const lastBit = i < lastInt ? 31 : end & 0x1F;\n                // Ones from firstBit to lastBit, inclusive\n                const mask = (2 << lastBit) - (1 << firstBit);\n                bits[i] |= mask;\n            }\n        }\n        /**\n         * Clears all bits (sets to false).\n         */\n        clear() {\n            const max = this.bits.length;\n            const bits = this.bits;\n            for (let i = 0; i < max; i++) {\n                bits[i] = 0;\n            }\n        }\n        /**\n         * Efficient method to check if a range of bits is set, or not set.\n         *\n         * @param start start of range, inclusive.\n         * @param end end of range, exclusive\n         * @param value if true, checks that bits in range are set, otherwise checks that they are not set\n         * \n         * @return true iff all bits are set or not set in range, according to value argument\n         * @throws IllegalArgumentException if end is less than start or the range is not contained in the array\n         */\n        isRange(start /*int*/, end /*int*/, value) {\n            if (end < start || start < 0 || end > this.size) {\n                throw new IllegalArgumentException();\n            }\n            if (end === start) {\n                return true; // empty range matches\n            }\n            end--; // will be easier to treat this as the last actually set bit -- inclusive\n            const firstInt = Math.floor(start / 32);\n            const lastInt = Math.floor(end / 32);\n            const bits = this.bits;\n            for (let i = firstInt; i <= lastInt; i++) {\n                const firstBit = i > firstInt ? 0 : start & 0x1F;\n                const lastBit = i < lastInt ? 31 : end & 0x1F;\n                // Ones from firstBit to lastBit, inclusive\n                const mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;\n                // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits\n                // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,\n                // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n                if ((bits[i] & mask) !== (value ? mask : 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        appendBit(bit) {\n            this.ensureCapacity(this.size + 1);\n            if (bit) {\n                this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);\n            }\n            this.size++;\n        }\n        /**\n         * Appends the least-significant bits, from value, in order from most-significant to\n         * least-significant. For example, appending 6 bits from 0x000001E will append the bits\n         * 0, 1, 1, 1, 1, 0 in that order.\n         *\n         * @param value {@code int} containing bits to append\n         * @param numBits bits from value to append\n         */\n        appendBits(value /*int*/, numBits /*int*/) {\n            if (numBits < 0 || numBits > 32) {\n                throw new IllegalArgumentException('Num bits must be between 0 and 32');\n            }\n            this.ensureCapacity(this.size + numBits);\n            // const appendBit = this.appendBit;\n            for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {\n                this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);\n            }\n        }\n        appendBitArray(other) {\n            const otherSize = other.size;\n            this.ensureCapacity(this.size + otherSize);\n            // const appendBit = this.appendBit;\n            for (let i = 0; i < otherSize; i++) {\n                this.appendBit(other.get(i));\n            }\n        }\n        xor(other) {\n            if (this.size !== other.size) {\n                throw new IllegalArgumentException('Sizes don\\'t match');\n            }\n            const bits = this.bits;\n            for (let i = 0, length = bits.length; i < length; i++) {\n                // The last int could be incomplete (i.e. not have 32 bits in\n                // it) but there is no problem since 0 XOR 0 == 0.\n                bits[i] ^= other.bits[i];\n            }\n        }\n        /**\n         *\n         * @param bitOffset first bit to start writing\n         * @param array array to write into. Bytes are written most-significant byte first. This is the opposite\n         *  of the internal representation, which is exposed by {@link #getBitArray()}\n         * @param offset position in array to start writing\n         * @param numBytes how many bytes to write\n         */\n        toBytes(bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {\n            for (let i = 0; i < numBytes; i++) {\n                let theByte = 0;\n                for (let j = 0; j < 8; j++) {\n                    if (this.get(bitOffset)) {\n                        theByte |= 1 << (7 - j);\n                    }\n                    bitOffset++;\n                }\n                array[offset + i] = /*(byte)*/ theByte;\n            }\n        }\n        /**\n         * @return underlying array of ints. The first element holds the first 32 bits, and the least\n         *         significant bit is bit 0.\n         */\n        getBitArray() {\n            return this.bits;\n        }\n        /**\n         * Reverses all bits in the array.\n         */\n        reverse() {\n            const newBits = new Int32Array(this.bits.length);\n            // reverse all int's first\n            const len = Math.floor((this.size - 1) / 32);\n            const oldBitsLen = len + 1;\n            const bits = this.bits;\n            for (let i = 0; i < oldBitsLen; i++) {\n                let x = bits[i];\n                x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n                x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n                x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n                x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n                x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n                newBits[len - i] = /*(int)*/ x;\n            }\n            // now correct the int's if the bit size isn't a multiple of 32\n            if (this.size !== oldBitsLen * 32) {\n                const leftOffset = oldBitsLen * 32 - this.size;\n                let currentInt = newBits[0] >>> leftOffset;\n                for (let i = 1; i < oldBitsLen; i++) {\n                    const nextInt = newBits[i];\n                    currentInt |= nextInt << (32 - leftOffset);\n                    newBits[i - 1] = currentInt;\n                    currentInt = nextInt >>> leftOffset;\n                }\n                newBits[oldBitsLen - 1] = currentInt;\n            }\n            this.bits = newBits;\n        }\n        static makeArray(size /*int*/) {\n            return new Int32Array(Math.floor((size + 31) / 32));\n        }\n        /*@Override*/\n        equals(o) {\n            if (!(o instanceof BitArray)) {\n                return false;\n            }\n            const other = o;\n            return this.size === other.size && Arrays.equals(this.bits, other.bits);\n        }\n        /*@Override*/\n        hashCode() {\n            return 31 * this.size + Arrays.hashCode(this.bits);\n        }\n        /*@Override*/\n        toString() {\n            let result = '';\n            for (let i = 0, size = this.size; i < size; i++) {\n                if ((i & 0x07) === 0) {\n                    result += ' ';\n                }\n                result += this.get(i) ? 'X' : '.';\n            }\n            return result;\n        }\n        /*@Override*/\n        clone() {\n            return new BitArray(this.size, this.bits.slice());\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * Encapsulates a type of hint that a caller may pass to a barcode reader to help it\n     * more quickly or accurately decode it. It is up to implementations to decide what,\n     * if anything, to do with the information that is supplied.\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @see Reader#decode(BinaryBitmap,java.util.Map)\n     */\n    var DecodeHintType;\n    (function (DecodeHintType) {\n        /**\n         * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.\n         */\n        DecodeHintType[DecodeHintType[\"OTHER\"] = 0] = \"OTHER\"; /*(Object.class)*/\n        /**\n         * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"PURE_BARCODE\"] = 1] = \"PURE_BARCODE\"; /*(Void.class)*/\n        /**\n         * Image is known to be of one of a few possible formats.\n         * Maps to a {@link List} of {@link BarcodeFormat}s.\n         */\n        DecodeHintType[DecodeHintType[\"POSSIBLE_FORMATS\"] = 2] = \"POSSIBLE_FORMATS\"; /*(List.class)*/\n        /**\n         * Spend more time to try to find a barcode; optimize for accuracy, not speed.\n         * Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"TRY_HARDER\"] = 3] = \"TRY_HARDER\"; /*(Void.class)*/\n        /**\n         * Specifies what character encoding to use when decoding, where applicable (type String)\n         */\n        DecodeHintType[DecodeHintType[\"CHARACTER_SET\"] = 4] = \"CHARACTER_SET\"; /*(String.class)*/\n        /**\n         * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.\n         */\n        DecodeHintType[DecodeHintType[\"ALLOWED_LENGTHS\"] = 5] = \"ALLOWED_LENGTHS\"; /*(Int32Array.class)*/\n        /**\n         * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"ASSUME_CODE_39_CHECK_DIGIT\"] = 6] = \"ASSUME_CODE_39_CHECK_DIGIT\"; /*(Void.class)*/\n        /**\n         * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.\n         * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;\n         * use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"ASSUME_GS1\"] = 7] = \"ASSUME_GS1\"; /*(Void.class)*/\n        /**\n         * If true, return the start and end digits in a Codabar barcode instead of stripping them. They\n         * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them\n         * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.\n         */\n        DecodeHintType[DecodeHintType[\"RETURN_CODABAR_START_END\"] = 8] = \"RETURN_CODABAR_START_END\"; /*(Void.class)*/\n        /**\n         * The caller needs to be notified via callback when a possible {@link ResultPoint}\n         * is found. Maps to a {@link ResultPointCallback}.\n         */\n        DecodeHintType[DecodeHintType[\"NEED_RESULT_POINT_CALLBACK\"] = 9] = \"NEED_RESULT_POINT_CALLBACK\"; /*(ResultPointCallback.class)*/\n        /**\n         * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.\n         * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].\n         * If it is optional to have an extension, do not set this hint. If this is set,\n         * and a UPC or EAN barcode is found but an extension is not, then no result will be returned\n         * at all.\n         */\n        DecodeHintType[DecodeHintType[\"ALLOWED_EAN_EXTENSIONS\"] = 10] = \"ALLOWED_EAN_EXTENSIONS\"; /*(Int32Array.class)*/\n        // End of enumeration values.\n        /**\n         * Data type the hint is expecting.\n         * Among the possible values the {@link Void} stands out as being used for\n         * hints that do not expect a value to be supplied (flag hints). Such hints\n         * will possibly have their value ignored, or replaced by a\n         * {@link Boolean#TRUE}. Hint suppliers should probably use\n         * {@link Boolean#TRUE} as directed by the actual hint documentation.\n         */\n        // private valueType: Class<?>\n        // DecodeHintType(valueType: Class<?>) {\n        //   this.valueType = valueType\n        // }\n        // public getValueType(): Class<?> {\n        //   return valueType\n        // }\n    })(DecodeHintType || (DecodeHintType = {}));\n    var DecodeHintType$1 = DecodeHintType;\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class FormatException extends Exception {\n        static getFormatInstance() {\n            return new FormatException();\n        }\n    }\n    FormatException.kind = 'FormatException';\n\n    /*import java.util.HashMap;*/\n    /*import java.util.Map;*/\n    var CharacterSetValueIdentifiers;\n    (function (CharacterSetValueIdentifiers) {\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp437\"] = 0] = \"Cp437\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_1\"] = 1] = \"ISO8859_1\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_2\"] = 2] = \"ISO8859_2\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_3\"] = 3] = \"ISO8859_3\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_4\"] = 4] = \"ISO8859_4\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_5\"] = 5] = \"ISO8859_5\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_6\"] = 6] = \"ISO8859_6\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_7\"] = 7] = \"ISO8859_7\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_8\"] = 8] = \"ISO8859_8\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_9\"] = 9] = \"ISO8859_9\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_10\"] = 10] = \"ISO8859_10\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_11\"] = 11] = \"ISO8859_11\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_13\"] = 12] = \"ISO8859_13\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_14\"] = 13] = \"ISO8859_14\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_15\"] = 14] = \"ISO8859_15\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ISO8859_16\"] = 15] = \"ISO8859_16\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"SJIS\"] = 16] = \"SJIS\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1250\"] = 17] = \"Cp1250\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1251\"] = 18] = \"Cp1251\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1252\"] = 19] = \"Cp1252\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Cp1256\"] = 20] = \"Cp1256\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UnicodeBigUnmarked\"] = 21] = \"UnicodeBigUnmarked\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"UTF8\"] = 22] = \"UTF8\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"ASCII\"] = 23] = \"ASCII\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"Big5\"] = 24] = \"Big5\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"GB18030\"] = 25] = \"GB18030\";\n        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers[\"EUC_KR\"] = 26] = \"EUC_KR\";\n    })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));\n    /**\n     * Encapsulates a Character Set ECI, according to \"Extended Channel Interpretations\" 5.3.1.1\n     * of ISO 18004.\n     *\n     * @author Sean Owen\n     */\n    class CharacterSetECI {\n        constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames) {\n            this.valueIdentifier = valueIdentifier;\n            this.name = name;\n            if (typeof valuesParam === 'number') {\n                this.values = Int32Array.from([valuesParam]);\n            }\n            else {\n                this.values = valuesParam;\n            }\n            this.otherEncodingNames = otherEncodingNames;\n            CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);\n            CharacterSetECI.NAME_TO_ECI.set(name, this);\n            const values = this.values;\n            for (let i = 0, length = values.length; i !== length; i++) {\n                const v = values[i];\n                CharacterSetECI.VALUES_TO_ECI.set(v, this);\n            }\n            for (const otherName of otherEncodingNames) {\n                CharacterSetECI.NAME_TO_ECI.set(otherName, this);\n            }\n        }\n        // CharacterSetECI(value: number /*int*/) {\n        //   this(new Int32Array {value})\n        // }\n        // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {\n        //   this.values = new Int32Array {value}\n        //   this.otherEncodingNames = otherEncodingNames\n        // }\n        // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {\n        //   this.values = values\n        //   this.otherEncodingNames = otherEncodingNames\n        // }\n        getValueIdentifier() {\n            return this.valueIdentifier;\n        }\n        getName() {\n            return this.name;\n        }\n        getValue() {\n            return this.values[0];\n        }\n        /**\n         * @param value character set ECI value\n         * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but\n         *   unsupported\n         * @throws FormatException if ECI value is invalid\n         */\n        static getCharacterSetECIByValue(value /*int*/) {\n            if (value < 0 || value >= 900) {\n                throw new FormatException('incorect value');\n            }\n            const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);\n            if (undefined === characterSet) {\n                throw new FormatException('incorect value');\n            }\n            return characterSet;\n        }\n        /**\n         * @param name character set ECI encoding name\n         * @return CharacterSetECI representing ECI for character encoding, or null if it is legal\n         *   but unsupported\n         */\n        static getCharacterSetECIByName(name) {\n            const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);\n            if (undefined === characterSet) {\n                throw new FormatException('incorect value');\n            }\n            return characterSet;\n        }\n        equals(o) {\n            if (!(o instanceof CharacterSetECI)) {\n                return false;\n            }\n            const other = o;\n            return this.getName() === other.getName();\n        }\n    }\n    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();\n    CharacterSetECI.VALUES_TO_ECI = new Map();\n    CharacterSetECI.NAME_TO_ECI = new Map();\n    // Enum name is a Java encoding valid for java.lang and java.io\n    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java\n    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)\n    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default\n    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');\n    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');\n    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');\n    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');\n    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');\n    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');\n    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');\n    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');\n    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');\n    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');\n    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');\n    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');\n    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');\n    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');\n    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');\n    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');\n    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');\n    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');\n    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');\n    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');\n    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');\n    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');\n    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');\n    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');\n    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');\n    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');\n    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class UnsupportedOperationException extends Exception {\n    }\n    UnsupportedOperationException.kind = 'UnsupportedOperationException';\n\n    /**\n     * Responsible for en/decoding strings.\n     */\n    class StringEncoding {\n        /**\n         * Decodes some Uint8Array to a string format.\n         */\n        static decode(bytes, encoding) {\n            const encodingName = this.encodingName(encoding);\n            if (this.customDecoder) {\n                return this.customDecoder(bytes, encodingName);\n            }\n            // Increases browser support.\n            if (typeof TextDecoder === 'undefined' || this.shouldDecodeOnFallback(encodingName)) {\n                return this.decodeFallback(bytes, encodingName);\n            }\n            return new TextDecoder(encodingName).decode(bytes);\n        }\n        /**\n         * Checks if the decoding method should use the fallback for decoding\n         * once Node TextDecoder doesn't support all encoding formats.\n         *\n         * @param encodingName\n         */\n        static shouldDecodeOnFallback(encodingName) {\n            return !StringEncoding.isBrowser() && encodingName === 'ISO-8859-1';\n        }\n        /**\n         * Encodes some string into a Uint8Array.\n         */\n        static encode(s, encoding) {\n            const encodingName = this.encodingName(encoding);\n            if (this.customEncoder) {\n                return this.customEncoder(s, encodingName);\n            }\n            // Increases browser support.\n            if (typeof TextEncoder === 'undefined') {\n                return this.encodeFallback(s);\n            }\n            // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org\n            return new TextEncoder().encode(s);\n        }\n        static isBrowser() {\n            return (typeof window !== 'undefined' && {}.toString.call(window) === '[object Window]');\n        }\n        /**\n         * Returns the string value from some encoding character set.\n         */\n        static encodingName(encoding) {\n            return typeof encoding === 'string'\n                ? encoding\n                : encoding.getName();\n        }\n        /**\n         * Returns character set from some encoding character set.\n         */\n        static encodingCharacterSet(encoding) {\n            if (encoding instanceof CharacterSetECI) {\n                return encoding;\n            }\n            return CharacterSetECI.getCharacterSetECIByName(encoding);\n        }\n        /**\n         * Runs a fallback for the native decoding funcion.\n         */\n        static decodeFallback(bytes, encoding) {\n            const characterSet = this.encodingCharacterSet(encoding);\n            if (StringEncoding.isDecodeFallbackSupported(characterSet)) {\n                let s = '';\n                for (let i = 0, length = bytes.length; i < length; i++) {\n                    let h = bytes[i].toString(16);\n                    if (h.length < 2) {\n                        h = '0' + h;\n                    }\n                    s += '%' + h;\n                }\n                return decodeURIComponent(s);\n            }\n            if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {\n                return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n            }\n            throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);\n        }\n        static isDecodeFallbackSupported(characterSet) {\n            return characterSet.equals(CharacterSetECI.UTF8) ||\n                characterSet.equals(CharacterSetECI.ISO8859_1) ||\n                characterSet.equals(CharacterSetECI.ASCII);\n        }\n        /**\n         * Runs a fallback for the native encoding funcion.\n         *\n         * @see https://stackoverflow.com/a/17192845/4367683\n         */\n        static encodeFallback(s) {\n            const encodedURIstring = btoa(unescape(encodeURIComponent(s)));\n            const charList = encodedURIstring.split('');\n            const uintArray = [];\n            for (let i = 0; i < charList.length; i++) {\n                uintArray.push(charList[i].charCodeAt(0));\n            }\n            return new Uint8Array(uintArray);\n        }\n    }\n\n    /*\n     * Copyright (C) 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * Common string-related functions.\n     *\n     * @author Sean Owen\n     * @author Alex Dupre\n     */\n    class StringUtils {\n        // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||\n        // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);\n        static castAsNonUtf8Char(code, encoding = null) {\n            // ISO 8859-1 is the Java default as UTF-8 is JavaScripts\n            // you can see this method as a Java version of String.fromCharCode\n            const e = encoding ? encoding.getName() : this.ISO88591;\n            // use passed format (fromCharCode will return UTF8 encoding)\n            return StringEncoding.decode(new Uint8Array([code]), e);\n        }\n        /**\n         * @param bytes bytes encoding a string, whose encoding should be guessed\n         * @param hints decode hints if applicable\n         * @return name of guessed encoding; at the moment will only guess one of:\n         *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform\n         *  default encoding if none of these can possibly be correct\n         */\n        static guessEncoding(bytes, hints) {\n            if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.CHARACTER_SET)) {\n                return hints.get(DecodeHintType$1.CHARACTER_SET).toString();\n            }\n            // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,\n            // which should be by far the most common encodings.\n            const length = bytes.length;\n            let canBeISO88591 = true;\n            let canBeShiftJIS = true;\n            let canBeUTF8 = true;\n            let utf8BytesLeft = 0;\n            // int utf8LowChars = 0\n            let utf2BytesChars = 0;\n            let utf3BytesChars = 0;\n            let utf4BytesChars = 0;\n            let sjisBytesLeft = 0;\n            // int sjisLowChars = 0\n            let sjisKatakanaChars = 0;\n            // int sjisDoubleBytesChars = 0\n            let sjisCurKatakanaWordLength = 0;\n            let sjisCurDoubleBytesWordLength = 0;\n            let sjisMaxKatakanaWordLength = 0;\n            let sjisMaxDoubleBytesWordLength = 0;\n            // int isoLowChars = 0\n            // int isoHighChars = 0\n            let isoHighOther = 0;\n            const utf8bom = bytes.length > 3 &&\n                bytes[0] === /*(byte) */ 0xEF &&\n                bytes[1] === /*(byte) */ 0xBB &&\n                bytes[2] === /*(byte) */ 0xBF;\n            for (let i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {\n                const value = bytes[i] & 0xFF;\n                // UTF-8 stuff\n                if (canBeUTF8) {\n                    if (utf8BytesLeft > 0) {\n                        if ((value & 0x80) === 0) {\n                            canBeUTF8 = false;\n                        }\n                        else {\n                            utf8BytesLeft--;\n                        }\n                    }\n                    else if ((value & 0x80) !== 0) {\n                        if ((value & 0x40) === 0) {\n                            canBeUTF8 = false;\n                        }\n                        else {\n                            utf8BytesLeft++;\n                            if ((value & 0x20) === 0) {\n                                utf2BytesChars++;\n                            }\n                            else {\n                                utf8BytesLeft++;\n                                if ((value & 0x10) === 0) {\n                                    utf3BytesChars++;\n                                }\n                                else {\n                                    utf8BytesLeft++;\n                                    if ((value & 0x08) === 0) {\n                                        utf4BytesChars++;\n                                    }\n                                    else {\n                                        canBeUTF8 = false;\n                                    }\n                                }\n                            }\n                        }\n                    } // else {\n                    // utf8LowChars++\n                    // }\n                }\n                // ISO-8859-1 stuff\n                if (canBeISO88591) {\n                    if (value > 0x7F && value < 0xA0) {\n                        canBeISO88591 = false;\n                    }\n                    else if (value > 0x9F) {\n                        if (value < 0xC0 || value === 0xD7 || value === 0xF7) {\n                            isoHighOther++;\n                        } // else {\n                        // isoHighChars++\n                        // }\n                    } // else {\n                    // isoLowChars++\n                    // }\n                }\n                // Shift_JIS stuff\n                if (canBeShiftJIS) {\n                    if (sjisBytesLeft > 0) {\n                        if (value < 0x40 || value === 0x7F || value > 0xFC) {\n                            canBeShiftJIS = false;\n                        }\n                        else {\n                            sjisBytesLeft--;\n                        }\n                    }\n                    else if (value === 0x80 || value === 0xA0 || value > 0xEF) {\n                        canBeShiftJIS = false;\n                    }\n                    else if (value > 0xA0 && value < 0xE0) {\n                        sjisKatakanaChars++;\n                        sjisCurDoubleBytesWordLength = 0;\n                        sjisCurKatakanaWordLength++;\n                        if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {\n                            sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;\n                        }\n                    }\n                    else if (value > 0x7F) {\n                        sjisBytesLeft++;\n                        // sjisDoubleBytesChars++\n                        sjisCurKatakanaWordLength = 0;\n                        sjisCurDoubleBytesWordLength++;\n                        if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {\n                            sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;\n                        }\n                    }\n                    else {\n                        // sjisLowChars++\n                        sjisCurKatakanaWordLength = 0;\n                        sjisCurDoubleBytesWordLength = 0;\n                    }\n                }\n            }\n            if (canBeUTF8 && utf8BytesLeft > 0) {\n                canBeUTF8 = false;\n            }\n            if (canBeShiftJIS && sjisBytesLeft > 0) {\n                canBeShiftJIS = false;\n            }\n            // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done\n            if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {\n                return StringUtils.UTF8;\n            }\n            // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done\n            if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {\n                return StringUtils.SHIFT_JIS;\n            }\n            // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:\n            // - If we saw\n            //   - only two consecutive katakana chars in the whole text, or\n            //   - at least 10% of bytes that could be \"upper\" not-alphanumeric Latin1,\n            // - then we conclude Shift_JIS, else ISO-8859-1\n            if (canBeISO88591 && canBeShiftJIS) {\n                return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length\n                    ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;\n            }\n            // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding\n            if (canBeISO88591) {\n                return StringUtils.ISO88591;\n            }\n            if (canBeShiftJIS) {\n                return StringUtils.SHIFT_JIS;\n            }\n            if (canBeUTF8) {\n                return StringUtils.UTF8;\n            }\n            // Otherwise, we take a wild guess with platform encoding\n            return StringUtils.PLATFORM_DEFAULT_ENCODING;\n        }\n        /**\n         *\n         * @see https://stackoverflow.com/a/13439711/4367683\n         *\n         * @param append The new string to append.\n         * @param args Argumets values to be formated.\n         */\n        static format(append, ...args) {\n            let i = -1;\n            function callback(exp, p0, p1, p2, p3, p4) {\n                if (exp === '%%')\n                    return '%';\n                if (args[++i] === undefined)\n                    return undefined;\n                exp = p2 ? parseInt(p2.substr(1)) : undefined;\n                let base = p3 ? parseInt(p3.substr(1)) : undefined;\n                let val;\n                switch (p4) {\n                    case 's':\n                        val = args[i];\n                        break;\n                    case 'c':\n                        val = args[i][0];\n                        break;\n                    case 'f':\n                        val = parseFloat(args[i]).toFixed(exp);\n                        break;\n                    case 'p':\n                        val = parseFloat(args[i]).toPrecision(exp);\n                        break;\n                    case 'e':\n                        val = parseFloat(args[i]).toExponential(exp);\n                        break;\n                    case 'x':\n                        val = parseInt(args[i]).toString(base ? base : 16);\n                        break;\n                    case 'd':\n                        val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                        break;\n                }\n                val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n                let size = parseInt(p1); /* padding size */\n                let ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\n                while (val.length < size)\n                    val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n                return val;\n            }\n            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n            return append.replace(regex, callback);\n        }\n        /**\n         *\n         */\n        static getBytes(str, encoding) {\n            return StringEncoding.encode(str, encoding);\n        }\n        /**\n         * Returns the charcode at the specified index or at index zero.\n         */\n        static getCharCode(str, index = 0) {\n            return str.charCodeAt(index);\n        }\n        /**\n         * Returns char for given charcode\n         */\n        static getCharAt(charCode) {\n            return String.fromCharCode(charCode);\n        }\n    }\n    StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName(); // \"SJIS\"\n    StringUtils.GB2312 = 'GB2312';\n    StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName(); // \"ISO8859_1\"\n    StringUtils.EUC_JP = 'EUC_JP';\n    StringUtils.UTF8 = CharacterSetECI.UTF8.getName(); // \"UTF8\"\n    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // \"UTF8\"//Charset.defaultCharset().name()\n    StringUtils.ASSUME_SHIFT_JIS = false;\n\n    class StringBuilder {\n        constructor(value = '') {\n            this.value = value;\n        }\n        enableDecoding(encoding) {\n            this.encoding = encoding;\n            return this;\n        }\n        append(s) {\n            if (typeof s === 'string') {\n                this.value += s.toString();\n            }\n            else if (this.encoding) {\n                // use passed format (fromCharCode will return UTF8 encoding)\n                this.value += StringUtils.castAsNonUtf8Char(s, this.encoding);\n            }\n            else {\n                // correctly converts from UTF-8, but not other encodings\n                this.value += String.fromCharCode(s);\n            }\n            return this;\n        }\n        appendChars(str, offset, len) {\n            for (let i = offset; offset < offset + len; i++) {\n                this.append(str[i]);\n            }\n            return this;\n        }\n        length() {\n            return this.value.length;\n        }\n        charAt(n) {\n            return this.value.charAt(n);\n        }\n        deleteCharAt(n) {\n            this.value = this.value.substr(0, n) + this.value.substring(n + 1);\n        }\n        setCharAt(n, c) {\n            this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);\n        }\n        substring(start, end) {\n            return this.value.substring(start, end);\n        }\n        /**\n         * @note helper method for RSS Expanded\n         */\n        setLengthToZero() {\n            this.value = '';\n        }\n        toString() {\n            return this.value;\n        }\n        insert(n, c) {\n            this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common\n     * module, x is the column position, and y is the row position. The ordering is always x, y.\n     * The origin is at the top-left.</p>\n     *\n     * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins\n     * with a new int. This is done intentionally so that we can copy out a row into a BitArray very\n     * efficiently.</p>\n     *\n     * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,\n     * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class BitMatrix /*implements Cloneable*/ {\n        /**\n         * Creates an empty square {@link BitMatrix}.\n         *\n         * @param dimension height and width\n         */\n        // public constructor(dimension: number /*int*/) {\n        //   this(dimension, dimension)\n        // }\n        /**\n         * Creates an empty {@link BitMatrix}.\n         *\n         * @param width bit matrix width\n         * @param height bit matrix height\n         */\n        // public constructor(width: number /*int*/, height: number /*int*/) {\n        //   if (width < 1 || height < 1) {\n        //     throw new IllegalArgumentException(\"Both dimensions must be greater than 0\")\n        //   }\n        //   this.width = width\n        //   this.height = height\n        //   this.rowSize = (width + 31) / 32\n        //   bits = new int[rowSize * height];\n        // }\n        constructor(width /*int*/, height /*int*/, rowSize /*int*/, bits) {\n            this.width = width;\n            this.height = height;\n            this.rowSize = rowSize;\n            this.bits = bits;\n            if (undefined === height || null === height) {\n                height = width;\n            }\n            this.height = height;\n            if (width < 1 || height < 1) {\n                throw new IllegalArgumentException('Both dimensions must be greater than 0');\n            }\n            if (undefined === rowSize || null === rowSize) {\n                rowSize = Math.floor((width + 31) / 32);\n            }\n            this.rowSize = rowSize;\n            if (undefined === bits || null === bits) {\n                this.bits = new Int32Array(this.rowSize * this.height);\n            }\n        }\n        /**\n         * Interprets a 2D array of booleans as a {@link BitMatrix}, where \"true\" means an \"on\" bit.\n         *\n         * @function parse\n         * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows\n         * @return {@link BitMatrix} representation of image\n         */\n        static parseFromBooleanArray(image) {\n            const height = image.length;\n            const width = image[0].length;\n            const bits = new BitMatrix(width, height);\n            for (let i = 0; i < height; i++) {\n                const imageI = image[i];\n                for (let j = 0; j < width; j++) {\n                    if (imageI[j]) {\n                        bits.set(j, i);\n                    }\n                }\n            }\n            return bits;\n        }\n        /**\n         *\n         * @function parse\n         * @param stringRepresentation\n         * @param setString\n         * @param unsetString\n         */\n        static parseFromString(stringRepresentation, setString, unsetString) {\n            if (stringRepresentation === null) {\n                throw new IllegalArgumentException('stringRepresentation cannot be null');\n            }\n            const bits = new Array(stringRepresentation.length);\n            let bitsPos = 0;\n            let rowStartPos = 0;\n            let rowLength = -1;\n            let nRows = 0;\n            let pos = 0;\n            while (pos < stringRepresentation.length) {\n                if (stringRepresentation.charAt(pos) === '\\n' ||\n                    stringRepresentation.charAt(pos) === '\\r') {\n                    if (bitsPos > rowStartPos) {\n                        if (rowLength === -1) {\n                            rowLength = bitsPos - rowStartPos;\n                        }\n                        else if (bitsPos - rowStartPos !== rowLength) {\n                            throw new IllegalArgumentException('row lengths do not match');\n                        }\n                        rowStartPos = bitsPos;\n                        nRows++;\n                    }\n                    pos++;\n                }\n                else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {\n                    pos += setString.length;\n                    bits[bitsPos] = true;\n                    bitsPos++;\n                }\n                else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {\n                    pos += unsetString.length;\n                    bits[bitsPos] = false;\n                    bitsPos++;\n                }\n                else {\n                    throw new IllegalArgumentException('illegal character encountered: ' + stringRepresentation.substring(pos));\n                }\n            }\n            // no EOL at end?\n            if (bitsPos > rowStartPos) {\n                if (rowLength === -1) {\n                    rowLength = bitsPos - rowStartPos;\n                }\n                else if (bitsPos - rowStartPos !== rowLength) {\n                    throw new IllegalArgumentException('row lengths do not match');\n                }\n                nRows++;\n            }\n            const matrix = new BitMatrix(rowLength, nRows);\n            for (let i = 0; i < bitsPos; i++) {\n                if (bits[i]) {\n                    matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));\n                }\n            }\n            return matrix;\n        }\n        /**\n         * <p>Gets the requested bit, where true means black.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         * @return value of given bit in matrix\n         */\n        get(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;\n        }\n        /**\n         * <p>Sets the given bit to true.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         */\n        set(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;\n        }\n        unset(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);\n        }\n        /**\n         * <p>Flips the given bit.</p>\n         *\n         * @param x The horizontal component (i.e. which column)\n         * @param y The vertical component (i.e. which row)\n         */\n        flip(x /*int*/, y /*int*/) {\n            const offset = y * this.rowSize + Math.floor(x / 32);\n            this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n        }\n        /**\n         * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding\n         * mask bit is set.\n         *\n         * @param mask XOR mask\n         */\n        xor(mask) {\n            if (this.width !== mask.getWidth() || this.height !== mask.getHeight()\n                || this.rowSize !== mask.getRowSize()) {\n                throw new IllegalArgumentException('input matrix dimensions do not match');\n            }\n            const rowArray = new BitArray(Math.floor(this.width / 32) + 1);\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            for (let y = 0, height = this.height; y < height; y++) {\n                const offset = y * rowSize;\n                const row = mask.getRow(y, rowArray).getBitArray();\n                for (let x = 0; x < rowSize; x++) {\n                    bits[offset + x] ^= row[x];\n                }\n            }\n        }\n        /**\n         * Clears all bits (sets to false).\n         */\n        clear() {\n            const bits = this.bits;\n            const max = bits.length;\n            for (let i = 0; i < max; i++) {\n                bits[i] = 0;\n            }\n        }\n        /**\n         * <p>Sets a square region of the bit matrix to true.</p>\n         *\n         * @param left The horizontal position to begin at (inclusive)\n         * @param top The vertical position to begin at (inclusive)\n         * @param width The width of the region\n         * @param height The height of the region\n         */\n        setRegion(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            if (top < 0 || left < 0) {\n                throw new IllegalArgumentException('Left and top must be nonnegative');\n            }\n            if (height < 1 || width < 1) {\n                throw new IllegalArgumentException('Height and width must be at least 1');\n            }\n            const right = left + width;\n            const bottom = top + height;\n            if (bottom > this.height || right > this.width) {\n                throw new IllegalArgumentException('The region must fit inside the matrix');\n            }\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            for (let y = top; y < bottom; y++) {\n                const offset = y * rowSize;\n                for (let x = left; x < right; x++) {\n                    bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);\n                }\n            }\n        }\n        /**\n         * A fast method to retrieve one row of data from the matrix as a BitArray.\n         *\n         * @param y The row to retrieve\n         * @param row An optional caller-allocated BitArray, will be allocated if null or too small\n         * @return The resulting BitArray - this reference should always be used even when passing\n         *         your own row\n         */\n        getRow(y /*int*/, row) {\n            if (row === null || row === undefined || row.getSize() < this.width) {\n                row = new BitArray(this.width);\n            }\n            else {\n                row.clear();\n            }\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            const offset = y * rowSize;\n            for (let x = 0; x < rowSize; x++) {\n                row.setBulk(x * 32, bits[offset + x]);\n            }\n            return row;\n        }\n        /**\n         * @param y row to set\n         * @param row {@link BitArray} to copy from\n         */\n        setRow(y /*int*/, row) {\n            System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);\n        }\n        /**\n         * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees\n         */\n        rotate180() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            let topRow = new BitArray(width);\n            let bottomRow = new BitArray(width);\n            for (let i = 0, length = Math.floor((height + 1) / 2); i < length; i++) {\n                topRow = this.getRow(i, topRow);\n                bottomRow = this.getRow(height - 1 - i, bottomRow);\n                topRow.reverse();\n                bottomRow.reverse();\n                this.setRow(i, bottomRow);\n                this.setRow(height - 1 - i, topRow);\n            }\n        }\n        /**\n         * This is useful in detecting the enclosing rectangle of a 'pure' barcode.\n         *\n         * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white\n         */\n        getEnclosingRectangle() {\n            const width = this.width;\n            const height = this.height;\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let left = width;\n            let top = height;\n            let right = -1;\n            let bottom = -1;\n            for (let y = 0; y < height; y++) {\n                for (let x32 = 0; x32 < rowSize; x32++) {\n                    const theBits = bits[y * rowSize + x32];\n                    if (theBits !== 0) {\n                        if (y < top) {\n                            top = y;\n                        }\n                        if (y > bottom) {\n                            bottom = y;\n                        }\n                        if (x32 * 32 < left) {\n                            let bit = 0;\n                            while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n                                bit++;\n                            }\n                            if ((x32 * 32 + bit) < left) {\n                                left = x32 * 32 + bit;\n                            }\n                        }\n                        if (x32 * 32 + 31 > right) {\n                            let bit = 31;\n                            while ((theBits >>> bit) === 0) {\n                                bit--;\n                            }\n                            if ((x32 * 32 + bit) > right) {\n                                right = x32 * 32 + bit;\n                            }\n                        }\n                    }\n                }\n            }\n            if (right < left || bottom < top) {\n                return null;\n            }\n            return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);\n        }\n        /**\n         * This is useful in detecting a corner of a 'pure' barcode.\n         *\n         * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white\n         */\n        getTopLeftOnBit() {\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let bitsOffset = 0;\n            while (bitsOffset < bits.length && bits[bitsOffset] === 0) {\n                bitsOffset++;\n            }\n            if (bitsOffset === bits.length) {\n                return null;\n            }\n            const y = bitsOffset / rowSize;\n            let x = (bitsOffset % rowSize) * 32;\n            const theBits = bits[bitsOffset];\n            let bit = 0;\n            while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {\n                bit++;\n            }\n            x += bit;\n            return Int32Array.from([x, y]);\n        }\n        getBottomRightOnBit() {\n            const rowSize = this.rowSize;\n            const bits = this.bits;\n            let bitsOffset = bits.length - 1;\n            while (bitsOffset >= 0 && bits[bitsOffset] === 0) {\n                bitsOffset--;\n            }\n            if (bitsOffset < 0) {\n                return null;\n            }\n            const y = Math.floor(bitsOffset / rowSize);\n            let x = Math.floor(bitsOffset % rowSize) * 32;\n            const theBits = bits[bitsOffset];\n            let bit = 31;\n            while ((theBits >>> bit) === 0) {\n                bit--;\n            }\n            x += bit;\n            return Int32Array.from([x, y]);\n        }\n        /**\n         * @return The width of the matrix\n         */\n        getWidth() {\n            return this.width;\n        }\n        /**\n         * @return The height of the matrix\n         */\n        getHeight() {\n            return this.height;\n        }\n        /**\n         * @return The row size of the matrix\n         */\n        getRowSize() {\n            return this.rowSize;\n        }\n        /*@Override*/\n        equals(o) {\n            if (!(o instanceof BitMatrix)) {\n                return false;\n            }\n            const other = o;\n            return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&\n                Arrays.equals(this.bits, other.bits);\n        }\n        /*@Override*/\n        hashCode() {\n            let hash = this.width;\n            hash = 31 * hash + this.width;\n            hash = 31 * hash + this.height;\n            hash = 31 * hash + this.rowSize;\n            hash = 31 * hash + Arrays.hashCode(this.bits);\n            return hash;\n        }\n        /**\n         * @return string representation using \"X\" for set and \" \" for unset bits\n         */\n        /*@Override*/\n        // public toString(): string {\n        //   return toString(\": \"X, \"  \")\n        // }\n        /**\n         * @param setString representation of a set bit\n         * @param unsetString representation of an unset bit\n         * @return string representation of entire matrix utilizing given strings\n         */\n        // public toString(setString: string = \"X \", unsetString: string = \"  \"): string {\n        //   return this.buildToString(setString, unsetString, \"\\n\")\n        // }\n        /**\n         * @param setString representation of a set bit\n         * @param unsetString representation of an unset bit\n         * @param lineSeparator newline character in string representation\n         * @return string representation of entire matrix utilizing given strings and line separator\n         * @deprecated call {@link #toString(String,String)} only, which uses \\n line separator always\n         */\n        // @Deprecated\n        toString(setString = 'X ', unsetString = '  ', lineSeparator = '\\n') {\n            return this.buildToString(setString, unsetString, lineSeparator);\n        }\n        buildToString(setString, unsetString, lineSeparator) {\n            let result = new StringBuilder();\n            // result.append(lineSeparator);\n            for (let y = 0, height = this.height; y < height; y++) {\n                for (let x = 0, width = this.width; x < width; x++) {\n                    result.append(this.get(x, y) ? setString : unsetString);\n                }\n                result.append(lineSeparator);\n            }\n            return result.toString();\n        }\n        /*@Override*/\n        clone() {\n            return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class NotFoundException extends Exception {\n        static getNotFoundInstance() {\n            return new NotFoundException();\n        }\n    }\n    NotFoundException.kind = 'NotFoundException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable\n     * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding\n     * algorithm. However, because it picks a global black point, it cannot handle difficult shadows\n     * and gradients.\n     *\n     * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     */\n    class GlobalHistogramBinarizer extends Binarizer {\n        constructor(source) {\n            super(source);\n            this.luminances = GlobalHistogramBinarizer.EMPTY;\n            this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);\n        }\n        // Applies simple sharpening to the row data to improve performance of the 1D Readers.\n        /*@Override*/\n        getBlackRow(y /*int*/, row) {\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            if (row === undefined || row === null || row.getSize() < width) {\n                row = new BitArray(width);\n            }\n            else {\n                row.clear();\n            }\n            this.initArrays(width);\n            const localLuminances = source.getRow(y, this.luminances);\n            const localBuckets = this.buckets;\n            for (let x = 0; x < width; x++) {\n                localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n            }\n            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n            if (width < 3) {\n                // Special case for very small images\n                for (let x = 0; x < width; x++) {\n                    if ((localLuminances[x] & 0xff) < blackPoint) {\n                        row.set(x);\n                    }\n                }\n            }\n            else {\n                let left = localLuminances[0] & 0xff;\n                let center = localLuminances[1] & 0xff;\n                for (let x = 1; x < width - 1; x++) {\n                    const right = localLuminances[x + 1] & 0xff;\n                    // A simple -1 4 -1 box filter with a weight of 2.\n                    if (((center * 4) - left - right) / 2 < blackPoint) {\n                        row.set(x);\n                    }\n                    left = center;\n                    center = right;\n                }\n            }\n            return row;\n        }\n        // Does not sharpen the data, as this call is intended to only be used by 2D Readers.\n        /*@Override*/\n        getBlackMatrix() {\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            const height = source.getHeight();\n            const matrix = new BitMatrix(width, height);\n            // Quickly calculates the histogram by sampling four rows from the image. This proved to be\n            // more robust on the blackbox tests than sampling a diagonal as we used to do.\n            this.initArrays(width);\n            const localBuckets = this.buckets;\n            for (let y = 1; y < 5; y++) {\n                const row = Math.floor((height * y) / 5);\n                const localLuminances = source.getRow(row, this.luminances);\n                const right = Math.floor((width * 4) / 5);\n                for (let x = Math.floor(width / 5); x < right; x++) {\n                    const pixel = localLuminances[x] & 0xff;\n                    localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;\n                }\n            }\n            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);\n            // We delay reading the entire image luminance until the black point estimation succeeds.\n            // Although we end up reading four rows twice, it is consistent with our motto of\n            // \"fail quickly\" which is necessary for continuous scanning.\n            const localLuminances = source.getMatrix();\n            for (let y = 0; y < height; y++) {\n                const offset = y * width;\n                for (let x = 0; x < width; x++) {\n                    const pixel = localLuminances[offset + x] & 0xff;\n                    if (pixel < blackPoint) {\n                        matrix.set(x, y);\n                    }\n                }\n            }\n            return matrix;\n        }\n        /*@Override*/\n        createBinarizer(source) {\n            return new GlobalHistogramBinarizer(source);\n        }\n        initArrays(luminanceSize /*int*/) {\n            if (this.luminances.length < luminanceSize) {\n                this.luminances = new Uint8ClampedArray(luminanceSize);\n            }\n            const buckets = this.buckets;\n            for (let x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {\n                buckets[x] = 0;\n            }\n        }\n        static estimateBlackPoint(buckets) {\n            // Find the tallest peak in the histogram.\n            const numBuckets = buckets.length;\n            let maxBucketCount = 0;\n            let firstPeak = 0;\n            let firstPeakSize = 0;\n            for (let x = 0; x < numBuckets; x++) {\n                if (buckets[x] > firstPeakSize) {\n                    firstPeak = x;\n                    firstPeakSize = buckets[x];\n                }\n                if (buckets[x] > maxBucketCount) {\n                    maxBucketCount = buckets[x];\n                }\n            }\n            // Find the second-tallest peak which is somewhat far from the tallest peak.\n            let secondPeak = 0;\n            let secondPeakScore = 0;\n            for (let x = 0; x < numBuckets; x++) {\n                const distanceToBiggest = x - firstPeak;\n                // Encourage more distant second peaks by multiplying by square of distance.\n                const score = buckets[x] * distanceToBiggest * distanceToBiggest;\n                if (score > secondPeakScore) {\n                    secondPeak = x;\n                    secondPeakScore = score;\n                }\n            }\n            // Make sure firstPeak corresponds to the black peak.\n            if (firstPeak > secondPeak) {\n                const temp = firstPeak;\n                firstPeak = secondPeak;\n                secondPeak = temp;\n            }\n            // If there is too little contrast in the image to pick a meaningful black point, throw rather\n            // than waste time trying to decode the image, and risk false positives.\n            if (secondPeak - firstPeak <= numBuckets / 16) {\n                throw new NotFoundException();\n            }\n            // Find a valley between them that is low and closer to the white peak.\n            let bestValley = secondPeak - 1;\n            let bestValleyScore = -1;\n            for (let x = secondPeak - 1; x > firstPeak; x--) {\n                const fromFirst = x - firstPeak;\n                const score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);\n                if (score > bestValleyScore) {\n                    bestValley = x;\n                    bestValleyScore = score;\n                }\n            }\n            return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;\n        }\n    }\n    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;\n    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;\n    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This class implements a local thresholding algorithm, which while slower than the\n     * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for\n     * high frequency images of barcodes with black data on white backgrounds. For this application,\n     * it does a much better job than a global blackpoint with severe shadows and gradients.\n     * However it tends to produce artifacts on lower frequency images and is therefore not\n     * a good general purpose binarizer for uses outside ZXing.\n     *\n     * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,\n     * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already\n     * inherently local, and only fails for horizontal gradients. We can revisit that problem later,\n     * but for now it was not a win to use local blocks for 1D.\n     *\n     * This Binarizer is the default for the unit tests and the recommended class for library users.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class HybridBinarizer extends GlobalHistogramBinarizer {\n        constructor(source) {\n            super(source);\n            this.matrix = null;\n        }\n        /**\n         * Calculates the final BitMatrix once for all requests. This could be called once from the\n         * constructor instead, but there are some advantages to doing it lazily, such as making\n         * profiling easier, and not doing heavy lifting when callers don't expect it.\n         */\n        /*@Override*/\n        getBlackMatrix() {\n            if (this.matrix !== null) {\n                return this.matrix;\n            }\n            const source = this.getLuminanceSource();\n            const width = source.getWidth();\n            const height = source.getHeight();\n            if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {\n                const luminances = source.getMatrix();\n                let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;\n                if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                    subWidth++;\n                }\n                let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;\n                if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {\n                    subHeight++;\n                }\n                const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n                const newMatrix = new BitMatrix(width, height);\n                HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);\n                this.matrix = newMatrix;\n            }\n            else {\n                // If the image is too small, fall back to the global histogram approach.\n                this.matrix = super.getBlackMatrix();\n            }\n            return this.matrix;\n        }\n        /*@Override*/\n        createBinarizer(source) {\n            return new HybridBinarizer(source);\n        }\n        /**\n         * For each block in the image, calculate the average black point using a 5x5 grid\n         * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n         * on the last pixels in the row/column which are also used in the previous block).\n         */\n        static calculateThresholdForBlock(luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {\n            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n            for (let y = 0; y < subHeight; y++) {\n                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (yoffset > maxYOffset) {\n                    yoffset = maxYOffset;\n                }\n                const top = HybridBinarizer.cap(y, 2, subHeight - 3);\n                for (let x = 0; x < subWidth; x++) {\n                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                    if (xoffset > maxXOffset) {\n                        xoffset = maxXOffset;\n                    }\n                    const left = HybridBinarizer.cap(x, 2, subWidth - 3);\n                    let sum = 0;\n                    for (let z = -2; z <= 2; z++) {\n                        const blackRow = blackPoints[top + z];\n                        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n                    }\n                    const average = sum / 25;\n                    HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n                }\n            }\n        }\n        static cap(value /*int*/, min /*int*/, max /*int*/) {\n            return value < min ? min : value > max ? max : value;\n        }\n        /**\n         * Applies a single threshold to a block of pixels.\n         */\n        static thresholdBlock(luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {\n            for (let y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {\n                for (let x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {\n                    // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.\n                    if ((luminances[offset + x] & 0xFF) <= threshold) {\n                        matrix.set(xoffset + x, yoffset + y);\n                    }\n                }\n            }\n        }\n        /**\n         * Calculates a single black point for each block of pixels and saves it away.\n         * See the following thread for a discussion of this algorithm:\n         *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0\n         */\n        static calculateBlackPoints(luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {\n            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;\n            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;\n            // tslint:disable-next-line:whitespace\n            const blackPoints = new Array(subHeight); // subWidth\n            for (let y = 0; y < subHeight; y++) {\n                blackPoints[y] = new Int32Array(subWidth);\n                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;\n                if (yoffset > maxYOffset) {\n                    yoffset = maxYOffset;\n                }\n                for (let x = 0; x < subWidth; x++) {\n                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;\n                    if (xoffset > maxXOffset) {\n                        xoffset = maxXOffset;\n                    }\n                    let sum = 0;\n                    let min = 0xFF;\n                    let max = 0;\n                    for (let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                        for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                            const pixel = luminances[offset + xx] & 0xFF;\n                            sum += pixel;\n                            // still looking for good contrast\n                            if (pixel < min) {\n                                min = pixel;\n                            }\n                            if (pixel > max) {\n                                max = pixel;\n                            }\n                        }\n                        // short-circuit min/max tests once dynamic range is met\n                        if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                            // finish the rest of the rows quickly\n                            for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {\n                                for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {\n                                    sum += luminances[offset + xx] & 0xFF;\n                                }\n                            }\n                        }\n                    }\n                    // The default estimate is the average of the values in the block.\n                    let average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);\n                    if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {\n                        // If variation within the block is low, assume this is a block with only light or only\n                        // dark pixels. In that case we do not want to use the average, as it would divide this\n                        // low contrast area into black and white pixels, essentially creating data out of noise.\n                        //\n                        // The default assumption is that the block is light/background. Since no estimate for\n                        // the level of dark pixels exists locally, use half the min for the block.\n                        average = min / 2;\n                        if (y > 0 && x > 0) {\n                            // Correct the \"white background\" assumption for blocks that have neighbors by comparing\n                            // the pixels in this block to the previously calculated black points. This is based on\n                            // the fact that dark barcode symbology is always surrounded by some amount of light\n                            // background for which reasonable black point estimates were made. The bp estimated at\n                            // the boundaries is used for the interior.\n                            // The (min < bp) is arbitrary but works better than other heuristics that were tried.\n                            const averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;\n                            if (min < averageNeighborBlackPoint) {\n                                average = averageNeighborBlackPoint;\n                            }\n                        }\n                    }\n                    blackPoints[y][x] = average;\n                }\n            }\n            return blackPoints;\n        }\n    }\n    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.\n    // So this is the smallest dimension in each axis we can accept.\n    HybridBinarizer.BLOCK_SIZE_POWER = 3;\n    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00\n    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11\n    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;\n    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * The purpose of this class hierarchy is to abstract different bitmap implementations across\n     * platforms into a standard interface for requesting greyscale luminance values. The interface\n     * only provides immutable methods; therefore crop and rotation create copies. This is to ensure\n     * that one Reader does not modify the original luminance source and leave it in an unknown state\n     * for other Readers in the chain.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class LuminanceSource {\n        constructor(width /*int*/, height /*int*/) {\n            this.width = width;\n            this.height = height;\n        }\n        /**\n         * @return The width of the bitmap.\n         */\n        getWidth() {\n            return this.width;\n        }\n        /**\n         * @return The height of the bitmap.\n         */\n        getHeight() {\n            return this.height;\n        }\n        /**\n         * @return Whether this subclass supports cropping.\n         */\n        isCropSupported() {\n            return false;\n        }\n        /**\n         * Returns a new object with cropped image data. Implementations may keep a reference to the\n         * original data rather than a copy. Only callable if isCropSupported() is true.\n         *\n         * @param left The left coordinate, which must be in [0,getWidth())\n         * @param top The top coordinate, which must be in [0,getHeight())\n         * @param width The width of the rectangle to crop.\n         * @param height The height of the rectangle to crop.\n         * @return A cropped version of this object.\n         */\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            throw new UnsupportedOperationException('This luminance source does not support cropping.');\n        }\n        /**\n         * @return Whether this subclass supports counter-clockwise rotation.\n         */\n        isRotateSupported() {\n            return false;\n        }\n        /**\n         * Returns a new object with rotated image data by 90 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise() {\n            throw new UnsupportedOperationException('This luminance source does not support rotation by 90 degrees.');\n        }\n        /**\n         * Returns a new object with rotated image data by 45 degrees counterclockwise.\n         * Only callable if {@link #isRotateSupported()} is true.\n         *\n         * @return A rotated version of this object.\n         */\n        rotateCounterClockwise45() {\n            throw new UnsupportedOperationException('This luminance source does not support rotation by 45 degrees.');\n        }\n        /*@Override*/\n        toString() {\n            const row = new Uint8ClampedArray(this.width);\n            let result = new StringBuilder();\n            for (let y = 0; y < this.height; y++) {\n                const sourceRow = this.getRow(y, row);\n                for (let x = 0; x < this.width; x++) {\n                    const luminance = sourceRow[x] & 0xFF;\n                    let c;\n                    if (luminance < 0x40) {\n                        c = '#';\n                    }\n                    else if (luminance < 0x80) {\n                        c = '+';\n                    }\n                    else if (luminance < 0xC0) {\n                        c = '.';\n                    }\n                    else {\n                        c = ' ';\n                    }\n                    result.append(c);\n                }\n                result.append('\\n');\n            }\n            return result.toString();\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes\n     * white and vice versa, and each value becomes (255-value).\n     *\n     * @author Sean Owen\n     */\n    class InvertedLuminanceSource extends LuminanceSource {\n        constructor(delegate) {\n            super(delegate.getWidth(), delegate.getHeight());\n            this.delegate = delegate;\n        }\n        /*@Override*/\n        getRow(y /*int*/, row) {\n            const sourceRow = this.delegate.getRow(y, row);\n            const width = this.getWidth();\n            for (let i = 0; i < width; i++) {\n                sourceRow[i] = /*(byte)*/ (255 - (sourceRow[i] & 0xFF));\n            }\n            return sourceRow;\n        }\n        /*@Override*/\n        getMatrix() {\n            const matrix = this.delegate.getMatrix();\n            const length = this.getWidth() * this.getHeight();\n            const invertedMatrix = new Uint8ClampedArray(length);\n            for (let i = 0; i < length; i++) {\n                invertedMatrix[i] = /*(byte)*/ (255 - (matrix[i] & 0xFF));\n            }\n            return invertedMatrix;\n        }\n        /*@Override*/\n        isCropSupported() {\n            return this.delegate.isCropSupported();\n        }\n        /*@Override*/\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));\n        }\n        /*@Override*/\n        isRotateSupported() {\n            return this.delegate.isRotateSupported();\n        }\n        /**\n         * @return original delegate {@link LuminanceSource} since invert undoes itself\n         */\n        /*@Override*/\n        invert() {\n            return this.delegate;\n        }\n        /*@Override*/\n        rotateCounterClockwise() {\n            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());\n        }\n        /*@Override*/\n        rotateCounterClockwise45() {\n            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     */\n    class HTMLCanvasElementLuminanceSource extends LuminanceSource {\n        constructor(canvas) {\n            super(canvas.width, canvas.height);\n            this.canvas = canvas;\n            this.tempCanvasElement = null;\n            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);\n        }\n        static makeBufferFromCanvasImageData(canvas) {\n            const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\n            return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);\n        }\n        static toGrayscaleBuffer(imageBuffer, width, height) {\n            const grayscaleBuffer = new Uint8ClampedArray(width * height);\n            for (let i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++) {\n                let gray;\n                const alpha = imageBuffer[i + 3];\n                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent\n                // black (0 alpha, and then 0 RGB). They are often used, of course as the \"white\" area in a\n                // barcode image. Force any such pixel to be white:\n                if (alpha === 0) {\n                    gray = 0xFF;\n                }\n                else {\n                    const pixelR = imageBuffer[i];\n                    const pixelG = imageBuffer[i + 1];\n                    const pixelB = imageBuffer[i + 2];\n                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),\n                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.\n                    // 0x200 >> 10 is 0.5, it implements rounding.\n                    gray = (306 * pixelR +\n                        601 * pixelG +\n                        117 * pixelB +\n                        0x200) >> 10;\n                }\n                grayscaleBuffer[j] = gray;\n            }\n            return grayscaleBuffer;\n        }\n        getRow(y /*int*/, row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException('Requested row is outside the image: ' + y);\n            }\n            const width = this.getWidth();\n            const start = y * width;\n            if (row === null) {\n                row = this.buffer.slice(start, start + width);\n            }\n            else {\n                if (row.length < width) {\n                    row = new Uint8ClampedArray(width);\n                }\n                // The underlying raster of image consists of bytes with the luminance values\n                // TODO: can avoid set/slice?\n                row.set(this.buffer.slice(start, start + width));\n            }\n            return row;\n        }\n        getMatrix() {\n            return this.buffer;\n        }\n        isCropSupported() {\n            return true;\n        }\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            super.crop(left, top, width, height);\n            return this;\n        }\n        /**\n         * This is always true, since the image is a gray-scale image.\n         *\n         * @return true\n         */\n        isRotateSupported() {\n            return true;\n        }\n        rotateCounterClockwise() {\n            this.rotate(-90);\n            return this;\n        }\n        rotateCounterClockwise45() {\n            this.rotate(-45);\n            return this;\n        }\n        getTempCanvasElement() {\n            if (null === this.tempCanvasElement) {\n                const tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');\n                tempCanvasElement.width = this.canvas.width;\n                tempCanvasElement.height = this.canvas.height;\n                this.tempCanvasElement = tempCanvasElement;\n            }\n            return this.tempCanvasElement;\n        }\n        rotate(angle) {\n            const tempCanvasElement = this.getTempCanvasElement();\n            const tempContext = tempCanvasElement.getContext('2d');\n            const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;\n            // Calculate and set new dimensions for temp canvas\n            const width = this.canvas.width;\n            const height = this.canvas.height;\n            const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);\n            const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);\n            tempCanvasElement.width = newWidth;\n            tempCanvasElement.height = newHeight;\n            // Draw at center of temp canvas to prevent clipping of image data\n            tempContext.translate(newWidth / 2, newHeight / 2);\n            tempContext.rotate(angleRadians);\n            tempContext.drawImage(this.canvas, width / -2, height / -2);\n            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);\n            return this;\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Video input device metadata containing the id and label of the device if available.\n     */\n    class VideoInputDevice {\n        /**\n         * Creates an instance of VideoInputDevice.\n         *\n         * @param {string} deviceId the video input device id\n         * @param {string} label the label of the device if available\n         */\n        constructor(deviceId, label, groupId) {\n            this.deviceId = deviceId;\n            this.label = label;\n            /** @inheritdoc */\n            this.kind = 'videoinput';\n            this.groupId = groupId || undefined;\n        }\n        /** @inheritdoc */\n        toJSON() {\n            return {\n                kind: this.kind,\n                groupId: this.groupId,\n                deviceId: this.deviceId,\n                label: this.label,\n            };\n        }\n    }\n\n    var __awaiter = ((globalThis || __webpack_require__.g || self || window || undefined) && (globalThis || __webpack_require__.g || self || window || undefined).__awaiter) || function (thisArg, _arguments, P, generator) {\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Base class for browser code reader.\n     */\n    class BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserCodeReader.\n         * @param {Reader} reader The reader instance to decode the barcode\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries\n         *\n         * @memberOf BrowserCodeReader\n         */\n        constructor(reader, timeBetweenScansMillis = 500, _hints) {\n            this.reader = reader;\n            this.timeBetweenScansMillis = timeBetweenScansMillis;\n            this._hints = _hints;\n            /**\n             * This will break the loop.\n             */\n            this._stopContinuousDecode = false;\n            /**\n             * This will break the loop.\n             */\n            this._stopAsyncDecode = false;\n            /**\n             * Delay time between decode attempts made by the scanner.\n             */\n            this._timeBetweenDecodingAttempts = 0;\n        }\n        /**\n         * If navigator is present.\n         */\n        get hasNavigator() {\n            return typeof navigator !== 'undefined';\n        }\n        /**\n         * If mediaDevices under navigator is supported.\n         */\n        get isMediaDevicesSuported() {\n            return this.hasNavigator && !!navigator.mediaDevices;\n        }\n        /**\n         * If enumerateDevices under navigator is supported.\n         */\n        get canEnumerateDevices() {\n            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\n        }\n        /** Time between two decoding tries in milli seconds. */\n        get timeBetweenDecodingAttempts() {\n            return this._timeBetweenDecodingAttempts;\n        }\n        /**\n         * Change the time span the decoder waits between two decoding tries.\n         *\n         * @param {number} millis Time between two decoding tries in milli seconds.\n         */\n        set timeBetweenDecodingAttempts(millis) {\n            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;\n        }\n        /**\n         * Sets the hints.\n         */\n        set hints(hints) {\n            this._hints = hints || null;\n        }\n        /**\n         * Sets the hints.\n         */\n        get hints() {\n            return this._hints;\n        }\n        /**\n         * Lists all the available video input devices.\n         */\n        listVideoInputDevices() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!this.hasNavigator) {\n                    throw new Error('Can\\'t enumerate devices, navigator is not present.');\n                }\n                if (!this.canEnumerateDevices) {\n                    throw new Error('Can\\'t enumerate devices, method not supported.');\n                }\n                const devices = yield navigator.mediaDevices.enumerateDevices();\n                const videoDevices = [];\n                for (const device of devices) {\n                    const kind = device.kind === 'video' ? 'videoinput' : device.kind;\n                    if (kind !== 'videoinput') {\n                        continue;\n                    }\n                    const deviceId = device.deviceId || device.id;\n                    const label = device.label || `Video device ${videoDevices.length + 1}`;\n                    const groupId = device.groupId;\n                    const videoDevice = { deviceId, label, kind, groupId };\n                    videoDevices.push(videoDevice);\n                }\n                return videoDevices;\n            });\n        }\n        /**\n         * Obtain the list of available devices with type 'videoinput'.\n         *\n         * @returns {Promise<VideoInputDevice[]>} an array of available video input devices\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `listVideoInputDevices` instead.\n         */\n        getVideoInputDevices() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const devices = yield this.listVideoInputDevices();\n                return devices.map(d => new VideoInputDevice(d.deviceId, d.label));\n            });\n        }\n        /**\n         * Let's you find a device using it's Id.\n         */\n        findDeviceById(deviceId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const devices = yield this.listVideoInputDevices();\n                if (!devices) {\n                    return null;\n                }\n                return devices.find(x => x.deviceId === deviceId);\n            });\n        }\n        /**\n         * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.\n         *\n         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `decodeOnceFromVideoDevice` instead.\n         */\n        decodeFromInputVideoDevice(deviceId, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.\n         *\n         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeOnceFromVideoDevice(deviceId, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.reset();\n                let videoConstraints;\n                if (!deviceId) {\n                    videoConstraints = { facingMode: 'environment' };\n                }\n                else {\n                    videoConstraints = { deviceId: { exact: deviceId } };\n                }\n                const constraints = { video: videoConstraints };\n                return yield this.decodeOnceFromConstraints(constraints, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param constraints the media stream constraints to get s valid media stream to decode from\n         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeOnceFromConstraints(constraints, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n                return yield this.decodeOnceFromStream(stream, videoSource);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeOnceFromStream(stream, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.reset();\n                const video = yield this.attachStreamToVideo(stream, videoSource);\n                const result = yield this.decodeOnce(video);\n                return result;\n            });\n        }\n        /**\n         * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.\n         *\n         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<void>}\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @deprecated Use `decodeFromVideoDevice` instead.\n         */\n        decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);\n            });\n        }\n        /**\n         * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.\n         *\n         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.\n         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<void>}\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromVideoDevice(deviceId, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let videoConstraints;\n                if (!deviceId) {\n                    videoConstraints = { facingMode: 'environment' };\n                }\n                else {\n                    videoConstraints = { deviceId: { exact: deviceId } };\n                }\n                const constraints = { video: videoConstraints };\n                return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);\n            });\n        }\n        /**\n         * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromConstraints(constraints, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n                return yield this.decodeFromStream(stream, videoSource, callbackFn);\n            });\n        }\n        /**\n         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.\n         *\n         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from\n         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromStream(stream, videoSource, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.reset();\n                const video = yield this.attachStreamToVideo(stream, videoSource);\n                return yield this.decodeContinuously(video, callbackFn);\n            });\n        }\n        /**\n         * Breaks the decoding loop.\n         */\n        stopAsyncDecode() {\n            this._stopAsyncDecode = true;\n        }\n        /**\n         * Breaks the decoding loop.\n         */\n        stopContinuousDecode() {\n            this._stopContinuousDecode = true;\n        }\n        /**\n         * Sets the new stream and request a new decoding-with-delay.\n         *\n         * @param stream The stream to be shown in the video element.\n         * @param decodeFn A callback for the decode method.\n         */\n        attachStreamToVideo(stream, videoSource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const videoElement = this.prepareVideoElement(videoSource);\n                this.addVideoSource(videoElement, stream);\n                this.videoElement = videoElement;\n                this.stream = stream;\n                yield this.playVideoOnLoadAsync(videoElement);\n                return videoElement;\n            });\n        }\n        /**\n         *\n         * @param videoElement\n         */\n        playVideoOnLoadAsync(videoElement) {\n            return new Promise((resolve, reject) => this.playVideoOnLoad(videoElement, () => resolve()));\n        }\n        /**\n         * Binds listeners and callbacks to the videoElement.\n         *\n         * @param element\n         * @param callbackFn\n         */\n        playVideoOnLoad(element, callbackFn) {\n            this.videoEndedListener = () => this.stopStreams();\n            this.videoCanPlayListener = () => this.tryPlayVideo(element);\n            element.addEventListener('ended', this.videoEndedListener);\n            element.addEventListener('canplay', this.videoCanPlayListener);\n            element.addEventListener('playing', callbackFn);\n            // if canplay was already fired, we won't know when to play, so just give it a try\n            this.tryPlayVideo(element);\n        }\n        /**\n         * Checks if the given video element is currently playing.\n         */\n        isVideoPlaying(video) {\n            return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;\n        }\n        /**\n         * Just tries to play the video and logs any errors.\n         * The play call is only made is the video is not already playing.\n         */\n        tryPlayVideo(videoElement) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.isVideoPlaying(videoElement)) {\n                    console.warn('Trying to play video that is already playing.');\n                    return;\n                }\n                try {\n                    yield videoElement.play();\n                }\n                catch (_a) {\n                    console.warn('It was not possible to play the video.');\n                }\n            });\n        }\n        /**\n         * Searches and validates a media element.\n         */\n        getMediaElement(mediaElementId, type) {\n            const mediaElement = document.getElementById(mediaElementId);\n            if (!mediaElement) {\n                throw new ArgumentException(`element with id '${mediaElementId}' not found`);\n            }\n            if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {\n                throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);\n            }\n            return mediaElement;\n        }\n        /**\n         * Decodes the barcode from an image.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromImage(source, url) {\n            if (!source && !url) {\n                throw new ArgumentException('either imageElement with a src set or an url must be provided');\n            }\n            if (url && !source) {\n                return this.decodeFromImageUrl(url);\n            }\n            return this.decodeFromImageElement(source);\n        }\n        /**\n         * Decodes the barcode from a video.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        decodeFromVideo(source, url) {\n            if (!source && !url) {\n                throw new ArgumentException('Either an element with a src set or an URL must be provided');\n            }\n            if (url && !source) {\n                return this.decodeFromVideoUrl(url);\n            }\n            return this.decodeFromVideoElement(source);\n        }\n        /**\n         * Decodes continuously the barcode from a video.\n         *\n         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.\n         * @param {string} [url]\n         * @returns {Promise<Result>} The decoding result.\n         *\n         * @memberOf BrowserCodeReader\n         *\n         * @experimental\n         */\n        decodeFromVideoContinuously(source, url, callbackFn) {\n            if (undefined === source && undefined === url) {\n                throw new ArgumentException('Either an element with a src set or an URL must be provided');\n            }\n            if (url && !source) {\n                return this.decodeFromVideoUrlContinuously(url, callbackFn);\n            }\n            return this.decodeFromVideoElementContinuously(source, callbackFn);\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */\n        decodeFromImageElement(source) {\n            if (!source) {\n                throw new ArgumentException('An image element must be provided.');\n            }\n            this.reset();\n            const element = this.prepareImageElement(source);\n            this.imageElement = element;\n            let task;\n            if (this.isImageLoaded(element)) {\n                task = this.decodeOnce(element, false, true);\n            }\n            else {\n                task = this._decodeOnLoadImage(element);\n            }\n            return task;\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */\n        decodeFromVideoElement(source) {\n            const element = this._decodeFromVideoElementSetup(source);\n            return this._decodeOnLoadVideo(element);\n        }\n        /**\n         * Decodes something from an image HTML element.\n         */\n        decodeFromVideoElementContinuously(source, callbackFn) {\n            const element = this._decodeFromVideoElementSetup(source);\n            return this._decodeOnLoadVideoContinuously(element, callbackFn);\n        }\n        /**\n         * Sets up the video source so it can be decoded when loaded.\n         *\n         * @param source The video source element.\n         */\n        _decodeFromVideoElementSetup(source) {\n            if (!source) {\n                throw new ArgumentException('A video element must be provided.');\n            }\n            this.reset();\n            const element = this.prepareVideoElement(source);\n            // defines the video element before starts decoding\n            this.videoElement = element;\n            return element;\n        }\n        /**\n         * Decodes an image from a URL.\n         */\n        decodeFromImageUrl(url) {\n            if (!url) {\n                throw new ArgumentException('An URL must be provided.');\n            }\n            this.reset();\n            const element = this.prepareImageElement();\n            this.imageElement = element;\n            const decodeTask = this._decodeOnLoadImage(element);\n            element.src = url;\n            return decodeTask;\n        }\n        /**\n         * Decodes an image from a URL.\n         */\n        decodeFromVideoUrl(url) {\n            if (!url) {\n                throw new ArgumentException('An URL must be provided.');\n            }\n            this.reset();\n            // creates a new element\n            const element = this.prepareVideoElement();\n            const decodeTask = this.decodeFromVideoElement(element);\n            element.src = url;\n            return decodeTask;\n        }\n        /**\n         * Decodes an image from a URL.\n         *\n         * @experimental\n         */\n        decodeFromVideoUrlContinuously(url, callbackFn) {\n            if (!url) {\n                throw new ArgumentException('An URL must be provided.');\n            }\n            this.reset();\n            // creates a new element\n            const element = this.prepareVideoElement();\n            const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);\n            element.src = url;\n            return decodeTask;\n        }\n        _decodeOnLoadImage(element) {\n            return new Promise((resolve, reject) => {\n                this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve, reject);\n                element.addEventListener('load', this.imageLoadedListener);\n            });\n        }\n        _decodeOnLoadVideo(videoElement) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // plays the video\n                yield this.playVideoOnLoadAsync(videoElement);\n                // starts decoding after played the video\n                return yield this.decodeOnce(videoElement);\n            });\n        }\n        _decodeOnLoadVideoContinuously(videoElement, callbackFn) {\n            return __awaiter(this, void 0, void 0, function* () {\n                // plays the video\n                yield this.playVideoOnLoadAsync(videoElement);\n                // starts decoding after played the video\n                this.decodeContinuously(videoElement, callbackFn);\n            });\n        }\n        isImageLoaded(img) {\n            // During the onload event, IE correctly identifies any images that\n            // werent downloaded as not complete. Others should too. Gecko-based\n            // browsers act like NS4 in that they report this incorrectly.\n            if (!img.complete) {\n                return false;\n            }\n            // However, they do have two very useful properties: naturalWidth and\n            // naturalHeight. These give the true size of the image. If it failed\n            // to load, either of these should be zero.\n            if (img.naturalWidth === 0) {\n                return false;\n            }\n            // No other way of checking: assume its ok.\n            return true;\n        }\n        prepareImageElement(imageSource) {\n            let imageElement;\n            if (typeof imageSource === 'undefined') {\n                imageElement = document.createElement('img');\n                imageElement.width = 200;\n                imageElement.height = 200;\n            }\n            if (typeof imageSource === 'string') {\n                imageElement = this.getMediaElement(imageSource, 'img');\n            }\n            if (imageSource instanceof HTMLImageElement) {\n                imageElement = imageSource;\n            }\n            return imageElement;\n        }\n        /**\n         * Sets a HTMLVideoElement for scanning or creates a new one.\n         *\n         * @param videoSource The HTMLVideoElement to be set.\n         */\n        prepareVideoElement(videoSource) {\n            let videoElement;\n            if (!videoSource && typeof document !== 'undefined') {\n                videoElement = document.createElement('video');\n                videoElement.width = 200;\n                videoElement.height = 200;\n            }\n            if (typeof videoSource === 'string') {\n                videoElement = this.getMediaElement(videoSource, 'video');\n            }\n            if (videoSource instanceof HTMLVideoElement) {\n                videoElement = videoSource;\n            }\n            // Needed for iOS 11\n            videoElement.setAttribute('autoplay', 'true');\n            videoElement.setAttribute('muted', 'true');\n            videoElement.setAttribute('playsinline', 'true');\n            return videoElement;\n        }\n        /**\n         * Tries to decode from the video input until it finds some value.\n         */\n        decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {\n            this._stopAsyncDecode = false;\n            const loop = (resolve, reject) => {\n                if (this._stopAsyncDecode) {\n                    reject(new NotFoundException('Video stream has ended before any code could be detected.'));\n                    this._stopAsyncDecode = undefined;\n                    return;\n                }\n                try {\n                    const result = this.decode(element);\n                    resolve(result);\n                }\n                catch (e) {\n                    const ifNotFound = retryIfNotFound && e instanceof NotFoundException;\n                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;\n                    const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;\n                    if (ifNotFound || ifChecksumOrFormat) {\n                        // trying again\n                        return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve, reject);\n                    }\n                    reject(e);\n                }\n            };\n            return new Promise((resolve, reject) => loop(resolve, reject));\n        }\n        /**\n         * Continuously decodes from video input.\n         */\n        decodeContinuously(element, callbackFn) {\n            this._stopContinuousDecode = false;\n            const loop = () => {\n                if (this._stopContinuousDecode) {\n                    this._stopContinuousDecode = undefined;\n                    return;\n                }\n                try {\n                    const result = this.decode(element);\n                    callbackFn(result, null);\n                    setTimeout(loop, this.timeBetweenScansMillis);\n                }\n                catch (e) {\n                    callbackFn(null, e);\n                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;\n                    const isNotFound = e instanceof NotFoundException;\n                    if (isChecksumOrFormatError || isNotFound) {\n                        // trying again\n                        setTimeout(loop, this._timeBetweenDecodingAttempts);\n                    }\n                }\n            };\n            loop();\n        }\n        /**\n         * Gets the BinaryBitmap for ya! (and decodes it)\n         */\n        decode(element) {\n            // get binary bitmap for decode function\n            const binaryBitmap = this.createBinaryBitmap(element);\n            return this.decodeBitmap(binaryBitmap);\n        }\n        /**\n         * Returns true if media element is indeed a {@link HtmlVideoElement}.\n         */\n        _isHTMLVideoElement(mediaElement) {\n            const potentialVideo = mediaElement;\n            return potentialVideo.videoWidth !== 0;\n        }\n        /**\n         * Overwriting this allows you to manipulate the next frame in anyway\n         * you want before decode.\n         */\n        drawFrameOnCanvas(\n            srcElement, dimensions, canvasElementContext) {\n            if (!dimensions) {\n                dimensions = {\n                    sx: 0,\n                    sy: 0,\n                    sWidth: srcElement.videoWidth,\n                    sHeight: srcElement.videoHeight,\n                    dx: 0,\n                    dy: 0,\n                    dWidth: srcElement.videoWidth,\n                    dHeight: srcElement.videoHeight};\n            }\n            if (!canvasElementContext) {\n                canvasElementContext = this.captureCanvasContext;\n            }\n            canvasElementContext.drawImage(\n                srcElement,\n                dimensions.sx,\n                dimensions.sy,\n                dimensions.sWidth,\n                dimensions.sHeight,\n                dimensions.dx,\n                dimensions.dy,\n                dimensions.dWidth,\n                dimensions.dHeight);\n        }\n        /**\n         * Ovewriting this allows you to manipulate the snapshot image in anyway\n         *  you want before decode.\n         */\n        drawImageOnCanvas(\n            srcElement,\n            dimensions,\n            canvasElementContext = this.captureCanvasContext) {\n            if (!dimensions) {\n                dimensions = {\n                    sx: 0,\n                    sy: 0,\n                    sWidth: srcElement.naturalWidth,\n                    sHeight: srcElement.naturalHeight,\n                    dx: 0,\n                    dy: 0,\n                    dWidth: srcElement.naturalWidth,\n                    dHeight: srcElement.naturalHeight\n                };\n            }\n            if (!canvasElementContext) {\n                canvasElementContext = this.captureCanvasContext;\n            }\n            canvasElementContext.drawImage(\n                srcElement,\n                dimensions.sx,\n                dimensions.sy,\n                dimensions.sWidth,\n                dimensions.sHeight,\n                dimensions.dx,\n                dimensions.dy,\n                dimensions.dWidth,\n                dimensions.dHeight);\n        }\n        /**\n         * Creates a binaryBitmap based in some image source.\n         *\n         * @param mediaElement HTML element containing drawable image source.\n         */\n        createBinaryBitmap(mediaElement) {\n            const ctx = this.getCaptureCanvasContext(mediaElement);\n            if (this._isHTMLVideoElement(mediaElement)) {\n                this.drawFrameOnCanvas(mediaElement);\n            } else {\n                this.drawImageOnCanvas(mediaElement);\n            }\n            const canvas = this.getCaptureCanvas(mediaElement);\n            const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);\n            const hybridBinarizer = new HybridBinarizer(luminanceSource);\n\n            return new BinaryBitmap(hybridBinarizer);\n        }\n\n        getCaptureCanvasContext(mediaElement) {\n            if (!this.captureCanvasContext) {\n                const elem = this.getCaptureCanvas(mediaElement);\n                const ctx = elem.getContext('2d');\n                this.captureCanvasContext = ctx;\n            }\n            return this.captureCanvasContext;\n        }\n        getCaptureCanvas(mediaElement) {\n            if (!this.captureCanvas) {\n                const elem = this.createCaptureCanvas(mediaElement);\n                this.captureCanvas = elem;\n            }\n            return this.captureCanvas;\n        }\n        /**\n         * Call the encapsulated readers decode\n         */\n        decodeBitmap(binaryBitmap) {\n            return this.reader.decode(binaryBitmap, this._hints);\n        }\n        /**\n         *  Prepares the canvas for capture and scan frames.\n         */\n        createCaptureCanvas(mediaElement) {\n            if (typeof document === 'undefined') {\n                this._destroyCaptureCanvas();\n                return null;\n            }\n            const canvasElement = document.createElement('canvas');\n            let width;\n            let height;\n            if (typeof mediaElement !== 'undefined') {\n                if (mediaElement instanceof HTMLVideoElement) {\n                    width = mediaElement.videoWidth;\n                    height = mediaElement.videoHeight;\n                }\n                else if (mediaElement instanceof HTMLImageElement) {\n                    width = mediaElement.naturalWidth || mediaElement.width;\n                    height = mediaElement.naturalHeight || mediaElement.height;\n                }\n            }\n            canvasElement.style.width = width + 'px';\n            canvasElement.style.height = height + 'px';\n            canvasElement.width = width;\n            canvasElement.height = height;\n            return canvasElement;\n        }\n        /**\n         * Stops the continuous scan and cleans the stream.\n         */\n        stopStreams() {\n            if (this.stream) {\n                this.stream.getVideoTracks().forEach(t => t.stop());\n                this.stream = undefined;\n            }\n            if (this._stopAsyncDecode === false) {\n                this.stopAsyncDecode();\n            }\n            if (this._stopContinuousDecode === false) {\n                this.stopContinuousDecode();\n            }\n        }\n        /**\n         * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.\n         *\n         * @memberOf BrowserCodeReader\n         */\n        reset() {\n            // stops the camera, preview and scan \n            this.stopStreams();\n            // clean and forget about HTML elements\n            this._destroyVideoElement();\n            this._destroyImageElement();\n            this._destroyCaptureCanvas();\n        }\n        _destroyVideoElement() {\n            if (!this.videoElement) {\n                return;\n            }\n            // first gives freedon to the element \n            if (typeof this.videoEndedListener !== 'undefined') {\n                this.videoElement.removeEventListener('ended', this.videoEndedListener);\n            }\n            if (typeof this.videoPlayingEventListener !== 'undefined') {\n                this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);\n            }\n            if (typeof this.videoCanPlayListener !== 'undefined') {\n                this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener);\n            }\n            // then forgets about that element \n            this.cleanVideoSource(this.videoElement);\n            this.videoElement = undefined;\n        }\n        _destroyImageElement() {\n            if (!this.imageElement) {\n                return;\n            }\n            // first gives freedon to the element \n            if (undefined !== this.imageLoadedListener) {\n                this.imageElement.removeEventListener('load', this.imageLoadedListener);\n            }\n            // then forget about that element \n            this.imageElement.src = undefined;\n            this.imageElement.removeAttribute('src');\n            this.imageElement = undefined;\n        }\n        /**\n         * Cleans canvas references \n         */\n        _destroyCaptureCanvas() {\n            // then forget about that element \n            this.captureCanvasContext = undefined;\n            this.captureCanvas = undefined;\n        }\n        /**\n         * Defines what the videoElement src will be.\n         *\n         * @param videoElement\n         * @param stream\n         */\n        addVideoSource(videoElement, stream) {\n            // Older browsers may not have `srcObject`\n            try {\n                // @note Throws Exception if interrupted by a new loaded request\n                videoElement.srcObject = stream;\n            }\n            catch (err) {\n                // @note Avoid using this in new browsers, as it is going away.\n                videoElement.src = URL.createObjectURL(stream);\n            }\n        }\n        /**\n         * Unbinds a HTML video src property.\n         *\n         * @param videoElement\n         */\n        cleanVideoSource(videoElement) {\n            try {\n                videoElement.srcObject = null;\n            }\n            catch (err) {\n                videoElement.src = '';\n            }\n            this.videoElement.removeAttribute('src');\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates the result of decoding a barcode within an image.</p>\n     *\n     * @author Sean Owen\n     */\n    class Result {\n        // public constructor(private text: string,\n        //               Uint8Array rawBytes,\n        //               ResultPoconst resultPoints: Int32Array,\n        //               BarcodeFormat format) {\n        //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())\n        // }\n        // public constructor(text: string,\n        //               Uint8Array rawBytes,\n        //               ResultPoconst resultPoints: Int32Array,\n        //               BarcodeFormat format,\n        //               long timestamp) {\n        //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,\n        //        resultPoints, format, timestamp)\n        // }\n        constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()) {\n            this.text = text;\n            this.rawBytes = rawBytes;\n            this.numBits = numBits;\n            this.resultPoints = resultPoints;\n            this.format = format;\n            this.timestamp = timestamp;\n            this.text = text;\n            this.rawBytes = rawBytes;\n            if (undefined === numBits || null === numBits) {\n                this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;\n            }\n            else {\n                this.numBits = numBits;\n            }\n            this.resultPoints = resultPoints;\n            this.format = format;\n            this.resultMetadata = null;\n            if (undefined === timestamp || null === timestamp) {\n                this.timestamp = System.currentTimeMillis();\n            }\n            else {\n                this.timestamp = timestamp;\n            }\n        }\n        /**\n         * @return raw text encoded by the barcode\n         */\n        getText() {\n            return this.text;\n        }\n        /**\n         * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}\n         */\n        getRawBytes() {\n            return this.rawBytes;\n        }\n        /**\n         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n         * @since 3.3.0\n         */\n        getNumBits() {\n            return this.numBits;\n        }\n        /**\n         * @return points related to the barcode in the image. These are typically points\n         *         identifying finder patterns or the corners of the barcode. The exact meaning is\n         *         specific to the type of barcode that was decoded.\n         */\n        getResultPoints() {\n            return this.resultPoints;\n        }\n        /**\n         * @return {@link BarcodeFormat} representing the format of the barcode that was decoded\n         */\n        getBarcodeFormat() {\n            return this.format;\n        }\n        /**\n         * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be\n         *   {@code null}. This contains optional metadata about what was detected about the barcode,\n         *   like orientation.\n         */\n        getResultMetadata() {\n            return this.resultMetadata;\n        }\n        putMetadata(type, value) {\n            if (this.resultMetadata === null) {\n                this.resultMetadata = new Map();\n            }\n            this.resultMetadata.set(type, value);\n        }\n        putAllMetadata(metadata) {\n            if (metadata !== null) {\n                if (this.resultMetadata === null) {\n                    this.resultMetadata = metadata;\n                }\n                else {\n                    this.resultMetadata = new Map(metadata);\n                }\n            }\n        }\n        addResultPoints(newPoints) {\n            const oldPoints = this.resultPoints;\n            if (oldPoints === null) {\n                this.resultPoints = newPoints;\n            }\n            else if (newPoints !== null && newPoints.length > 0) {\n                const allPoints = new Array(oldPoints.length + newPoints.length);\n                System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);\n                System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);\n                this.resultPoints = allPoints;\n            }\n        }\n        getTimestamp() {\n            return this.timestamp;\n        }\n        /*@Override*/\n        toString() {\n            return this.text;\n        }\n    }\n\n    /*\n     * Direct port to TypeScript of ZXing by Adrian Toc\n     */\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * Enumerates barcode formats known to this package. Please keep alphabetized.\n     *\n     * @author Sean Owen\n     */\n    var BarcodeFormat;\n    (function (BarcodeFormat) {\n        /** Aztec 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"AZTEC\"] = 0] = \"AZTEC\";\n        /** CODABAR 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODABAR\"] = 1] = \"CODABAR\";\n        /** Code 39 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODE_39\"] = 2] = \"CODE_39\";\n        /** Code 93 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODE_93\"] = 3] = \"CODE_93\";\n        /** Code 128 1D format. */\n        BarcodeFormat[BarcodeFormat[\"CODE_128\"] = 4] = \"CODE_128\";\n        /** Data Matrix 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"DATA_MATRIX\"] = 5] = \"DATA_MATRIX\";\n        /** EAN-8 1D format. */\n        BarcodeFormat[BarcodeFormat[\"EAN_8\"] = 6] = \"EAN_8\";\n        /** EAN-13 1D format. */\n        BarcodeFormat[BarcodeFormat[\"EAN_13\"] = 7] = \"EAN_13\";\n        /** ITF (Interleaved Two of Five) 1D format. */\n        BarcodeFormat[BarcodeFormat[\"ITF\"] = 8] = \"ITF\";\n        /** MaxiCode 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"MAXICODE\"] = 9] = \"MAXICODE\";\n        /** PDF417 format. */\n        BarcodeFormat[BarcodeFormat[\"PDF_417\"] = 10] = \"PDF_417\";\n        /** QR Code 2D barcode format. */\n        BarcodeFormat[BarcodeFormat[\"QR_CODE\"] = 11] = \"QR_CODE\";\n        /** RSS 14 */\n        BarcodeFormat[BarcodeFormat[\"RSS_14\"] = 12] = \"RSS_14\";\n        /** RSS EXPANDED */\n        BarcodeFormat[BarcodeFormat[\"RSS_EXPANDED\"] = 13] = \"RSS_EXPANDED\";\n        /** UPC-A 1D format. */\n        BarcodeFormat[BarcodeFormat[\"UPC_A\"] = 14] = \"UPC_A\";\n        /** UPC-E 1D format. */\n        BarcodeFormat[BarcodeFormat[\"UPC_E\"] = 15] = \"UPC_E\";\n        /** UPC/EAN extension format. Not a stand-alone format. */\n        BarcodeFormat[BarcodeFormat[\"UPC_EAN_EXTENSION\"] = 16] = \"UPC_EAN_EXTENSION\";\n    })(BarcodeFormat || (BarcodeFormat = {}));\n    var BarcodeFormat$1 = BarcodeFormat;\n\n    /*namespace com.google.zxing {*/\n    /**\n     * Represents some type of metadata about the result of the decoding that the decoder\n     * wishes to communicate back to the caller.\n     *\n     * @author Sean Owen\n     */\n    var ResultMetadataType;\n    (function (ResultMetadataType) {\n        /**\n         * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.\n         */\n        ResultMetadataType[ResultMetadataType[\"OTHER\"] = 0] = \"OTHER\";\n        /**\n         * Denotes the likely approximate orientation of the barcode in the image. This value\n         * is given as degrees rotated clockwise from the normal, upright orientation.\n         * For example a 1D barcode which was found by reading top-to-bottom would be\n         * said to have orientation \"90\". This key maps to an {@link Integer} whose\n         * value is in the range [0,360).\n         */\n        ResultMetadataType[ResultMetadataType[\"ORIENTATION\"] = 1] = \"ORIENTATION\";\n        /**\n         * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'\n         * which is sometimes used to encode binary data. While {@link Result} makes available\n         * the complete raw bytes in the barcode for these formats, it does not offer the bytes\n         * from the byte segments alone.</p>\n         *\n         * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the\n         * raw bytes in the byte segments in the barcode, in order.</p>\n         */\n        ResultMetadataType[ResultMetadataType[\"BYTE_SEGMENTS\"] = 2] = \"BYTE_SEGMENTS\";\n        /**\n         * Error correction level used, if applicable. The value type depends on the\n         * format, but is typically a String.\n         */\n        ResultMetadataType[ResultMetadataType[\"ERROR_CORRECTION_LEVEL\"] = 3] = \"ERROR_CORRECTION_LEVEL\";\n        /**\n         * For some periodicals, indicates the issue number as an {@link Integer}.\n         */\n        ResultMetadataType[ResultMetadataType[\"ISSUE_NUMBER\"] = 4] = \"ISSUE_NUMBER\";\n        /**\n         * For some products, indicates the suggested retail price in the barcode as a\n         * formatted {@link String}.\n         */\n        ResultMetadataType[ResultMetadataType[\"SUGGESTED_PRICE\"] = 5] = \"SUGGESTED_PRICE\";\n        /**\n         * For some products, the possible country of manufacture as a {@link String} denoting the\n         * ISO country code. Some map to multiple possible countries, like \"US/CA\".\n         */\n        ResultMetadataType[ResultMetadataType[\"POSSIBLE_COUNTRY\"] = 6] = \"POSSIBLE_COUNTRY\";\n        /**\n         * For some products, the extension text\n         */\n        ResultMetadataType[ResultMetadataType[\"UPC_EAN_EXTENSION\"] = 7] = \"UPC_EAN_EXTENSION\";\n        /**\n         * PDF417-specific metadata\n         */\n        ResultMetadataType[ResultMetadataType[\"PDF417_EXTRA_METADATA\"] = 8] = \"PDF417_EXTRA_METADATA\";\n        /**\n         * If the code format supports structured append and the current scanned code is part of one then the\n         * sequence number is given with it.\n         */\n        ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_SEQUENCE\"] = 9] = \"STRUCTURED_APPEND_SEQUENCE\";\n        /**\n         * If the code format supports structured append and the current scanned code is part of one then the\n         * parity is given with it.\n         */\n        ResultMetadataType[ResultMetadataType[\"STRUCTURED_APPEND_PARITY\"] = 10] = \"STRUCTURED_APPEND_PARITY\";\n    })(ResultMetadataType || (ResultMetadataType = {}));\n    var ResultMetadataType$1 = ResultMetadataType;\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing.common {*/\n    /*import java.util.List;*/\n    /**\n     * <p>Encapsulates the result of decoding a matrix of bits. This typically\n     * applies to 2D barcode formats. For now it contains the raw bytes obtained,\n     * as well as a String interpretation of those bytes, if applicable.</p>\n     *\n     * @author Sean Owen\n     */\n    class DecoderResult {\n        // public constructor(rawBytes: Uint8Array,\n        //                      text: string,\n        //                      List<Uint8Array> byteSegments,\n        //                      String ecLevel) {\n        //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)\n        // }\n        constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {\n            this.rawBytes = rawBytes;\n            this.text = text;\n            this.byteSegments = byteSegments;\n            this.ecLevel = ecLevel;\n            this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;\n            this.structuredAppendParity = structuredAppendParity;\n            this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;\n        }\n        /**\n         * @return raw bytes representing the result, or {@code null} if not applicable\n         */\n        getRawBytes() {\n            return this.rawBytes;\n        }\n        /**\n         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length\n         * @since 3.3.0\n         */\n        getNumBits() {\n            return this.numBits;\n        }\n        /**\n         * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}\n         * @since 3.3.0\n         */\n        setNumBits(numBits /*int*/) {\n            this.numBits = numBits;\n        }\n        /**\n         * @return text representation of the result\n         */\n        getText() {\n            return this.text;\n        }\n        /**\n         * @return list of byte segments in the result, or {@code null} if not applicable\n         */\n        getByteSegments() {\n            return this.byteSegments;\n        }\n        /**\n         * @return name of error correction level used, or {@code null} if not applicable\n         */\n        getECLevel() {\n            return this.ecLevel;\n        }\n        /**\n         * @return number of errors corrected, or {@code null} if not applicable\n         */\n        getErrorsCorrected() {\n            return this.errorsCorrected;\n        }\n        setErrorsCorrected(errorsCorrected /*Integer*/) {\n            this.errorsCorrected = errorsCorrected;\n        }\n        /**\n         * @return number of erasures corrected, or {@code null} if not applicable\n         */\n        getErasures() {\n            return this.erasures;\n        }\n        setErasures(erasures /*Integer*/) {\n            this.erasures = erasures;\n        }\n        /**\n         * @return arbitrary additional metadata\n         */\n        getOther() {\n            return this.other;\n        }\n        setOther(other) {\n            this.other = other;\n        }\n        hasStructuredAppend() {\n            return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;\n        }\n        getStructuredAppendParity() {\n            return this.structuredAppendParity;\n        }\n        getStructuredAppendSequenceNumber() {\n            return this.structuredAppendSequenceNumber;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>This class contains utility methods for performing mathematical operations over\n     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n     *\n     * <p>Throughout this package, elements of the GF are represented as an {@code int}\n     * for convenience and speed (but at the cost of memory).\n     * </p>\n     *\n     * @author Sean Owen\n     * @author David Olivier\n     */\n    class AbstractGenericGF {\n        /**\n         * @return 2 to the power of a in GF(size)\n         */\n        exp(a) {\n            return this.expTable[a];\n        }\n        /**\n         * @return base 2 log of a in GF(size)\n         */\n        log(a /*int*/) {\n            if (a === 0) {\n                throw new IllegalArgumentException();\n            }\n            return this.logTable[a];\n        }\n        /**\n         * Implements both addition and subtraction -- they are the same in GF(size).\n         *\n         * @return sum/difference of a and b\n         */\n        static addOrSubtract(a /*int*/, b /*int*/) {\n            return a ^ b;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Represents a polynomial whose coefficients are elements of a GF.\n     * Instances of this class are immutable.</p>\n     *\n     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n     * port of his C++ Reed-Solomon implementation.</p>\n     *\n     * @author Sean Owen\n     */\n    class GenericGFPoly {\n        /**\n         * @param field the {@link GenericGF} instance representing the field to use\n         * to perform computations\n         * @param coefficients coefficients as ints representing elements of GF(size), arranged\n         * from most significant (highest-power term) coefficient to least significant\n         * @throws IllegalArgumentException if argument is null or empty,\n         * or if leading coefficient is 0 and this is not a\n         * constant polynomial (that is, it is not the monomial \"0\")\n         */\n        constructor(field, coefficients) {\n            if (coefficients.length === 0) {\n                throw new IllegalArgumentException();\n            }\n            this.field = field;\n            const coefficientsLength = coefficients.length;\n            if (coefficientsLength > 1 && coefficients[0] === 0) {\n                // Leading term must be non-zero for anything except the constant polynomial \"0\"\n                let firstNonZero = 1;\n                while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                    firstNonZero++;\n                }\n                if (firstNonZero === coefficientsLength) {\n                    this.coefficients = Int32Array.from([0]);\n                }\n                else {\n                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n                }\n            }\n            else {\n                this.coefficients = coefficients;\n            }\n        }\n        getCoefficients() {\n            return this.coefficients;\n        }\n        /**\n         * @return degree of this polynomial\n         */\n        getDegree() {\n            return this.coefficients.length - 1;\n        }\n        /**\n         * @return true iff this polynomial is the monomial \"0\"\n         */\n        isZero() {\n            return this.coefficients[0] === 0;\n        }\n        /**\n         * @return coefficient of x^degree term in this polynomial\n         */\n        getCoefficient(degree /*int*/) {\n            return this.coefficients[this.coefficients.length - 1 - degree];\n        }\n        /**\n         * @return evaluation of this polynomial at a given point\n         */\n        evaluateAt(a /*int*/) {\n            if (a === 0) {\n                // Just return the x^0 coefficient\n                return this.getCoefficient(0);\n            }\n            const coefficients = this.coefficients;\n            let result;\n            if (a === 1) {\n                // Just the sum of the coefficients\n                result = 0;\n                for (let i = 0, length = coefficients.length; i !== length; i++) {\n                    const coefficient = coefficients[i];\n                    result = AbstractGenericGF.addOrSubtract(result, coefficient);\n                }\n                return result;\n            }\n            result = coefficients[0];\n            const size = coefficients.length;\n            const field = this.field;\n            for (let i = 1; i < size; i++) {\n                result = AbstractGenericGF.addOrSubtract(field.multiply(a, result), coefficients[i]);\n            }\n            return result;\n        }\n        addOrSubtract(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');\n            }\n            if (this.isZero()) {\n                return other;\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            let smallerCoefficients = this.coefficients;\n            let largerCoefficients = other.coefficients;\n            if (smallerCoefficients.length > largerCoefficients.length) {\n                const temp = smallerCoefficients;\n                smallerCoefficients = largerCoefficients;\n                largerCoefficients = temp;\n            }\n            let sumDiff = new Int32Array(largerCoefficients.length);\n            const lengthDiff = largerCoefficients.length - smallerCoefficients.length;\n            // Copy high-order terms only found in higher-degree polynomial's coefficients\n            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n            for (let i = lengthDiff; i < largerCoefficients.length; i++) {\n                sumDiff[i] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n            }\n            return new GenericGFPoly(this.field, sumDiff);\n        }\n        multiply(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');\n            }\n            if (this.isZero() || other.isZero()) {\n                return this.field.getZero();\n            }\n            const aCoefficients = this.coefficients;\n            const aLength = aCoefficients.length;\n            const bCoefficients = other.coefficients;\n            const bLength = bCoefficients.length;\n            const product = new Int32Array(aLength + bLength - 1);\n            const field = this.field;\n            for (let i = 0; i < aLength; i++) {\n                const aCoeff = aCoefficients[i];\n                for (let j = 0; j < bLength; j++) {\n                    product[i + j] = AbstractGenericGF.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));\n                }\n            }\n            return new GenericGFPoly(field, product);\n        }\n        multiplyScalar(scalar /*int*/) {\n            if (scalar === 0) {\n                return this.field.getZero();\n            }\n            if (scalar === 1) {\n                return this;\n            }\n            const size = this.coefficients.length;\n            const field = this.field;\n            const product = new Int32Array(size);\n            const coefficients = this.coefficients;\n            for (let i = 0; i < size; i++) {\n                product[i] = field.multiply(coefficients[i], scalar);\n            }\n            return new GenericGFPoly(field, product);\n        }\n        multiplyByMonomial(degree /*int*/, coefficient /*int*/) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.field.getZero();\n            }\n            const coefficients = this.coefficients;\n            const size = coefficients.length;\n            const product = new Int32Array(size + degree);\n            const field = this.field;\n            for (let i = 0; i < size; i++) {\n                product[i] = field.multiply(coefficients[i], coefficient);\n            }\n            return new GenericGFPoly(field, product);\n        }\n        divide(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');\n            }\n            if (other.isZero()) {\n                throw new IllegalArgumentException('Divide by 0');\n            }\n            const field = this.field;\n            let quotient = field.getZero();\n            let remainder = this;\n            const denominatorLeadingTerm = other.getCoefficient(other.getDegree());\n            const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);\n            while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n                const degreeDifference = remainder.getDegree() - other.getDegree();\n                const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n                const term = other.multiplyByMonomial(degreeDifference, scale);\n                const iterationQuotient = field.buildMonomial(degreeDifference, scale);\n                quotient = quotient.addOrSubtract(iterationQuotient);\n                remainder = remainder.addOrSubtract(term);\n            }\n            return [quotient, remainder];\n        }\n        /*@Override*/\n        toString() {\n            let result = '';\n            for (let degree = this.getDegree(); degree >= 0; degree--) {\n                let coefficient = this.getCoefficient(degree);\n                if (coefficient !== 0) {\n                    if (coefficient < 0) {\n                        result += ' - ';\n                        coefficient = -coefficient;\n                    }\n                    else {\n                        if (result.length > 0) {\n                            result += ' + ';\n                        }\n                    }\n                    if (degree === 0 || coefficient !== 1) {\n                        const alphaPower = this.field.log(coefficient);\n                        if (alphaPower === 0) {\n                            result += '1';\n                        }\n                        else if (alphaPower === 1) {\n                            result += 'a';\n                        }\n                        else {\n                            result += 'a^';\n                            result += alphaPower;\n                        }\n                    }\n                    if (degree !== 0) {\n                        if (degree === 1) {\n                            result += 'x';\n                        }\n                        else {\n                            result += 'x^';\n                            result += degree;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ArithmeticException extends Exception {\n    }\n    ArithmeticException.kind = 'ArithmeticException';\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>This class contains utility methods for performing mathematical operations over\n     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>\n     *\n     * <p>Throughout this package, elements of the GF are represented as an {@code int}\n     * for convenience and speed (but at the cost of memory).\n     * </p>\n     *\n     * @author Sean Owen\n     * @author David Olivier\n     */\n    class GenericGF extends AbstractGenericGF {\n        /**\n         * Create a representation of GF(size) using the given primitive polynomial.\n         *\n         * @param primitive irreducible polynomial whose coefficients are represented by\n         *  the bits of an int, where the least-significant bit represents the constant\n         *  coefficient\n         * @param size the size of the field\n         * @param b the factor b in the generator polynomial can be 0- or 1-based\n         *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).\n         *  In most cases it should be 1, but for QR code it is 0.\n         */\n        constructor(primitive /*int*/, size /*int*/, generatorBase /*int*/) {\n            super();\n            this.primitive = primitive;\n            this.size = size;\n            this.generatorBase = generatorBase;\n            const expTable = new Int32Array(size);\n            let x = 1;\n            for (let i = 0; i < size; i++) {\n                expTable[i] = x;\n                x *= 2; // we're assuming the generator alpha is 2\n                if (x >= size) {\n                    x ^= primitive;\n                    x &= size - 1;\n                }\n            }\n            this.expTable = expTable;\n            const logTable = new Int32Array(size);\n            for (let i = 0; i < size - 1; i++) {\n                logTable[expTable[i]] = i;\n            }\n            this.logTable = logTable;\n            // logTable[0] == 0 but this should never be used\n            this.zero = new GenericGFPoly(this, Int32Array.from([0]));\n            this.one = new GenericGFPoly(this, Int32Array.from([1]));\n        }\n        getZero() {\n            return this.zero;\n        }\n        getOne() {\n            return this.one;\n        }\n        /**\n         * @return the monomial representing coefficient * x^degree\n         */\n        buildMonomial(degree /*int*/, coefficient /*int*/) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.zero;\n            }\n            const coefficients = new Int32Array(degree + 1);\n            coefficients[0] = coefficient;\n            return new GenericGFPoly(this, coefficients);\n        }\n        /**\n         * @return multiplicative inverse of a\n         */\n        inverse(a /*int*/) {\n            if (a === 0) {\n                throw new ArithmeticException();\n            }\n            return this.expTable[this.size - this.logTable[a] - 1];\n        }\n        /**\n         * @return product of a and b in GF(size)\n         */\n        multiply(a /*int*/, b /*int*/) {\n            if (a === 0 || b === 0) {\n                return 0;\n            }\n            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];\n        }\n        getSize() {\n            return this.size;\n        }\n        getGeneratorBase() {\n            return this.generatorBase;\n        }\n        /*@Override*/\n        toString() {\n            return ('GF(0x' + Integer.toHexString(this.primitive) + ',' + this.size + ')');\n        }\n        equals(o) {\n            return o === this;\n        }\n    }\n    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1\n    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1\n    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1\n    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1\n    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1\n    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1\n    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;\n    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ReedSolomonException extends Exception {\n    }\n    ReedSolomonException.kind = 'ReedSolomonException';\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class IllegalStateException extends Exception {\n    }\n    IllegalStateException.kind = 'IllegalStateException';\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Implements Reed-Solomon decoding, as the name implies.</p>\n     *\n     * <p>The algorithm will not be explained here, but the following references were helpful\n     * in creating this implementation:</p>\n     *\n     * <ul>\n     * <li>Bruce Maggs.\n     * <a href=\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps\">\n     * \"Decoding Reed-Solomon Codes\"</a> (see discussion of Forney's Formula)</li>\n     * <li>J.I. Hall. <a href=\"www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf\">\n     * \"Chapter 5. Generalized Reed-Solomon Codes\"</a>\n     * (see discussion of Euclidean algorithm)</li>\n     * </ul>\n     *\n     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect\n     * port of his C++ Reed-Solomon implementation.</p>\n     *\n     * @author Sean Owen\n     * @author William Rucklidge\n     * @author sanfordsquires\n     */\n    class ReedSolomonDecoder {\n        constructor(field) {\n            this.field = field;\n        }\n        /**\n         * <p>Decodes given set of received codewords, which include both data and error-correction\n         * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,\n         * in the input.</p>\n         *\n         * @param received data and error-correction codewords\n         * @param twoS number of error-correction codewords available\n         * @throws ReedSolomonException if decoding fails for any reason\n         */\n        decode(received, twoS /*int*/) {\n            const field = this.field;\n            const poly = new GenericGFPoly(field, received);\n            const syndromeCoefficients = new Int32Array(twoS);\n            let noError = true;\n            for (let i = 0; i < twoS; i++) {\n                const evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n                syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;\n                if (evalResult !== 0) {\n                    noError = false;\n                }\n            }\n            if (noError) {\n                return;\n            }\n            const syndrome = new GenericGFPoly(field, syndromeCoefficients);\n            const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n            const sigma = sigmaOmega[0];\n            const omega = sigmaOmega[1];\n            const errorLocations = this.findErrorLocations(sigma);\n            const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);\n            for (let i = 0; i < errorLocations.length; i++) {\n                const position = received.length - 1 - field.log(errorLocations[i]);\n                if (position < 0) {\n                    throw new ReedSolomonException('Bad error location');\n                }\n                received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);\n            }\n        }\n        runEuclideanAlgorithm(a, b, R /*int*/) {\n            // Assume a's degree is >= b's\n            if (a.getDegree() < b.getDegree()) {\n                const temp = a;\n                a = b;\n                b = temp;\n            }\n            const field = this.field;\n            let rLast = a;\n            let r = b;\n            let tLast = field.getZero();\n            let t = field.getOne();\n            // Run Euclidean algorithm until r's degree is less than R/2\n            while (r.getDegree() >= (R / 2 | 0)) {\n                let rLastLast = rLast;\n                let tLastLast = tLast;\n                rLast = r;\n                tLast = t;\n                // Divide rLastLast by rLast, with quotient in q and remainder in r\n                if (rLast.isZero()) {\n                    // Oops, Euclidean algorithm already terminated?\n                    throw new ReedSolomonException('r_{i-1} was zero');\n                }\n                r = rLastLast;\n                let q = field.getZero();\n                const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n                const dltInverse = field.inverse(denominatorLeadingTerm);\n                while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                    const degreeDiff = r.getDegree() - rLast.getDegree();\n                    const scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                    q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));\n                    r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));\n                }\n                t = q.multiply(tLast).addOrSubtract(tLastLast);\n                if (r.getDegree() >= rLast.getDegree()) {\n                    throw new IllegalStateException('Division algorithm failed to reduce polynomial?');\n                }\n            }\n            const sigmaTildeAtZero = t.getCoefficient(0);\n            if (sigmaTildeAtZero === 0) {\n                throw new ReedSolomonException('sigmaTilde(0) was zero');\n            }\n            const inverse = field.inverse(sigmaTildeAtZero);\n            const sigma = t.multiplyScalar(inverse);\n            const omega = r.multiplyScalar(inverse);\n            return [sigma, omega];\n        }\n        findErrorLocations(errorLocator) {\n            // This is a direct application of Chien's search\n            const numErrors = errorLocator.getDegree();\n            if (numErrors === 1) { // shortcut\n                return Int32Array.from([errorLocator.getCoefficient(1)]);\n            }\n            const result = new Int32Array(numErrors);\n            let e = 0;\n            const field = this.field;\n            for (let i = 1; i < field.getSize() && e < numErrors; i++) {\n                if (errorLocator.evaluateAt(i) === 0) {\n                    result[e] = field.inverse(i);\n                    e++;\n                }\n            }\n            if (e !== numErrors) {\n                throw new ReedSolomonException('Error locator degree does not match number of roots');\n            }\n            return result;\n        }\n        findErrorMagnitudes(errorEvaluator, errorLocations) {\n            // This is directly applying Forney's Formula\n            const s = errorLocations.length;\n            const result = new Int32Array(s);\n            const field = this.field;\n            for (let i = 0; i < s; i++) {\n                const xiInverse = field.inverse(errorLocations[i]);\n                let denominator = 1;\n                for (let j = 0; j < s; j++) {\n                    if (i !== j) {\n                        // denominator = field.multiply(denominator,\n                        //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))\n                        // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.\n                        // Below is a funny-looking workaround from Steven Parkes\n                        const term = field.multiply(errorLocations[j], xiInverse);\n                        const termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;\n                        denominator = field.multiply(denominator, termPlus1);\n                    }\n                }\n                result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));\n                if (field.getGeneratorBase() !== 0) {\n                    result[i] = field.multiply(result[i], xiInverse);\n                }\n            }\n            return result;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.Arrays;\n    var Table;\n    (function (Table) {\n        Table[Table[\"UPPER\"] = 0] = \"UPPER\";\n        Table[Table[\"LOWER\"] = 1] = \"LOWER\";\n        Table[Table[\"MIXED\"] = 2] = \"MIXED\";\n        Table[Table[\"DIGIT\"] = 3] = \"DIGIT\";\n        Table[Table[\"PUNCT\"] = 4] = \"PUNCT\";\n        Table[Table[\"BINARY\"] = 5] = \"BINARY\";\n    })(Table || (Table = {}));\n    /**\n     * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting\n     * the Aztec Code from an image.</p>\n     *\n     * @author David Olivier\n     */\n    class Decoder {\n        decode(detectorResult) {\n            this.ddata = detectorResult;\n            let matrix = detectorResult.getBits();\n            let rawbits = this.extractBits(matrix);\n            let correctedBits = this.correctBits(rawbits);\n            let rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);\n            let result = Decoder.getEncodedData(correctedBits);\n            let decoderResult = new DecoderResult(rawBytes, result, null, null);\n            decoderResult.setNumBits(correctedBits.length);\n            return decoderResult;\n        }\n        // This method is used for testing the high-level encoder\n        static highLevelDecode(correctedBits) {\n            return this.getEncodedData(correctedBits);\n        }\n        /**\n         * Gets the string encoded in the aztec code bits\n         *\n         * @return the decoded string\n         */\n        static getEncodedData(correctedBits) {\n            let endIndex = correctedBits.length;\n            let latchTable = Table.UPPER; // table most recently latched to\n            let shiftTable = Table.UPPER; // table to use for the next read\n            let result = '';\n            let index = 0;\n            while (index < endIndex) {\n                if (shiftTable === Table.BINARY) {\n                    if (endIndex - index < 5) {\n                        break;\n                    }\n                    let length = Decoder.readCode(correctedBits, index, 5);\n                    index += 5;\n                    if (length === 0) {\n                        if (endIndex - index < 11) {\n                            break;\n                        }\n                        length = Decoder.readCode(correctedBits, index, 11) + 31;\n                        index += 11;\n                    }\n                    for (let charCount = 0; charCount < length; charCount++) {\n                        if (endIndex - index < 8) {\n                            index = endIndex; // Force outer loop to exit\n                            break;\n                        }\n                        const code = Decoder.readCode(correctedBits, index, 8);\n                        result += /*(char)*/ StringUtils.castAsNonUtf8Char(code);\n                        index += 8;\n                    }\n                    // Go back to whatever mode we had been in\n                    shiftTable = latchTable;\n                }\n                else {\n                    let size = shiftTable === Table.DIGIT ? 4 : 5;\n                    if (endIndex - index < size) {\n                        break;\n                    }\n                    let code = Decoder.readCode(correctedBits, index, size);\n                    index += size;\n                    let str = Decoder.getCharacter(shiftTable, code);\n                    if (str.startsWith('CTRL_')) {\n                        // Table changes\n                        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n                        // That's including when that mode is a shift.\n                        // Our test case dlusbs.png for issue #642 exercises that.\n                        latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S\n                        shiftTable = Decoder.getTable(str.charAt(5));\n                        if (str.charAt(6) === 'L') {\n                            latchTable = shiftTable;\n                        }\n                    }\n                    else {\n                        result += str;\n                        // Go back to whatever mode we had been in\n                        shiftTable = latchTable;\n                    }\n                }\n            }\n            return result;\n        }\n        /**\n         * gets the table corresponding to the char passed\n         */\n        static getTable(t) {\n            switch (t) {\n                case 'L':\n                    return Table.LOWER;\n                case 'P':\n                    return Table.PUNCT;\n                case 'M':\n                    return Table.MIXED;\n                case 'D':\n                    return Table.DIGIT;\n                case 'B':\n                    return Table.BINARY;\n                case 'U':\n                default:\n                    return Table.UPPER;\n            }\n        }\n        /**\n         * Gets the character (or string) corresponding to the passed code in the given table\n         *\n         * @param table the table used\n         * @param code the code of the character\n         */\n        static getCharacter(table, code) {\n            switch (table) {\n                case Table.UPPER:\n                    return Decoder.UPPER_TABLE[code];\n                case Table.LOWER:\n                    return Decoder.LOWER_TABLE[code];\n                case Table.MIXED:\n                    return Decoder.MIXED_TABLE[code];\n                case Table.PUNCT:\n                    return Decoder.PUNCT_TABLE[code];\n                case Table.DIGIT:\n                    return Decoder.DIGIT_TABLE[code];\n                default:\n                    // Should not reach here.\n                    throw new IllegalStateException('Bad table');\n            }\n        }\n        /**\n         * <p>Performs RS error correction on an array of bits.</p>\n         *\n         * @return the corrected array\n         * @throws FormatException if the input contains too many errors\n         */\n        correctBits(rawbits) {\n            let gf;\n            let codewordSize;\n            if (this.ddata.getNbLayers() <= 2) {\n                codewordSize = 6;\n                gf = GenericGF.AZTEC_DATA_6;\n            }\n            else if (this.ddata.getNbLayers() <= 8) {\n                codewordSize = 8;\n                gf = GenericGF.AZTEC_DATA_8;\n            }\n            else if (this.ddata.getNbLayers() <= 22) {\n                codewordSize = 10;\n                gf = GenericGF.AZTEC_DATA_10;\n            }\n            else {\n                codewordSize = 12;\n                gf = GenericGF.AZTEC_DATA_12;\n            }\n            let numDataCodewords = this.ddata.getNbDatablocks();\n            let numCodewords = rawbits.length / codewordSize;\n            if (numCodewords < numDataCodewords) {\n                throw new FormatException();\n            }\n            let offset = rawbits.length % codewordSize;\n            let dataWords = new Int32Array(numCodewords);\n            for (let i = 0; i < numCodewords; i++, offset += codewordSize) {\n                dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);\n            }\n            try {\n                let rsDecoder = new ReedSolomonDecoder(gf);\n                rsDecoder.decode(dataWords, numCodewords - numDataCodewords);\n            }\n            catch (ex) {\n                throw new FormatException(ex);\n            }\n            // Now perform the unstuffing operation.\n            // First, count how many bits are going to be thrown out as stuffing\n            let mask = (1 << codewordSize) - 1;\n            let stuffedBits = 0;\n            for (let i = 0; i < numDataCodewords; i++) {\n                let dataWord = dataWords[i];\n                if (dataWord === 0 || dataWord === mask) {\n                    throw new FormatException();\n                }\n                else if (dataWord === 1 || dataWord === mask - 1) {\n                    stuffedBits++;\n                }\n            }\n            // Now, actually unpack the bits and remove the stuffing\n            let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);\n            let index = 0;\n            for (let i = 0; i < numDataCodewords; i++) {\n                let dataWord = dataWords[i];\n                if (dataWord === 1 || dataWord === mask - 1) {\n                    // next codewordSize-1 bits are all zeros or all ones\n                    correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);\n                    // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);\n                    index += codewordSize - 1;\n                }\n                else {\n                    for (let bit = codewordSize - 1; bit >= 0; --bit) {\n                        correctedBits[index++] = (dataWord & (1 << bit)) !== 0;\n                    }\n                }\n            }\n            return correctedBits;\n        }\n        /**\n         * Gets the array of bits from an Aztec Code matrix\n         *\n         * @return the array of bits\n         */\n        extractBits(matrix) {\n            let compact = this.ddata.isCompact();\n            let layers = this.ddata.getNbLayers();\n            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n            let alignmentMap = new Int32Array(baseMatrixSize);\n            let rawbits = new Array(this.totalBitsInLayer(layers, compact));\n            if (compact) {\n                for (let i = 0; i < alignmentMap.length; i++) {\n                    alignmentMap[i] = i;\n                }\n            }\n            else {\n                let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);\n                let origCenter = baseMatrixSize / 2;\n                let center = Integer.truncDivision(matrixSize, 2);\n                for (let i = 0; i < origCenter; i++) {\n                    let newOffset = i + Integer.truncDivision(i, 15);\n                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                    alignmentMap[origCenter + i] = center + newOffset + 1;\n                }\n            }\n            for (let i = 0, rowOffset = 0; i < layers; i++) {\n                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n                // The top-left most point of this layer is <low, low> (not including alignment lines)\n                let low = i * 2;\n                // The bottom-right most point of this layer is <high, high> (not including alignment lines)\n                let high = baseMatrixSize - 1 - low;\n                // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows\n                for (let j = 0; j < rowSize; j++) {\n                    let columnOffset = j * 2;\n                    for (let k = 0; k < 2; k++) {\n                        // left column\n                        rawbits[rowOffset + columnOffset + k] =\n                            matrix.get(alignmentMap[low + k], alignmentMap[low + j]);\n                        // bottom row\n                        rawbits[rowOffset + 2 * rowSize + columnOffset + k] =\n                            matrix.get(alignmentMap[low + j], alignmentMap[high - k]);\n                        // right column\n                        rawbits[rowOffset + 4 * rowSize + columnOffset + k] =\n                            matrix.get(alignmentMap[high - k], alignmentMap[high - j]);\n                        // top row\n                        rawbits[rowOffset + 6 * rowSize + columnOffset + k] =\n                            matrix.get(alignmentMap[high - j], alignmentMap[low + k]);\n                    }\n                }\n                rowOffset += rowSize * 8;\n            }\n            return rawbits;\n        }\n        /**\n         * Reads a code of given length and at given index in an array of bits\n         */\n        static readCode(rawbits, startIndex, length) {\n            let res = 0;\n            for (let i = startIndex; i < startIndex + length; i++) {\n                res <<= 1;\n                if (rawbits[i]) {\n                    res |= 0x01;\n                }\n            }\n            return res;\n        }\n        /**\n         * Reads a code of length 8 in an array of bits, padding with zeros\n         */\n        static readByte(rawbits, startIndex) {\n            let n = rawbits.length - startIndex;\n            if (n >= 8) {\n                return Decoder.readCode(rawbits, startIndex, 8);\n            }\n            return Decoder.readCode(rawbits, startIndex, n) << (8 - n);\n        }\n        /**\n         * Packs a bit array into bytes, most significant bit first\n         */\n        static convertBoolArrayToByteArray(boolArr) {\n            let byteArr = new Uint8Array((boolArr.length + 7) / 8);\n            for (let i = 0; i < byteArr.length; i++) {\n                byteArr[i] = Decoder.readByte(boolArr, 8 * i);\n            }\n            return byteArr;\n        }\n        totalBitsInLayer(layers, compact) {\n            return ((compact ? 88 : 112) + 16 * layers) * layers;\n        }\n    }\n    Decoder.UPPER_TABLE = [\n        'CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.LOWER_TABLE = [\n        'CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n        'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'\n    ];\n    Decoder.MIXED_TABLE = [\n        // Module parse failed: Octal literal in strict mode (50:29)\n        // so number string were scaped\n        'CTRL_PS', ' ', '\\\\1', '\\\\2', '\\\\3', '\\\\4', '\\\\5', '\\\\6', '\\\\7', '\\b', '\\t', '\\n',\n        '\\\\13', '\\f', '\\r', '\\\\33', '\\\\34', '\\\\35', '\\\\36', '\\\\37', '@', '\\\\', '^', '_',\n        '`', '|', '~', '\\\\177', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'\n    ];\n    Decoder.PUNCT_TABLE = [\n        '', '\\r', '\\r\\n', '. ', ', ', ': ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')',\n        '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'\n    ];\n    Decoder.DIGIT_TABLE = [\n        'CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'\n    ];\n\n    /*\n     * Copyright 2012 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing.common.detector {*/\n    /**\n     * General math-related and numeric utility functions.\n     */\n    class MathUtils {\n        constructor() { }\n        /**\n         * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its\n         * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut\n         * differ slightly from {@link Math#round(float)} in that half rounds down for negative\n         * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.\n         *\n         * @param d real value to round\n         * @return nearest {@code int}\n         */\n        static round(d /*float*/) {\n            if (NaN === d)\n                return 0;\n            if (d <= Number.MIN_SAFE_INTEGER)\n                return Number.MIN_SAFE_INTEGER;\n            if (d >= Number.MAX_SAFE_INTEGER)\n                return Number.MAX_SAFE_INTEGER;\n            return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;\n        }\n        // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js\n        /**\n         * @param aX point A x coordinate\n         * @param aY point A y coordinate\n         * @param bX point B x coordinate\n         * @param bY point B y coordinate\n         * @return Euclidean distance between points A and B\n         */\n        static distance(aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {\n            const xDiff = aX - bX;\n            const yDiff = aY - bY;\n            return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n        }\n        /**\n         * @param aX point A x coordinate\n         * @param aY point A y coordinate\n         * @param bX point B x coordinate\n         * @param bY point B y coordinate\n         * @return Euclidean distance between points A and B\n         */\n        // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {\n        //   const xDiff = aX - bX\n        //   const yDiff = aY - bY\n        //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n        // }\n        /**\n         * @param array values to sum\n         * @return sum of values in array\n         */\n        static sum(array) {\n            let count = 0;\n            for (let i = 0, length = array.length; i !== length; i++) {\n                const a = array[i];\n                count += a;\n            }\n            return count;\n        }\n    }\n\n    /**\n     * Ponyfill for Java's Float class.\n     */\n    class Float {\n        /**\n         * SincTS has no difference between int and float, there's all numbers,\n         * this is used only to polyfill Java code.\n         */\n        static floatToIntBits(f) {\n            return f;\n        }\n    }\n    /**\n     * The float max value in JS is the number max value.\n     */\n    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this\n     * would be the location of a finder pattern or the corner of the barcode, for example.</p>\n     *\n     * @author Sean Owen\n     */\n    class ResultPoint {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        getX() {\n            return this.x;\n        }\n        getY() {\n            return this.y;\n        }\n        /*@Override*/\n        equals(other) {\n            if (other instanceof ResultPoint) {\n                const otherPoint = other;\n                return this.x === otherPoint.x && this.y === otherPoint.y;\n            }\n            return false;\n        }\n        /*@Override*/\n        hashCode() {\n            return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);\n        }\n        /*@Override*/\n        toString() {\n            return '(' + this.x + ',' + this.y + ')';\n        }\n        /**\n         * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC\n         * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.\n         *\n         * @param patterns array of three {@code ResultPoint} to order\n         */\n        static orderBestPatterns(patterns) {\n            // Find distances between pattern centers\n            const zeroOneDistance = this.distance(patterns[0], patterns[1]);\n            const oneTwoDistance = this.distance(patterns[1], patterns[2]);\n            const zeroTwoDistance = this.distance(patterns[0], patterns[2]);\n            let pointA;\n            let pointB;\n            let pointC;\n            // Assume one closest to other two is B; A and C will just be guesses at first\n            if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {\n                pointB = patterns[0];\n                pointA = patterns[1];\n                pointC = patterns[2];\n            }\n            else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {\n                pointB = patterns[1];\n                pointA = patterns[0];\n                pointC = patterns[2];\n            }\n            else {\n                pointB = patterns[2];\n                pointA = patterns[0];\n                pointC = patterns[1];\n            }\n            // Use cross product to figure out whether A and C are correct or flipped.\n            // This asks whether BC x BA has a positive z component, which is the arrangement\n            // we want for A, B, C. If it's negative, then we've got it flipped around and\n            // should swap A and C.\n            if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {\n                const temp = pointA;\n                pointA = pointC;\n                pointC = temp;\n            }\n            patterns[0] = pointA;\n            patterns[1] = pointB;\n            patterns[2] = pointC;\n        }\n        /**\n         * @param pattern1 first pattern\n         * @param pattern2 second pattern\n         * @return distance between two points\n         */\n        static distance(pattern1, pattern2) {\n            return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);\n        }\n        /**\n         * Returns the z component of the cross product between vectors BC and BA.\n         */\n        static crossProductZ(pointA, pointB, pointC) {\n            const bX = pointB.x;\n            const bY = pointB.y;\n            return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw\n     * matrix of black/white pixels corresponding to the barcode, and possibly points of interest\n     * in the image, like the location of finder patterns or corners of the barcode in the image.</p>\n     *\n     * @author Sean Owen\n     */\n    class DetectorResult {\n        constructor(bits, points) {\n            this.bits = bits;\n            this.points = points;\n        }\n        getBits() {\n            return this.bits;\n        }\n        getPoints() {\n            return this.points;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,\n     * like the number of layers and whether it's compact.</p>\n     *\n     * @author Sean Owen\n     */\n    class AztecDetectorResult extends DetectorResult {\n        constructor(bits, points, compact, nbDatablocks, nbLayers) {\n            super(bits, points);\n            this.compact = compact;\n            this.nbDatablocks = nbDatablocks;\n            this.nbLayers = nbLayers;\n        }\n        getNbLayers() {\n            return this.nbLayers;\n        }\n        getNbDatablocks() {\n            return this.nbDatablocks;\n        }\n        isCompact() {\n            return this.compact;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>\n     * Detects a candidate barcode-like rectangular region within an image. It\n     * starts around the center of the image, increases the size of the candidate\n     * region until it finds a white rectangular region. By keeping track of the\n     * last black points it encountered, it determines the corners of the barcode.\n     * </p>\n     *\n     * @author David Olivier\n     */\n    class WhiteRectangleDetector {\n        // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {\n        //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)\n        // }\n        /**\n         * @param image barcode image to find a rectangle in\n         * @param initSize initial size of search area around center\n         * @param x x position of search center\n         * @param y y position of search center\n         * @throws NotFoundException if image is too small to accommodate {@code initSize}\n         */\n        constructor(image, initSize /*int*/, x /*int*/, y /*int*/) {\n            this.image = image;\n            this.height = image.getHeight();\n            this.width = image.getWidth();\n            if (undefined === initSize || null === initSize) {\n                initSize = WhiteRectangleDetector.INIT_SIZE;\n            }\n            if (undefined === x || null === x) {\n                x = image.getWidth() / 2 | 0;\n            }\n            if (undefined === y || null === y) {\n                y = image.getHeight() / 2 | 0;\n            }\n            const halfsize = initSize / 2 | 0;\n            this.leftInit = x - halfsize;\n            this.rightInit = x + halfsize;\n            this.upInit = y - halfsize;\n            this.downInit = y + halfsize;\n            if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {\n                throw new NotFoundException();\n            }\n        }\n        /**\n         * <p>\n         * Detects a candidate barcode-like rectangular region within an image. It\n         * starts around the center of the image, increases the size of the candidate\n         * region until it finds a white rectangular region.\n         * </p>\n         *\n         * @return {@link ResultPoint}[] describing the corners of the rectangular\n         *         region. The first and last points are opposed on the diagonal, as\n         *         are the second and third. The first point will be the topmost\n         *         point and the last, the bottommost. The second point will be\n         *         leftmost and the third, the rightmost\n         * @throws NotFoundException if no Data Matrix Code can be found\n         */\n        detect() {\n            let left = this.leftInit;\n            let right = this.rightInit;\n            let up = this.upInit;\n            let down = this.downInit;\n            let sizeExceeded = false;\n            let aBlackPointFoundOnBorder = true;\n            let atLeastOneBlackPointFoundOnBorder = false;\n            let atLeastOneBlackPointFoundOnRight = false;\n            let atLeastOneBlackPointFoundOnBottom = false;\n            let atLeastOneBlackPointFoundOnLeft = false;\n            let atLeastOneBlackPointFoundOnTop = false;\n            const width = this.width;\n            const height = this.height;\n            while (aBlackPointFoundOnBorder) {\n                aBlackPointFoundOnBorder = false;\n                // .....\n                // .   |\n                // .....\n                let rightBorderNotWhite = true;\n                while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n                    rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);\n                    if (rightBorderNotWhite) {\n                        right++;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnRight = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnRight) {\n                        right++;\n                    }\n                }\n                if (right >= width) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .....\n                // .   .\n                // .___.\n                let bottomBorderNotWhite = true;\n                while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n                    bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);\n                    if (bottomBorderNotWhite) {\n                        down++;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnBottom = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnBottom) {\n                        down++;\n                    }\n                }\n                if (down >= height) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .....\n                // |   .\n                // .....\n                let leftBorderNotWhite = true;\n                while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n                    leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);\n                    if (leftBorderNotWhite) {\n                        left--;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnLeft = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnLeft) {\n                        left--;\n                    }\n                }\n                if (left < 0) {\n                    sizeExceeded = true;\n                    break;\n                }\n                // .___.\n                // .   .\n                // .....\n                let topBorderNotWhite = true;\n                while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n                    topBorderNotWhite = this.containsBlackPoint(left, right, up, true);\n                    if (topBorderNotWhite) {\n                        up--;\n                        aBlackPointFoundOnBorder = true;\n                        atLeastOneBlackPointFoundOnTop = true;\n                    }\n                    else if (!atLeastOneBlackPointFoundOnTop) {\n                        up--;\n                    }\n                }\n                if (up < 0) {\n                    sizeExceeded = true;\n                    break;\n                }\n                if (aBlackPointFoundOnBorder) {\n                    atLeastOneBlackPointFoundOnBorder = true;\n                }\n            }\n            if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {\n                const maxSize = right - left;\n                let z = null;\n                for (let i = 1; z === null && i < maxSize; i++) {\n                    z = this.getBlackPointOnSegment(left, down - i, left + i, down);\n                }\n                if (z == null) {\n                    throw new NotFoundException();\n                }\n                let t = null;\n                // go down right\n                for (let i = 1; t === null && i < maxSize; i++) {\n                    t = this.getBlackPointOnSegment(left, up + i, left + i, up);\n                }\n                if (t == null) {\n                    throw new NotFoundException();\n                }\n                let x = null;\n                // go down left\n                for (let i = 1; x === null && i < maxSize; i++) {\n                    x = this.getBlackPointOnSegment(right, up + i, right - i, up);\n                }\n                if (x == null) {\n                    throw new NotFoundException();\n                }\n                let y = null;\n                // go up left\n                for (let i = 1; y === null && i < maxSize; i++) {\n                    y = this.getBlackPointOnSegment(right, down - i, right - i, down);\n                }\n                if (y == null) {\n                    throw new NotFoundException();\n                }\n                return this.centerEdges(y, z, x, t);\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n        getBlackPointOnSegment(aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {\n            const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));\n            const xStep = (bX - aX) / dist;\n            const yStep = (bY - aY) / dist;\n            const image = this.image;\n            for (let i = 0; i < dist; i++) {\n                const x = MathUtils.round(aX + i * xStep);\n                const y = MathUtils.round(aY + i * yStep);\n                if (image.get(x, y)) {\n                    return new ResultPoint(x, y);\n                }\n            }\n            return null;\n        }\n        /**\n         * recenters the points of a constant distance towards the center\n         *\n         * @param y bottom most point\n         * @param z left most point\n         * @param x right most point\n         * @param t top most point\n         * @return {@link ResultPoint}[] describing the corners of the rectangular\n         *         region. The first and last points are opposed on the diagonal, as\n         *         are the second and third. The first point will be the topmost\n         *         point and the last, the bottommost. The second point will be\n         *         leftmost and the third, the rightmost\n         */\n        centerEdges(y, z, x, t) {\n            //\n            //       t            t\n            //  z                      x\n            //        x    OR    z\n            //   y                    y\n            //\n            const yi = y.getX();\n            const yj = y.getY();\n            const zi = z.getX();\n            const zj = z.getY();\n            const xi = x.getX();\n            const xj = x.getY();\n            const ti = t.getX();\n            const tj = t.getY();\n            const CORR = WhiteRectangleDetector.CORR;\n            if (yi < this.width / 2.0) {\n                return [\n                    new ResultPoint(ti - CORR, tj + CORR),\n                    new ResultPoint(zi + CORR, zj + CORR),\n                    new ResultPoint(xi - CORR, xj - CORR),\n                    new ResultPoint(yi + CORR, yj - CORR)\n                ];\n            }\n            else {\n                return [\n                    new ResultPoint(ti + CORR, tj + CORR),\n                    new ResultPoint(zi + CORR, zj - CORR),\n                    new ResultPoint(xi - CORR, xj + CORR),\n                    new ResultPoint(yi - CORR, yj - CORR)\n                ];\n            }\n        }\n        /**\n         * Determines whether a segment contains a black point\n         *\n         * @param a          min value of the scanned coordinate\n         * @param b          max value of the scanned coordinate\n         * @param fixed      value of fixed coordinate\n         * @param horizontal set to true if scan must be horizontal, false if vertical\n         * @return true if a black point has been found, else false.\n         */\n        containsBlackPoint(a /*int*/, b /*int*/, fixed /*int*/, horizontal) {\n            const image = this.image;\n            if (horizontal) {\n                for (let x = a; x <= b; x++) {\n                    if (image.get(x, fixed)) {\n                        return true;\n                    }\n                }\n            }\n            else {\n                for (let y = a; y <= b; y++) {\n                    if (image.get(fixed, y)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    WhiteRectangleDetector.INIT_SIZE = 10;\n    WhiteRectangleDetector.CORR = 1;\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * Implementations of this class can, given locations of finder patterns for a QR code in an\n     * image, sample the right points in the image to reconstruct the QR code, accounting for\n     * perspective distortion. It is abstracted since it is relatively expensive and should be allowed\n     * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced\n     * Imaging library, but which may not be available in other environments such as J2ME, and vice\n     * versa.\n     *\n     * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}\n     * with an instance of a class which implements this interface.\n     *\n     * @author Sean Owen\n     */\n    class GridSampler {\n        /**\n         * <p>Checks a set of points that have been transformed to sample points on an image against\n         * the image's dimensions to see if the point are even within the image.</p>\n         *\n         * <p>This method will actually \"nudge\" the endpoints back onto the image if they are found to be\n         * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder\n         * patterns in an image where the QR Code runs all the way to the image border.</p>\n         *\n         * <p>For efficiency, the method will check points from either end of the line until one is found\n         * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>\n         *\n         * @param image image into which the points should map\n         * @param points actual points in x1,y1,...,xn,yn form\n         * @throws NotFoundException if an endpoint is lies outside the image boundaries\n         */\n        static checkAndNudgePoints(image, points) {\n            const width = image.getWidth();\n            const height = image.getHeight();\n            // Check and nudge points from start until we see some that are OK:\n            let nudged = true;\n            for (let offset = 0; offset < points.length && nudged; offset += 2) {\n                const x = Math.floor(points[offset]);\n                const y = Math.floor(points[offset + 1]);\n                if (x < -1 || x > width || y < -1 || y > height) {\n                    throw new NotFoundException();\n                }\n                nudged = false;\n                if (x === -1) {\n                    points[offset] = 0.0;\n                    nudged = true;\n                }\n                else if (x === width) {\n                    points[offset] = width - 1;\n                    nudged = true;\n                }\n                if (y === -1) {\n                    points[offset + 1] = 0.0;\n                    nudged = true;\n                }\n                else if (y === height) {\n                    points[offset + 1] = height - 1;\n                    nudged = true;\n                }\n            }\n            // Check and nudge points from end:\n            nudged = true;\n            for (let offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {\n                const x = Math.floor(points[offset]);\n                const y = Math.floor(points[offset + 1]);\n                if (x < -1 || x > width || y < -1 || y > height) {\n                    throw new NotFoundException();\n                }\n                nudged = false;\n                if (x === -1) {\n                    points[offset] = 0.0;\n                    nudged = true;\n                }\n                else if (x === width) {\n                    points[offset] = width - 1;\n                    nudged = true;\n                }\n                if (y === -1) {\n                    points[offset + 1] = 0.0;\n                    nudged = true;\n                }\n                else if (y === height) {\n                    points[offset + 1] = height - 1;\n                    nudged = true;\n                }\n            }\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing.common {*/\n    /**\n     * <p>This class implements a perspective transform in two dimensions. Given four source and four\n     * destination points, it will compute the transformation implied between them. The code is based\n     * directly upon section 3.4.2 of George Wolberg's \"Digital Image Warping\"; see pages 54-56.</p>\n     *\n     * @author Sean Owen\n     */\n    class PerspectiveTransform {\n        constructor(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {\n            this.a11 = a11;\n            this.a21 = a21;\n            this.a31 = a31;\n            this.a12 = a12;\n            this.a22 = a22;\n            this.a32 = a32;\n            this.a13 = a13;\n            this.a23 = a23;\n            this.a33 = a33;\n        }\n        static quadrilateralToQuadrilateral(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {\n            const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);\n            const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);\n            return sToQ.times(qToS);\n        }\n        transformPoints(points) {\n            const max = points.length;\n            const a11 = this.a11;\n            const a12 = this.a12;\n            const a13 = this.a13;\n            const a21 = this.a21;\n            const a22 = this.a22;\n            const a23 = this.a23;\n            const a31 = this.a31;\n            const a32 = this.a32;\n            const a33 = this.a33;\n            for (let i = 0; i < max; i += 2) {\n                const x = points[i];\n                const y = points[i + 1];\n                const denominator = a13 * x + a23 * y + a33;\n                points[i] = (a11 * x + a21 * y + a31) / denominator;\n                points[i + 1] = (a12 * x + a22 * y + a32) / denominator;\n            }\n        }\n        transformPointsWithValues(xValues, yValues) {\n            const a11 = this.a11;\n            const a12 = this.a12;\n            const a13 = this.a13;\n            const a21 = this.a21;\n            const a22 = this.a22;\n            const a23 = this.a23;\n            const a31 = this.a31;\n            const a32 = this.a32;\n            const a33 = this.a33;\n            const n = xValues.length;\n            for (let i = 0; i < n; i++) {\n                const x = xValues[i];\n                const y = yValues[i];\n                const denominator = a13 * x + a23 * y + a33;\n                xValues[i] = (a11 * x + a21 * y + a31) / denominator;\n                yValues[i] = (a12 * x + a22 * y + a32) / denominator;\n            }\n        }\n        static squareToQuadrilateral(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {\n            const dx3 = x0 - x1 + x2 - x3;\n            const dy3 = y0 - y1 + y2 - y3;\n            if (dx3 === 0.0 && dy3 === 0.0) {\n                // Affine\n                return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);\n            }\n            else {\n                const dx1 = x1 - x2;\n                const dx2 = x3 - x2;\n                const dy1 = y1 - y2;\n                const dy2 = y3 - y2;\n                const denominator = dx1 * dy2 - dx2 * dy1;\n                const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;\n                const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;\n                return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);\n            }\n        }\n        static quadrilateralToSquare(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {\n            // Here, the adjoint serves as the inverse:\n            return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();\n        }\n        buildAdjoint() {\n            // Adjoint is the transpose of the cofactor matrix:\n            return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);\n        }\n        times(other) {\n            return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Sean Owen\n     */\n    class DefaultGridSampler extends GridSampler {\n        /*@Override*/\n        sampleGrid(image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {\n            const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);\n            return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);\n        }\n        /*@Override*/\n        sampleGridWithTransform(image, dimensionX /*int*/, dimensionY /*int*/, transform) {\n            if (dimensionX <= 0 || dimensionY <= 0) {\n                throw new NotFoundException();\n            }\n            const bits = new BitMatrix(dimensionX, dimensionY);\n            const points = new Float32Array(2 * dimensionX);\n            for (let y = 0; y < dimensionY; y++) {\n                const max = points.length;\n                const iValue = y + 0.5;\n                for (let x = 0; x < max; x += 2) {\n                    points[x] = (x / 2) + 0.5;\n                    points[x + 1] = iValue;\n                }\n                transform.transformPoints(points);\n                // Quick check to see if points transformed to something inside the image\n                // sufficient to check the endpoints\n                GridSampler.checkAndNudgePoints(image, points);\n                try {\n                    for (let x = 0; x < max; x += 2) {\n                        if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {\n                            // Black(-ish) pixel\n                            bits.set(x / 2, y);\n                        }\n                    }\n                }\n                catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {\n                    // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting\n                    // transform gets \"twisted\" such that it maps a straight line of points to a set of points\n                    // whose endpoints are in bounds, but others are not. There is probably some mathematical\n                    // way to detect this about the transformation that I don't know yet.\n                    // This results in an ugly runtime exception despite our clever checks above -- can't have\n                    // that. We could check each point's coordinates but that feels duplicative. We settle for\n                    // catching and wrapping ArrayIndexOutOfBoundsException.\n                    throw new NotFoundException();\n                }\n            }\n            return bits;\n        }\n    }\n\n    class GridSamplerInstance {\n        /**\n         * Sets the implementation of GridSampler used by the library. One global\n         * instance is stored, which may sound problematic. But, the implementation provided\n         * ought to be appropriate for the entire platform, and all uses of this library\n         * in the whole lifetime of the JVM. For instance, an Android activity can swap in\n         * an implementation that takes advantage of native platform libraries.\n         *\n         * @param newGridSampler The platform-specific object to install.\n         */\n        static setGridSampler(newGridSampler) {\n            GridSamplerInstance.gridSampler = newGridSampler;\n        }\n        /**\n         * @return the current implementation of GridSampler\n         */\n        static getInstance() {\n            return GridSamplerInstance.gridSampler;\n        }\n    }\n    GridSamplerInstance.gridSampler = new DefaultGridSampler();\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    class Point {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        toResultPoint() {\n            return new ResultPoint(this.getX(), this.getY());\n        }\n        getX() {\n            return this.x;\n        }\n        getY() {\n            return this.y;\n        }\n    }\n    /**\n     * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code\n     * is rotated or skewed, or partially obscured.\n     *\n     * @author David Olivier\n     * @author Frank Yellin\n     */\n    class Detector {\n        constructor(image) {\n            this.EXPECTED_CORNER_BITS = new Int32Array([\n                0xee0,\n                0x1dc,\n                0x83b,\n                0x707,\n            ]);\n            this.image = image;\n        }\n        detect() {\n            return this.detectMirror(false);\n        }\n        /**\n         * Detects an Aztec Code in an image.\n         *\n         * @param isMirror if true, image is a mirror-image of original\n         * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code\n         * @throws NotFoundException if no Aztec Code can be found\n         */\n        detectMirror(isMirror) {\n            // 1. Get the center of the aztec matrix\n            let pCenter = this.getMatrixCenter();\n            // 2. Get the center points of the four diagonal points just outside the bull's eye\n            //  [topRight, bottomRight, bottomLeft, topLeft]\n            let bullsEyeCorners = this.getBullsEyeCorners(pCenter);\n            if (isMirror) {\n                let temp = bullsEyeCorners[0];\n                bullsEyeCorners[0] = bullsEyeCorners[2];\n                bullsEyeCorners[2] = temp;\n            }\n            // 3. Get the size of the matrix and other parameters from the bull's eye\n            this.extractParameters(bullsEyeCorners);\n            // 4. Sample the grid\n            let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);\n            // 5. Get the corners of the matrix.\n            let corners = this.getMatrixCornerPoints(bullsEyeCorners);\n            return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);\n        }\n        /**\n         * Extracts the number of data layers and data blocks from the layer around the bull's eye.\n         *\n         * @param bullsEyeCorners the array of bull's eye corners\n         * @throws NotFoundException in case of too many errors or invalid parameters\n         */\n        extractParameters(bullsEyeCorners) {\n            if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||\n                !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {\n                throw new NotFoundException();\n            }\n            let length = 2 * this.nbCenterLayers;\n            // Get the bits around the bull's eye\n            let sides = new Int32Array([\n                this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),\n                this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),\n                this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),\n                this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top\n            ]);\n            // bullsEyeCorners[shift] is the corner of the bulls'eye that has three\n            // orientation marks.\n            // sides[shift] is the row/column that goes from the corner with three\n            // orientation marks to the corner with two.\n            this.shift = this.getRotation(sides, length);\n            // Flatten the parameter bits into a single 28- or 40-bit long\n            let parameterData = 0;\n            for (let i = 0; i < 4; i++) {\n                let side = sides[(this.shift + i) % 4];\n                if (this.compact) {\n                    // Each side of the form ..XXXXXXX. where Xs are parameter data\n                    parameterData <<= 7;\n                    parameterData += (side >> 1) & 0x7F;\n                }\n                else {\n                    // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data\n                    parameterData <<= 10;\n                    parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);\n                }\n            }\n            // Corrects parameter data using RS.  Returns just the data portion\n            // without the error correction.\n            let correctedData = this.getCorrectedParameterData(parameterData, this.compact);\n            if (this.compact) {\n                // 8 bits:  2 bits layers and 6 bits data blocks\n                this.nbLayers = (correctedData >> 6) + 1;\n                this.nbDataBlocks = (correctedData & 0x3F) + 1;\n            }\n            else {\n                // 16 bits:  5 bits layers and 11 bits data blocks\n                this.nbLayers = (correctedData >> 11) + 1;\n                this.nbDataBlocks = (correctedData & 0x7FF) + 1;\n            }\n        }\n        getRotation(sides, length) {\n            // In a normal pattern, we expect to See\n            //   **    .*             D       A\n            //   *      *\n            //\n            //   .      *\n            //   ..    ..             C       B\n            //\n            // Grab the 3 bits from each of the sides the form the locator pattern and concatenate\n            // into a 12-bit integer.  Start with the bit at A\n            let cornerBits = 0;\n            sides.forEach((side, idx, arr) => {\n                // XX......X where X's are orientation marks\n                let t = ((side >> (length - 2)) << 1) + (side & 1);\n                cornerBits = (cornerBits << 3) + t;\n            });\n            // for (var side in sides) {\n            //     // XX......X where X's are orientation marks\n            //     var t = ((side >> (length - 2)) << 1) + (side & 1);\n            //     cornerBits = (cornerBits << 3) + t;\n            // }\n            // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are\n            // together.  cornerBits is now:\n            //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D\n            cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);\n            // The result shift indicates which element of BullsEyeCorners[] goes into the top-left\n            // corner. Since the four rotation values have a Hamming distance of 8, we\n            // can easily tolerate two errors.\n            for (let shift = 0; shift < 4; shift++) {\n                if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {\n                    return shift;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Corrects the parameter bits using Reed-Solomon algorithm.\n         *\n         * @param parameterData parameter bits\n         * @param compact true if this is a compact Aztec code\n         * @throws NotFoundException if the array contains too many errors\n         */\n        getCorrectedParameterData(parameterData, compact) {\n            let numCodewords;\n            let numDataCodewords;\n            if (compact) {\n                numCodewords = 7;\n                numDataCodewords = 2;\n            }\n            else {\n                numCodewords = 10;\n                numDataCodewords = 4;\n            }\n            let numECCodewords = numCodewords - numDataCodewords;\n            let parameterWords = new Int32Array(numCodewords);\n            for (let i = numCodewords - 1; i >= 0; --i) {\n                parameterWords[i] = parameterData & 0xF;\n                parameterData >>= 4;\n            }\n            try {\n                let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);\n                rsDecoder.decode(parameterWords, numECCodewords);\n            }\n            catch (ignored) {\n                throw new NotFoundException();\n            }\n            // Toss the error correction.  Just return the data as an integer\n            let result = 0;\n            for (let i = 0; i < numDataCodewords; i++) {\n                result = (result << 4) + parameterWords[i];\n            }\n            return result;\n        }\n        /**\n         * Finds the corners of a bull-eye centered on the passed point.\n         * This returns the centers of the diagonal points just outside the bull's eye\n         * Returns [topRight, bottomRight, bottomLeft, topLeft]\n         *\n         * @param pCenter Center point\n         * @return The corners of the bull-eye\n         * @throws NotFoundException If no valid bull-eye can be found\n         */\n        getBullsEyeCorners(pCenter) {\n            let pina = pCenter;\n            let pinb = pCenter;\n            let pinc = pCenter;\n            let pind = pCenter;\n            let color = true;\n            for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {\n                let pouta = this.getFirstDifferent(pina, color, 1, -1);\n                let poutb = this.getFirstDifferent(pinb, color, 1, 1);\n                let poutc = this.getFirstDifferent(pinc, color, -1, 1);\n                let poutd = this.getFirstDifferent(pind, color, -1, -1);\n                // d      a\n                //\n                // c      b\n                if (this.nbCenterLayers > 2) {\n                    let q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));\n                    if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {\n                        break;\n                    }\n                }\n                pina = pouta;\n                pinb = poutb;\n                pinc = poutc;\n                pind = poutd;\n                color = !color;\n            }\n            if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {\n                throw new NotFoundException();\n            }\n            this.compact = this.nbCenterLayers === 5;\n            // Expand the square by .5 pixel in each direction so that we're on the border\n            // between the white square and the black square\n            let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);\n            let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);\n            let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);\n            let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);\n            // Expand the square so that its corners are the centers of the points\n            // just outside the bull's eye.\n            return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);\n        }\n        /**\n         * Finds a candidate center point of an Aztec code from an image\n         *\n         * @return the center point\n         */\n        getMatrixCenter() {\n            let pointA;\n            let pointB;\n            let pointC;\n            let pointD;\n            // Get a white rectangle that can be the border of the matrix in center bull's eye or\n            try {\n                let cornerPoints = new WhiteRectangleDetector(this.image).detect();\n                pointA = cornerPoints[0];\n                pointB = cornerPoints[1];\n                pointC = cornerPoints[2];\n                pointD = cornerPoints[3];\n            }\n            catch (e) {\n                // This exception can be in case the initial rectangle is white\n                // In that case, surely in the bull's eye, we try to expand the rectangle.\n                let cx = this.image.getWidth() / 2;\n                let cy = this.image.getHeight() / 2;\n                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n            }\n            // Compute the center of the rectangle\n            let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n            let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n            // Redetermine the white rectangle starting from previously computed center.\n            // This will ensure that we end up with a white rectangle in center bull's eye\n            // in order to compute a more accurate center.\n            try {\n                let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();\n                pointA = cornerPoints[0];\n                pointB = cornerPoints[1];\n                pointC = cornerPoints[2];\n                pointD = cornerPoints[3];\n            }\n            catch (e) {\n                // This exception can be in case the initial rectangle is white\n                // In that case we try to expand the rectangle.\n                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n            }\n            // Recompute the center of the rectangle\n            cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);\n            cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);\n            return new Point(cx, cy);\n        }\n        /**\n         * Gets the Aztec code corners from the bull's eye corners and the parameters.\n         *\n         * @param bullsEyeCorners the array of bull's eye corners\n         * @return the array of aztec code corners\n         */\n        getMatrixCornerPoints(bullsEyeCorners) {\n            return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());\n        }\n        /**\n         * Creates a BitMatrix by sampling the provided image.\n         * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the\n         * diagonal just outside the bull's eye.\n         */\n        sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {\n            let sampler = GridSamplerInstance.getInstance();\n            let dimension = this.getDimension();\n            let low = dimension / 2 - this.nbCenterLayers;\n            let high = dimension / 2 + this.nbCenterLayers;\n            return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft\n            high, low, // topright\n            high, high, // bottomright\n            low, high, // bottomleft\n            topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n        }\n        /**\n         * Samples a line.\n         *\n         * @param p1   start point (inclusive)\n         * @param p2   end point (exclusive)\n         * @param size number of bits\n         * @return the array of bits as an int (first bit is high-order bit of result)\n         */\n        sampleLine(p1, p2, size) {\n            let result = 0;\n            let d = this.distanceResultPoint(p1, p2);\n            let moduleSize = d / size;\n            let px = p1.getX();\n            let py = p1.getY();\n            let dx = moduleSize * (p2.getX() - p1.getX()) / d;\n            let dy = moduleSize * (p2.getY() - p1.getY()) / d;\n            for (let i = 0; i < size; i++) {\n                if (this.image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {\n                    result |= 1 << (size - i - 1);\n                }\n            }\n            return result;\n        }\n        /**\n         * @return true if the border of the rectangle passed in parameter is compound of white points only\n         *         or black points only\n         */\n        isWhiteOrBlackRectangle(p1, p2, p3, p4) {\n            let corr = 3;\n            p1 = new Point(p1.getX() - corr, p1.getY() + corr);\n            p2 = new Point(p2.getX() - corr, p2.getY() - corr);\n            p3 = new Point(p3.getX() + corr, p3.getY() - corr);\n            p4 = new Point(p4.getX() + corr, p4.getY() + corr);\n            let cInit = this.getColor(p4, p1);\n            if (cInit === 0) {\n                return false;\n            }\n            let c = this.getColor(p1, p2);\n            if (c !== cInit) {\n                return false;\n            }\n            c = this.getColor(p2, p3);\n            if (c !== cInit) {\n                return false;\n            }\n            c = this.getColor(p3, p4);\n            return c === cInit;\n        }\n        /**\n         * Gets the color of a segment\n         *\n         * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else\n         */\n        getColor(p1, p2) {\n            let d = this.distancePoint(p1, p2);\n            let dx = (p2.getX() - p1.getX()) / d;\n            let dy = (p2.getY() - p1.getY()) / d;\n            let error = 0;\n            let px = p1.getX();\n            let py = p1.getY();\n            let colorModel = this.image.get(p1.getX(), p1.getY());\n            let iMax = Math.ceil(d);\n            for (let i = 0; i < iMax; i++) {\n                px += dx;\n                py += dy;\n                if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {\n                    error++;\n                }\n            }\n            let errRatio = error / d;\n            if (errRatio > 0.1 && errRatio < 0.9) {\n                return 0;\n            }\n            return (errRatio <= 0.1) === colorModel ? 1 : -1;\n        }\n        /**\n         * Gets the coordinate of the first point with a different color in the given direction\n         */\n        getFirstDifferent(init, color, dx, dy) {\n            let x = init.getX() + dx;\n            let y = init.getY() + dy;\n            while (this.isValid(x, y) && this.image.get(x, y) === color) {\n                x += dx;\n                y += dy;\n            }\n            x -= dx;\n            y -= dy;\n            while (this.isValid(x, y) && this.image.get(x, y) === color) {\n                x += dx;\n            }\n            x -= dx;\n            while (this.isValid(x, y) && this.image.get(x, y) === color) {\n                y += dy;\n            }\n            y -= dy;\n            return new Point(x, y);\n        }\n        /**\n         * Expand the square represented by the corner points by pushing out equally in all directions\n         *\n         * @param cornerPoints the corners of the square, which has the bull's eye at its center\n         * @param oldSide the original length of the side of the square in the target bit matrix\n         * @param newSide the new length of the size of the square in the target bit matrix\n         * @return the corners of the expanded square\n         */\n        expandSquare(cornerPoints, oldSide, newSide) {\n            let ratio = newSide / (2.0 * oldSide);\n            let dx = cornerPoints[0].getX() - cornerPoints[2].getX();\n            let dy = cornerPoints[0].getY() - cornerPoints[2].getY();\n            let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;\n            let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;\n            let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n            let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n            dx = cornerPoints[1].getX() - cornerPoints[3].getX();\n            dy = cornerPoints[1].getY() - cornerPoints[3].getY();\n            centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;\n            centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;\n            let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);\n            let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);\n            let results = [result0, result1, result2, result3];\n            return results;\n        }\n        isValid(x, y) {\n            return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();\n        }\n        isValidPoint(point) {\n            let x = MathUtils.round(point.getX());\n            let y = MathUtils.round(point.getY());\n            return this.isValid(x, y);\n        }\n        distancePoint(a, b) {\n            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n        }\n        distanceResultPoint(a, b) {\n            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());\n        }\n        getDimension() {\n            if (this.compact) {\n                return 4 * this.nbLayers + 11;\n            }\n            if (this.nbLayers <= 4) {\n                return 4 * this.nbLayers + 15;\n            }\n            return 4 * this.nbLayers + 2 * (Integer.truncDivision((this.nbLayers - 4), 8) + 1) + 15;\n        }\n    }\n\n    /*\n     * Copyright 2010 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * This implementation can detect and decode Aztec codes in an image.\n     *\n     * @author David Olivier\n     */\n    class AztecReader {\n        /**\n         * Locates and decodes a Data Matrix code in an image.\n         *\n         * @return a String representing the content encoded by the Data Matrix code\n         * @throws NotFoundException if a Data Matrix code cannot be found\n         * @throws FormatException if a Data Matrix code cannot be decoded\n         */\n        decode(image, hints = null) {\n            let exception = null;\n            let detector = new Detector(image.getBlackMatrix());\n            let points = null;\n            let decoderResult = null;\n            try {\n                let detectorResult = detector.detectMirror(false);\n                points = detectorResult.getPoints();\n                this.reportFoundResultPoints(hints, points);\n                decoderResult = new Decoder().decode(detectorResult);\n            }\n            catch (e) {\n                exception = e;\n            }\n            if (decoderResult == null) {\n                try {\n                    let detectorResult = detector.detectMirror(true);\n                    points = detectorResult.getPoints();\n                    this.reportFoundResultPoints(hints, points);\n                    decoderResult = new Decoder().decode(detectorResult);\n                }\n                catch (e) {\n                    if (exception != null) {\n                        throw exception;\n                    }\n                    throw e;\n                }\n            }\n            let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());\n            let byteSegments = decoderResult.getByteSegments();\n            if (byteSegments != null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            let ecLevel = decoderResult.getECLevel();\n            if (ecLevel != null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            return result;\n        }\n        reportFoundResultPoints(hints, points) {\n            if (hints != null) {\n                let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                if (rpcb != null) {\n                    points.forEach((point, idx, arr) => {\n                        rpcb.foundPossibleResultPoint(point);\n                    });\n                }\n            }\n        }\n        // @Override\n        reset() {\n            // do nothing\n        }\n    }\n\n    /**\n     * Aztec Code reader to use from browser.\n     *\n     * @class BrowserAztecCodeReader\n     * @extends {BrowserCodeReader}\n     */\n    class BrowserAztecCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserAztecCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         *\n         * @memberOf BrowserAztecCodeReader\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new AztecReader(), timeBetweenScansMillis);\n        }\n    }\n\n    /**\n     * Encapsulates functionality and implementation that is common to all families\n     * of one-dimensional barcodes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     */\n    class OneDReader {\n        /*\n        @Override\n        public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {\n          return decode(image, null);\n        }\n        */\n        // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n        // @Override\n        decode(image, hints) {\n            try {\n                return this.doDecode(image, hints);\n            }\n            catch (nfe) {\n                const tryHarder = hints && (hints.get(DecodeHintType$1.TRY_HARDER) === true);\n                if (tryHarder && image.isRotateSupported()) {\n                    const rotatedImage = image.rotateCounterClockwise();\n                    const result = this.doDecode(rotatedImage, hints);\n                    // Record that we found it rotated 90 degrees CCW / 270 degrees CW\n                    const metadata = result.getResultMetadata();\n                    let orientation = 270;\n                    if (metadata !== null && (metadata.get(ResultMetadataType$1.ORIENTATION) === true)) {\n                        // But if we found it reversed in doDecode(), add in that result here:\n                        orientation = (orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360);\n                    }\n                    result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);\n                    // Update result points\n                    const points = result.getResultPoints();\n                    if (points !== null) {\n                        const height = rotatedImage.getHeight();\n                        for (let i = 0; i < points.length; i++) {\n                            points[i] = new ResultPoint(height - points[i].getY() - 1, points[i].getX());\n                        }\n                    }\n                    return result;\n                }\n                else {\n                    throw new NotFoundException();\n                }\n            }\n        }\n        // @Override\n        reset() {\n            // do nothing\n        }\n        /**\n         * We're going to examine rows from the middle outward, searching alternately above and below the\n         * middle, and farther out each time. rowStep is the number of rows between each successive\n         * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then\n         * middle + rowStep, then middle - (2 * rowStep), etc.\n         * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily\n         * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the\n         * image if \"trying harder\".\n         *\n         * @param image The image to decode\n         * @param hints Any hints that were requested\n         * @return The contents of the decoded barcode\n         * @throws NotFoundException Any spontaneous errors which occur\n         */\n        doDecode(image, hints) {\n            const width = image.getWidth();\n            const height = image.getHeight();\n            let row = new BitArray(width);\n            const tryHarder = hints && (hints.get(DecodeHintType$1.TRY_HARDER) === true);\n            const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));\n            let maxLines;\n            if (tryHarder) {\n                maxLines = height; // Look at the whole image, not just the center\n            }\n            else {\n                maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image\n            }\n            const middle = Math.trunc(height / 2);\n            for (let x = 0; x < maxLines; x++) {\n                // Scanning from the middle out. Determine which row we're looking at next:\n                const rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);\n                const isAbove = (x & 0x01) === 0; // i.e. is x even?\n                const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);\n                if (rowNumber < 0 || rowNumber >= height) {\n                    // Oops, if we run off the top or bottom, stop\n                    break;\n                }\n                // Estimate black point for this row and load it:\n                try {\n                    row = image.getBlackRow(rowNumber, row);\n                }\n                catch (ignored) {\n                    continue;\n                }\n                // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to\n                // handle decoding upside down barcodes.\n                for (let attempt = 0; attempt < 2; attempt++) {\n                    if (attempt === 1) { // trying again?\n                        row.reverse(); // reverse the row and continue\n                        // This means we will only ever draw result points *once* in the life of this method\n                        // since we want to avoid drawing the wrong points after flipping the row, and,\n                        // don't want to clutter with noise from every single row scan -- just the scans\n                        // that start on the center line.\n                        if (hints && (hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true)) {\n                            const newHints = new Map();\n                            hints.forEach((hint, key) => newHints.set(key, hint));\n                            newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                            hints = newHints;\n                        }\n                    }\n                    try {\n                        // Look for a barcode\n                        const result = this.decodeRow(rowNumber, row, hints);\n                        // We found our barcode\n                        if (attempt === 1) {\n                            // But it was upside down, so note that\n                            result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);\n                            // And remember to flip the result points horizontally.\n                            const points = result.getResultPoints();\n                            if (points !== null) {\n                                points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());\n                                points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());\n                            }\n                        }\n                        return result;\n                    }\n                    catch (re) {\n                        // continue -- just couldn't decode this row\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Records the size of successive runs of white and black pixels in a row, starting at a given point.\n         * The values are recorded in the given array, and the number of runs recorded is equal to the size\n         * of the array. If the row starts on a white pixel at the given start point, then the first count\n         * recorded is the run of white pixels starting from that point; likewise it is the count of a run\n         * of black pixels if the row begin on a black pixels at that point.\n         *\n         * @param row row to count from\n         * @param start offset into row to start at\n         * @param counters array into which to record counts\n         * @throws NotFoundException if counters cannot be filled entirely from row before running out\n         *  of pixels\n         */\n        static recordPattern(row, start, counters) {\n            const numCounters = counters.length;\n            for (let index = 0; index < numCounters; index++)\n                counters[index] = 0;\n            const end = row.getSize();\n            if (start >= end) {\n                throw new NotFoundException();\n            }\n            let isWhite = !row.get(start);\n            let counterPosition = 0;\n            let i = start;\n            while (i < end) {\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (++counterPosition === numCounters) {\n                        break;\n                    }\n                    else {\n                        counters[counterPosition] = 1;\n                        isWhite = !isWhite;\n                    }\n                }\n                i++;\n            }\n            // If we read fully the last section of pixels and filled up our counters -- or filled\n            // the last counter but ran off the side of the image, OK. Otherwise, a problem.\n            if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {\n                throw new NotFoundException();\n            }\n        }\n        static recordPatternInReverse(row, start, counters) {\n            // This could be more efficient I guess\n            let numTransitionsLeft = counters.length;\n            let last = row.get(start);\n            while (start > 0 && numTransitionsLeft >= 0) {\n                if (row.get(--start) !== last) {\n                    numTransitionsLeft--;\n                    last = !last;\n                }\n            }\n            if (numTransitionsLeft >= 0) {\n                throw new NotFoundException();\n            }\n            OneDReader.recordPattern(row, start + 1, counters);\n        }\n        /**\n         * Determines how closely a set of observed counts of runs of black/white values matches a given\n         * target pattern. This is reported as the ratio of the total variance from the expected pattern\n         * proportions across all pattern elements, to the length of the pattern.\n         *\n         * @param counters observed counters\n         * @param pattern expected pattern\n         * @param maxIndividualVariance The most any counter can differ before we give up\n         * @return ratio of total variance between counters and pattern compared to total pattern size\n         */\n        static patternMatchVariance(counters, pattern, maxIndividualVariance) {\n            const numCounters = counters.length;\n            let total = 0;\n            let patternLength = 0;\n            for (let i = 0; i < numCounters; i++) {\n                total += counters[i];\n                patternLength += pattern[i];\n            }\n            if (total < patternLength) {\n                // If we don't even have one pixel per unit of bar width, assume this is too small\n                // to reliably match, so fail:\n                return Number.POSITIVE_INFINITY;\n            }\n            const unitBarWidth = total / patternLength;\n            maxIndividualVariance *= unitBarWidth;\n            let totalVariance = 0.0;\n            for (let x = 0; x < numCounters; x++) {\n                const counter = counters[x];\n                const scaledPattern = pattern[x] * unitBarWidth;\n                const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n                if (variance > maxIndividualVariance) {\n                    return Number.POSITIVE_INFINITY;\n                }\n                totalVariance += variance;\n            }\n            return totalVariance / total;\n        }\n    }\n\n    /**\n     * <p>Decodes Code 128 barcodes.</p>\n     *\n     * @author Sean Owen\n     */\n    class Code128Reader extends OneDReader {\n        static findStartPattern(row) {\n            const width = row.getSize();\n            const rowOffset = row.getNextSet(0);\n            let counterPosition = 0;\n            let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n            let patternStart = rowOffset;\n            let isWhite = false;\n            const patternLength = 6;\n            for (let i = rowOffset; i < width; i++) {\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === (patternLength - 1)) {\n                        let bestVariance = Code128Reader.MAX_AVG_VARIANCE;\n                        let bestMatch = -1;\n                        for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {\n                            const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                            if (variance < bestVariance) {\n                                bestVariance = variance;\n                                bestMatch = startCode;\n                            }\n                        }\n                        // Look for whitespace before start pattern, >= 50% of width of start pattern\n                        if (bestMatch >= 0 &&\n                            row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {\n                            return Int32Array.from([patternStart, i, bestMatch]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters = counters.slice(2, counters.length - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static decodeCode(row, counters, rowOffset) {\n            OneDReader.recordPattern(row, rowOffset, counters);\n            let bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept\n            let bestMatch = -1;\n            for (let d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {\n                const pattern = Code128Reader.CODE_PATTERNS[d];\n                const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = d;\n                }\n            }\n            // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.\n            if (bestMatch >= 0) {\n                return bestMatch;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n        decodeRow(rowNumber, row, hints) {\n            const convertFNC1 = hints && (hints.get(DecodeHintType$1.ASSUME_GS1) === true);\n            const startPatternInfo = Code128Reader.findStartPattern(row);\n            const startCode = startPatternInfo[2];\n            let currentRawCodesIndex = 0;\n            const rawCodes = new Uint8Array(20);\n            rawCodes[currentRawCodesIndex++] = startCode;\n            let codeSet;\n            switch (startCode) {\n                case Code128Reader.CODE_START_A:\n                    codeSet = Code128Reader.CODE_CODE_A;\n                    break;\n                case Code128Reader.CODE_START_B:\n                    codeSet = Code128Reader.CODE_CODE_B;\n                    break;\n                case Code128Reader.CODE_START_C:\n                    codeSet = Code128Reader.CODE_CODE_C;\n                    break;\n                default:\n                    throw new FormatException();\n            }\n            let done = false;\n            let isNextShifted = false;\n            let result = '';\n            let lastStart = startPatternInfo[0];\n            let nextStart = startPatternInfo[1];\n            const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);\n            let lastCode = 0;\n            let code = 0;\n            let checksumTotal = startCode;\n            let multiplier = 0;\n            let lastCharacterWasPrintable = true;\n            let upperMode = false;\n            let shiftUpperMode = false;\n            while (!done) {\n                const unshift = isNextShifted;\n                isNextShifted = false;\n                // Save off last code\n                lastCode = code;\n                // Decode another code from image\n                code = Code128Reader.decodeCode(row, counters, nextStart);\n                rawCodes[currentRawCodesIndex++] = code;\n                // Remember whether the last code was printable or not (excluding CODE_STOP)\n                if (code !== Code128Reader.CODE_STOP) {\n                    lastCharacterWasPrintable = true;\n                }\n                // Add to checksum computation (if not CODE_STOP of course)\n                if (code !== Code128Reader.CODE_STOP) {\n                    multiplier++;\n                    checksumTotal += multiplier * code;\n                }\n                // Advance to where the next code will to start\n                lastStart = nextStart;\n                nextStart += counters.reduce((previous, current) => previous + current, 0);\n                // Take care of illegal start codes\n                switch (code) {\n                    case Code128Reader.CODE_START_A:\n                    case Code128Reader.CODE_START_B:\n                    case Code128Reader.CODE_START_C:\n                        throw new FormatException();\n                }\n                switch (codeSet) {\n                    case Code128Reader.CODE_CODE_A:\n                        if (code < 64) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code));\n                            }\n                            else {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                            }\n                            shiftUpperMode = false;\n                        }\n                        else if (code < 96) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode((code - 64));\n                            }\n                            else {\n                                result += String.fromCharCode((code + 64));\n                            }\n                            shiftUpperMode = false;\n                        }\n                        else {\n                            // Don't let CODE_STOP, which always appears, affect whether whether we think the last\n                            // code was printable or not.\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch (code) {\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += ']C1';\n                                        }\n                                        else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_FNC_2:\n                                case Code128Reader.CODE_FNC_3:\n                                    // do nothing?\n                                    break;\n                                case Code128Reader.CODE_FNC_4_A:\n                                    if (!upperMode && shiftUpperMode) {\n                                        upperMode = true;\n                                        shiftUpperMode = false;\n                                    }\n                                    else if (upperMode && shiftUpperMode) {\n                                        upperMode = false;\n                                        shiftUpperMode = false;\n                                    }\n                                    else {\n                                        shiftUpperMode = true;\n                                    }\n                                    break;\n                                case Code128Reader.CODE_SHIFT:\n                                    isNextShifted = true;\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_CODE_B:\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_CODE_C:\n                                    codeSet = Code128Reader.CODE_CODE_C;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Code128Reader.CODE_CODE_B:\n                        if (code < 96) {\n                            if (shiftUpperMode === upperMode) {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code));\n                            }\n                            else {\n                                result += String.fromCharCode((' '.charCodeAt(0) + code + 128));\n                            }\n                            shiftUpperMode = false;\n                        }\n                        else {\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch (code) {\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += ']C1';\n                                        }\n                                        else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_FNC_2:\n                                case Code128Reader.CODE_FNC_3:\n                                    // do nothing?\n                                    break;\n                                case Code128Reader.CODE_FNC_4_B:\n                                    if (!upperMode && shiftUpperMode) {\n                                        upperMode = true;\n                                        shiftUpperMode = false;\n                                    }\n                                    else if (upperMode && shiftUpperMode) {\n                                        upperMode = false;\n                                        shiftUpperMode = false;\n                                    }\n                                    else {\n                                        shiftUpperMode = true;\n                                    }\n                                    break;\n                                case Code128Reader.CODE_SHIFT:\n                                    isNextShifted = true;\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_A:\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_C:\n                                    codeSet = Code128Reader.CODE_CODE_C;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Code128Reader.CODE_CODE_C:\n                        if (code < 100) {\n                            if (code < 10) {\n                                result += '0';\n                            }\n                            result += code;\n                        }\n                        else {\n                            if (code !== Code128Reader.CODE_STOP) {\n                                lastCharacterWasPrintable = false;\n                            }\n                            switch (code) {\n                                case Code128Reader.CODE_FNC_1:\n                                    if (convertFNC1) {\n                                        if (result.length === 0) {\n                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code\n                                            // is FNC1 then this is GS1-128. We add the symbology identifier.\n                                            result += ']C1';\n                                        }\n                                        else {\n                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)\n                                            result += String.fromCharCode(29);\n                                        }\n                                    }\n                                    break;\n                                case Code128Reader.CODE_CODE_A:\n                                    codeSet = Code128Reader.CODE_CODE_A;\n                                    break;\n                                case Code128Reader.CODE_CODE_B:\n                                    codeSet = Code128Reader.CODE_CODE_B;\n                                    break;\n                                case Code128Reader.CODE_STOP:\n                                    done = true;\n                                    break;\n                            }\n                        }\n                        break;\n                }\n                // Unshift back to another code set if we were shifted\n                if (unshift) {\n                    codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;\n                }\n            }\n            const lastPatternSize = nextStart - lastStart;\n            // Check for ample whitespace following pattern, but, to do this we first need to remember that\n            // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left\n            // to read off. Would be slightly better to properly read. Here we just skip it:\n            nextStart = row.getNextUnset(nextStart);\n            if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {\n                throw new NotFoundException();\n            }\n            // Pull out from sum the value of the penultimate check code\n            checksumTotal -= multiplier * lastCode;\n            // lastCode is the checksum then:\n            if (checksumTotal % 103 !== lastCode) {\n                throw new ChecksumException();\n            }\n            // Need to pull out the check digits from string\n            const resultLength = result.length;\n            if (resultLength === 0) {\n                // false positive\n                throw new NotFoundException();\n            }\n            // Only bother if the result had at least one character, and if the checksum digit happened to\n            // be a printable character. If it was just interpreted as a control code, nothing to remove.\n            if (resultLength > 0 && lastCharacterWasPrintable) {\n                if (codeSet === Code128Reader.CODE_CODE_C) {\n                    result = result.substring(0, resultLength - 2);\n                }\n                else {\n                    result = result.substring(0, resultLength - 1);\n                }\n            }\n            const left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;\n            const right = lastStart + lastPatternSize / 2.0;\n            const rawCodesSize = rawCodes.length;\n            const rawBytes = new Uint8Array(rawCodesSize);\n            for (let i = 0; i < rawCodesSize; i++) {\n                rawBytes[i] = rawCodes[i];\n            }\n            const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];\n            return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, new Date().getTime());\n        }\n    }\n    Code128Reader.CODE_PATTERNS = [\n        Int32Array.from([2, 1, 2, 2, 2, 2]),\n        Int32Array.from([2, 2, 2, 1, 2, 2]),\n        Int32Array.from([2, 2, 2, 2, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 2, 3]),\n        Int32Array.from([1, 2, 1, 3, 2, 2]),\n        Int32Array.from([1, 3, 1, 2, 2, 2]),\n        Int32Array.from([1, 2, 2, 2, 1, 3]),\n        Int32Array.from([1, 2, 2, 3, 1, 2]),\n        Int32Array.from([1, 3, 2, 2, 1, 2]),\n        Int32Array.from([2, 2, 1, 2, 1, 3]),\n        Int32Array.from([2, 2, 1, 3, 1, 2]),\n        Int32Array.from([2, 3, 1, 2, 1, 2]),\n        Int32Array.from([1, 1, 2, 2, 3, 2]),\n        Int32Array.from([1, 2, 2, 1, 3, 2]),\n        Int32Array.from([1, 2, 2, 2, 3, 1]),\n        Int32Array.from([1, 1, 3, 2, 2, 2]),\n        Int32Array.from([1, 2, 3, 1, 2, 2]),\n        Int32Array.from([1, 2, 3, 2, 2, 1]),\n        Int32Array.from([2, 2, 3, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 3, 2]),\n        Int32Array.from([2, 2, 1, 2, 3, 1]),\n        Int32Array.from([2, 1, 3, 2, 1, 2]),\n        Int32Array.from([2, 2, 3, 1, 1, 2]),\n        Int32Array.from([3, 1, 2, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 2, 2, 2]),\n        Int32Array.from([3, 2, 1, 1, 2, 2]),\n        Int32Array.from([3, 2, 1, 2, 2, 1]),\n        Int32Array.from([3, 1, 2, 2, 1, 2]),\n        Int32Array.from([3, 2, 2, 1, 1, 2]),\n        Int32Array.from([3, 2, 2, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 2, 3]),\n        Int32Array.from([2, 1, 2, 3, 2, 1]),\n        Int32Array.from([2, 3, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 3, 2, 3]),\n        Int32Array.from([1, 3, 1, 1, 2, 3]),\n        Int32Array.from([1, 3, 1, 3, 2, 1]),\n        Int32Array.from([1, 1, 2, 3, 1, 3]),\n        Int32Array.from([1, 3, 2, 1, 1, 3]),\n        Int32Array.from([1, 3, 2, 3, 1, 1]),\n        Int32Array.from([2, 1, 1, 3, 1, 3]),\n        Int32Array.from([2, 3, 1, 1, 1, 3]),\n        Int32Array.from([2, 3, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 3, 3]),\n        Int32Array.from([1, 1, 2, 3, 3, 1]),\n        Int32Array.from([1, 3, 2, 1, 3, 1]),\n        Int32Array.from([1, 1, 3, 1, 2, 3]),\n        Int32Array.from([1, 1, 3, 3, 2, 1]),\n        Int32Array.from([1, 3, 3, 1, 2, 1]),\n        Int32Array.from([3, 1, 3, 1, 2, 1]),\n        Int32Array.from([2, 1, 1, 3, 3, 1]),\n        Int32Array.from([2, 3, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 3, 1, 1, 3]),\n        Int32Array.from([2, 1, 3, 3, 1, 1]),\n        Int32Array.from([2, 1, 3, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 2, 3]),\n        Int32Array.from([3, 1, 1, 3, 2, 1]),\n        Int32Array.from([3, 3, 1, 1, 2, 1]),\n        Int32Array.from([3, 1, 2, 1, 1, 3]),\n        Int32Array.from([3, 1, 2, 3, 1, 1]),\n        Int32Array.from([3, 3, 2, 1, 1, 1]),\n        Int32Array.from([3, 1, 4, 1, 1, 1]),\n        Int32Array.from([2, 2, 1, 4, 1, 1]),\n        Int32Array.from([4, 3, 1, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2, 4]),\n        Int32Array.from([1, 1, 1, 4, 2, 2]),\n        Int32Array.from([1, 2, 1, 1, 2, 4]),\n        Int32Array.from([1, 2, 1, 4, 2, 1]),\n        Int32Array.from([1, 4, 1, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 2, 2, 1]),\n        Int32Array.from([1, 1, 2, 2, 1, 4]),\n        Int32Array.from([1, 1, 2, 4, 1, 2]),\n        Int32Array.from([1, 2, 2, 1, 1, 4]),\n        Int32Array.from([1, 2, 2, 4, 1, 1]),\n        Int32Array.from([1, 4, 2, 1, 1, 2]),\n        Int32Array.from([1, 4, 2, 2, 1, 1]),\n        Int32Array.from([2, 4, 1, 2, 1, 1]),\n        Int32Array.from([2, 2, 1, 1, 1, 4]),\n        Int32Array.from([4, 1, 3, 1, 1, 1]),\n        Int32Array.from([2, 4, 1, 1, 1, 2]),\n        Int32Array.from([1, 3, 4, 1, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 4, 2]),\n        Int32Array.from([1, 2, 1, 1, 4, 2]),\n        Int32Array.from([1, 2, 1, 2, 4, 1]),\n        Int32Array.from([1, 1, 4, 2, 1, 2]),\n        Int32Array.from([1, 2, 4, 1, 1, 2]),\n        Int32Array.from([1, 2, 4, 2, 1, 1]),\n        Int32Array.from([4, 1, 1, 2, 1, 2]),\n        Int32Array.from([4, 2, 1, 1, 1, 2]),\n        Int32Array.from([4, 2, 1, 2, 1, 1]),\n        Int32Array.from([2, 1, 2, 1, 4, 1]),\n        Int32Array.from([2, 1, 4, 1, 2, 1]),\n        Int32Array.from([4, 1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 1, 1, 4, 3]),\n        Int32Array.from([1, 1, 1, 3, 4, 1]),\n        Int32Array.from([1, 3, 1, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 1, 3]),\n        Int32Array.from([1, 1, 4, 3, 1, 1]),\n        Int32Array.from([4, 1, 1, 1, 1, 3]),\n        Int32Array.from([4, 1, 1, 3, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 4, 1]),\n        Int32Array.from([1, 1, 4, 1, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 4, 1]),\n        Int32Array.from([4, 1, 1, 1, 3, 1]),\n        Int32Array.from([2, 1, 1, 4, 1, 2]),\n        Int32Array.from([2, 1, 1, 2, 1, 4]),\n        Int32Array.from([2, 1, 1, 2, 3, 2]),\n        Int32Array.from([2, 3, 3, 1, 1, 1, 2]),\n    ];\n    Code128Reader.MAX_AVG_VARIANCE = 0.25;\n    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    Code128Reader.CODE_SHIFT = 98;\n    Code128Reader.CODE_CODE_C = 99;\n    Code128Reader.CODE_CODE_B = 100;\n    Code128Reader.CODE_CODE_A = 101;\n    Code128Reader.CODE_FNC_1 = 102;\n    Code128Reader.CODE_FNC_2 = 97;\n    Code128Reader.CODE_FNC_3 = 96;\n    Code128Reader.CODE_FNC_4_A = 101;\n    Code128Reader.CODE_FNC_4_B = 100;\n    Code128Reader.CODE_START_A = 103;\n    Code128Reader.CODE_START_B = 104;\n    Code128Reader.CODE_START_C = 105;\n    Code128Reader.CODE_STOP = 106;\n\n    /**\n     * <p>Decodes Code 39 barcodes. Supports \"Full ASCII Code 39\" if USE_CODE_39_EXTENDED_MODE is set.</p>\n     *\n     * @author Sean Owen\n     * @see Code93Reader\n     */\n    class Code39Reader extends OneDReader {\n        /**\n         * Creates a reader that assumes all encoded data is data, and does not treat the final\n         * character as a check digit. It will not decoded \"extended Code 39\" sequences.\n         */\n        // public Code39Reader() {\n        //   this(false);\n        // }\n        /**\n         * Creates a reader that can be configured to check the last character as a check digit.\n         * It will not decoded \"extended Code 39\" sequences.\n         *\n         * @param usingCheckDigit if true, treat the last data character as a check digit, not\n         * data, and verify that the checksum passes.\n         */\n        // public Code39Reader(boolean usingCheckDigit) {\n        //   this(usingCheckDigit, false);\n        // }\n        /**\n         * Creates a reader that can be configured to check the last character as a check digit,\n         * or optionally attempt to decode \"extended Code 39\" sequences that are used to encode\n         * the full ASCII character set.\n         *\n         * @param usingCheckDigit if true, treat the last data character as a check digit, not\n         * data, and verify that the checksum passes.\n         * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the\n         * text.\n         */\n        constructor(usingCheckDigit = false, extendedMode = false) {\n            super();\n            this.usingCheckDigit = usingCheckDigit;\n            this.extendedMode = extendedMode;\n            this.decodeRowResult = '';\n            this.counters = new Int32Array(9);\n        }\n        decodeRow(rowNumber, row, hints) {\n            let theCounters = this.counters;\n            theCounters.fill(0);\n            this.decodeRowResult = '';\n            let start = Code39Reader.findAsteriskPattern(row, theCounters);\n            // Read off white space\n            let nextStart = row.getNextSet(start[1]);\n            let end = row.getSize();\n            let decodedChar;\n            let lastStart;\n            do {\n                Code39Reader.recordPattern(row, nextStart, theCounters);\n                let pattern = Code39Reader.toNarrowWidePattern(theCounters);\n                if (pattern < 0) {\n                    throw new NotFoundException();\n                }\n                decodedChar = Code39Reader.patternToChar(pattern);\n                this.decodeRowResult += decodedChar;\n                lastStart = nextStart;\n                for (let counter of theCounters) {\n                    nextStart += counter;\n                }\n                // Read off white space\n                nextStart = row.getNextSet(nextStart);\n            } while (decodedChar !== '*');\n            this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk\n            // Look for whitespace after pattern:\n            let lastPatternSize = 0;\n            for (let counter of theCounters) {\n                lastPatternSize += counter;\n            }\n            let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;\n            // If 50% of last pattern size, following last pattern, is not whitespace, fail\n            // (but if it's whitespace to the very end of the image, that's OK)\n            if (nextStart !== end && (whiteSpaceAfterEnd * 2) < lastPatternSize) {\n                throw new NotFoundException();\n            }\n            if (this.usingCheckDigit) {\n                let max = this.decodeRowResult.length - 1;\n                let total = 0;\n                for (let i = 0; i < max; i++) {\n                    total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));\n                }\n                if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {\n                    throw new ChecksumException();\n                }\n                this.decodeRowResult = this.decodeRowResult.substring(0, max);\n            }\n            if (this.decodeRowResult.length === 0) {\n                // false positive\n                throw new NotFoundException();\n            }\n            let resultString;\n            if (this.extendedMode) {\n                resultString = Code39Reader.decodeExtended(this.decodeRowResult);\n            }\n            else {\n                resultString = this.decodeRowResult;\n            }\n            let left = (start[1] + start[0]) / 2.0;\n            let right = lastStart + lastPatternSize / 2.0;\n            return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, new Date().getTime());\n        }\n        static findAsteriskPattern(row, counters) {\n            let width = row.getSize();\n            let rowOffset = row.getNextSet(0);\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            let isWhite = false;\n            let patternLength = counters.length;\n            for (let i = rowOffset; i < width; i++) {\n                if (row.get(i) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        // Look for whitespace before start pattern, >= 50% of width of start pattern\n                        if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING &&\n                            row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {\n                            return [patternStart, i];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters.copyWithin(0, 2, 2 + counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions\n        // per image when using some of our blackbox images.\n        static toNarrowWidePattern(counters) {\n            let numCounters = counters.length;\n            let maxNarrowCounter = 0;\n            let wideCounters;\n            do {\n                let minCounter = 0x7fffffff;\n                for (let counter of counters) {\n                    if (counter < minCounter && counter > maxNarrowCounter) {\n                        minCounter = counter;\n                    }\n                }\n                maxNarrowCounter = minCounter;\n                wideCounters = 0;\n                let totalWideCountersWidth = 0;\n                let pattern = 0;\n                for (let i = 0; i < numCounters; i++) {\n                    let counter = counters[i];\n                    if (counter > maxNarrowCounter) {\n                        pattern |= 1 << (numCounters - 1 - i);\n                        wideCounters++;\n                        totalWideCountersWidth += counter;\n                    }\n                }\n                if (wideCounters === 3) {\n                    // Found 3 wide counters, but are they close enough in width?\n                    // We can perform a cheap, conservative check to see if any individual\n                    // counter is more than 1.5 times the average:\n                    for (let i = 0; i < numCounters && wideCounters > 0; i++) {\n                        let counter = counters[i];\n                        if (counter > maxNarrowCounter) {\n                            wideCounters--;\n                            // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average\n                            if ((counter * 2) >= totalWideCountersWidth) {\n                                return -1;\n                            }\n                        }\n                    }\n                    return pattern;\n                }\n            } while (wideCounters > 3);\n            return -1;\n        }\n        static patternToChar(pattern) {\n            for (let i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {\n                if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {\n                    return Code39Reader.ALPHABET_STRING.charAt(i);\n                }\n            }\n            if (pattern === Code39Reader.ASTERISK_ENCODING) {\n                return '*';\n            }\n            throw new NotFoundException();\n        }\n        static decodeExtended(encoded) {\n            let length = encoded.length;\n            let decoded = '';\n            for (let i = 0; i < length; i++) {\n                let c = encoded.charAt(i);\n                if (c === '+' || c === '$' || c === '%' || c === '/') {\n                    let next = encoded.charAt(i + 1);\n                    let decodedChar = '\\0';\n                    switch (c) {\n                        case '+':\n                            // +A to +Z map to a to z\n                            if (next >= 'A' && next <= 'Z') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case '$':\n                            // $A to $Z map to control codes SH to SB\n                            if (next >= 'A' && next <= 'Z') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case '%':\n                            // %A to %E map to control codes ESC to US\n                            if (next >= 'A' && next <= 'E') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);\n                            }\n                            else if (next >= 'F' && next <= 'J') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);\n                            }\n                            else if (next >= 'K' && next <= 'O') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);\n                            }\n                            else if (next >= 'P' && next <= 'T') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);\n                            }\n                            else if (next === 'U') {\n                                decodedChar = '\\0';\n                            }\n                            else if (next === 'V') {\n                                decodedChar = '@';\n                            }\n                            else if (next === 'W') {\n                                decodedChar = '`';\n                            }\n                            else if (next === 'X' || next === 'Y' || next === 'Z') {\n                                decodedChar = '\\x7f';\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case '/':\n                            // /A to /O map to ! to , and /Z maps to :\n                            if (next >= 'A' && next <= 'O') {\n                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);\n                            }\n                            else if (next === 'Z') {\n                                decodedChar = ':';\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                    decoded += decodedChar;\n                    // bump up i again since we read two characters\n                    i++;\n                }\n                else {\n                    decoded += c;\n                }\n            }\n            return decoded;\n        }\n    }\n    Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';\n    /**\n     * These represent the encodings of characters, as patterns of wide and narrow bars.\n     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,\n     * with 1s representing \"wide\" and 0s representing narrow.\n     */\n    Code39Reader.CHARACTER_ENCODINGS = [\n        0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,\n        0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C,\n        0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,\n        0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8,\n        0x0A2, 0x08A, 0x02A // /-%\n    ];\n    Code39Reader.ASTERISK_ENCODING = 0x094;\n\n    /**\n     * <p>Decodes ITF barcodes.</p>\n     *\n     * @author Tjieco\n     */\n    class ITFReader extends OneDReader {\n        constructor() {\n            // private static W = 3; // Pixel width of a 3x wide line\n            // private static w = 2; // Pixel width of a 2x wide line\n            // private static N = 1; // Pixed width of a narrow line\n            super(...arguments);\n            // Stores the actual narrow line width of the image being decoded.\n            this.narrowLineWidth = -1;\n        }\n        // See ITFWriter.PATTERNS\n        /*\n      \n        /!**\n         * Patterns of Wide / Narrow lines to indicate each digit\n         *!/\n        */\n        decodeRow(rowNumber, row, hints) {\n            // Find out where the Middle section (payload) starts & ends\n            let startRange = this.decodeStart(row);\n            let endRange = this.decodeEnd(row);\n            let result = new StringBuilder();\n            ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n            let resultString = result.toString();\n            let allowedLengths = null;\n            if (hints != null) {\n                allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);\n            }\n            if (allowedLengths == null) {\n                allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n            }\n            // To avoid false positives with 2D barcodes (and other patterns), make\n            // an assumption that the decoded string must be a 'standard' length if it's short\n            let length = resultString.length;\n            let lengthOK = false;\n            let maxAllowedLength = 0;\n            for (let value of allowedLengths) {\n                if (length === value) {\n                    lengthOK = true;\n                    break;\n                }\n                if (value > maxAllowedLength) {\n                    maxAllowedLength = value;\n                }\n            }\n            if (!lengthOK && length > maxAllowedLength) {\n                lengthOK = true;\n            }\n            if (!lengthOK) {\n                throw new FormatException();\n            }\n            const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];\n            let resultReturn = new Result(resultString, null, // no natural byte representation for these barcodes\n            0, points, BarcodeFormat$1.ITF, new Date().getTime());\n            return resultReturn;\n        }\n        /*\n        /!**\n         * @param row          row of black/white values to search\n         * @param payloadStart offset of start pattern\n         * @param resultString {@link StringBuilder} to append decoded chars to\n         * @throws NotFoundException if decoding could not complete successfully\n         *!/*/\n        static decodeMiddle(row, payloadStart, payloadEnd, resultString) {\n            // Digits are interleaved in pairs - 5 black lines for one digit, and the\n            // 5\n            // interleaved white lines for the second digit.\n            // Therefore, need to scan 10 lines and then\n            // split these into two arrays\n            let counterDigitPair = new Int32Array(10); // 10\n            let counterBlack = new Int32Array(5); // 5\n            let counterWhite = new Int32Array(5); // 5\n            counterDigitPair.fill(0);\n            counterBlack.fill(0);\n            counterWhite.fill(0);\n            while (payloadStart < payloadEnd) {\n                // Get 10 runs of black/white.\n                OneDReader.recordPattern(row, payloadStart, counterDigitPair);\n                // Split them into each array\n                for (let k = 0; k < 5; k++) {\n                    let twoK = 2 * k;\n                    counterBlack[k] = counterDigitPair[twoK];\n                    counterWhite[k] = counterDigitPair[twoK + 1];\n                }\n                let bestMatch = ITFReader.decodeDigit(counterBlack);\n                resultString.append(bestMatch.toString());\n                bestMatch = this.decodeDigit(counterWhite);\n                resultString.append(bestMatch.toString());\n                counterDigitPair.forEach(function (counterDigit) {\n                    payloadStart += counterDigit;\n                });\n            }\n        }\n        /*/!**\n         * Identify where the start of the middle / payload section starts.\n         *\n         * @param row row of black/white values to search\n         * @return Array, containing index of start of 'start block' and end of\n         *         'start block'\n         *!/*/\n        decodeStart(row) {\n            let endStart = ITFReader.skipWhiteSpace(row);\n            let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);\n            // Determine the width of a narrow line in pixels. We can do this by\n            // getting the width of the start pattern and dividing by 4 because its\n            // made up of 4 narrow lines.\n            this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n            this.validateQuietZone(row, startPattern[0]);\n            return startPattern;\n        }\n        /*/!**\n         * The start & end patterns must be pre/post fixed by a quiet zone. This\n         * zone must be at least 10 times the width of a narrow line.  Scan back until\n         * we either get to the start of the barcode or match the necessary number of\n         * quiet zone pixels.\n         *\n         * Note: Its assumed the row is reversed when using this method to find\n         * quiet zone after the end pattern.\n         *\n         * ref: http://www.barcode-1.net/i25code.html\n         *\n         * @param row bit array representing the scanned barcode.\n         * @param startPattern index into row of the start or end pattern.\n         * @throws NotFoundException if the quiet zone cannot be found\n         *!/*/\n        validateQuietZone(row, startPattern) {\n            let quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n            // if there are not so many pixel at all let's try as many as possible\n            quietCount = quietCount < startPattern ? quietCount : startPattern;\n            for (let i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n                if (row.get(i)) {\n                    break;\n                }\n                quietCount--;\n            }\n            if (quietCount !== 0) {\n                // Unable to find the necessary number of quiet zone pixels.\n                throw new NotFoundException();\n            }\n        }\n        /*\n        /!**\n         * Skip all whitespace until we get to the first black line.\n         *\n         * @param row row of black/white values to search\n         * @return index of the first black line.\n         * @throws NotFoundException Throws exception if no black lines are found in the row\n         *!/*/\n        static skipWhiteSpace(row) {\n            const width = row.getSize();\n            const endStart = row.getNextSet(0);\n            if (endStart === width) {\n                throw new NotFoundException();\n            }\n            return endStart;\n        }\n        /*/!**\n         * Identify where the end of the middle / payload section ends.\n         *\n         * @param row row of black/white values to search\n         * @return Array, containing index of start of 'end block' and end of 'end\n         *         block'\n         *!/*/\n        decodeEnd(row) {\n            // For convenience, reverse the row and then\n            // search from 'the start' for the end block\n            row.reverse();\n            try {\n                let endStart = ITFReader.skipWhiteSpace(row);\n                let endPattern;\n                try {\n                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n                }\n                catch (error) {\n                    if (error instanceof NotFoundException) {\n                        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n                    }\n                }\n                // The start & end patterns must be pre/post fixed by a quiet zone. This\n                // zone must be at least 10 times the width of a narrow line.\n                // ref: http://www.barcode-1.net/i25code.html\n                this.validateQuietZone(row, endPattern[0]);\n                // Now recalculate the indices of where the 'endblock' starts & stops to\n                // accommodate\n                // the reversed nature of the search\n                let temp = endPattern[0];\n                endPattern[0] = row.getSize() - endPattern[1];\n                endPattern[1] = row.getSize() - temp;\n                return endPattern;\n            }\n            finally {\n                // Put the row back the right way.\n                row.reverse();\n            }\n        }\n        /*\n        /!**\n         * @param row       row of black/white values to search\n         * @param rowOffset position to start search\n         * @param pattern   pattern of counts of number of black and white pixels that are\n         *                  being searched for as a pattern\n         * @return start/end horizontal offset of guard pattern, as an array of two\n         *         ints\n         * @throws NotFoundException if pattern is not found\n         *!/*/\n        static findGuardPattern(row, rowOffset, pattern) {\n            let patternLength = pattern.length;\n            let counters = new Int32Array(patternLength);\n            let width = row.getSize();\n            let isWhite = false;\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            counters.fill(0);\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n                            return [patternStart, x];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /*/!**\n         * Attempts to decode a sequence of ITF black/white lines into single\n         * digit.\n         *\n         * @param counters the counts of runs of observed black/white/black/... values\n         * @return The decoded digit\n         * @throws NotFoundException if digit cannot be decoded\n         *!/*/\n        static decodeDigit(counters) {\n            let bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n            let bestMatch = -1;\n            let max = ITFReader.PATTERNS.length;\n            for (let i = 0; i < max; i++) {\n                let pattern = ITFReader.PATTERNS[i];\n                let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = i;\n                }\n                else if (variance === bestVariance) {\n                    // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n                    bestMatch = -1;\n                }\n            }\n            if (bestMatch >= 0) {\n                return bestMatch % 10;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n    }\n    ITFReader.PATTERNS = [\n        Int32Array.from([1, 1, 2, 2, 1]),\n        Int32Array.from([2, 1, 1, 1, 2]),\n        Int32Array.from([1, 2, 1, 1, 2]),\n        Int32Array.from([2, 2, 1, 1, 1]),\n        Int32Array.from([1, 1, 2, 1, 2]),\n        Int32Array.from([2, 1, 2, 1, 1]),\n        Int32Array.from([1, 2, 2, 1, 1]),\n        Int32Array.from([1, 1, 1, 2, 2]),\n        Int32Array.from([2, 1, 1, 2, 1]),\n        Int32Array.from([1, 2, 1, 2, 1]),\n        Int32Array.from([1, 1, 3, 3, 1]),\n        Int32Array.from([3, 1, 1, 1, 3]),\n        Int32Array.from([1, 3, 1, 1, 3]),\n        Int32Array.from([3, 3, 1, 1, 1]),\n        Int32Array.from([1, 1, 3, 1, 3]),\n        Int32Array.from([3, 1, 3, 1, 1]),\n        Int32Array.from([1, 3, 3, 1, 1]),\n        Int32Array.from([1, 1, 1, 3, 3]),\n        Int32Array.from([3, 1, 1, 3, 1]),\n        Int32Array.from([1, 3, 1, 3, 1]) // 9\n    ];\n    ITFReader.MAX_AVG_VARIANCE = 0.38;\n    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n    /*/!**\n     * Start/end guard pattern.\n     *\n     * Note: The end pattern is reversed because the row is reversed before\n     * searching for the END_PATTERN\n     *!/*/\n    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);\n    ITFReader.END_PATTERN_REVERSED = [\n        Int32Array.from([1, 1, 2]),\n        Int32Array.from([1, 1, 3]) // 3x\n    ];\n\n    /**\n     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n     * of one-dimensional barcodes.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */\n    class AbstractUPCEANReader extends OneDReader {\n        constructor() {\n            super(...arguments);\n            this.decodeRowStringBuffer = '';\n        }\n\n        static findStartGuardPattern(row) {\n            let foundStart = false;\n            let startRange;\n            let nextStart = 0;\n            let counters = Int32Array.from([0, 0, 0]);\n            while (!foundStart) {\n                counters = Int32Array.from([0, 0, 0]);\n                startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);\n                let start = startRange[0];\n                nextStart = startRange[1];\n                let quietStart = start - (nextStart - start);\n                if (quietStart >= 0) {\n                    foundStart = row.isRange(quietStart, start, false);\n                }\n            }\n            return startRange;\n        }\n        static checkChecksum(s) {\n            return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);\n        }\n        static checkStandardUPCEANChecksum(s) {\n            let length = s.length;\n            if (length === 0)\n                return false;\n            let check = parseInt(s.charAt(length - 1), 10);\n            return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n        }\n        static getStandardUPCEANChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for (let i = length - 1; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            sum *= 3;\n            for (let i = length - 2; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            return (1000 - sum) % 10;\n        }\n        static decodeEnd(row, endStart) {\n            return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));\n        }\n        /**\n         * @throws NotFoundException\n         */\n        static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {\n            return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));\n        }\n        /**\n         * @param row row of black/white values to search\n         * @param rowOffset position to start search\n         * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...\n         * pixel counts, otherwise, it is interpreted as black/white/black/...\n         * @param pattern pattern of counts of number of black and white pixels that are being\n         * searched for as a pattern\n         * @param counters array of counters, as long as pattern, to re-use\n         * @return start/end horizontal offset of guard pattern, as an array of two ints\n         * @throws NotFoundException if pattern is not found\n         */\n        static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {\n            let width = row.getSize();\n            rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            let patternLength = pattern.length;\n            let isWhite = whiteFirst;\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {\n                            return Int32Array.from([patternStart, x]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        let slice = counters.slice(2, counters.length - 1);\n                        for (let i = 0; i < counterPosition - 1; i++) {\n                            counters[i] = slice[i];\n                        }\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static decodeDigit(row, counters, rowOffset, patterns) {\n            this.recordPattern(row, rowOffset, counters);\n            let bestVariance = this.MAX_AVG_VARIANCE;\n            let bestMatch = -1;\n            let max = patterns.length;\n            for (let i = 0; i < max; i++) {\n                let pattern = patterns[i];\n                let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);\n                if (variance < bestVariance) {\n                    bestVariance = variance;\n                    bestMatch = i;\n                }\n            }\n            if (bestMatch >= 0) {\n                return bestMatch;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n    }\n    // These two values are critical for determining how permissive the decoding will be.\n    // We've arrived at these values through a lot of trial and error. Setting them any higher\n    // lets false positives creep in quickly.\n    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;\n    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;\n    /**\n     * Start/end guard pattern.\n     */\n    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);\n    /**\n     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.\n     */\n    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);\n    /**\n     * end guard pattern.\n     */\n    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    /**\n     * \"Odd\", or \"L\" patterns used to encode UPC/EAN digits.\n     */\n    AbstractUPCEANReader.L_PATTERNS = [\n        Int32Array.from([3, 2, 1, 1]),\n        Int32Array.from([2, 2, 2, 1]),\n        Int32Array.from([2, 1, 2, 2]),\n        Int32Array.from([1, 4, 1, 1]),\n        Int32Array.from([1, 1, 3, 2]),\n        Int32Array.from([1, 2, 3, 1]),\n        Int32Array.from([1, 1, 1, 4]),\n        Int32Array.from([1, 3, 1, 2]),\n        Int32Array.from([1, 2, 1, 3]),\n        Int32Array.from([3, 1, 1, 2]),\n    ];\n\n    /**\n     * @see UPCEANExtension2Support\n     */\n    class UPCEANExtension5Support {\n        constructor() {\n            this.CHECK_DIGIT_ENCODINGS = [0x18, 0x14, 0x12, 0x11, 0x0C, 0x06, 0x03, 0x0A, 0x09, 0x05];\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n            this.decodeRowStringBuffer = '';\n        }\n        decodeRow(rowNumber, row, extensionStartRange) {\n            let result = this.decodeRowStringBuffer;\n            let end = this.decodeMiddle(row, extensionStartRange, result);\n            let resultString = result.toString();\n            let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);\n            let resultPoints = [\n                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n                new ResultPoint(end, rowNumber)\n            ];\n            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());\n            if (extensionData != null) {\n                extensionResult.putAllMetadata(extensionData);\n            }\n            return extensionResult;\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for (let x = 0; x < 5 && rowOffset < end; x++) {\n                let bestMatch = AbstractUPCEANReader.decodeDigit(\n                    row,\n                    counters,\n                    rowOffset,\n                    AbstractUPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= 1 << (4 - x);\n                }\n                if (x !== 4) {\n                    // Read off separator if not last\n                    rowOffset = row.getNextSet(rowOffset);\n                    rowOffset = row.getNextUnset(rowOffset);\n                }\n            }\n            if (resultString.length !== 5) {\n                throw new NotFoundException();\n            }\n            let checkDigit = this.determineCheckDigit(lgPatternFound);\n            if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {\n                throw new NotFoundException();\n            }\n            return rowOffset;\n        }\n        static extensionChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for (let i = length - 2; i >= 0; i -= 2) {\n                sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            }\n            sum *= 3;\n            for (let i = length - 1; i >= 0; i -= 2) {\n                sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n            }\n            sum *= 3;\n            return sum % 10;\n        }\n        determineCheckDigit(lgPatternFound) {\n            for (let d = 0; d < 10; d++) {\n                if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {\n                    return d;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static parseExtensionString(raw) {\n            if (raw.length !== 5) {\n                return null;\n            }\n            let value = UPCEANExtension5Support.parseExtension5String(raw);\n            if (value == null) {\n                return null;\n            }\n            return new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value]]);\n        }\n        static parseExtension5String(raw) {\n            let currency;\n            switch (raw.charAt(0)) {\n                case '0':\n                    currency = '';\n                    break;\n                case '5':\n                    currency = '$';\n                    break;\n                case '9':\n                    // Reference: http://www.jollytech.com\n                    switch (raw) {\n                        case '90000':\n                            // No suggested retail price\n                            return null;\n                        case '99991':\n                            // Complementary\n                            return '0.00';\n                        case '99990':\n                            return 'Used';\n                    }\n                    // Otherwise... unknown currency?\n                    currency = '';\n                    break;\n                default:\n                    currency = '';\n                    break;\n            }\n            let rawAmount = parseInt(raw.substring(1));\n            let unitsString = (rawAmount / 100).toString();\n            let hundredths = rawAmount % 100;\n            let hundredthsString = hundredths < 10 ? '0' + hundredths : hundredths.toString(); // fixme\n            return currency + unitsString + '.' + hundredthsString;\n        }\n    }\n\n    /**\n     * @see UPCEANExtension5Support\n     */\n    class UPCEANExtension2Support {\n        constructor() {\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n            this.decodeRowStringBuffer = '';\n        }\n        decodeRow(rowNumber, row, extensionStartRange) {\n            let result = this.decodeRowStringBuffer;\n            let end = this.decodeMiddle(row, extensionStartRange, result);\n            let resultString = result.toString();\n            let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);\n            let resultPoints = [\n                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),\n                new ResultPoint(end, rowNumber)\n            ];\n            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());\n            if (extensionData != null) {\n                extensionResult.putAllMetadata(extensionData);\n            }\n            return extensionResult;\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let checkParity = 0;\n            for (let x = 0; x < 2 && rowOffset < end; x++) {\n                let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    checkParity |= 1 << (1 - x);\n                }\n                if (x !== 1) {\n                    // Read off separator if not last\n                    rowOffset = row.getNextSet(rowOffset);\n                    rowOffset = row.getNextUnset(rowOffset);\n                }\n            }\n            if (resultString.length !== 2) {\n                throw new NotFoundException();\n            }\n            if (parseInt(resultString.toString()) % 4 !== checkParity) {\n                throw new NotFoundException();\n            }\n            return rowOffset;\n        }\n        static parseExtensionString(raw) {\n            if (raw.length !== 2) {\n                return null;\n            }\n            return new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw)]]);\n        }\n    }\n\n    class UPCEANExtensionSupport {\n        static decodeRow(rowNumber, row, rowOffset) {\n            let extensionStartRange = AbstractUPCEANReader.findGuardPattern(\n                row,\n                rowOffset,\n                false,\n                this.EXTENSION_START_PATTERN,\n                new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));\n            try {\n                // return null;\n                let fiveSupport = new UPCEANExtension5Support();\n                return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);\n            }\n            catch (err) {\n                // return null;\n                let twoSupport = new UPCEANExtension2Support();\n                return twoSupport.decodeRow(rowNumber, row, extensionStartRange);\n            }\n        }\n    }\n    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);\n\n    /**\n     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families\n     * of one-dimensional barcodes.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */\n    class UPCEANReader extends AbstractUPCEANReader {\n        constructor() {\n            super();\n            this.decodeRowStringBuffer = '';\n            UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(arr => Int32Array.from(arr));\n            for (let i = 10; i < 20; i++) {\n                let widths = UPCEANReader.L_PATTERNS[i - 10];\n                let reversedWidths = new Int32Array(widths.length);\n                for (let j = 0; j < widths.length; j++) {\n                    reversedWidths[j] = widths[widths.length - j - 1];\n                }\n                UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;\n            }\n        }\n        decodeRow(rowNumber, row, hints) {\n            let startGuardRange = UPCEANReader.findStartGuardPattern(row);\n            let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);\n            let endStart = budello.rowOffset;\n            let result = budello.resultString;\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint(endStart, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            let endRange = this.decodeEnd(row, endStart);\n            if (resultPointCallback != null) {\n                const resultPoint = new ResultPoint((endRange[0] + endRange[1]) / 2.0, rowNumber);\n                resultPointCallback.foundPossibleResultPoint(resultPoint);\n            }\n            // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The\n            // spec might want more whitespace, but in practice this is the maximum we can count on.\n            let end = endRange[1];\n            let quietEnd = end + (end - endRange[0]);\n            if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {\n                throw new NotFoundException();\n            }\n            let resultString = result.toString();\n            // UPC/EAN should never be less than 8 chars anyway\n            if (resultString.length < 8) {\n                throw new FormatException();\n            }\n            if (!UPCEANReader.checkChecksum(resultString)) {\n                throw new ChecksumException();\n            }\n            let left = (startGuardRange[1] + startGuardRange[0]) / 2.0;\n            let right = (endRange[1] + endRange[0]) / 2.0;\n            let format = this.getBarcodeFormat();\n            let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];\n            let decodeResult = new Result(resultString, null, 0, resultPoint, format, new Date().getTime());\n            let extensionLength = 0;\n            try {\n                let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);\n                decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());\n                decodeResult.putAllMetadata(extensionResult.getResultMetadata());\n                decodeResult.addResultPoints(extensionResult.getResultPoints());\n                extensionLength = extensionResult.getText().length;\n            }\n            catch (ignoreError) {}\n            let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);\n            if (allowedExtensions != null) {\n                let valid = false;\n                for (let length in allowedExtensions) {\n                    if (extensionLength.toString() === length) { // check me\n                        valid = true;\n                        break;\n                    }\n                }\n                if (!valid) {\n                    throw new NotFoundException();\n                }\n            }\n            return decodeResult;\n        }\n        decodeEnd(row, endStart) {\n            return UPCEANReader.findGuardPattern(\n                row, endStart, false, UPCEANReader.START_END_PATTERN,\n                new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));\n        }\n        static checkChecksum(s) {\n            return UPCEANReader.checkStandardUPCEANChecksum(s);\n        }\n        static checkStandardUPCEANChecksum(s) {\n            let length = s.length;\n            if (length === 0)\n                return false;\n            let check = parseInt(s.charAt(length - 1), 10);\n            return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;\n        }\n        static getStandardUPCEANChecksum(s) {\n            let length = s.length;\n            let sum = 0;\n            for (let i = length - 1; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            sum *= 3;\n            for (let i = length - 2; i >= 0; i -= 2) {\n                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                if (digit < 0 || digit > 9) {\n                    throw new FormatException();\n                }\n                sum += digit;\n            }\n            return (1000 - sum) % 10;\n        }\n    }\n\n    /**\n     * <p>Implements decoding of the EAN-13 format.</p>\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author alasdair@google.com (Alasdair Mackintosh)\n     */\n    class EAN13Reader extends UPCEANReader {\n        constructor() {\n            super();\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        }\n        decodeMiddle(row, startRange, resultString) {\n            let counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for (let x = 0; x < 6 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= 1 << (5 - x);\n                }\n            }\n            resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);\n            let middleRange = UPCEANReader.findGuardPattern(\n                row,\n                rowOffset,\n                true,\n                UPCEANReader.MIDDLE_PATTERN,\n                new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));\n            rowOffset = middleRange[1];\n            for (let x = 0; x < 6 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n            }\n            return { rowOffset, resultString };\n        }\n        getBarcodeFormat() {\n            return BarcodeFormat$1.EAN_13;\n        }\n        static determineFirstDigit(resultString, lgPatternFound) {\n            for (let d = 0; d < 10; d++) {\n                if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {\n                    resultString = String.fromCharCode(('0'.charCodeAt(0) + d)) + resultString;\n                    return resultString;\n                }\n            }\n            throw new NotFoundException();\n        }\n    }\n    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0x00, 0x0B, 0x0D, 0xE, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A];\n\n    /**\n     * <p>Implements decoding of the EAN-8 format.</p>\n     *\n     * @author Sean Owen\n     */\n    class EAN8Reader extends UPCEANReader {\n        constructor() {\n            super();\n            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n        }\n        decodeMiddle(row, startRange, resultString) {\n            const counters = this.decodeMiddleCounters;\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let end = row.getSize();\n            let rowOffset = startRange[1];\n            for (let x = 0; x < 4 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n            }\n            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));\n            rowOffset = middleRange[1];\n            for (let x = 0; x < 4 && rowOffset < end; x++) {\n                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);\n                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n            }\n            return { rowOffset, resultString };\n        }\n        getBarcodeFormat() {\n            return BarcodeFormat$1.EAN_8;\n        }\n    }\n\n    /**\n     * Encapsulates functionality and implementation that is common to all families\n     * of one-dimensional barcodes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Sean Owen\n     * @author sam2332 (Sam Rudloff)\n     *\n     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java\n     *\n     * @experimental\n     */\n    class UPCAReader extends UPCEANReader {\n        constructor() {\n            super(...arguments);\n            this.ean13Reader = new EAN13Reader();\n        }\n        // @Override\n        getBarcodeFormat() {\n            return BarcodeFormat$1.UPC_A;\n        }\n        // Note that we don't try rotation without the try harder flag, even if rotation was supported.\n        // @Override\n        decode(image, hints) {\n            return this.maybeReturnResult(this.ean13Reader.decode(image));\n        }\n        // @Override\n        decodeRow(rowNumber, row, hints) {\n            return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));\n        }\n        // @Override\n        decodeMiddle(row, startRange, resultString) {\n            return this.ean13Reader.decodeMiddle(row, startRange, resultString);\n        }\n        maybeReturnResult(result) {\n            let text = result.getText();\n            if (text.charAt(0) === '0') {\n                let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);\n                if (result.getResultMetadata() != null) {\n                    upcaResult.putAllMetadata(result.getResultMetadata());\n                }\n                return upcaResult;\n            }\n            else {\n                throw new NotFoundException();\n            }\n        }\n        reset() {\n            this.ean13Reader.reset();\n        }\n    }\n\n    /**\n     * <p>Implements decoding of the UPC-E format.</p>\n     * <p><a href=\"http://www.barcodeisland.com/upce.phtml\">This</a> is a great reference for\n     * UPC-E information.</p>\n     *\n     * @author Sean Owen\n     *\n     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java\n     *\n     * @experimental\n     */\n    /* final */ class UPCEReader extends UPCEANReader {\n        constructor() {\n            super();\n            this.decodeMiddleCounters = new Int32Array(4);\n        }\n        /**\n         * @throws NotFoundException\n         */\n        // @Override\n        decodeMiddle(row, startRange, result) {\n            const counters = this.decodeMiddleCounters.map(x => x);\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            const end = row.getSize();\n            let rowOffset = startRange[1];\n            let lgPatternFound = 0;\n            for (let x = 0; x < 6 && rowOffset < end; x++) {\n                const bestMatch = UPCEReader.decodeDigit(\n                    row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);\n                result += String.fromCharCode(('0'.charCodeAt(0) + (bestMatch % 10)));\n                for (let counter of counters) {\n                    rowOffset += counter;\n                }\n                if (bestMatch >= 10) {\n                    lgPatternFound |= (1 << (5 - x));\n                }\n            }\n            let resultString = UPCEReader.determineNumSysAndCheckDigit(\n                result, lgPatternFound);\n            return {rowOffset, resultString};\n        }\n        /**\n         * @throws NotFoundException\n         */\n        // @Override\n        decodeEnd(row, endStart) {\n            return UPCEReader.findGuardPatternWithoutCounters(\n                row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);\n        }\n        /**\n         * @throws FormatException\n         */\n        // @Override\n        checkChecksum(s) {\n            return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));\n        }\n        /**\n         * @throws NotFoundException\n         */\n        static determineNumSysAndCheckDigit(resultString, lgPatternFound) {\n            for (let numSys = 0; numSys <= 1; numSys++) {\n                for (let d = 0; d < 10; d++) {\n                    if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {\n                        let prefix = String.fromCharCode('0'.charCodeAt(0) + numSys);\n                        let suffix = String.fromCharCode('0'.charCodeAt(0) + d);\n                        return prefix + resultString + suffix;\n                    }\n                }\n            }\n            throw NotFoundException.getNotFoundInstance();\n        }\n        // @Override\n        getBarcodeFormat() {\n            return BarcodeFormat$1.UPC_E;\n        }\n        /**\n         * Expands a UPC-E value back into its full, equivalent UPC-A code value.\n         *\n         * @param upce UPC-E code as string of digits\n         * @return equivalent UPC-A code as string of digits\n         */\n        static convertUPCEtoUPCA(upce) {\n            // the following line is equivalent to upce.getChars(1, 7, upceChars, 0);\n            const upceChars = upce.slice(1, 7).split('').map(x => x.charCodeAt(0));\n            const result = new StringBuilder( /*12*/);\n            result.append(upce.charAt(0));\n            let lastChar = upceChars[5];\n            switch (lastChar) {\n                case 0:\n                case 1:\n                case 2:\n                    result.appendChars(upceChars, 0, 2);\n                    result.append(lastChar);\n                    result.append('0000');\n                    result.appendChars(upceChars, 2, 3);\n                    break;\n                case 3:\n                    result.appendChars(upceChars, 0, 3);\n                    result.append('00000');\n                    result.appendChars(upceChars, 3, 2);\n                    break;\n                case 4:\n                    result.appendChars(upceChars, 0, 4);\n                    result.append('00000');\n                    result.append(upceChars[4]);\n                    break;\n                default:\n                    result.appendChars(upceChars, 0, 5);\n                    result.append('0000');\n                    result.append(lastChar);\n                    break;\n            }\n            // Only append check digit in conversion if supplied\n            if (upce.length >= 8) {\n                result.append(upce.charAt(7));\n            }\n            return result.toString();\n        }\n    }\n    /**\n     * The pattern that marks the middle, and end, of a UPC-E pattern.\n     * There is no \"second half\" to a UPC-E barcode.\n     */\n    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);\n    // For an UPC-E barcode, the final digit is represented by the parities used\n    // to encode the middle six digits, according to the table below.\n    //\n    //                Parity of next 6 digits\n    //    Digit   0     1     2     3     4     5\n    //       0    Even   Even  Even Odd  Odd   Odd\n    //       1    Even   Even  Odd  Even Odd   Odd\n    //       2    Even   Even  Odd  Odd  Even  Odd\n    //       3    Even   Even  Odd  Odd  Odd   Even\n    //       4    Even   Odd   Even Even Odd   Odd\n    //       5    Even   Odd   Odd  Even Even  Odd\n    //       6    Even   Odd   Odd  Odd  Even  Even\n    //       7    Even   Odd   Even Odd  Even  Odd\n    //       8    Even   Odd   Even Odd  Odd   Even\n    //       9    Even   Odd   Odd  Even Odd   Even\n    //\n    // The encoding is represented by the following array, which is a bit pattern\n    // using Odd = 0 and Even = 1. For example, 5 is represented by:\n    //\n    //              Odd Even Even Odd Odd Even\n    // in binary:\n    //                0    1    1   0   0    1   == 0x19\n    //\n    /**\n     * See {@link #L_AND_G_PATTERNS}; these values similarly represent patterns of\n     * even-odd parity encodings of digits that imply both the number system (0 or 1)\n     * used, and the check digit.\n     */\n    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [\n        Int32Array.from([0x38, 0x34, 0x32, 0x31, 0x2C, 0x26, 0x23, 0x2A, 0x29, 0x25]),\n        Int32Array.from([0x07, 0x0B, 0x0D, 0x0E, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A]),\n    ];\n\n    /**\n     * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to\n     * read all such formats, it is most efficient to use this implementation rather than invoke\n     * individual readers.</p>\n     *\n     * @author Sean Owen\n     */\n    class MultiFormatUPCEANReader extends OneDReader {\n        constructor(hints) {\n            super();\n            let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            let readers = [];\n            if (!isNullOrUndefined(possibleFormats)) {\n                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {\n                    readers.push(new EAN13Reader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {\n                    readers.push(new UPCAReader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {\n                    readers.push(new EAN8Reader());\n                }\n                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {\n                    readers.push(new UPCEReader());\n                }\n            } else {\n                // No hints provided.\n                readers.push(new EAN13Reader());\n                readers.push(new UPCAReader());\n                readers.push(new EAN8Reader());\n                readers.push(new UPCEReader());\n            }\n            this.readers = readers;\n        }\n        decodeRow(rowNumber, row, hints) {\n            for (let reader of this.readers) {\n                try {\n                    // const result: Result = reader.decodeRow(rowNumber, row, startGuardPattern, hints);\n                    const result = reader.decodeRow(rowNumber, row, hints);\n                    // Special case: a 12-digit code encoded in UPC-A is identical to a \"0\"\n                    // followed by those 12 digits encoded as EAN-13. Each will recognize such a code,\n                    // UPC-A as a 12-digit string and EAN-13 as a 13-digit string starting with \"0\".\n                    // Individually these are correct and their readers will both read such a code\n                    // and correctly call it EAN-13, or UPC-A, respectively.\n                    //\n                    // In this case, if we've been looking for both types, we'd like to call it\n                    // a UPC-A code. But for efficiency we only run the EAN-13 decoder to also read\n                    // UPC-A. So we special case it here, and convert an EAN-13 result to a UPC-A\n                    // result if appropriate.\n                    //\n                    // But, don't return UPC-A if UPC-A was not a requested format!\n                    const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 &&\n                        result.getText().charAt(0) === '0';\n                    // @SuppressWarnings(\"unchecked\")\n                    const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n                    const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);\n                    if (ean13MayBeUPCA && canReturnUPCA) {\n                        const rawBytes = result.getRawBytes();\n                        // Transfer the metadata across\n                        const resultUPCA = new Result(\n                            result.getText().substring(1),\n                            rawBytes,\n                            (rawBytes ? rawBytes.length : null),\n                            result.getResultPoints(),\n                            BarcodeFormat$1.UPC_A);\n                        resultUPCA.putAllMetadata(result.getResultMetadata());\n                        return resultUPCA;\n                    }\n                    return result;\n                }\n                catch (err) {\n                    // continue;\n                }\n            }\n            throw new NotFoundException();\n        }\n        reset() {\n            for (let reader of this.readers) {\n                reader.reset();\n            }\n        }\n    }\n\n    // import Integer from '../../util/Integer';\n    // import Float from '../../util/Float';\n    class AbstractRSSReader extends OneDReader {\n        constructor() {\n            super();\n            this.decodeFinderCounters = new Int32Array(4);\n            this.dataCharacterCounters = new Int32Array(8);\n            this.oddRoundingErrors = new Array(4);\n            this.evenRoundingErrors = new Array(4);\n            this.oddCounts = new Array(this.dataCharacterCounters.length / 2);\n            this.evenCounts = new Array(this.dataCharacterCounters.length / 2);\n        }\n        getDecodeFinderCounters() {\n            return this.decodeFinderCounters;\n        }\n        getDataCharacterCounters() {\n            return this.dataCharacterCounters;\n        }\n        getOddRoundingErrors() {\n            return this.oddRoundingErrors;\n        }\n        getEvenRoundingErrors() {\n            return this.evenRoundingErrors;\n        }\n        getOddCounts() {\n            return this.oddCounts;\n        }\n        getEvenCounts() {\n            return this.evenCounts;\n        }\n        parseFinderValue(counters, finderPatterns) {\n            for (let value = 0; value < finderPatterns.length; value++) {\n                if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {\n                    return value;\n                }\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * @param array values to sum\n         * @return sum of values\n         * @deprecated call {@link MathUtils#sum(int[])}\n         */\n        static count(array) {\n            return MathUtils.sum(new Int32Array(array));\n        }\n        static increment(array, errors) {\n            let index = 0;\n            let biggestError = errors[0];\n            for (let i = 1; i < array.length; i++) {\n                if (errors[i] > biggestError) {\n                    biggestError = errors[i];\n                    index = i;\n                }\n            }\n            array[index]++;\n        }\n        static decrement(array, errors) {\n            let index = 0;\n            let biggestError = errors[0];\n            for (let i = 1; i < array.length; i++) {\n                if (errors[i] < biggestError) {\n                    biggestError = errors[i];\n                    index = i;\n                }\n            }\n            array[index]--;\n        }\n        static isFinderPattern(counters) {\n            let firstTwoSum = counters[0] + counters[1];\n            let sum = firstTwoSum + counters[2] + counters[3];\n            let ratio = firstTwoSum / sum;\n            if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {\n                // passes ratio test in spec, but see if the counts are unreasonable\n                let minCounter = Number.MAX_SAFE_INTEGER;\n                let maxCounter = Number.MIN_SAFE_INTEGER;\n                for (let counter of counters) {\n                    if (counter > maxCounter) {\n                        maxCounter = counter;\n                    }\n                    if (counter < minCounter) {\n                        minCounter = counter;\n                    }\n                }\n                return maxCounter < 10 * minCounter;\n            }\n            return false;\n        }\n    }\n    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;\n    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;\n    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12.0;\n    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14.0;\n\n    class DataCharacter {\n        constructor(value, checksumPortion) {\n            this.value = value;\n            this.checksumPortion = checksumPortion;\n        }\n        getValue() {\n            return this.value;\n        }\n        getChecksumPortion() {\n            return this.checksumPortion;\n        }\n        toString() {\n            return this.value + '(' + this.checksumPortion + ')';\n        }\n        equals(o) {\n            if (!(o instanceof DataCharacter)) {\n                return false;\n            }\n            const that = o;\n            return this.value === that.value && this.checksumPortion === that.checksumPortion;\n        }\n        hashCode() {\n            return this.value ^ this.checksumPortion;\n        }\n    }\n\n    class FinderPattern {\n        constructor(value, startEnd, start, end, rowNumber) {\n            this.value = value;\n            this.startEnd = startEnd;\n            this.value = value;\n            this.startEnd = startEnd;\n            this.resultPoints = new Array();\n            this.resultPoints.push(new ResultPoint(start, rowNumber));\n            this.resultPoints.push(new ResultPoint(end, rowNumber));\n        }\n        getValue() {\n            return this.value;\n        }\n        getStartEnd() {\n            return this.startEnd;\n        }\n        getResultPoints() {\n            return this.resultPoints;\n        }\n        equals(o) {\n            if (!(o instanceof FinderPattern)) {\n                return false;\n            }\n            const that = o;\n            return this.value === that.value;\n        }\n        hashCode() {\n            return this.value;\n        }\n    }\n\n    /**\n     * RSS util functions.\n     */\n    class RSSUtils {\n        constructor() { }\n        static getRSSvalue(widths, maxWidth, noNarrow) {\n            let n = 0;\n            for (let width of widths) {\n                n += width;\n            }\n            let val = 0;\n            let narrowMask = 0;\n            let elements = widths.length;\n            for (let bar = 0; bar < elements - 1; bar++) {\n                let elmWidth;\n                for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {\n                    let subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);\n                    if (noNarrow && (narrowMask === 0) && (n - elmWidth - (elements - bar - 1) >= elements - bar - 1)) {\n                        subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);\n                    }\n                    if (elements - bar - 1 > 1) {\n                        let lessVal = 0;\n                        for (let mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {\n                            lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);\n                        }\n                        subVal -= lessVal * (elements - 1 - bar);\n                    }\n                    else if (n - elmWidth > maxWidth) {\n                        subVal--;\n                    }\n                    val += subVal;\n                }\n                n -= elmWidth;\n            }\n            return val;\n        }\n        static combins(n, r) {\n            let maxDenom;\n            let minDenom;\n            if (n - r > r) {\n                minDenom = r;\n                maxDenom = n - r;\n            }\n            else {\n                minDenom = n - r;\n                maxDenom = r;\n            }\n            let val = 1;\n            let j = 1;\n            for (let i = n; i > maxDenom; i--) {\n                val *= i;\n                if (j <= minDenom) {\n                    val /= j;\n                    j++;\n                }\n            }\n            while ((j <= minDenom)) {\n                val /= j;\n                j++;\n            }\n            return val;\n        }\n    }\n\n    class BitArrayBuilder {\n        static buildBitArray(pairs) {\n            let charNumber = (pairs.length * 2) - 1;\n            if (pairs[pairs.length - 1].getRightChar() == null) {\n                charNumber -= 1;\n            }\n            let size = 12 * charNumber;\n            let binary = new BitArray(size);\n            let accPos = 0;\n            let firstPair = pairs[0];\n            let firstValue = firstPair.getRightChar().getValue();\n            for (let i = 11; i >= 0; --i) {\n                if ((firstValue & (1 << i)) != 0) {\n                    binary.set(accPos);\n                }\n                accPos++;\n            }\n            for (let i = 1; i < pairs.length; ++i) {\n                let currentPair = pairs[i];\n                let leftValue = currentPair.getLeftChar().getValue();\n                for (let j = 11; j >= 0; --j) {\n                    if ((leftValue & (1 << j)) != 0) {\n                        binary.set(accPos);\n                    }\n                    accPos++;\n                }\n                if (currentPair.getRightChar() != null) {\n                    let rightValue = currentPair.getRightChar().getValue();\n                    for (let j = 11; j >= 0; --j) {\n                        if ((rightValue & (1 << j)) != 0) {\n                            binary.set(accPos);\n                        }\n                        accPos++;\n                    }\n                }\n            }\n            return binary;\n        }\n    }\n\n    class BlockParsedResult {\n        constructor(finished, decodedInformation) {\n            if (decodedInformation) {\n                this.decodedInformation = null;\n            }\n            else {\n                this.finished = finished;\n                this.decodedInformation = decodedInformation;\n            }\n        }\n        getDecodedInformation() {\n            return this.decodedInformation;\n        }\n        isFinished() {\n            return this.finished;\n        }\n    }\n\n    class DecodedObject {\n        constructor(newPosition) {\n            this.newPosition = newPosition;\n        }\n        getNewPosition() {\n            return this.newPosition;\n        }\n    }\n\n    class DecodedChar extends DecodedObject {\n        constructor(newPosition, value) {\n            super(newPosition);\n            this.value = value;\n        }\n        getValue() {\n            return this.value;\n        }\n        isFNC1() {\n            return this.value === DecodedChar.FNC1;\n        }\n    }\n    DecodedChar.FNC1 = '$';\n\n    class DecodedInformation extends DecodedObject {\n        constructor(newPosition, newString, remainingValue) {\n            super(newPosition);\n            if (remainingValue) {\n                this.remaining = true;\n                this.remainingValue = this.remainingValue;\n            }\n            else {\n                this.remaining = false;\n                this.remainingValue = 0;\n            }\n            this.newString = newString;\n        }\n        getNewString() {\n            return this.newString;\n        }\n        isRemaining() {\n            return this.remaining;\n        }\n        getRemainingValue() {\n            return this.remainingValue;\n        }\n    }\n\n    class DecodedNumeric extends DecodedObject {\n        constructor(newPosition, firstDigit, secondDigit) {\n            super(newPosition);\n            if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {\n                throw new FormatException();\n            }\n            this.firstDigit = firstDigit;\n            this.secondDigit = secondDigit;\n        }\n        getFirstDigit() {\n            return this.firstDigit;\n        }\n        getSecondDigit() {\n            return this.secondDigit;\n        }\n        getValue() {\n            return this.firstDigit * 10 + this.secondDigit;\n        }\n        isFirstDigitFNC1() {\n            return this.firstDigit === DecodedNumeric.FNC1;\n        }\n        isSecondDigitFNC1() {\n            return this.secondDigit === DecodedNumeric.FNC1;\n        }\n        isAnyFNC1() {\n            return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;\n        }\n    }\n    DecodedNumeric.FNC1 = 10;\n\n    class FieldParser {\n        constructor() {\n        }\n        static parseFieldsInGeneralPurpose(rawInformation) {\n            if (!rawInformation) {\n                return null;\n            }\n            // Processing 2-digit AIs\n            if (rawInformation.length < 2) {\n                throw new NotFoundException();\n            }\n            let firstTwoDigits = rawInformation.substring(0, 2);\n            for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstTwoDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(2, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(2, dataLength[1], rawInformation);\n                }\n            }\n            if (rawInformation.length < 3) {\n                throw new NotFoundException();\n            }\n            let firstThreeDigits = rawInformation.substring(0, 3);\n            for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(3, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(3, dataLength[1], rawInformation);\n                }\n            }\n            for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstThreeDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n            if (rawInformation.length < 4) {\n                throw new NotFoundException();\n            }\n            let firstFourDigits = rawInformation.substring(0, 4);\n            for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {\n                if (dataLength[0] === firstFourDigits) {\n                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {\n                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);\n                    }\n                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);\n                }\n            }\n            throw new NotFoundException();\n        }\n        static processFixedAI(aiSize, fieldSize, rawInformation) {\n            if (rawInformation.length < aiSize) {\n                throw new NotFoundException();\n            }\n            let ai = rawInformation.substring(0, aiSize);\n            if (rawInformation.length < aiSize + fieldSize) {\n                throw new NotFoundException();\n            }\n            let field = rawInformation.substring(aiSize, aiSize + fieldSize);\n            let remaining = rawInformation.substring(aiSize + fieldSize);\n            let result = '(' + ai + ')' + field;\n            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n            return parsedAI == null ? result : result + parsedAI;\n        }\n        static processVariableAI(aiSize, variableFieldSize, rawInformation) {\n            let ai = rawInformation.substring(0, aiSize);\n            let maxSize;\n            if (rawInformation.length < aiSize + variableFieldSize) {\n                maxSize = rawInformation.length;\n            }\n            else {\n                maxSize = aiSize + variableFieldSize;\n            }\n            let field = rawInformation.substring(aiSize, maxSize);\n            let remaining = rawInformation.substring(maxSize);\n            let result = '(' + ai + ')' + field;\n            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);\n            return parsedAI == null ? result : result + parsedAI;\n        }\n    }\n    FieldParser.VARIABLE_LENGTH = [];\n    FieldParser.TWO_DIGIT_DATA_LENGTH = [\n        ['00', 18],\n        ['01', 14],\n        ['02', 14],\n        ['10', FieldParser.VARIABLE_LENGTH, 20],\n        ['11', 6],\n        ['12', 6],\n        ['13', 6],\n        ['15', 6],\n        ['17', 6],\n        ['20', 2],\n        ['21', FieldParser.VARIABLE_LENGTH, 20],\n        ['22', FieldParser.VARIABLE_LENGTH, 29],\n        ['30', FieldParser.VARIABLE_LENGTH, 8],\n        ['37', FieldParser.VARIABLE_LENGTH, 8],\n        // internal company codes\n        ['90', FieldParser.VARIABLE_LENGTH, 30],\n        ['91', FieldParser.VARIABLE_LENGTH, 30],\n        ['92', FieldParser.VARIABLE_LENGTH, 30],\n        ['93', FieldParser.VARIABLE_LENGTH, 30],\n        ['94', FieldParser.VARIABLE_LENGTH, 30],\n        ['95', FieldParser.VARIABLE_LENGTH, 30],\n        ['96', FieldParser.VARIABLE_LENGTH, 30],\n        ['97', FieldParser.VARIABLE_LENGTH, 3],\n        ['98', FieldParser.VARIABLE_LENGTH, 30],\n        ['99', FieldParser.VARIABLE_LENGTH, 30],\n    ];\n    FieldParser.THREE_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['240', FieldParser.VARIABLE_LENGTH, 30],\n        ['241', FieldParser.VARIABLE_LENGTH, 30],\n        ['242', FieldParser.VARIABLE_LENGTH, 6],\n        ['250', FieldParser.VARIABLE_LENGTH, 30],\n        ['251', FieldParser.VARIABLE_LENGTH, 30],\n        ['253', FieldParser.VARIABLE_LENGTH, 17],\n        ['254', FieldParser.VARIABLE_LENGTH, 20],\n        ['400', FieldParser.VARIABLE_LENGTH, 30],\n        ['401', FieldParser.VARIABLE_LENGTH, 30],\n        ['402', 17],\n        ['403', FieldParser.VARIABLE_LENGTH, 30],\n        ['410', 13],\n        ['411', 13],\n        ['412', 13],\n        ['413', 13],\n        ['414', 13],\n        ['420', FieldParser.VARIABLE_LENGTH, 20],\n        ['421', FieldParser.VARIABLE_LENGTH, 15],\n        ['422', 3],\n        ['423', FieldParser.VARIABLE_LENGTH, 15],\n        ['424', 3],\n        ['425', 3],\n        ['426', 3],\n    ];\n    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['310', 6],\n        ['311', 6],\n        ['312', 6],\n        ['313', 6],\n        ['314', 6],\n        ['315', 6],\n        ['316', 6],\n        ['320', 6],\n        ['321', 6],\n        ['322', 6],\n        ['323', 6],\n        ['324', 6],\n        ['325', 6],\n        ['326', 6],\n        ['327', 6],\n        ['328', 6],\n        ['329', 6],\n        ['330', 6],\n        ['331', 6],\n        ['332', 6],\n        ['333', 6],\n        ['334', 6],\n        ['335', 6],\n        ['336', 6],\n        ['340', 6],\n        ['341', 6],\n        ['342', 6],\n        ['343', 6],\n        ['344', 6],\n        ['345', 6],\n        ['346', 6],\n        ['347', 6],\n        ['348', 6],\n        ['349', 6],\n        ['350', 6],\n        ['351', 6],\n        ['352', 6],\n        ['353', 6],\n        ['354', 6],\n        ['355', 6],\n        ['356', 6],\n        ['357', 6],\n        ['360', 6],\n        ['361', 6],\n        ['362', 6],\n        ['363', 6],\n        ['364', 6],\n        ['365', 6],\n        ['366', 6],\n        ['367', 6],\n        ['368', 6],\n        ['369', 6],\n        ['390', FieldParser.VARIABLE_LENGTH, 15],\n        ['391', FieldParser.VARIABLE_LENGTH, 18],\n        ['392', FieldParser.VARIABLE_LENGTH, 15],\n        ['393', FieldParser.VARIABLE_LENGTH, 18],\n        ['703', FieldParser.VARIABLE_LENGTH, 30],\n    ];\n    FieldParser.FOUR_DIGIT_DATA_LENGTH = [\n        // Same format as above\n        ['7001', 13],\n        ['7002', FieldParser.VARIABLE_LENGTH, 30],\n        ['7003', 10],\n        ['8001', 14],\n        ['8002', FieldParser.VARIABLE_LENGTH, 20],\n        ['8003', FieldParser.VARIABLE_LENGTH, 30],\n        ['8004', FieldParser.VARIABLE_LENGTH, 30],\n        ['8005', 6],\n        ['8006', 18],\n        ['8007', FieldParser.VARIABLE_LENGTH, 30],\n        ['8008', FieldParser.VARIABLE_LENGTH, 12],\n        ['8018', 18],\n        ['8020', FieldParser.VARIABLE_LENGTH, 25],\n        ['8100', 6],\n        ['8101', 10],\n        ['8102', 2],\n        ['8110', FieldParser.VARIABLE_LENGTH, 70],\n        ['8200', FieldParser.VARIABLE_LENGTH, 70],\n    ];\n\n    class GeneralAppIdDecoder {\n        constructor(information) {\n            this.buffer = new StringBuilder();\n            this.information = information;\n        }\n        decodeAllCodes(buff, initialPosition) {\n            let currentPosition = initialPosition;\n            let remaining = null;\n            do {\n                let info = this.decodeGeneralPurposeField(currentPosition, remaining);\n                let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());\n                if (parsedFields != null) {\n                    buff.append(parsedFields);\n                }\n                if (info.isRemaining()) {\n                    remaining = '' + info.getRemainingValue();\n                }\n                else {\n                    remaining = null;\n                }\n                if (currentPosition === info.getNewPosition()) { // No step forward!\n                    break;\n                }\n                currentPosition = info.getNewPosition();\n            } while (true);\n            return buff.toString();\n        }\n        isStillNumeric(pos) {\n            // It's numeric if it still has 7 positions\n            // and one of the first 4 bits is \"1\".\n            if (pos + 7 > this.information.getSize()) {\n                return pos + 4 <= this.information.getSize();\n            }\n            for (let i = pos; i < pos + 3; ++i) {\n                if (this.information.get(i)) {\n                    return true;\n                }\n            }\n            return this.information.get(pos + 3);\n        }\n        decodeNumeric(pos) {\n            if (pos + 7 > this.information.getSize()) {\n                let numeric = this.extractNumericValueFromBitArray(pos, 4);\n                if (numeric === 0) {\n                    return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);\n                }\n                return new DecodedNumeric(this.information.getSize(), numeric - 1, DecodedNumeric.FNC1);\n            }\n            let numeric = this.extractNumericValueFromBitArray(pos, 7);\n            let digit1 = (numeric - 8) / 11;\n            let digit2 = (numeric - 8) % 11;\n            return new DecodedNumeric(pos + 7, digit1, digit2);\n        }\n        extractNumericValueFromBitArray(pos, bits) {\n            return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);\n        }\n        static extractNumericValueFromBitArray(information, pos, bits) {\n            let value = 0;\n            for (let i = 0; i < bits; ++i) {\n                if (information.get(pos + i)) {\n                    value |= 1 << (bits - i - 1);\n                }\n            }\n            return value;\n        }\n        decodeGeneralPurposeField(pos, remaining) {\n            // this.buffer.setLength(0);\n            this.buffer.setLengthToZero();\n            if (remaining != null) {\n                this.buffer.append(remaining);\n            }\n            this.current.setPosition(pos);\n            let lastDecoded = this.parseBlocks();\n            if (lastDecoded != null && lastDecoded.isRemaining()) {\n                return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());\n            }\n            return new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n        }\n        parseBlocks() {\n            let isFinished;\n            let result;\n            do {\n                let initialPosition = this.current.getPosition();\n                if (this.current.isAlpha()) {\n                    result = this.parseAlphaBlock();\n                    isFinished = result.isFinished();\n                }\n                else if (this.current.isIsoIec646()) {\n                    result = this.parseIsoIec646Block();\n                    isFinished = result.isFinished();\n                }\n                else { // it must be numeric\n                    result = this.parseNumericBlock();\n                    isFinished = result.isFinished();\n                }\n                let positionChanged = initialPosition !== this.current.getPosition();\n                if (!positionChanged && !isFinished) {\n                    break;\n                }\n            } while (!isFinished);\n            return result.getDecodedInformation();\n        }\n        parseNumericBlock() {\n            while (this.isStillNumeric(this.current.getPosition())) {\n                let numeric = this.decodeNumeric(this.current.getPosition());\n                this.current.setPosition(numeric.getNewPosition());\n                if (numeric.isFirstDigitFNC1()) {\n                    let information;\n                    if (numeric.isSecondDigitFNC1()) {\n                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    }\n                    else {\n                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());\n                    }\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(numeric.getFirstDigit());\n                if (numeric.isSecondDigitFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(numeric.getSecondDigit());\n            }\n            if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {\n                this.current.setAlpha();\n                this.current.incrementPosition(4);\n            }\n            return new BlockParsedResult(false);\n        }\n        parseIsoIec646Block() {\n            while (this.isStillIsoIec646(this.current.getPosition())) {\n                let iso = this.decodeIsoIec646(this.current.getPosition());\n                this.current.setPosition(iso.getNewPosition());\n                if (iso.isFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information);\n                }\n                this.buffer.append(iso.getValue());\n            }\n            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n                this.current.incrementPosition(3);\n                this.current.setNumeric();\n            }\n            else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n                if (this.current.getPosition() + 5 < this.information.getSize()) {\n                    this.current.incrementPosition(5);\n                }\n                else {\n                    this.current.setPosition(this.information.getSize());\n                }\n                this.current.setAlpha();\n            }\n            return new BlockParsedResult(false);\n        }\n        parseAlphaBlock() {\n            while (this.isStillAlpha(this.current.getPosition())) {\n                let alpha = this.decodeAlphanumeric(this.current.getPosition());\n                this.current.setPosition(alpha.getNewPosition());\n                if (alpha.isFNC1()) {\n                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());\n                    return new BlockParsedResult(true, information); // end of the char block\n                }\n                this.buffer.append(alpha.getValue());\n            }\n            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {\n                this.current.incrementPosition(3);\n                this.current.setNumeric();\n            }\n            else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {\n                if (this.current.getPosition() + 5 < this.information.getSize()) {\n                    this.current.incrementPosition(5);\n                }\n                else {\n                    this.current.setPosition(this.information.getSize());\n                }\n                this.current.setIsoIec646();\n            }\n            return new BlockParsedResult(false);\n        }\n        isStillIsoIec646(pos) {\n            if (pos + 5 > this.information.getSize()) {\n                return false;\n            }\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue >= 5 && fiveBitValue < 16) {\n                return true;\n            }\n            if (pos + 7 > this.information.getSize()) {\n                return false;\n            }\n            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n            if (sevenBitValue >= 64 && sevenBitValue < 116) {\n                return true;\n            }\n            if (pos + 8 > this.information.getSize()) {\n                return false;\n            }\n            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n            return eightBitValue >= 232 && eightBitValue < 253;\n        }\n        decodeIsoIec646(pos) {\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue === 15) {\n                return new DecodedChar(pos + 5, DecodedChar.FNC1);\n            }\n            if (fiveBitValue >= 5 && fiveBitValue < 15) {\n                return new DecodedChar(pos + 5, ('0' + (fiveBitValue - 5)));\n            }\n            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);\n            if (sevenBitValue >= 64 && sevenBitValue < 90) {\n                return new DecodedChar(pos + 7, ('' + (sevenBitValue + 1)));\n            }\n            if (sevenBitValue >= 90 && sevenBitValue < 116) {\n                return new DecodedChar(pos + 7, ('' + (sevenBitValue + 7)));\n            }\n            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);\n            let c;\n            switch (eightBitValue) {\n                case 232:\n                    c = '!';\n                    break;\n                case 233:\n                    c = '\"';\n                    break;\n                case 234:\n                    c = '%';\n                    break;\n                case 235:\n                    c = '&';\n                    break;\n                case 236:\n                    c = '\\'';\n                    break;\n                case 237:\n                    c = '(';\n                    break;\n                case 238:\n                    c = ')';\n                    break;\n                case 239:\n                    c = '*';\n                    break;\n                case 240:\n                    c = '+';\n                    break;\n                case 241:\n                    c = ',';\n                    break;\n                case 242:\n                    c = '-';\n                    break;\n                case 243:\n                    c = '.';\n                    break;\n                case 244:\n                    c = '/';\n                    break;\n                case 245:\n                    c = ':';\n                    break;\n                case 246:\n                    c = ';';\n                    break;\n                case 247:\n                    c = '<';\n                    break;\n                case 248:\n                    c = '=';\n                    break;\n                case 249:\n                    c = '>';\n                    break;\n                case 250:\n                    c = '?';\n                    break;\n                case 251:\n                    c = '_';\n                    break;\n                case 252:\n                    c = ' ';\n                    break;\n                default:\n                    throw new FormatException();\n            }\n            return new DecodedChar(pos + 8, c);\n        }\n        isStillAlpha(pos) {\n            if (pos + 5 > this.information.getSize()) {\n                return false;\n            }\n            // We now check if it's a valid 5-bit value (0..9 and FNC1)\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue >= 5 && fiveBitValue < 16) {\n                return true;\n            }\n            if (pos + 6 > this.information.getSize()) {\n                return false;\n            }\n            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n            return sixBitValue >= 16 && sixBitValue < 63; // 63 not included\n        }\n        decodeAlphanumeric(pos) {\n            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);\n            if (fiveBitValue === 15) {\n                return new DecodedChar(pos + 5, DecodedChar.FNC1);\n            }\n            if (fiveBitValue >= 5 && fiveBitValue < 15) {\n                return new DecodedChar(pos + 5, ('0' + (fiveBitValue - 5)));\n            }\n            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);\n            if (sixBitValue >= 32 && sixBitValue < 58) {\n                return new DecodedChar(pos + 6, ('' + (sixBitValue + 33)));\n            }\n            let c;\n            switch (sixBitValue) {\n                case 58:\n                    c = '*';\n                    break;\n                case 59:\n                    c = ',';\n                    break;\n                case 60:\n                    c = '-';\n                    break;\n                case 61:\n                    c = '.';\n                    break;\n                case 62:\n                    c = '/';\n                    break;\n                default:\n                    throw new IllegalStateException('Decoding invalid alphanumeric value: ' + sixBitValue);\n            }\n            return new DecodedChar(pos + 6, c);\n        }\n        isAlphaTo646ToAlphaLatch(pos) {\n            if (pos + 1 > this.information.getSize()) {\n                return false;\n            }\n            for (let i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {\n                if (i === 2) {\n                    if (!this.information.get(pos + 2)) {\n                        return false;\n                    }\n                }\n                else if (this.information.get(pos + i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        isAlphaOr646ToNumericLatch(pos) {\n            // Next is alphanumeric if there are 3 positions and they are all zeros\n            if (pos + 3 > this.information.getSize()) {\n                return false;\n            }\n            for (let i = pos; i < pos + 3; ++i) {\n                if (this.information.get(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        isNumericToAlphaNumericLatch(pos) {\n            // Next is alphanumeric if there are 4 positions and they are all zeros, or\n            // if there is a subset of this just before the end of the symbol\n            if (pos + 1 > this.information.getSize()) {\n                return false;\n            }\n            for (let i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {\n                if (this.information.get(pos + i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class AbstractExpandedDecoder {\n        constructor(information) {\n            this.information = information;\n            this.generalDecoder = new GeneralAppIdDecoder(information);\n        }\n        getInformation() {\n            return this.information;\n        }\n        getGeneralDecoder() {\n            return this.generalDecoder;\n        }\n    }\n\n    class AI01decoder extends AbstractExpandedDecoder {\n        constructor(information) {\n            super(information);\n        }\n        encodeCompressedGtin(buf, currentPos) {\n            buf.append('(01)');\n            let initialPosition = buf.length();\n            buf.append('9');\n            this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);\n        }\n        encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {\n            for (let i = 0; i < 4; ++i) {\n                let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);\n                if (currentBlock / 100 === 0) {\n                    buf.append('0');\n                }\n                if (currentBlock / 10 === 0) {\n                    buf.append('0');\n                }\n                buf.append(currentBlock);\n            }\n            AI01decoder.appendCheckDigit(buf, initialBufferPosition);\n        }\n        static appendCheckDigit(buf, currentPos) {\n            let checkDigit = 0;\n            for (let i = 0; i < 13; i++) {\n                // let digit = buf.charAt(i + currentPos) - '0';\n                // To be checked\n                let digit = buf.charAt(i + currentPos).charCodeAt(0) - '0'.charCodeAt(0);\n                checkDigit += (i & 0x01) === 0 ? 3 * digit : digit;\n            }\n            checkDigit = 10 - (checkDigit % 10);\n            if (checkDigit === 10) {\n                checkDigit = 0;\n            }\n            buf.append(checkDigit);\n        }\n    }\n    AI01decoder.GTIN_SIZE = 40;\n\n    class AI01AndOtherAIs extends AI01decoder {\n        // the second one is the encodation method, and the other two are for the variable length\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            let buff = new StringBuilder();\n            buff.append('(01)');\n            let initialGtinPosition = buff.length();\n            let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);\n            buff.append(firstGtinDigit);\n            this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);\n            return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);\n        }\n    }\n    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2; // first bit encodes the linkage flag,\n\n    class AnyAIDecoder extends AbstractExpandedDecoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            let buf = new StringBuilder();\n            return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);\n        }\n    }\n    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;\n\n    class AI01weightDecoder extends AI01decoder {\n        constructor(information) {\n            super(information);\n        }\n        encodeCompressedWeight(buf, currentPos, weightSize) {\n            let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);\n            this.addWeightCode(buf, originalWeightNumeric);\n            let weightNumeric = this.checkWeight(originalWeightNumeric);\n            let currentDivisor = 100000;\n            for (let i = 0; i < 5; ++i) {\n                if (weightNumeric / currentDivisor === 0) {\n                    buf.append('0');\n                }\n                currentDivisor /= 10;\n            }\n            buf.append(weightNumeric);\n        }\n    }\n\n    class AI013x0xDecoder extends AI01weightDecoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);\n            this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);\n            return buf.toString();\n        }\n    }\n    AI013x0xDecoder.HEADER_SIZE = 4 + 1;\n    AI013x0xDecoder.WEIGHT_SIZE = 15;\n\n    class AI013103decoder extends AI013x0xDecoder {\n        constructor(information) {\n            super(information);\n        }\n        addWeightCode(buf, weight) {\n            buf.append('(3103)');\n        }\n        checkWeight(weight) {\n            return weight;\n        }\n    }\n\n    class AI01320xDecoder extends AI013x0xDecoder {\n        constructor(information) {\n            super(information);\n        }\n        addWeightCode(buf, weight) {\n            if (weight < 10000) {\n                buf.append('(3202)');\n            }\n            else {\n                buf.append('(3203)');\n            }\n        }\n        checkWeight(weight) {\n            if (weight < 10000) {\n                return weight;\n            }\n            return weight - 10000;\n        }\n    }\n\n    class AI01392xDecoder extends AI01decoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);\n            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);\n            buf.append('(392');\n            buf.append(lastAIdigit);\n            buf.append(')');\n            let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);\n            buf.append(decodedInformation.getNewString());\n            return buf.toString();\n        }\n    }\n    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01392xDecoder.LAST_DIGIT_SIZE = 2;\n\n    class AI01393xDecoder extends AI01decoder {\n        constructor(information) {\n            super(information);\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);\n            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);\n            buf.append('(393');\n            buf.append(lastAIdigit);\n            buf.append(')');\n            let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);\n            if (firstThreeDigits / 100 == 0) {\n                buf.append('0');\n            }\n            if (firstThreeDigits / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(firstThreeDigits);\n            let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);\n            buf.append(generalInformation.getNewString());\n            return buf.toString();\n        }\n    }\n    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;\n    AI01393xDecoder.LAST_DIGIT_SIZE = 2;\n    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;\n\n    class AI013x0x1xDecoder extends AI01weightDecoder {\n        constructor(information, firstAIdigits, dateCode) {\n            super(information);\n            this.dateCode = dateCode;\n            this.firstAIdigits = firstAIdigits;\n        }\n        parseInformation() {\n            if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {\n                throw new NotFoundException();\n            }\n            let buf = new StringBuilder();\n            this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);\n            this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);\n            this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);\n            return buf.toString();\n        }\n        encodeCompressedDate(buf, currentPos) {\n            let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);\n            if (numericDate == 38400) {\n                return;\n            }\n            buf.append('(');\n            buf.append(this.dateCode);\n            buf.append(')');\n            let day = numericDate % 32;\n            numericDate /= 32;\n            let month = numericDate % 12 + 1;\n            numericDate /= 12;\n            let year = numericDate;\n            if (year / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(year);\n            if (month / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(month);\n            if (day / 10 == 0) {\n                buf.append('0');\n            }\n            buf.append(day);\n        }\n        addWeightCode(buf, weight) {\n            buf.append('(');\n            buf.append(this.firstAIdigits);\n            buf.append(weight / 100000);\n            buf.append(')');\n        }\n        checkWeight(weight) {\n            return weight % 100000;\n        }\n    }\n    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;\n    AI013x0x1xDecoder.WEIGHT_SIZE = 20;\n    AI013x0x1xDecoder.DATE_SIZE = 16;\n\n    function createDecoder(information) {\n        try {\n            if (information.get(1)) {\n                return new AI01AndOtherAIs(information);\n            }\n            if (!information.get(2)) {\n                return new AnyAIDecoder(information);\n            }\n            let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);\n            switch (fourBitEncodationMethod) {\n                case 4: return new AI013103decoder(information);\n                case 5: return new AI01320xDecoder(information);\n            }\n            let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);\n            switch (fiveBitEncodationMethod) {\n                case 12: return new AI01392xDecoder(information);\n                case 13: return new AI01393xDecoder(information);\n            }\n            let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);\n            switch (sevenBitEncodationMethod) {\n                case 56: return new AI013x0x1xDecoder(information, '310', '11');\n                case 57: return new AI013x0x1xDecoder(information, '320', '11');\n                case 58: return new AI013x0x1xDecoder(information, '310', '13');\n                case 59: return new AI013x0x1xDecoder(information, '320', '13');\n                case 60: return new AI013x0x1xDecoder(information, '310', '15');\n                case 61: return new AI013x0x1xDecoder(information, '320', '15');\n                case 62: return new AI013x0x1xDecoder(information, '310', '17');\n                case 63: return new AI013x0x1xDecoder(information, '320', '17');\n            }\n        }\n        catch (e) {\n            console.log(e);\n            throw new IllegalStateException('unknown decoder: ' + information);\n        }\n    }\n\n    class ExpandedPair {\n        constructor(leftChar, rightChar, finderPatter, mayBeLast) {\n            this.leftchar = leftChar;\n            this.rightchar = rightChar;\n            this.finderpattern = finderPatter;\n            this.maybeLast = mayBeLast;\n        }\n        mayBeLast() {\n            return this.maybeLast;\n        }\n        getLeftChar() {\n            return this.leftchar;\n        }\n        getRightChar() {\n            return this.rightchar;\n        }\n        getFinderPattern() {\n            return this.finderpattern;\n        }\n        mustBeLast() {\n            return this.rightchar == null;\n        }\n        toString() {\n            return '[ ' + this.leftchar + ', ' + this.rightchar + ' : ' + (this.finderpattern == null ? 'null' : this.finderpattern.getValue()) + ' ]';\n        }\n        static equals(o1, o2) {\n            if (!(o1 instanceof ExpandedPair)) {\n                return false;\n            }\n            return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) &&\n                ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) &&\n                ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);\n        }\n        static equalsOrNull(o1, o2) {\n            return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);\n        }\n        hashCode() {\n            // return ExpandedPair.hashNotNull(leftChar) ^ hashNotNull(rightChar) ^ hashNotNull(finderPattern);\n            let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();\n            return value;\n        }\n    }\n\n    class ExpandedRow {\n        constructor(pairs, rowNumber, wasReversed) {\n            this.pairs = pairs;\n            this.rowNumber = rowNumber;\n            this.wasReversed = wasReversed;\n        }\n        getPairs() {\n            return this.pairs;\n        }\n        getRowNumber() {\n            return this.rowNumber;\n        }\n        isReversed() {\n            return this.wasReversed;\n        }\n        // check implementation\n        isEquivalent(otherPairs) {\n            return this.checkEqualitity(this, otherPairs);\n        }\n        // @Override\n        toString() {\n            return '{ ' + this.pairs + ' }';\n        }\n        /**\n         * Two rows are equal if they contain the same pairs in the same order.\n         */\n        // @Override\n        // check implementation\n        equals(o1, o2) {\n            if (!(o1 instanceof ExpandedRow)) {\n                return false;\n            }\n            return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;\n        }\n        checkEqualitity(pair1, pair2) {\n            if (!pair1 || !pair2)\n                return;\n            let result;\n            pair1.forEach((e1, i) => {\n                pair2.forEach(e2 => {\n                    if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {\n                        result = true;\n                    }\n                });\n            });\n            return result;\n        }\n    }\n\n    // import java.util.ArrayList;\n    // import java.util.Iterator;\n    // import java.util.List;\n    // import java.util.Map;\n    // import java.util.Collections;\n    class RSSExpandedReader extends AbstractRSSReader {\n        constructor(verbose) {\n            super(...arguments);\n            this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);\n            this.rows = new Array();\n            this.startEnd = [2];\n            this.verbose = (verbose === true);\n        }\n        decodeRow(rowNumber, row, hints) {\n            // Rows can start with even pattern in case in prev rows there where odd number of patters.\n            // So lets try twice\n            // this.pairs.clear();\n            this.pairs.length = 0;\n            this.startFromEven = false;\n            try {\n                return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n            }\n            catch (e) {\n                // OK\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            this.pairs.length = 0;\n            this.startFromEven = true;\n            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));\n        }\n        reset() {\n            this.pairs.length = 0;\n            this.rows.length = 0;\n        }\n        // Not private for testing\n        decodeRow2pairs(rowNumber, row) {\n            let done = false;\n            while (!done) {\n                try {\n                    this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));\n                }\n                catch (error) {\n                    if (error instanceof NotFoundException) {\n                        if (!this.pairs.length) {\n                            throw new NotFoundException();\n                        }\n                        // exit this loop when retrieveNextPair() fails and throws\n                        done = true;\n                    }\n                }\n            }\n            // TODO: verify sequence of finder patterns as in checkPairSequence()\n            if (this.checkChecksum()) {\n                return this.pairs;\n            }\n            let tryStackedDecode;\n            if (this.rows.length) {\n                tryStackedDecode = true;\n            }\n            else {\n                tryStackedDecode = false;\n            }\n            // let tryStackedDecode = !this.rows.isEmpty();\n            this.storeRow(rowNumber, false); // TODO: deal with reversed rows\n            if (tryStackedDecode) {\n                // When the image is 180-rotated, then rows are sorted in wrong direction.\n                // Try twice with both the directions.\n                let ps = this.checkRowsBoolean(false);\n                if (ps != null) {\n                    return ps;\n                }\n                ps = this.checkRowsBoolean(true);\n                if (ps != null) {\n                    return ps;\n                }\n            }\n            throw new NotFoundException();\n        }\n        // Need to Verify\n        checkRowsBoolean(reverse) {\n            // Limit number of rows we are checking\n            // We use recursive algorithm with pure complexity and don't want it to take forever\n            // Stacked barcode can have up to 11 rows, so 25 seems reasonable enough\n            if (this.rows.length > 25) {\n                this.rows.length = 0; // We will never have a chance to get result, so clear it\n                return null;\n            }\n            this.pairs.length = 0;\n            if (reverse) {\n                this.rows = this.rows.reverse();\n                // Collections.reverse(this.rows);\n            }\n            let ps = null;\n            try {\n                ps = this.checkRows(new Array(), 0);\n            }\n            catch (e) {\n                // OK\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            if (reverse) {\n                this.rows = this.rows.reverse();\n                // Collections.reverse(this.rows);\n            }\n            return ps;\n        }\n        // Try to construct a valid rows sequence\n        // Recursion is used to implement backtracking\n        checkRows(collectedRows, currentRow) {\n            for (let i = currentRow; i < this.rows.length; i++) {\n                let row = this.rows[i];\n                this.pairs.length = 0;\n                for (let collectedRow of collectedRows) {\n                    this.pairs.push(collectedRow.getPairs());\n                }\n                this.pairs.push(row.getPairs());\n                if (!RSSExpandedReader.isValidSequence(this.pairs)) {\n                    continue;\n                }\n                if (this.checkChecksum()) {\n                    return this.pairs;\n                }\n                let rs = new Array(collectedRows);\n                rs.push(row);\n                try {\n                    // Recursion: try to add more rows\n                    return this.checkRows(rs, i + 1);\n                }\n                catch (e) {\n                    // We failed, try the next candidate\n                    if (this.verbose) {\n                        console.log(e);\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        // Whether the pairs form a valid find pattern sequence,\n        // either complete or a prefix\n        static isValidSequence(pairs) {\n            for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {\n                if (pairs.length > sequence.length) {\n                    continue;\n                }\n                let stop = true;\n                for (let j = 0; j < pairs.length; j++) {\n                    if (pairs[j].getFinderPattern().getValue() != sequence[j]) {\n                        stop = false;\n                        break;\n                    }\n                }\n                if (stop) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        storeRow(rowNumber, wasReversed) {\n            // Discard if duplicate above or below; otherwise insert in order by row number.\n            let insertPos = 0;\n            let prevIsSame = false;\n            let nextIsSame = false;\n            while (insertPos < this.rows.length) {\n                let erow = this.rows[insertPos];\n                if (erow.getRowNumber() > rowNumber) {\n                    nextIsSame = erow.isEquivalent(this.pairs);\n                    break;\n                }\n                prevIsSame = erow.isEquivalent(this.pairs);\n                insertPos++;\n            }\n            if (nextIsSame || prevIsSame) {\n                return;\n            }\n            // When the row was partially decoded (e.g. 2 pairs found instead of 3),\n            // it will prevent us from detecting the barcode.\n            // Try to merge partial rows\n            // Check whether the row is part of an allready detected row\n            if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {\n                return;\n            }\n            this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));\n            this.removePartialRows(this.pairs, this.rows);\n        }\n        // Remove all the rows that contains only specified pairs\n        removePartialRows(pairs, rows) {\n            // for (Iterator<ExpandedRow> iterator = rows.iterator(); iterator.hasNext();) {\n            //   ExpandedRow r = iterator.next();\n            //   if (r.getPairs().size() == pairs.size()) {\n            //     continue;\n            //   }\n            //   boolean allFound = true;\n            //   for (ExpandedPair p : r.getPairs()) {\n            //     boolean found = false;\n            //     for (ExpandedPair pp : pairs) {\n            //       if (p.equals(pp)) {\n            //         found = true;\n            //         break;\n            //       }\n            //     }\n            //     if (!found) {\n            //       allFound = false;\n            //       break;\n            //     }\n            //   }\n            //   if (allFound) {\n            //     // 'pairs' contains all the pairs from the row 'r'\n            //     iterator.remove();\n            //   }\n            // }\n            for (let row of rows) {\n                if (row.getPairs().length === pairs.length) {\n                    continue;\n                }\n                for (let p of row.getPairs()) {\n                    for (let pp of pairs) {\n                        if (ExpandedPair.equals(p, pp)) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // Returns true when one of the rows already contains all the pairs\n        static isPartialRow(pairs, rows) {\n            for (let r of rows) {\n                let allFound = true;\n                for (let p of pairs) {\n                    let found = false;\n                    for (let pp of r.getPairs()) {\n                        if (p.equals(pp)) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        allFound = false;\n                        break;\n                    }\n                }\n                if (allFound) {\n                    // the row 'r' contain all the pairs from 'pairs'\n                    return true;\n                }\n            }\n            return false;\n        }\n        // Only used for unit testing\n        getRows() {\n            return this.rows;\n        }\n        // Not private for unit testing\n        static constructResult(pairs) {\n            let binary = BitArrayBuilder.buildBitArray(pairs);\n            let decoder = createDecoder(binary);\n            let resultingString = decoder.parseInformation();\n            let firstPoints = pairs[0].getFinderPattern().getResultPoints();\n            let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();\n            let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];\n            return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);\n        }\n        checkChecksum() {\n            let firstPair = this.pairs.get(0);\n            let checkCharacter = firstPair.getLeftChar();\n            let firstCharacter = firstPair.getRightChar();\n            if (firstCharacter == null) {\n                return false;\n            }\n            let checksum = firstCharacter.getChecksumPortion();\n            let s = 2;\n            for (let i = 1; i < this.pairs.size(); ++i) {\n                let currentPair = this.pairs.get(i);\n                checksum += currentPair.getLeftChar().getChecksumPortion();\n                s++;\n                let currentRightChar = currentPair.getRightChar();\n                if (currentRightChar != null) {\n                    checksum += currentRightChar.getChecksumPortion();\n                    s++;\n                }\n            }\n            checksum %= 211;\n            let checkCharacterValue = 211 * (s - 4) + checksum;\n            return checkCharacterValue == checkCharacter.getValue();\n        }\n        static getNextSecondBar(row, initialPos) {\n            let currentPos;\n            if (row.get(initialPos)) {\n                currentPos = row.getNextUnset(initialPos);\n                currentPos = row.getNextSet(currentPos);\n            }\n            else {\n                currentPos = row.getNextSet(initialPos);\n                currentPos = row.getNextUnset(currentPos);\n            }\n            return currentPos;\n        }\n        // not private for testing\n        retrieveNextPair(row, previousPairs, rowNumber) {\n            let isOddPattern = previousPairs.length % 2 == 0;\n            if (this.startFromEven) {\n                isOddPattern = !isOddPattern;\n            }\n            let pattern;\n            let keepFinding = true;\n            let forcedOffset = -1;\n            do {\n                this.findNextPair(row, previousPairs, forcedOffset);\n                pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);\n                if (pattern == null) {\n                    forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);\n                }\n                else {\n                    keepFinding = false;\n                }\n            } while (keepFinding);\n            // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.\n            // boolean mayBeLast = checkPairSequence(previousPairs, pattern);\n            let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);\n            if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {\n                throw new NotFoundException();\n            }\n            let rightChar;\n            try {\n                rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);\n            }\n            catch (e) {\n                rightChar = null;\n                if (this.verbose) {\n                    console.log(e);\n                }\n            }\n            return new ExpandedPair(leftChar, rightChar, pattern, true);\n        }\n        isEmptyPair(pairs) {\n            if (pairs.length === 0) {\n                return true;\n            }\n            return false;\n        }\n        findNextPair(row, previousPairs, forcedOffset) {\n            let counters = this.getDecodeFinderCounters();\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let width = row.getSize();\n            let rowOffset;\n            if (forcedOffset >= 0) {\n                rowOffset = forcedOffset;\n            }\n            else if (this.isEmptyPair(previousPairs)) {\n                rowOffset = 0;\n            }\n            else {\n                let lastPair = previousPairs[previousPairs.length - 1];\n                rowOffset = lastPair.getFinderPattern().getStartEnd()[1];\n            }\n            let searchingEvenPair = previousPairs.length % 2 != 0;\n            if (this.startFromEven) {\n                searchingEvenPair = !searchingEvenPair;\n            }\n            let isWhite = false;\n            while (rowOffset < width) {\n                isWhite = !row.get(rowOffset);\n                if (!isWhite) {\n                    break;\n                }\n                rowOffset++;\n            }\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) != isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition == 3) {\n                        if (searchingEvenPair) {\n                            RSSExpandedReader.reverseCounters(counters);\n                        }\n                        if (RSSExpandedReader.isFinderPattern(counters)) {\n                            this.startEnd[0] = patternStart;\n                            this.startEnd[1] = x;\n                            return;\n                        }\n                        if (searchingEvenPair) {\n                            RSSExpandedReader.reverseCounters(counters);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters[0] = counters[2];\n                        counters[1] = counters[3];\n                        counters[2] = 0;\n                        counters[3] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        static reverseCounters(counters) {\n            let length = counters.length;\n            for (let i = 0; i < length / 2; ++i) {\n                let tmp = counters[i];\n                counters[i] = counters[length - i - 1];\n                counters[length - i - 1] = tmp;\n            }\n        }\n        parseFoundFinderPattern(row, rowNumber, oddPattern) {\n            // Actually we found elements 2-5.\n            let firstCounter;\n            let start;\n            let end;\n            if (oddPattern) {\n                // If pattern number is odd, we need to locate element 1 *before* the current block.\n                let firstElementStart = this.startEnd[0] - 1;\n                // Locate element 1\n                while (firstElementStart >= 0 && !row.get(firstElementStart)) {\n                    firstElementStart--;\n                }\n                firstElementStart++;\n                firstCounter = this.startEnd[0] - firstElementStart;\n                start = firstElementStart;\n                end = this.startEnd[1];\n            }\n            else {\n                // If pattern number is even, the pattern is reversed, so we need to locate element 1 *after* the current block.\n                start = this.startEnd[0];\n                end = row.getNextUnset(this.startEnd[1] + 1);\n                firstCounter = end - this.startEnd[1];\n            }\n            // Make 'counters' hold 1-4\n            let counters = this.getDecodeFinderCounters();\n            System.arraycopy(counters, 0, counters, 1, counters.length - 1);\n            counters[0] = firstCounter;\n            let value;\n            try {\n                value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);\n            }\n            catch (e) {\n                return null;\n            }\n            // return new FinderPattern(value, new int[] { start, end }, start, end, rowNumber});\n            return new FinderPattern(value, [start, end], start, end, rowNumber);\n        }\n        decodeDataCharacter(row, pattern, isOddPattern, leftChar) {\n            let counters = this.getDataCharacterCounters();\n            for (let x = 0; x < counters.length; x++) {\n                counters[x] = 0;\n            }\n            if (leftChar) {\n                RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n            }\n            else {\n                RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);\n                // reverse it\n                for (let i = 0, j = counters.length - 1; i < j; i++, j--) {\n                    let temp = counters[i];\n                    counters[i] = counters[j];\n                    counters[j] = temp;\n                }\n            } // counters[] has the pixels of the module\n            let numModules = 17; // left and right data characters have all the same length\n            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;\n            // Sanity check: element width for pattern and the character should match\n            let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15.0;\n            if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {\n                throw new NotFoundException();\n            }\n            let oddCounts = this.getOddCounts();\n            let evenCounts = this.getEvenCounts();\n            let oddRoundingErrors = this.getOddRoundingErrors();\n            let evenRoundingErrors = this.getEvenRoundingErrors();\n            for (let i = 0; i < counters.length; i++) {\n                let value = 1.0 * counters[i] / elementWidth;\n                let count = value + 0.5; // Round\n                if (count < 1) {\n                    if (value < 0.3) {\n                        throw new NotFoundException();\n                    }\n                    count = 1;\n                }\n                else if (count > 8) {\n                    if (value > 8.7) {\n                        throw new NotFoundException();\n                    }\n                    count = 8;\n                }\n                let offset = i / 2;\n                if ((i & 0x01) == 0) {\n                    oddCounts[offset] = count;\n                    oddRoundingErrors[offset] = value - count;\n                }\n                else {\n                    evenCounts[offset] = count;\n                    evenRoundingErrors[offset] = value - count;\n                }\n            }\n            this.adjustOddEvenCounts(numModules);\n            let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;\n            let oddSum = 0;\n            let oddChecksumPortion = 0;\n            for (let i = oddCounts.length - 1; i >= 0; i--) {\n                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];\n                    oddChecksumPortion += oddCounts[i] * weight;\n                }\n                oddSum += oddCounts[i];\n            }\n            let evenChecksumPortion = 0;\n            // int evenSum = 0;\n            for (let i = evenCounts.length - 1; i >= 0; i--) {\n                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {\n                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];\n                    evenChecksumPortion += evenCounts[i] * weight;\n                }\n                // evenSum += evenCounts[i];\n            }\n            let checksumPortion = oddChecksumPortion + evenChecksumPortion;\n            if ((oddSum & 0x01) != 0 || oddSum > 13 || oddSum < 4) {\n                throw new NotFoundException();\n            }\n            let group = (13 - oddSum) / 2;\n            let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];\n            let evenWidest = 9 - oddWidest;\n            let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);\n            let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);\n            let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];\n            let gSum = RSSExpandedReader.GSUM[group];\n            let value = vOdd * tEven + vEven + gSum;\n            return new DataCharacter(value, checksumPortion);\n        }\n        static isNotA1left(pattern, isOddPattern, leftChar) {\n            // A1: pattern.getValue is 0 (A), and it's an oddPattern, and it is a left char\n            return !(pattern.getValue() == 0 && isOddPattern && leftChar);\n        }\n        adjustOddEvenCounts(numModules) {\n            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));\n            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));\n            let incrementOdd = false;\n            let decrementOdd = false;\n            if (oddSum > 13) {\n                decrementOdd = true;\n            }\n            else if (oddSum < 4) {\n                incrementOdd = true;\n            }\n            let incrementEven = false;\n            let decrementEven = false;\n            if (evenSum > 13) {\n                decrementEven = true;\n            }\n            else if (evenSum < 4) {\n                incrementEven = true;\n            }\n            let mismatch = oddSum + evenSum - numModules;\n            let oddParityBad = (oddSum & 0x01) == 1;\n            let evenParityBad = (evenSum & 0x01) == 0;\n            if (mismatch == 1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementEven = true;\n                }\n            }\n            else if (mismatch == -1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementEven = true;\n                }\n            }\n            else if (mismatch == 0) {\n                if (oddParityBad) {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Both bad\n                    if (oddSum < evenSum) {\n                        incrementOdd = true;\n                        decrementEven = true;\n                    }\n                    else {\n                        decrementOdd = true;\n                        incrementEven = true;\n                    }\n                }\n                else {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Nothing to do!\n                }\n            }\n            else {\n                throw new NotFoundException();\n            }\n            if (incrementOdd) {\n                if (decrementOdd) {\n                    throw new NotFoundException();\n                }\n                RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementOdd) {\n                RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (incrementEven) {\n                if (decrementEven) {\n                    throw new NotFoundException();\n                }\n                RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementEven) {\n                RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n            }\n        }\n    }\n    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];\n    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];\n    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];\n    RSSExpandedReader.FINDER_PATTERNS = [\n        Int32Array.from([1, 8, 4, 1]),\n        Int32Array.from([3, 6, 4, 1]),\n        Int32Array.from([3, 4, 6, 1]),\n        Int32Array.from([3, 2, 8, 1]),\n        Int32Array.from([2, 6, 5, 1]),\n        Int32Array.from([2, 2, 9, 1]) // F\n    ];\n    RSSExpandedReader.WEIGHTS = [\n        [1, 3, 9, 27, 81, 32, 96, 77],\n        [20, 60, 180, 118, 143, 7, 21, 63],\n        [189, 145, 13, 39, 117, 140, 209, 205],\n        [193, 157, 49, 147, 19, 57, 171, 91],\n        [62, 186, 136, 197, 169, 85, 44, 132],\n        [185, 133, 188, 142, 4, 12, 36, 108],\n        [113, 128, 173, 97, 80, 29, 87, 50],\n        [150, 28, 84, 41, 123, 158, 52, 156],\n        [46, 138, 203, 187, 139, 206, 196, 166],\n        [76, 17, 51, 153, 37, 111, 122, 155],\n        [43, 129, 176, 106, 107, 110, 119, 146],\n        [16, 48, 144, 10, 30, 90, 59, 177],\n        [109, 116, 137, 200, 178, 112, 125, 164],\n        [70, 210, 208, 202, 184, 130, 179, 115],\n        [134, 191, 151, 31, 93, 68, 204, 190],\n        [148, 22, 66, 198, 172, 94, 71, 2],\n        [6, 18, 54, 162, 64, 192, 154, 40],\n        [120, 149, 25, 75, 14, 42, 126, 167],\n        [79, 26, 78, 23, 69, 207, 199, 175],\n        [103, 98, 83, 38, 114, 131, 182, 124],\n        [161, 61, 183, 127, 170, 88, 53, 159],\n        [55, 165, 73, 8, 24, 72, 5, 15],\n        [45, 135, 194, 160, 58, 174, 100, 89]\n    ];\n    RSSExpandedReader.FINDER_PAT_A = 0;\n    RSSExpandedReader.FINDER_PAT_B = 1;\n    RSSExpandedReader.FINDER_PAT_C = 2;\n    RSSExpandedReader.FINDER_PAT_D = 3;\n    RSSExpandedReader.FINDER_PAT_E = 4;\n    RSSExpandedReader.FINDER_PAT_F = 5;\n    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],\n        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],\n    ];\n    RSSExpandedReader.MAX_PAIRS = 11;\n\n    class Pair extends DataCharacter {\n        constructor(value, checksumPortion, finderPattern) {\n            super(value, checksumPortion);\n            this.count = 0;\n            this.finderPattern = finderPattern;\n        }\n        getFinderPattern() {\n            return this.finderPattern;\n        }\n        getCount() {\n            return this.count;\n        }\n        incrementCount() {\n            this.count++;\n        }\n    }\n\n    class RSS14Reader extends AbstractRSSReader {\n        constructor() {\n            super(...arguments);\n            this.possibleLeftPairs = [];\n            this.possibleRightPairs = [];\n        }\n        decodeRow(rowNumber, row, hints) {\n            const leftPair = this.decodePair(row, false, rowNumber, hints);\n            RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);\n            row.reverse();\n            let rightPair = this.decodePair(row, true, rowNumber, hints);\n            RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);\n            row.reverse();\n            for (let left of this.possibleLeftPairs) {\n                if (left.getCount() > 1) {\n                    for (let right of this.possibleRightPairs) {\n                        if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {\n                            return RSS14Reader.constructResult(left, right);\n                        }\n                    }\n                }\n            }\n            throw new NotFoundException();\n        }\n        static addOrTally(possiblePairs, pair) {\n            if (pair == null) {\n                return;\n            }\n            let found = false;\n            for (let other of possiblePairs) {\n                if (other.getValue() === pair.getValue()) {\n                    other.incrementCount();\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                possiblePairs.push(pair);\n            }\n        }\n        reset() {\n            this.possibleLeftPairs.length = 0;\n            this.possibleRightPairs.length = 0;\n        }\n        static constructResult(leftPair, rightPair) {\n            let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();\n            let text = new String(symbolValue).toString();\n            let buffer = new StringBuilder();\n            for (let i = 13 - text.length; i > 0; i--) {\n                buffer.append('0');\n            }\n            buffer.append(text);\n            let checkDigit = 0;\n            for (let i = 0; i < 13; i++) {\n                let digit = buffer.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);\n                checkDigit += ((i & 0x01) === 0) ? 3 * digit : digit;\n            }\n            checkDigit = 10 - (checkDigit % 10);\n            if (checkDigit === 10) {\n                checkDigit = 0;\n            }\n            buffer.append(checkDigit.toString());\n            let leftPoints = leftPair.getFinderPattern().getResultPoints();\n            let rightPoints = rightPair.getFinderPattern().getResultPoints();\n            return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, new Date().getTime());\n        }\n        static checkChecksum(leftPair, rightPair) {\n            let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;\n            let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();\n            if (targetCheckValue > 72) {\n                targetCheckValue--;\n            }\n            if (targetCheckValue > 8) {\n                targetCheckValue--;\n            }\n            return checkValue === targetCheckValue;\n        }\n        decodePair(row, right, rowNumber, hints) {\n            try {\n                let startEnd = this.findFinderPattern(row, right);\n                let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);\n                let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n                if (resultPointCallback != null) {\n                    let center = (startEnd[0] + startEnd[1]) / 2.0;\n                    if (right) {\n                        // row is actually reversed\n                        center = row.getSize() - 1 - center;\n                    }\n                    resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));\n                }\n                let outside = this.decodeDataCharacter(row, pattern, true);\n                let inside = this.decodeDataCharacter(row, pattern, false);\n                return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);\n            }\n            catch (err) {\n                return null;\n            }\n        }\n        decodeDataCharacter(row, pattern, outsideChar) {\n            let counters = this.getDataCharacterCounters();\n            for (let x = 0; x < counters.length; x++) {\n                counters[x] = 0;\n            }\n            if (outsideChar) {\n                OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);\n            }\n            else {\n                OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);\n                // reverse it\n                for (let i = 0, j = counters.length - 1; i < j; i++, j--) {\n                    let temp = counters[i];\n                    counters[i] = counters[j];\n                    counters[j] = temp;\n                }\n            }\n            let numModules = outsideChar ? 16 : 15;\n            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;\n            let oddCounts = this.getOddCounts();\n            let evenCounts = this.getEvenCounts();\n            let oddRoundingErrors = this.getOddRoundingErrors();\n            let evenRoundingErrors = this.getEvenRoundingErrors();\n            for (let i = 0; i < counters.length; i++) {\n                let value = counters[i] / elementWidth;\n                let count = Math.floor(value + 0.5);\n                if (count < 1) {\n                    count = 1;\n                }\n                else if (count > 8) {\n                    count = 8;\n                }\n                let offset = Math.floor(i / 2);\n                if ((i & 0x01) === 0) {\n                    oddCounts[offset] = count;\n                    oddRoundingErrors[offset] = value - count;\n                }\n                else {\n                    evenCounts[offset] = count;\n                    evenRoundingErrors[offset] = value - count;\n                }\n            }\n            this.adjustOddEvenCounts(outsideChar, numModules);\n            let oddSum = 0;\n            let oddChecksumPortion = 0;\n            for (let i = oddCounts.length - 1; i >= 0; i--) {\n                oddChecksumPortion *= 9;\n                oddChecksumPortion += oddCounts[i];\n                oddSum += oddCounts[i];\n            }\n            let evenChecksumPortion = 0;\n            let evenSum = 0;\n            for (let i = evenCounts.length - 1; i >= 0; i--) {\n                evenChecksumPortion *= 9;\n                evenChecksumPortion += evenCounts[i];\n                evenSum += evenCounts[i];\n            }\n            let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;\n            if (outsideChar) {\n                if ((oddSum & 0x01) !== 0 || oddSum > 12 || oddSum < 4) {\n                    throw new NotFoundException();\n                }\n                let group = (12 - oddSum) / 2;\n                let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];\n                let evenWidest = 9 - oddWidest;\n                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);\n                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);\n                let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];\n                let gSum = RSS14Reader.OUTSIDE_GSUM[group];\n                return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);\n            }\n            else {\n                if ((evenSum & 0x01) !== 0 || evenSum > 10 || evenSum < 4) {\n                    throw new NotFoundException();\n                }\n                let group = (10 - evenSum) / 2;\n                let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];\n                let evenWidest = 9 - oddWidest;\n                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);\n                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);\n                let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];\n                let gSum = RSS14Reader.INSIDE_GSUM[group];\n                return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);\n            }\n        }\n        findFinderPattern(row, rightFinderPattern) {\n            let counters = this.getDecodeFinderCounters();\n            counters[0] = 0;\n            counters[1] = 0;\n            counters[2] = 0;\n            counters[3] = 0;\n            let width = row.getSize();\n            let isWhite = false;\n            let rowOffset = 0;\n            while (rowOffset < width) {\n                isWhite = !row.get(rowOffset);\n                if (rightFinderPattern === isWhite) {\n                    // Will encounter white first when searching for right finder pattern\n                    break;\n                }\n                rowOffset++;\n            }\n            let counterPosition = 0;\n            let patternStart = rowOffset;\n            for (let x = rowOffset; x < width; x++) {\n                if (row.get(x) !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === 3) {\n                        if (AbstractRSSReader.isFinderPattern(counters)) {\n                            return [patternStart, x];\n                        }\n                        patternStart += counters[0] + counters[1];\n                        counters[0] = counters[2];\n                        counters[1] = counters[3];\n                        counters[2] = 0;\n                        counters[3] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            throw new NotFoundException();\n        }\n        parseFoundFinderPattern(row, rowNumber, right, startEnd) {\n            // Actually we found elements 2-5\n            let firstIsBlack = row.get(startEnd[0]);\n            let firstElementStart = startEnd[0] - 1;\n            // Locate element 1\n            while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {\n                firstElementStart--;\n            }\n            firstElementStart++;\n            const firstCounter = startEnd[0] - firstElementStart;\n            // Make 'counters' hold 1-4\n            const counters = this.getDecodeFinderCounters();\n            const copy = new Int32Array(counters.length);\n            System.arraycopy(counters, 0, copy, 1, counters.length - 1);\n            copy[0] = firstCounter;\n            const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);\n            let start = firstElementStart;\n            let end = startEnd[1];\n            if (right) {\n                // row is actually reversed\n                start = row.getSize() - 1 - start;\n                end = row.getSize() - 1 - end;\n            }\n            return new FinderPattern(value, [firstElementStart, startEnd[1]], start, end, rowNumber);\n        }\n        adjustOddEvenCounts(outsideChar, numModules) {\n            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));\n            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));\n            let incrementOdd = false;\n            let decrementOdd = false;\n            let incrementEven = false;\n            let decrementEven = false;\n            if (outsideChar) {\n                if (oddSum > 12) {\n                    decrementOdd = true;\n                }\n                else if (oddSum < 4) {\n                    incrementOdd = true;\n                }\n                if (evenSum > 12) {\n                    decrementEven = true;\n                }\n                else if (evenSum < 4) {\n                    incrementEven = true;\n                }\n            }\n            else {\n                if (oddSum > 11) {\n                    decrementOdd = true;\n                }\n                else if (oddSum < 5) {\n                    incrementOdd = true;\n                }\n                if (evenSum > 10) {\n                    decrementEven = true;\n                }\n                else if (evenSum < 4) {\n                    incrementEven = true;\n                }\n            }\n            let mismatch = oddSum + evenSum - numModules;\n            let oddParityBad = (oddSum & 0x01) === (outsideChar ? 1 : 0);\n            let evenParityBad = (evenSum & 0x01) === 1;\n            if (mismatch === 1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    decrementEven = true;\n                }\n            }\n            else if (mismatch === -1) {\n                if (oddParityBad) {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementOdd = true;\n                }\n                else {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    incrementEven = true;\n                }\n            }\n            else if (mismatch === 0) {\n                if (oddParityBad) {\n                    if (!evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Both bad\n                    if (oddSum < evenSum) {\n                        incrementOdd = true;\n                        decrementEven = true;\n                    }\n                    else {\n                        decrementOdd = true;\n                        incrementEven = true;\n                    }\n                }\n                else {\n                    if (evenParityBad) {\n                        throw new NotFoundException();\n                    }\n                    // Nothing to do!\n                }\n            }\n            else {\n                throw new NotFoundException();\n            }\n            if (incrementOdd) {\n                if (decrementOdd) {\n                    throw new NotFoundException();\n                }\n                AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementOdd) {\n                AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());\n            }\n            if (incrementEven) {\n                if (decrementEven) {\n                    throw new NotFoundException();\n                }\n                AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());\n            }\n            if (decrementEven) {\n                AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());\n            }\n        }\n    }\n    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];\n    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];\n    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];\n    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];\n    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];\n    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];\n    RSS14Reader.FINDER_PATTERNS = [\n        Int32Array.from([3, 8, 2, 1]),\n        Int32Array.from([3, 5, 5, 1]),\n        Int32Array.from([3, 3, 7, 1]),\n        Int32Array.from([3, 1, 9, 1]),\n        Int32Array.from([2, 7, 4, 1]),\n        Int32Array.from([2, 5, 6, 1]),\n        Int32Array.from([2, 3, 8, 1]),\n        Int32Array.from([1, 5, 7, 1]),\n        Int32Array.from([1, 3, 9, 1]),\n    ];\n\n    /**\n     * @author Daniel Switkin <dswitkin@google.com>\n     * @author Sean Owen\n     */\n    class MultiFormatOneDReader extends OneDReader {\n        constructor(hints, verbose) {\n            super();\n            this.readers = [];\n            this.verbose = (verbose === true);\n            const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== undefined;\n            if (possibleFormats) {\n                if (possibleFormats.includes(BarcodeFormat$1.EAN_13) ||\n                    possibleFormats.includes(BarcodeFormat$1.UPC_A) ||\n                    possibleFormats.includes(BarcodeFormat$1.EAN_8) ||\n                    possibleFormats.includes(BarcodeFormat$1.UPC_E)) {\n                    this.readers.push(new MultiFormatUPCEANReader(hints));\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {\n                    this.readers.push(new Code39Reader(useCode39CheckDigit));\n                }\n                // if (possibleFormats.includes(BarcodeFormat.CODE_93)) {\n                //    this.readers.push(new Code93Reader());\n                // }\n                if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {\n                    this.readers.push(new Code128Reader());\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.ITF)) {\n                    this.readers.push(new ITFReader());\n                }\n                // if (possibleFormats.includes(BarcodeFormat.CODABAR)) {\n                //    this.readers.push(new CodaBarReader());\n                // }\n                if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {\n                    this.readers.push(new RSS14Reader());\n                }\n                if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {\n                    this.readers.push(new RSSExpandedReader(this.verbose));\n                }\n            } else {\n                // Case when no hints were provided -> add all.\n                this.readers.push(new MultiFormatUPCEANReader(hints));\n                this.readers.push(new Code39Reader());\n                // this.readers.push(new CodaBarReader());\n                // this.readers.push(new Code93Reader());\n                this.readers.push(new MultiFormatUPCEANReader(hints));\n                this.readers.push(new Code128Reader());\n                this.readers.push(new ITFReader());\n                this.readers.push(new RSS14Reader());\n                this.readers.push(new RSSExpandedReader(this.verbose));\n            }\n        }\n        // @Override\n        decodeRow(rowNumber, row, hints) {\n            for (let i = 0; i < this.readers.length; i++) {\n                try {\n                    return this.readers[i].decodeRow(rowNumber, row, hints);\n                }\n                catch (re) {\n                    // continue\n                }\n            }\n            throw new NotFoundException();\n        }\n        // @Override\n        reset() {\n            this.readers.forEach(reader => reader.reset());\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * Barcode reader reader to use from browser.\n     */\n    class BrowserBarcodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserBarcodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         * @param {Map<DecodeHintType, any>} hints\n         */\n        constructor(timeBetweenScansMillis = 500, hints) {\n            super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n     * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n     * each set of blocks. It also holds the number of error-correction codewords per block since it\n     * will be the same across all blocks within one version.</p>\n     */\n    class ECBlocks {\n        constructor(ecCodewords, ecBlocks1, ecBlocks2) {\n            this.ecCodewords = ecCodewords;\n            this.ecBlocks = [ecBlocks1];\n            ecBlocks2 && this.ecBlocks.push(ecBlocks2);\n        }\n        getECCodewords() {\n            return this.ecCodewords;\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n    }\n    /**\n     * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n     * This includes the number of data codewords, and the number of times a block with these\n     * parameters is used consecutively in the Data Matrix code version's format.</p>\n     */\n    class ECB {\n        constructor(count, dataCodewords) {\n            this.count = count;\n            this.dataCodewords = dataCodewords;\n        }\n        getCount() {\n            return this.count;\n        }\n        getDataCodewords() {\n            return this.dataCodewords;\n        }\n    }\n    /**\n     * The Version object encapsulates attributes about a particular\n     * size Data Matrix Code.\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class Version {\n        constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {\n            this.versionNumber = versionNumber;\n            this.symbolSizeRows = symbolSizeRows;\n            this.symbolSizeColumns = symbolSizeColumns;\n            this.dataRegionSizeRows = dataRegionSizeRows;\n            this.dataRegionSizeColumns = dataRegionSizeColumns;\n            this.ecBlocks = ecBlocks;\n            // Calculate the total number of codewords\n            let total = 0;\n            const ecCodewords = ecBlocks.getECCodewords();\n            const ecbArray = ecBlocks.getECBlocks();\n            for (let ecBlock of ecbArray) {\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n            this.totalCodewords = total;\n        }\n        getVersionNumber() {\n            return this.versionNumber;\n        }\n        getSymbolSizeRows() {\n            return this.symbolSizeRows;\n        }\n        getSymbolSizeColumns() {\n            return this.symbolSizeColumns;\n        }\n        getDataRegionSizeRows() {\n            return this.dataRegionSizeRows;\n        }\n        getDataRegionSizeColumns() {\n            return this.dataRegionSizeColumns;\n        }\n        getTotalCodewords() {\n            return this.totalCodewords;\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n        /**\n         * <p>Deduces version information from Data Matrix dimensions.</p>\n         *\n         * @param numRows Number of rows in modules\n         * @param numColumns Number of columns in modules\n         * @return Version for a Data Matrix Code of those dimensions\n         * @throws FormatException if dimensions do correspond to a valid Data Matrix size\n         */\n        static getVersionForDimensions(numRows, numColumns) {\n            if ((numRows & 0x01) !== 0 || (numColumns & 0x01) !== 0) {\n                throw new FormatException();\n            }\n            for (let version of Version.VERSIONS) {\n                if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {\n                    return version;\n                }\n            }\n            throw new FormatException();\n        }\n        //  @Override\n        toString() {\n            return '' + this.versionNumber;\n        }\n        /**\n         * See ISO 16022:2006 5.5.1 Table 7\n         */\n        static buildVersions() {\n            return [\n                new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),\n                new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),\n                new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),\n                new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),\n                new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),\n                new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),\n                new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),\n                new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),\n                new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),\n                new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),\n                new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),\n                new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),\n                new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),\n                new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),\n                new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),\n                new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),\n                new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),\n                new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),\n                new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),\n                new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),\n                new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),\n                new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),\n                new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),\n                new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),\n                new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),\n                new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),\n                new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),\n                new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),\n                new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),\n                new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))\n            ];\n        }\n    }\n    Version.VERSIONS = Version.buildVersions();\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class BitMatrixParser {\n        /**\n         * @param bitMatrix {@link BitMatrix} to parse\n         * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2\n         */\n        constructor(bitMatrix) {\n            const dimension = bitMatrix.getHeight();\n            if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {\n                throw new FormatException();\n            }\n            this.version = BitMatrixParser.readVersion(bitMatrix);\n            this.mappingBitMatrix = this.extractDataRegion(bitMatrix);\n            this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());\n        }\n        getVersion() {\n            return this.version;\n        }\n        /**\n         * <p>Creates the version object based on the dimension of the original bit matrix from\n         * the datamatrix code.</p>\n         *\n         * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>\n         *\n         * @param bitMatrix Original {@link BitMatrix} including alignment patterns\n         * @return {@link Version} encapsulating the Data Matrix Code's \"version\"\n         * @throws FormatException if the dimensions of the mapping matrix are not valid\n         * Data Matrix dimensions.\n         */\n        static readVersion(bitMatrix) {\n            const numRows = bitMatrix.getHeight();\n            const numColumns = bitMatrix.getWidth();\n            return Version.getVersionForDimensions(numRows, numColumns);\n        }\n        /**\n         * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)\n         * in the correct order in order to reconstitute the codewords bytes contained within the\n         * Data Matrix Code.</p>\n         *\n         * @return bytes encoded within the Data Matrix Code\n         * @throws FormatException if the exact number of bytes expected is not read\n         */\n        readCodewords() {\n            const result = new Int8Array(this.version.getTotalCodewords());\n            let resultOffset = 0;\n            let row = 4;\n            let column = 0;\n            const numRows = this.mappingBitMatrix.getHeight();\n            const numColumns = this.mappingBitMatrix.getWidth();\n            let corner1Read = false;\n            let corner2Read = false;\n            let corner3Read = false;\n            let corner4Read = false;\n            // Read all of the codewords\n            do {\n                // Check the four corner cases\n                if ((row === numRows) && (column === 0) && !corner1Read) {\n                    result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner1Read = true;\n                }\n                else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {\n                    result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner2Read = true;\n                }\n                else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {\n                    result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner3Read = true;\n                }\n                else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {\n                    result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;\n                    row -= 2;\n                    column += 2;\n                    corner4Read = true;\n                }\n                else {\n                    // Sweep upward diagonally to the right\n                    do {\n                        if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {\n                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                        }\n                        row -= 2;\n                        column += 2;\n                    } while ((row >= 0) && (column < numColumns));\n                    row += 1;\n                    column += 3;\n                    // Sweep downward diagonally to the left\n                    do {\n                        if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {\n                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;\n                        }\n                        row += 2;\n                        column -= 2;\n                    } while ((row < numRows) && (column >= 0));\n                    row += 3;\n                    column += 1;\n                }\n            } while ((row < numRows) || (column < numColumns));\n            if (resultOffset !== this.version.getTotalCodewords()) {\n                throw new FormatException();\n            }\n            return result;\n        }\n        /**\n         * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>\n         *\n         * @param row Row to read in the mapping matrix\n         * @param column Column to read in the mapping matrix\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return value of the given bit in the mapping matrix\n         */\n        readModule(row, column, numRows, numColumns) {\n            // Adjust the row and column indices based on boundary wrapping\n            if (row < 0) {\n                row += numRows;\n                column += 4 - ((numRows + 4) & 0x07);\n            }\n            if (column < 0) {\n                column += numColumns;\n                row += 4 - ((numColumns + 4) & 0x07);\n            }\n            this.readMappingMatrix.set(column, row);\n            return this.mappingBitMatrix.get(column, row);\n        }\n        /**\n         * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>\n         *\n         * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>\n         *\n         * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n         * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the utah shape\n         */\n        readUtah(row, column, numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(row - 2, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 2, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row - 1, column, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(row, column, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 1.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.3</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 1\n         */\n        readCorner1(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 2.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.4</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 2\n         */\n        readCorner2(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 4, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 3.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.5</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 3\n         */\n        readCorner3(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 3, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Reads the 8 bits of the special corner condition 4.</p>\n         *\n         * <p>See ISO 16022:2006, Figure F.6</p>\n         *\n         * @param numRows Number of rows in the mapping matrix\n         * @param numColumns Number of columns in the mapping matrix\n         * @return byte from the Corner condition 4\n         */\n        readCorner4(numRows, numColumns) {\n            let currentByte = 0;\n            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            currentByte <<= 1;\n            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {\n                currentByte |= 1;\n            }\n            return currentByte;\n        }\n        /**\n         * <p>Extracts the data region from a {@link BitMatrix} that contains\n         * alignment patterns.</p>\n         *\n         * @param bitMatrix Original {@link BitMatrix} with alignment patterns\n         * @return BitMatrix that has the alignment patterns removed\n         */\n        extractDataRegion(bitMatrix) {\n            const symbolSizeRows = this.version.getSymbolSizeRows();\n            const symbolSizeColumns = this.version.getSymbolSizeColumns();\n            if (bitMatrix.getHeight() !== symbolSizeRows) {\n                throw new IllegalArgumentException('Dimension of bitMatrix must match the version size');\n            }\n            const dataRegionSizeRows = this.version.getDataRegionSizeRows();\n            const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();\n            const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;\n            const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;\n            const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;\n            const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;\n            const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);\n            for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {\n                const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;\n                for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {\n                    const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;\n                    for (let i = 0; i < dataRegionSizeRows; ++i) {\n                        const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;\n                        const writeRowOffset = dataRegionRowOffset + i;\n                        for (let j = 0; j < dataRegionSizeColumns; ++j) {\n                            const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;\n                            if (bitMatrix.get(readColumnOffset, readRowOffset)) {\n                                const writeColumnOffset = dataRegionColumnOffset + j;\n                                bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);\n                            }\n                        }\n                    }\n                }\n            }\n            return bitMatrixWithoutAlignment;\n        }\n    }\n\n    /**\n     * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into\n     * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n     * is represented by an instance of this class.</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class DataBlock {\n        constructor(numDataCodewords, codewords) {\n            this.numDataCodewords = numDataCodewords;\n            this.codewords = codewords;\n        }\n        /**\n         * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.\n         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n         * method will separate the data into original blocks.</p>\n         *\n         * @param rawCodewords bytes as read directly from the Data Matrix Code\n         * @param version version of the Data Matrix Code\n         * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n         *         Data Matrix Code\n         */\n        static getDataBlocks(rawCodewords, version) {\n            // Figure out the number and size of data blocks used by this version\n            const ecBlocks = version.getECBlocks();\n            // First count the total number of data blocks\n            let totalBlocks = 0;\n            const ecBlockArray = ecBlocks.getECBlocks();\n            for (let ecBlock of ecBlockArray) {\n                totalBlocks += ecBlock.getCount();\n            }\n            // Now establish DataBlocks of the appropriate size and number of data codewords\n            const result = new Array(totalBlocks);\n            let numResultBlocks = 0;\n            for (let ecBlock of ecBlockArray) {\n                for (let i = 0; i < ecBlock.getCount(); i++) {\n                    const numDataCodewords = ecBlock.getDataCodewords();\n                    const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n            // All blocks have the same amount of data, except that the last n\n            // (where n may be 0) have 1 less byte. Figure out where these start.\n            // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144\n            const longerBlocksTotalCodewords = result[0].codewords.length;\n            // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;\n            const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();\n            const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;\n            // The last elements of result may be 1 element shorter for 144 matrix\n            // first fill out as many elements as all of them have minus 1\n            let rawCodewordsOffset = 0;\n            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            // Fill out the last data block in the longer ones\n            const specialVersion = version.getVersionNumber() === 24;\n            const numLongerBlocks = specialVersion ? 8 : numResultBlocks;\n            for (let j = 0; j < numLongerBlocks; j++) {\n                result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];\n            }\n            // Now add in error correction blocks\n            const max = result[0].codewords.length;\n            for (let i = longerBlocksNumDataCodewords; i < max; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    const jOffset = specialVersion ? (j + 8) % numResultBlocks : j;\n                    const iOffset = specialVersion && jOffset > 7 ? i - 1 : i;\n                    result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            if (rawCodewordsOffset !== rawCodewords.length) {\n                throw new IllegalArgumentException();\n            }\n            return result;\n        }\n        getNumDataCodewords() {\n            return this.numDataCodewords;\n        }\n        getCodewords() {\n            return this.codewords;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the\n     * number of bits read is not often a multiple of 8.</p>\n     *\n     * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array\n     * it passed in, in which case all bets are off.</p>\n     *\n     * @author Sean Owen\n     */\n    class BitSource {\n        /**\n         * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.\n         * Bits are read within a byte from most-significant to least-significant bit.\n         */\n        constructor(bytes) {\n            this.bytes = bytes;\n            this.byteOffset = 0;\n            this.bitOffset = 0;\n        }\n        /**\n         * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.\n         */\n        getBitOffset() {\n            return this.bitOffset;\n        }\n        /**\n         * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.\n         */\n        getByteOffset() {\n            return this.byteOffset;\n        }\n        /**\n         * @param numBits number of bits to read\n         * @return int representing the bits read. The bits will appear as the least-significant\n         *         bits of the int\n         * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available\n         */\n        readBits(numBits /*int*/) {\n            if (numBits < 1 || numBits > 32 || numBits > this.available()) {\n                throw new IllegalArgumentException('' + numBits);\n            }\n            let result = 0;\n            let bitOffset = this.bitOffset;\n            let byteOffset = this.byteOffset;\n            const bytes = this.bytes;\n            // First, read remainder from current byte\n            if (bitOffset > 0) {\n                const bitsLeft = 8 - bitOffset;\n                const toRead = numBits < bitsLeft ? numBits : bitsLeft;\n                const bitsToNotRead = bitsLeft - toRead;\n                const mask = (0xFF >> (8 - toRead)) << bitsToNotRead;\n                result = (bytes[byteOffset] & mask) >> bitsToNotRead;\n                numBits -= toRead;\n                bitOffset += toRead;\n                if (bitOffset === 8) {\n                    bitOffset = 0;\n                    byteOffset++;\n                }\n            }\n            // Next read whole bytes\n            if (numBits > 0) {\n                while (numBits >= 8) {\n                    result = (result << 8) | (bytes[byteOffset] & 0xFF);\n                    byteOffset++;\n                    numBits -= 8;\n                }\n                // Finally read a partial byte\n                if (numBits > 0) {\n                    const bitsToNotRead = 8 - numBits;\n                    const mask = (0xFF >> bitsToNotRead) << bitsToNotRead;\n                    result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);\n                    bitOffset += numBits;\n                }\n            }\n            this.bitOffset = bitOffset;\n            this.byteOffset = byteOffset;\n            return result;\n        }\n        /**\n         * @return number of bits that can be read successfully\n         */\n        available() {\n            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;\n        }\n    }\n\n    var Mode;\n    (function (Mode) {\n        Mode[Mode[\"PAD_ENCODE\"] = 0] = \"PAD_ENCODE\";\n        Mode[Mode[\"ASCII_ENCODE\"] = 1] = \"ASCII_ENCODE\";\n        Mode[Mode[\"C40_ENCODE\"] = 2] = \"C40_ENCODE\";\n        Mode[Mode[\"TEXT_ENCODE\"] = 3] = \"TEXT_ENCODE\";\n        Mode[Mode[\"ANSIX12_ENCODE\"] = 4] = \"ANSIX12_ENCODE\";\n        Mode[Mode[\"EDIFACT_ENCODE\"] = 5] = \"EDIFACT_ENCODE\";\n        Mode[Mode[\"BASE256_ENCODE\"] = 6] = \"BASE256_ENCODE\";\n    })(Mode || (Mode = {}));\n    /**\n     * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes\n     * in one Data Matrix Code. This class decodes the bits back into text.</p>\n     *\n     * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     * @author Sean Owen\n     */\n    class DecodedBitStreamParser {\n        static decode(bytes) {\n            const bits = new BitSource(bytes);\n            const result = new StringBuilder();\n            const resultTrailer = new StringBuilder();\n            const byteSegments = new Array();\n            let mode = Mode.ASCII_ENCODE;\n            do {\n                if (mode === Mode.ASCII_ENCODE) {\n                    mode = this.decodeAsciiSegment(bits, result, resultTrailer);\n                }\n                else {\n                    switch (mode) {\n                        case Mode.C40_ENCODE:\n                            this.decodeC40Segment(bits, result);\n                            break;\n                        case Mode.TEXT_ENCODE:\n                            this.decodeTextSegment(bits, result);\n                            break;\n                        case Mode.ANSIX12_ENCODE:\n                            this.decodeAnsiX12Segment(bits, result);\n                            break;\n                        case Mode.EDIFACT_ENCODE:\n                            this.decodeEdifactSegment(bits, result);\n                            break;\n                        case Mode.BASE256_ENCODE:\n                            this.decodeBase256Segment(bits, result, byteSegments);\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                    mode = Mode.ASCII_ENCODE;\n                }\n            } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);\n            if (resultTrailer.length() > 0) {\n                result.append(resultTrailer.toString());\n            }\n            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2\n         */\n        static decodeAsciiSegment(bits, result, resultTrailer) {\n            let upperShift = false;\n            do {\n                let oneByte = bits.readBits(8);\n                if (oneByte === 0) {\n                    throw new FormatException();\n                }\n                else if (oneByte <= 128) { // ASCII data (ASCII value + 1)\n                    if (upperShift) {\n                        oneByte += 128;\n                        // upperShift = false;\n                    }\n                    result.append(String.fromCharCode(oneByte - 1));\n                    return Mode.ASCII_ENCODE;\n                }\n                else if (oneByte === 129) { // Pad\n                    return Mode.PAD_ENCODE;\n                }\n                else if (oneByte <= 229) { // 2-digit data 00-99 (Numeric Value + 130)\n                    const value = oneByte - 130;\n                    if (value < 10) { // pad with '0' for single digit values\n                        result.append('0');\n                    }\n                    result.append('' + value);\n                }\n                else {\n                    switch (oneByte) {\n                        case 230: // Latch to C40 encodation\n                            return Mode.C40_ENCODE;\n                        case 231: // Latch to Base 256 encodation\n                            return Mode.BASE256_ENCODE;\n                        case 232: // FNC1\n                            result.append(String.fromCharCode(29)); // translate as ASCII 29\n                            break;\n                        case 233: // Structured Append\n                        case 234: // Reader Programming\n                            // Ignore these symbols for now\n                            // throw ReaderException.getInstance();\n                            break;\n                        case 235: // Upper Shift (shift to Extended ASCII)\n                            upperShift = true;\n                            break;\n                        case 236: // 05 Macro\n                            result.append('[)>\\u001E05\\u001D');\n                            resultTrailer.insert(0, '\\u001E\\u0004');\n                            break;\n                        case 237: // 06 Macro\n                            result.append('[)>\\u001E06\\u001D');\n                            resultTrailer.insert(0, '\\u001E\\u0004');\n                            break;\n                        case 238: // Latch to ANSI X12 encodation\n                            return Mode.ANSIX12_ENCODE;\n                        case 239: // Latch to Text encodation\n                            return Mode.TEXT_ENCODE;\n                        case 240: // Latch to EDIFACT encodation\n                            return Mode.EDIFACT_ENCODE;\n                        case 241: // ECI Character\n                            // TODO(bbrown): I think we need to support ECI\n                            // throw ReaderException.getInstance();\n                            // Ignore this symbol for now\n                            break;\n                        default:\n                            // Not to be used in ASCII encodation\n                            // but work around encoders that end with 254, latch back to ASCII\n                            if (oneByte !== 254 || bits.available() !== 0) {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                }\n            } while (bits.available() > 0);\n            return Mode.ASCII_ENCODE;\n        }\n        /**\n         * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1\n         */\n        static decodeC40Segment(bits, result) {\n            // Three C40 values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time\n            let upperShift = false;\n            const cValues = [];\n            let shift = 0;\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) { // Unlatch codeword\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for (let i = 0; i < 3; i++) {\n                    const cValue = cValues[i];\n                    switch (shift) {\n                        case 0:\n                            if (cValue < 3) {\n                                shift = cValue + 1;\n                            }\n                            else if (cValue < this.C40_BASIC_SET_CHARS.length) {\n                                const c40char = this.C40_BASIC_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(c40char);\n                                }\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case 1:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(String.fromCharCode(cValue));\n                            }\n                            shift = 0;\n                            break;\n                        case 2:\n                            if (cValue < this.C40_SHIFT2_SET_CHARS.length) {\n                                const c40char = this.C40_SHIFT2_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(c40char);\n                                }\n                            }\n                            else {\n                                switch (cValue) {\n                                    case 27: // FNC1\n                                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                        break;\n                                    case 30: // Upper Shift\n                                        upperShift = true;\n                                        break;\n                                    default:\n                                        throw new FormatException();\n                                }\n                            }\n                            shift = 0;\n                            break;\n                        case 3:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 224));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(String.fromCharCode(cValue + 96));\n                            }\n                            shift = 0;\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                }\n            } while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2\n         */\n        static decodeTextSegment(bits, result) {\n            // Three Text values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time\n            let upperShift = false;\n            let cValues = [];\n            let shift = 0;\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) { // Unlatch codeword\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for (let i = 0; i < 3; i++) {\n                    const cValue = cValues[i];\n                    switch (shift) {\n                        case 0:\n                            if (cValue < 3) {\n                                shift = cValue + 1;\n                            }\n                            else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {\n                                const textChar = this.TEXT_BASIC_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(textChar);\n                                }\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        case 1:\n                            if (upperShift) {\n                                result.append(String.fromCharCode(cValue + 128));\n                                upperShift = false;\n                            }\n                            else {\n                                result.append(String.fromCharCode(cValue));\n                            }\n                            shift = 0;\n                            break;\n                        case 2:\n                            // Shift 2 for Text is the same encoding as C40\n                            if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {\n                                const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(textChar);\n                                }\n                            }\n                            else {\n                                switch (cValue) {\n                                    case 27: // FNC1\n                                        result.append(String.fromCharCode(29)); // translate as ASCII 29\n                                        break;\n                                    case 30: // Upper Shift\n                                        upperShift = true;\n                                        break;\n                                    default:\n                                        throw new FormatException();\n                                }\n                            }\n                            shift = 0;\n                            break;\n                        case 3:\n                            if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {\n                                const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];\n                                if (upperShift) {\n                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));\n                                    upperShift = false;\n                                }\n                                else {\n                                    result.append(textChar);\n                                }\n                                shift = 0;\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                        default:\n                            throw new FormatException();\n                    }\n                }\n            } while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.7\n         */\n        static decodeAnsiX12Segment(bits, result) {\n            // Three ANSI X12 values are encoded in a 16-bit value as\n            // (1600 * C1) + (40 * C2) + C3 + 1\n            const cValues = [];\n            do {\n                // If there is only one byte left then it will be encoded as ASCII\n                if (bits.available() === 8) {\n                    return;\n                }\n                const firstByte = bits.readBits(8);\n                if (firstByte === 254) { // Unlatch codeword\n                    return;\n                }\n                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);\n                for (let i = 0; i < 3; i++) {\n                    const cValue = cValues[i];\n                    switch (cValue) {\n                        case 0: // X12 segment terminator <CR>\n                            result.append('\\r');\n                            break;\n                        case 1: // X12 segment separator *\n                            result.append('*');\n                            break;\n                        case 2: // X12 sub-element separator >\n                            result.append('>');\n                            break;\n                        case 3: // space\n                            result.append(' ');\n                            break;\n                        default:\n                            if (cValue < 14) { // 0 - 9\n                                result.append(String.fromCharCode(cValue + 44));\n                            }\n                            else if (cValue < 40) { // A - Z\n                                result.append(String.fromCharCode(cValue + 51));\n                            }\n                            else {\n                                throw new FormatException();\n                            }\n                            break;\n                    }\n                }\n            } while (bits.available() > 0);\n        }\n        static parseTwoBytes(firstByte, secondByte, result) {\n            let fullBitValue = (firstByte << 8) + secondByte - 1;\n            let temp = Math.floor(fullBitValue / 1600);\n            result[0] = temp;\n            fullBitValue -= temp * 1600;\n            temp = Math.floor(fullBitValue / 40);\n            result[1] = temp;\n            result[2] = fullBitValue - temp * 40;\n        }\n        /**\n         * See ISO 16022:2006, 5.2.8 and Annex C Table C.3\n         */\n        static decodeEdifactSegment(bits, result) {\n            do {\n                // If there is only two or less bytes left then it will be encoded as ASCII\n                if (bits.available() <= 16) {\n                    return;\n                }\n                for (let i = 0; i < 4; i++) {\n                    let edifactValue = bits.readBits(6);\n                    // Check for the unlatch character\n                    if (edifactValue === 0x1F) { // 011111\n                        // Read rest of byte, which should be 0, and stop\n                        const bitsLeft = 8 - bits.getBitOffset();\n                        if (bitsLeft !== 8) {\n                            bits.readBits(bitsLeft);\n                        }\n                        return;\n                    }\n                    if ((edifactValue & 0x20) === 0) { // no 1 in the leading (6th) bit\n                        edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value\n                    }\n                    result.append(String.fromCharCode(edifactValue));\n                }\n            } while (bits.available() > 0);\n        }\n        /**\n         * See ISO 16022:2006, 5.2.9 and Annex B, B.2\n         */\n        static decodeBase256Segment(bits, result, byteSegments) {\n            // Figure out how long the Base 256 Segment is.\n            let codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed\n            const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            let count;\n            if (d1 === 0) { // Read the remainder of the symbol\n                count = bits.available() / 8 | 0;\n            }\n            else if (d1 < 250) {\n                count = d1;\n            }\n            else {\n                count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            }\n            // We're seeing NegativeArraySizeException errors from users.\n            if (count < 0) {\n                throw new FormatException();\n            }\n            const bytes = new Uint8Array(count);\n            for (let i = 0; i < count; i++) {\n                // Have seen this particular error in the wild, such as at\n                // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2\n                if (bits.available() < 8) {\n                    throw new FormatException();\n                }\n                bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);\n            }\n            byteSegments.push(bytes);\n            try {\n                result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));\n            }\n            catch (uee) {\n                throw new IllegalStateException('Platform does not support required encoding: ' + uee.message);\n            }\n        }\n        /**\n         * See ISO 16022:2006, Annex B, B.2\n         */\n        static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {\n            const pseudoRandomNumber = ((149 * base256CodewordPosition) % 255) + 1;\n            const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;\n            return tempVariable >= 0 ? tempVariable : tempVariable + 256;\n        }\n    }\n    /**\n     * See ISO 16022:2006, Annex C Table C.1\n     * The C40 Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n    ];\n    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [\n        '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.',\n        '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^', '_'\n    ];\n    /**\n     * See ISO 16022:2006, Annex C Table C.2\n     * The Text Basic Character Set (*'s used for placeholders for the shift values)\n     */\n    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [\n        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n    // Shift 2 for Text is the same encoding as C40\n    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;\n    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [\n        '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', String.fromCharCode(127)\n    ];\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting\n     * the Data Matrix Code from an image.</p>\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class Decoder$1 {\n        constructor() {\n            this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);\n        }\n        /**\n         * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken\n         * to mean a black module.</p>\n         *\n         * @param bits booleans representing white/black Data Matrix Code modules\n         * @return text and bytes encoded within the Data Matrix Code\n         * @throws FormatException if the Data Matrix Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        decode(bits) {\n            // Construct a parser and read version, error-correction level\n            const parser = new BitMatrixParser(bits);\n            const version = parser.getVersion();\n            // Read codewords\n            const codewords = parser.readCodewords();\n            // Separate into data blocks\n            const dataBlocks = DataBlock.getDataBlocks(codewords, version);\n            // Count total number of data bytes\n            let totalBytes = 0;\n            for (let db of dataBlocks) {\n                totalBytes += db.getNumDataCodewords();\n            }\n            const resultBytes = new Uint8Array(totalBytes);\n            const dataBlocksCount = dataBlocks.length;\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (let j = 0; j < dataBlocksCount; j++) {\n                const dataBlock = dataBlocks[j];\n                const codewordBytes = dataBlock.getCodewords();\n                const numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for (let i = 0; i < numDataCodewords; i++) {\n                    // De-interlace data blocks.\n                    resultBytes[i * dataBlocksCount + j] = codewordBytes[i];\n                }\n            }\n            // Decode the contents of that stream of bytes\n            return DecodedBitStreamParser.decode(resultBytes);\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place using Reed-Solomon error correction.</p>\n         *\n         * @param codewordBytes data and error correction codewords\n         * @param numDataCodewords number of codewords that are data bytes\n         * @throws ChecksumException if error correction fails\n         */\n        correctErrors(codewordBytes, numDataCodewords) {\n            // const numCodewords = codewordBytes.length;\n            // First read into an array of ints\n            const codewordsInts = new Int32Array(codewordBytes);\n            // for (let i = 0; i < numCodewords; i++) {\n            //   codewordsInts[i] = codewordBytes[i] & 0xFF;\n            // }\n            try {\n                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n            }\n            catch (ignored /* ReedSolomonException */) {\n                throw new ChecksumException();\n            }\n            // Copy back into array of bytes -- only need to worry about the bytes that were data\n            // We don't care about errors in the error-correction codewords\n            for (let i = 0; i < numDataCodewords; i++) {\n                codewordBytes[i] = codewordsInts[i];\n            }\n        }\n    }\n\n    /**\n     * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code\n     * is rotated or skewed, or partially obscured.</p>\n     *\n     * @author Sean Owen\n     */\n    class Detector$1 {\n        constructor(image) {\n            this.image = image;\n            this.rectangleDetector = new WhiteRectangleDetector(this.image);\n        }\n        /**\n         * <p>Detects a Data Matrix Code in an image.</p>\n         *\n         * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code\n         * @throws NotFoundException if no Data Matrix Code can be found\n         */\n        detect() {\n            const cornerPoints = this.rectangleDetector.detect();\n            let points = this.detectSolid1(cornerPoints);\n            points = this.detectSolid2(points);\n            points[3] = this.correctTopRight(points);\n            if (!points[3]) {\n                throw new NotFoundException();\n            }\n            points = this.shiftToModuleCenter(points);\n            const topLeft = points[0];\n            const bottomLeft = points[1];\n            const bottomRight = points[2];\n            const topRight = points[3];\n            let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;\n            let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;\n            if ((dimensionTop & 0x01) === 1) {\n                dimensionTop += 1;\n            }\n            if ((dimensionRight & 0x01) === 1) {\n                dimensionRight += 1;\n            }\n            if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {\n                // The matrix is square\n                dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);\n            }\n            let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);\n            return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);\n        }\n        static shiftPoint(point, to, div) {\n            let x = (to.getX() - point.getX()) / (div + 1);\n            let y = (to.getY() - point.getY()) / (div + 1);\n            return new ResultPoint(point.getX() + x, point.getY() + y);\n        }\n        static moveAway(point, fromX, fromY) {\n            let x = point.getX();\n            let y = point.getY();\n            if (x < fromX) {\n                x -= 1;\n            }\n            else {\n                x += 1;\n            }\n            if (y < fromY) {\n                y -= 1;\n            }\n            else {\n                y += 1;\n            }\n            return new ResultPoint(x, y);\n        }\n        /**\n         * Detect a solid side which has minimum transition.\n         */\n        detectSolid1(cornerPoints) {\n            // 0  2\n            // 1  3\n            let pointA = cornerPoints[0];\n            let pointB = cornerPoints[1];\n            let pointC = cornerPoints[3];\n            let pointD = cornerPoints[2];\n            let trAB = this.transitionsBetween(pointA, pointB);\n            let trBC = this.transitionsBetween(pointB, pointC);\n            let trCD = this.transitionsBetween(pointC, pointD);\n            let trDA = this.transitionsBetween(pointD, pointA);\n            // 0..3\n            // :  :\n            // 1--2\n            let min = trAB;\n            let points = [pointD, pointA, pointB, pointC];\n            if (min > trBC) {\n                min = trBC;\n                points[0] = pointA;\n                points[1] = pointB;\n                points[2] = pointC;\n                points[3] = pointD;\n            }\n            if (min > trCD) {\n                min = trCD;\n                points[0] = pointB;\n                points[1] = pointC;\n                points[2] = pointD;\n                points[3] = pointA;\n            }\n            if (min > trDA) {\n                points[0] = pointC;\n                points[1] = pointD;\n                points[2] = pointA;\n                points[3] = pointB;\n            }\n            return points;\n        }\n        /**\n         * Detect a second solid side next to first solid side.\n         */\n        detectSolid2(points) {\n            // A..D\n            // :  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // Transition detection on the edge is not stable.\n            // To safely detect, shift the points to the module center.\n            let tr = this.transitionsBetween(pointA, pointD);\n            let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);\n            let trBA = this.transitionsBetween(pointBs, pointA);\n            let trCD = this.transitionsBetween(pointCs, pointD);\n            // 0..3\n            // |  :\n            // 1--2\n            if (trBA < trCD) {\n                // solid sides: A-B-C\n                points[0] = pointA;\n                points[1] = pointB;\n                points[2] = pointC;\n                points[3] = pointD;\n            }\n            else {\n                // solid sides: B-C-D\n                points[0] = pointB;\n                points[1] = pointC;\n                points[2] = pointD;\n                points[3] = pointA;\n            }\n            return points;\n        }\n        /**\n         * Calculates the corner position of the white top right module.\n         */\n        correctTopRight(points) {\n            // A..D\n            // |  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // shift points for safe transition detection.\n            let trTop = this.transitionsBetween(pointA, pointD);\n            let trRight = this.transitionsBetween(pointB, pointD);\n            let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);\n            trTop = this.transitionsBetween(pointAs, pointD);\n            trRight = this.transitionsBetween(pointCs, pointD);\n            let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));\n            let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));\n            if (!this.isValid(candidate1)) {\n                if (this.isValid(candidate2)) {\n                    return candidate2;\n                }\n                return null;\n            }\n            if (!this.isValid(candidate2)) {\n                return candidate1;\n            }\n            let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);\n            let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);\n            if (sumc1 > sumc2) {\n                return candidate1;\n            }\n            else {\n                return candidate2;\n            }\n        }\n        /**\n         * Shift the edge points to the module center.\n         */\n        shiftToModuleCenter(points) {\n            // A..D\n            // |  :\n            // B--C\n            let pointA = points[0];\n            let pointB = points[1];\n            let pointC = points[2];\n            let pointD = points[3];\n            // calculate pseudo dimensions\n            let dimH = this.transitionsBetween(pointA, pointD) + 1;\n            let dimV = this.transitionsBetween(pointC, pointD) + 1;\n            // shift points for safe dimension detection\n            let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);\n            let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);\n            //  calculate more precise dimensions\n            dimH = this.transitionsBetween(pointAs, pointD) + 1;\n            dimV = this.transitionsBetween(pointCs, pointD) + 1;\n            if ((dimH & 0x01) === 1) {\n                dimH += 1;\n            }\n            if ((dimV & 0x01) === 1) {\n                dimV += 1;\n            }\n            // WhiteRectangleDetector returns points inside of the rectangle.\n            // I want points on the edges.\n            let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;\n            let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;\n            pointA = Detector$1.moveAway(pointA, centerX, centerY);\n            pointB = Detector$1.moveAway(pointB, centerX, centerY);\n            pointC = Detector$1.moveAway(pointC, centerX, centerY);\n            pointD = Detector$1.moveAway(pointD, centerX, centerY);\n            let pointBs;\n            let pointDs;\n            // shift points to the center of each modules\n            pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);\n            pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);\n            pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);\n            pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);\n            pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);\n            pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);\n            pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);\n            pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);\n            return [pointAs, pointBs, pointCs, pointDs];\n        }\n        isValid(p) {\n            return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();\n        }\n        static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {\n            const sampler = GridSamplerInstance.getInstance();\n            return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());\n        }\n        /**\n         * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.\n         */\n        transitionsBetween(from, to) {\n            // See QR Code Detector, sizeOfBlackWhiteBlackRun()\n            let fromX = Math.trunc(from.getX());\n            let fromY = Math.trunc(from.getY());\n            let toX = Math.trunc(to.getX());\n            let toY = Math.trunc(to.getY());\n            let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n            if (steep) {\n                let temp = fromX;\n                fromX = fromY;\n                fromY = temp;\n                temp = toX;\n                toX = toY;\n                toY = temp;\n            }\n            let dx = Math.abs(toX - fromX);\n            let dy = Math.abs(toY - fromY);\n            let error = -dx / 2;\n            let ystep = fromY < toY ? 1 : -1;\n            let xstep = fromX < toX ? 1 : -1;\n            let transitions = 0;\n            let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);\n            for (let x = fromX, y = fromY; x !== toX; x += xstep) {\n                let isBlack = this.image.get(steep ? y : x, steep ? x : y);\n                if (isBlack !== inBlack) {\n                    transitions++;\n                    inBlack = isBlack;\n                }\n                error += dy;\n                if (error > 0) {\n                    if (y === toY) {\n                        break;\n                    }\n                    y += ystep;\n                    error -= dx;\n                }\n            }\n            return transitions;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This implementation can detect and decode Data Matrix codes in an image.\n     *\n     * @author bbrown@google.com (Brian Brown)\n     */\n    class DataMatrixReader {\n        constructor() {\n            this.decoder = new Decoder$1();\n        }\n        /**\n         * Locates and decodes a Data Matrix code in an image.\n         *\n         * @return a String representing the content encoded by the Data Matrix code\n         * @throws NotFoundException if a Data Matrix code cannot be found\n         * @throws FormatException if a Data Matrix code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        // @Override\n        // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n        //   return decode(image, null);\n        // }\n        // @Override\n        decode(image, hints = null) {\n            let decoderResult;\n            let points;\n            if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {\n                const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n                decoderResult = this.decoder.decode(bits);\n                points = DataMatrixReader.NO_POINTS;\n            }\n            else {\n                const detectorResult = new Detector$1(image.getBlackMatrix()).detect();\n                decoderResult = this.decoder.decode(detectorResult.getBits());\n                points = detectorResult.getPoints();\n            }\n            const rawBytes = decoderResult.getRawBytes();\n            const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());\n            const byteSegments = decoderResult.getByteSegments();\n            if (byteSegments != null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            const ecLevel = decoderResult.getECLevel();\n            if (ecLevel != null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            return result;\n        }\n        // @Override\n        reset() {\n            // do nothing\n        }\n        /**\n         * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n         * which contains only an unrotated, unskewed, image of a code, with some white border\n         * around it. This is a specialized method that works exceptionally fast in this special\n         * case.\n         *\n         * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n         */\n        static extractPureBits(image) {\n            const leftTopBlack = image.getTopLeftOnBit();\n            const rightBottomBlack = image.getBottomRightOnBit();\n            if (leftTopBlack == null || rightBottomBlack == null) {\n                throw new NotFoundException();\n            }\n            const moduleSize = this.moduleSize(leftTopBlack, image);\n            let top = leftTopBlack[1];\n            const bottom = rightBottomBlack[1];\n            let left = leftTopBlack[0];\n            const right = rightBottomBlack[0];\n            const matrixWidth = (right - left + 1) / moduleSize;\n            const matrixHeight = (bottom - top + 1) / moduleSize;\n            if (matrixWidth <= 0 || matrixHeight <= 0) {\n                throw new NotFoundException();\n            }\n            // Push in the \"border\" by half the module width so that we start\n            // sampling in the middle of the module. Just in case the image is a\n            // little off, this will help recover.\n            const nudge = moduleSize / 2;\n            top += nudge;\n            left += nudge;\n            // Now just read off the bits\n            const bits = new BitMatrix(matrixWidth, matrixHeight);\n            for (let y = 0; y < matrixHeight; y++) {\n                const iOffset = top + y * moduleSize;\n                for (let x = 0; x < matrixWidth; x++) {\n                    if (image.get(left + x * moduleSize, iOffset)) {\n                        bits.set(x, y);\n                    }\n                }\n            }\n            return bits;\n        }\n        static moduleSize(leftTopBlack, image) {\n            const width = image.getWidth();\n            let x = leftTopBlack[0];\n            const y = leftTopBlack[1];\n            while (x < width && image.get(x, y)) {\n                x++;\n            }\n            if (x === width) {\n                throw new NotFoundException();\n            }\n            const moduleSize = x - leftTopBlack[0];\n            if (moduleSize === 0) {\n                throw new NotFoundException();\n            }\n            return moduleSize;\n        }\n    }\n    DataMatrixReader.NO_POINTS = [];\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */\n    class BrowserDatamatrixCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserQRCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new DataMatrixReader(), timeBetweenScansMillis);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var ErrorCorrectionLevelValues;\n    (function (ErrorCorrectionLevelValues) {\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"L\"] = 0] = \"L\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"M\"] = 1] = \"M\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"Q\"] = 2] = \"Q\";\n        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues[\"H\"] = 3] = \"H\";\n    })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));\n    /**\n     * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels\n     * defined by the QR code standard.</p>\n     *\n     * @author Sean Owen\n     */\n    class ErrorCorrectionLevel {\n        constructor(value, stringValue, bits /*int*/) {\n            this.value = value;\n            this.stringValue = stringValue;\n            this.bits = bits;\n            ErrorCorrectionLevel.FOR_BITS.set(bits, this);\n            ErrorCorrectionLevel.FOR_VALUE.set(value, this);\n        }\n        getValue() {\n            return this.value;\n        }\n        getBits() {\n            return this.bits;\n        }\n        static fromString(s) {\n            switch (s) {\n                case 'L': return ErrorCorrectionLevel.L;\n                case 'M': return ErrorCorrectionLevel.M;\n                case 'Q': return ErrorCorrectionLevel.Q;\n                case 'H': return ErrorCorrectionLevel.H;\n                default: throw new ArgumentException(s + 'not available');\n            }\n        }\n        toString() {\n            return this.stringValue;\n        }\n        equals(o) {\n            if (!(o instanceof ErrorCorrectionLevel)) {\n                return false;\n            }\n            const other = o;\n            return this.value === other.value;\n        }\n        /**\n         * @param bits int containing the two bits encoding a QR Code's error correction level\n         * @return ErrorCorrectionLevel representing the encoded error correction level\n         */\n        static forBits(bits /*int*/) {\n            if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {\n                throw new IllegalArgumentException();\n            }\n            return ErrorCorrectionLevel.FOR_BITS.get(bits);\n        }\n    }\n    ErrorCorrectionLevel.FOR_BITS = new Map();\n    ErrorCorrectionLevel.FOR_VALUE = new Map();\n    /** L = ~7% correction */\n    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, 'L', 0x01);\n    /** M = ~15% correction */\n    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, 'M', 0x00);\n    /** Q = ~25% correction */\n    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, 'Q', 0x03);\n    /** H = ~30% correction */\n    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, 'H', 0x02);\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a QR Code's format information, including the data mask used and\n     * error correction level.</p>\n     *\n     * @author Sean Owen\n     * @see DataMask\n     * @see ErrorCorrectionLevel\n     */\n    class FormatInformation {\n        constructor(formatInfo /*int*/) {\n            // Bits 3,4\n            this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo >> 3) & 0x03);\n            // Bottom 3 bits\n            this.dataMask = /*(byte) */ (formatInfo & 0x07);\n        }\n        static numBitsDiffering(a /*int*/, b /*int*/) {\n            return Integer.bitCount(a ^ b);\n        }\n        /**\n         * @param maskedFormatInfo1 format info indicator, with mask still applied\n         * @param maskedFormatInfo2 second copy of same info; both are checked at the same time\n         *  to establish best match\n         * @return information about the format it specifies, or {@code null}\n         *  if doesn't seem to match any known pattern\n         */\n        static decodeFormatInformation(maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n            const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);\n            if (formatInfo !== null) {\n                return formatInfo;\n            }\n            // Should return null, but, some QR codes apparently\n            // do not mask this info. Try again by actually masking the pattern\n            // first\n            return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);\n        }\n        static doDecodeFormatInformation(maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {\n            // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing\n            let bestDifference = Number.MAX_SAFE_INTEGER;\n            let bestFormatInfo = 0;\n            for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {\n                const targetInfo = decodeInfo[0];\n                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {\n                    // Found an exact match\n                    return new FormatInformation(decodeInfo[1]);\n                }\n                let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);\n                if (bitsDifference < bestDifference) {\n                    bestFormatInfo = decodeInfo[1];\n                    bestDifference = bitsDifference;\n                }\n                if (maskedFormatInfo1 !== maskedFormatInfo2) {\n                    // also try the other option\n                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);\n                    if (bitsDifference < bestDifference) {\n                        bestFormatInfo = decodeInfo[1];\n                        bestDifference = bitsDifference;\n                    }\n                }\n            }\n            // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits\n            // differing means we found a match\n            if (bestDifference <= 3) {\n                return new FormatInformation(bestFormatInfo);\n            }\n            return null;\n        }\n        getErrorCorrectionLevel() {\n            return this.errorCorrectionLevel;\n        }\n        getDataMask() {\n            return this.dataMask;\n        }\n        /*@Override*/\n        hashCode() {\n            return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;\n        }\n        /*@Override*/\n        equals(o) {\n            if (!(o instanceof FormatInformation)) {\n                return false;\n            }\n            const other = o;\n            return this.errorCorrectionLevel === other.errorCorrectionLevel &&\n                this.dataMask === other.dataMask;\n        }\n    }\n    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;\n    /**\n     * See ISO 18004:2006, Annex C, Table C.1\n     */\n    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [\n        Int32Array.from([0x5412, 0x00]),\n        Int32Array.from([0x5125, 0x01]),\n        Int32Array.from([0x5E7C, 0x02]),\n        Int32Array.from([0x5B4B, 0x03]),\n        Int32Array.from([0x45F9, 0x04]),\n        Int32Array.from([0x40CE, 0x05]),\n        Int32Array.from([0x4F97, 0x06]),\n        Int32Array.from([0x4AA0, 0x07]),\n        Int32Array.from([0x77C4, 0x08]),\n        Int32Array.from([0x72F3, 0x09]),\n        Int32Array.from([0x7DAA, 0x0A]),\n        Int32Array.from([0x789D, 0x0B]),\n        Int32Array.from([0x662F, 0x0C]),\n        Int32Array.from([0x6318, 0x0D]),\n        Int32Array.from([0x6C41, 0x0E]),\n        Int32Array.from([0x6976, 0x0F]),\n        Int32Array.from([0x1689, 0x10]),\n        Int32Array.from([0x13BE, 0x11]),\n        Int32Array.from([0x1CE7, 0x12]),\n        Int32Array.from([0x19D0, 0x13]),\n        Int32Array.from([0x0762, 0x14]),\n        Int32Array.from([0x0255, 0x15]),\n        Int32Array.from([0x0D0C, 0x16]),\n        Int32Array.from([0x083B, 0x17]),\n        Int32Array.from([0x355F, 0x18]),\n        Int32Array.from([0x3068, 0x19]),\n        Int32Array.from([0x3F31, 0x1A]),\n        Int32Array.from([0x3A06, 0x1B]),\n        Int32Array.from([0x24B4, 0x1C]),\n        Int32Array.from([0x2183, 0x1D]),\n        Int32Array.from([0x2EDA, 0x1E]),\n        Int32Array.from([0x2BED, 0x1F]),\n    ];\n\n    /**\n     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n     * use blocks of differing sizes within one version, so, this encapsulates the parameters for\n     * each set of blocks. It also holds the number of error-correction codewords per block since it\n     * will be the same across all blocks within one version.</p>\n     */\n    class ECBlocks$1 {\n        constructor(ecCodewordsPerBlock /*int*/, ...ecBlocks) {\n            this.ecCodewordsPerBlock = ecCodewordsPerBlock;\n            this.ecBlocks = ecBlocks;\n        }\n        getECCodewordsPerBlock() {\n            return this.ecCodewordsPerBlock;\n        }\n        getNumBlocks() {\n            let total = 0;\n            const ecBlocks = this.ecBlocks;\n            for (const ecBlock of ecBlocks) {\n                total += ecBlock.getCount();\n            }\n            return total;\n        }\n        getTotalECCodewords() {\n            return this.ecCodewordsPerBlock * this.getNumBlocks();\n        }\n        getECBlocks() {\n            return this.ecBlocks;\n        }\n    }\n\n    /**\n     * <p>Encapsulates the parameters for one error-correction block in one symbol version.\n     * This includes the number of data codewords, and the number of times a block with these\n     * parameters is used consecutively in the QR code version's format.</p>\n     */\n    class ECB$1 {\n        constructor(count /*int*/, dataCodewords /*int*/) {\n            this.count = count;\n            this.dataCodewords = dataCodewords;\n        }\n        getCount() {\n            return this.count;\n        }\n        getDataCodewords() {\n            return this.dataCodewords;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * See ISO 18004:2006 Annex D\n     *\n     * @author Sean Owen\n     */\n    class Version$1 {\n        constructor(versionNumber /*int*/, alignmentPatternCenters, ...ecBlocks) {\n            this.versionNumber = versionNumber;\n            this.alignmentPatternCenters = alignmentPatternCenters;\n            this.ecBlocks = ecBlocks;\n            let total = 0;\n            const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();\n            const ecbArray = ecBlocks[0].getECBlocks();\n            for (const ecBlock of ecbArray) {\n                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);\n            }\n            this.totalCodewords = total;\n        }\n        getVersionNumber() {\n            return this.versionNumber;\n        }\n        getAlignmentPatternCenters() {\n            return this.alignmentPatternCenters;\n        }\n        getTotalCodewords() {\n            return this.totalCodewords;\n        }\n        getDimensionForVersion() {\n            return 17 + 4 * this.versionNumber;\n        }\n        getECBlocksForLevel(ecLevel) {\n            return this.ecBlocks[ecLevel.getValue()];\n            // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)\n            // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number\n        }\n        /**\n         * <p>Deduces version information purely from QR Code dimensions.</p>\n         *\n         * @param dimension dimension in modules\n         * @return Version for a QR Code of that dimension\n         * @throws FormatException if dimension is not 1 mod 4\n         */\n        static getProvisionalVersionForDimension(dimension /*int*/) {\n            if (dimension % 4 !== 1) {\n                throw new FormatException();\n            }\n            try {\n                return this.getVersionForNumber((dimension - 17) / 4);\n            }\n            catch (ignored /*: IllegalArgumentException*/) {\n                throw new FormatException();\n            }\n        }\n        static getVersionForNumber(versionNumber /*int*/) {\n            if (versionNumber < 1 || versionNumber > 40) {\n                throw new IllegalArgumentException();\n            }\n            return Version$1.VERSIONS[versionNumber - 1];\n        }\n        static decodeVersionInformation(versionBits /*int*/) {\n            let bestDifference = Number.MAX_SAFE_INTEGER;\n            let bestVersion = 0;\n            for (let i = 0; i < Version$1.VERSION_DECODE_INFO.length; i++) {\n                const targetVersion = Version$1.VERSION_DECODE_INFO[i];\n                // Do the version info bits match exactly? done.\n                if (targetVersion === versionBits) {\n                    return Version$1.getVersionForNumber(i + 7);\n                }\n                // Otherwise see if this is the closest to a real version info bit string\n                // we have seen so far\n                const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);\n                if (bitsDifference < bestDifference) {\n                    bestVersion = i + 7;\n                    bestDifference = bitsDifference;\n                }\n            }\n            // We can tolerate up to 3 bits of error since no two version info codewords will\n            // differ in less than 8 bits.\n            if (bestDifference <= 3) {\n                return Version$1.getVersionForNumber(bestVersion);\n            }\n            // If we didn't find a close enough match, fail\n            return null;\n        }\n        /**\n         * See ISO 18004:2006 Annex E\n         */\n        buildFunctionPattern() {\n            const dimension = this.getDimensionForVersion();\n            const bitMatrix = new BitMatrix(dimension);\n            // Top left finder pattern + separator + format\n            bitMatrix.setRegion(0, 0, 9, 9);\n            // Top right finder pattern + separator + format\n            bitMatrix.setRegion(dimension - 8, 0, 8, 9);\n            // Bottom left finder pattern + separator + format\n            bitMatrix.setRegion(0, dimension - 8, 9, 8);\n            // Alignment patterns\n            const max = this.alignmentPatternCenters.length;\n            for (let x = 0; x < max; x++) {\n                const i = this.alignmentPatternCenters[x] - 2;\n                for (let y = 0; y < max; y++) {\n                    if ((x === 0 && (y === 0 || y === max - 1)) || (x === max - 1 && y === 0)) {\n                        // No alignment patterns near the three finder patterns\n                        continue;\n                    }\n                    bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);\n                }\n            }\n            // Vertical timing pattern\n            bitMatrix.setRegion(6, 9, 1, dimension - 17);\n            // Horizontal timing pattern\n            bitMatrix.setRegion(9, 6, dimension - 17, 1);\n            if (this.versionNumber > 6) {\n                // Version info, top right\n                bitMatrix.setRegion(dimension - 11, 0, 3, 6);\n                // Version info, bottom left\n                bitMatrix.setRegion(0, dimension - 11, 6, 3);\n            }\n            return bitMatrix;\n        }\n        /*@Override*/\n        toString() {\n            return '' + this.versionNumber;\n        }\n    }\n    /**\n       * See ISO 18004:2006 Annex D.\n       * Element i represents the raw version bits that specify version i + 7\n       */\n    Version$1.VERSION_DECODE_INFO = Int32Array.from([\n        0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,\n        0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,\n        0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,\n        0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,\n        0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,\n        0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,\n        0x2542E, 0x26A64, 0x27541, 0x28C69\n    ]);\n    /**\n       * See ISO 18004:2006 6.5.1 Table 9\n       */\n    Version$1.VERSIONS = [\n        new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),\n        new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),\n        new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),\n        new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),\n        new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),\n        new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),\n        new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),\n        new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),\n        new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),\n        new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),\n        new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),\n        new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),\n        new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),\n        new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),\n        new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),\n        new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),\n        new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),\n        new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),\n        new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),\n        new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),\n        new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),\n        new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),\n        new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),\n        new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),\n        new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),\n        new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),\n        new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),\n        new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),\n        new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),\n        new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),\n        new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),\n        new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),\n        new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),\n        new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),\n        new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),\n        new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),\n        new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),\n        new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),\n        new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),\n        new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))\n    ];\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var DataMaskValues;\n    (function (DataMaskValues) {\n        DataMaskValues[DataMaskValues[\"DATA_MASK_000\"] = 0] = \"DATA_MASK_000\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_001\"] = 1] = \"DATA_MASK_001\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_010\"] = 2] = \"DATA_MASK_010\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_011\"] = 3] = \"DATA_MASK_011\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_100\"] = 4] = \"DATA_MASK_100\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_101\"] = 5] = \"DATA_MASK_101\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_110\"] = 6] = \"DATA_MASK_110\";\n        DataMaskValues[DataMaskValues[\"DATA_MASK_111\"] = 7] = \"DATA_MASK_111\";\n    })(DataMaskValues || (DataMaskValues = {}));\n    /**\n     * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations\n     * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,\n     * including areas used for finder patterns, timing patterns, etc. These areas should be unused\n     * after the point they are unmasked anyway.</p>\n     *\n     * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position\n     * and j is row position. In fact, as the text says, i is row position and j is column position.</p>\n     *\n     * @author Sean Owen\n     */\n    class DataMask {\n        // See ISO 18004:2006 6.8.1\n        constructor(value, isMasked) {\n            this.value = value;\n            this.isMasked = isMasked;\n        }\n        // End of enum constants.\n        /**\n         * <p>Implementations of this method reverse the data masking process applied to a QR Code and\n         * make its bits ready to read.</p>\n         *\n         * @param bits representation of QR Code bits\n         * @param dimension dimension of QR Code, represented by bits, being unmasked\n         */\n        unmaskBitMatrix(bits, dimension /*int*/) {\n            for (let i = 0; i < dimension; i++) {\n                for (let j = 0; j < dimension; j++) {\n                    if (this.isMasked(i, j)) {\n                        bits.flip(j, i);\n                    }\n                }\n            }\n        }\n    }\n    DataMask.values = new Map([\n        /**\n         * 000: mask bits for which (x + y) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i /*int*/, j /*int*/) => { return ((i + j) & 0x01) === 0; })],\n        /**\n         * 001: mask bits for which x mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i /*int*/, j /*int*/) => { return (i & 0x01) === 0; })],\n        /**\n         * 010: mask bits for which y mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i /*int*/, j /*int*/) => { return j % 3 === 0; })],\n        /**\n         * 011: mask bits for which (x + y) mod 3 == 0\n         */\n        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i /*int*/, j /*int*/) => { return (i + j) % 3 === 0; })],\n        /**\n         * 100: mask bits for which (x/2 + y/3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i /*int*/, j /*int*/) => { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],\n        /**\n         * 101: mask bits for which xy mod 2 + xy mod 3 == 0\n         * equivalently, such that xy mod 6 == 0\n         */\n        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i /*int*/, j /*int*/) => { return (i * j) % 6 === 0; })],\n        /**\n         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that xy mod 6 < 3\n         */\n        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i /*int*/, j /*int*/) => { return ((i * j) % 6) < 3; })],\n        /**\n         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0\n         * equivalently, such that (x + y + xy mod 3) mod 2 == 0\n         */\n        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i /*int*/, j /*int*/) => { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],\n    ]);\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Sean Owen\n     */\n    class BitMatrixParser$1 {\n        /**\n         * @param bitMatrix {@link BitMatrix} to parse\n         * @throws FormatException if dimension is not >= 21 and 1 mod 4\n         */\n        constructor(bitMatrix) {\n            const dimension = bitMatrix.getHeight();\n            if (dimension < 21 || (dimension & 0x03) !== 1) {\n                throw new FormatException();\n            }\n            this.bitMatrix = bitMatrix;\n        }\n        /**\n         * <p>Reads format information from one of its two locations within the QR Code.</p>\n         *\n         * @return {@link FormatInformation} encapsulating the QR Code's format info\n         * @throws FormatException if both format information locations cannot be parsed as\n         * the valid encoding of format information\n         */\n        readFormatInformation() {\n            if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {\n                return this.parsedFormatInfo;\n            }\n            // Read top-left format info bits\n            let formatInfoBits1 = 0;\n            for (let i = 0; i < 6; i++) {\n                formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);\n            }\n            // .. and skip a bit in the timing pattern ...\n            formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);\n            formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);\n            formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);\n            // .. and skip a bit in the timing pattern ...\n            for (let j = 5; j >= 0; j--) {\n                formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);\n            }\n            // Read the top-right/bottom-left pattern too\n            const dimension = this.bitMatrix.getHeight();\n            let formatInfoBits2 = 0;\n            const jMin = dimension - 7;\n            for (let j = dimension - 1; j >= jMin; j--) {\n                formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);\n            }\n            for (let i = dimension - 8; i < dimension; i++) {\n                formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);\n            }\n            this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);\n            if (this.parsedFormatInfo !== null) {\n                return this.parsedFormatInfo;\n            }\n            throw new FormatException();\n        }\n        /**\n         * <p>Reads version information from one of its two locations within the QR Code.</p>\n         *\n         * @return {@link Version} encapsulating the QR Code's version\n         * @throws FormatException if both version information locations cannot be parsed as\n         * the valid encoding of version information\n         */\n        readVersion() {\n            if (this.parsedVersion !== null && this.parsedVersion !== undefined) {\n                return this.parsedVersion;\n            }\n            const dimension = this.bitMatrix.getHeight();\n            const provisionalVersion = Math.floor((dimension - 17) / 4);\n            if (provisionalVersion <= 6) {\n                return Version$1.getVersionForNumber(provisionalVersion);\n            }\n            // Read top-right version info: 3 wide by 6 tall\n            let versionBits = 0;\n            const ijMin = dimension - 11;\n            for (let j = 5; j >= 0; j--) {\n                for (let i = dimension - 9; i >= ijMin; i--) {\n                    versionBits = this.copyBit(i, j, versionBits);\n                }\n            }\n            let theParsedVersion = Version$1.decodeVersionInformation(versionBits);\n            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n                this.parsedVersion = theParsedVersion;\n                return theParsedVersion;\n            }\n            // Hmm, failed. Try bottom left: 6 wide by 3 tall\n            versionBits = 0;\n            for (let i = 5; i >= 0; i--) {\n                for (let j = dimension - 9; j >= ijMin; j--) {\n                    versionBits = this.copyBit(i, j, versionBits);\n                }\n            }\n            theParsedVersion = Version$1.decodeVersionInformation(versionBits);\n            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {\n                this.parsedVersion = theParsedVersion;\n                return theParsedVersion;\n            }\n            throw new FormatException();\n        }\n        copyBit(i /*int*/, j /*int*/, versionBits /*int*/) {\n            const bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);\n            return bit ? (versionBits << 1) | 0x1 : versionBits << 1;\n        }\n        /**\n         * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the\n         * correct order in order to reconstruct the codewords bytes contained within the\n         * QR Code.</p>\n         *\n         * @return bytes encoded within the QR Code\n         * @throws FormatException if the exact number of bytes expected is not read\n         */\n        readCodewords() {\n            const formatInfo = this.readFormatInformation();\n            const version = this.readVersion();\n            // Get the data mask for the format used in this QR Code. This will exclude\n            // some bits from reading as we wind through the bit matrix.\n            const dataMask = DataMask.values.get(formatInfo.getDataMask());\n            const dimension = this.bitMatrix.getHeight();\n            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n            const functionPattern = version.buildFunctionPattern();\n            let readingUp = true;\n            const result = new Uint8Array(version.getTotalCodewords());\n            let resultOffset = 0;\n            let currentByte = 0;\n            let bitsRead = 0;\n            // Read columns in pairs, from right to left\n            for (let j = dimension - 1; j > 0; j -= 2) {\n                if (j === 6) {\n                    // Skip whole column with vertical alignment pattern\n                    // saves time and makes the other code proceed more cleanly\n                    j--;\n                }\n                // Read alternatingly from bottom to top then top to bottom\n                for (let count = 0; count < dimension; count++) {\n                    const i = readingUp ? dimension - 1 - count : count;\n                    for (let col = 0; col < 2; col++) {\n                        // Ignore bits covered by the function pattern\n                        if (!functionPattern.get(j - col, i)) {\n                            // Read a bit\n                            bitsRead++;\n                            currentByte <<= 1;\n                            if (this.bitMatrix.get(j - col, i)) {\n                                currentByte |= 1;\n                            }\n                            // If we've made a whole byte, save it off\n                            if (bitsRead === 8) {\n                                result[resultOffset++] = /*(byte) */ currentByte;\n                                bitsRead = 0;\n                                currentByte = 0;\n                            }\n                        }\n                    }\n                }\n                readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions\n            }\n            if (resultOffset !== version.getTotalCodewords()) {\n                throw new FormatException();\n            }\n            return result;\n        }\n        /**\n         * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.\n         */\n        remask() {\n            if (this.parsedFormatInfo === null) {\n                return; // We have no format information, and have no data mask\n            }\n            const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];\n            const dimension = this.bitMatrix.getHeight();\n            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);\n        }\n        /**\n         * Prepare the parser for a mirrored operation.\n         * This flag has effect only on the {@link #readFormatInformation()} and the\n         * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the\n         * {@link #mirror()} method should be called.\n         *\n         * @param mirror Whether to read version and format information mirrored.\n         */\n        setMirror(isMirror) {\n            this.parsedVersion = null;\n            this.parsedFormatInfo = null;\n            this.isMirror = isMirror;\n        }\n        /** Mirror the bit matrix in order to attempt a second reading. */\n        mirror() {\n            const bitMatrix = this.bitMatrix;\n            for (let x = 0, width = bitMatrix.getWidth(); x < width; x++) {\n                for (let y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {\n                    if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {\n                        bitMatrix.flip(y, x);\n                        bitMatrix.flip(x, y);\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into\n     * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n     * is represented by an instance of this class.</p>\n     *\n     * @author Sean Owen\n     */\n    class DataBlock$1 {\n        constructor(numDataCodewords /*int*/, codewords) {\n            this.numDataCodewords = numDataCodewords;\n            this.codewords = codewords;\n        }\n        /**\n         * <p>When QR Codes use multiple data blocks, they are actually interleaved.\n         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n         * method will separate the data into original blocks.</p>\n         *\n         * @param rawCodewords bytes as read directly from the QR Code\n         * @param version version of the QR Code\n         * @param ecLevel error-correction level of the QR Code\n         * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n         *         QR Code\n         */\n        static getDataBlocks(rawCodewords, version, ecLevel) {\n            if (rawCodewords.length !== version.getTotalCodewords()) {\n                throw new IllegalArgumentException();\n            }\n            // Figure out the number and size of data blocks used by this version and\n            // error correction level\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            // First count the total number of data blocks\n            let totalBlocks = 0;\n            const ecBlockArray = ecBlocks.getECBlocks();\n            for (const ecBlock of ecBlockArray) {\n                totalBlocks += ecBlock.getCount();\n            }\n            // Now establish DataBlocks of the appropriate size and number of data codewords\n            const result = new Array(totalBlocks);\n            let numResultBlocks = 0;\n            for (const ecBlock of ecBlockArray) {\n                for (let i = 0; i < ecBlock.getCount(); i++) {\n                    const numDataCodewords = ecBlock.getDataCodewords();\n                    const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;\n                    result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));\n                }\n            }\n            // All blocks have the same amount of data, except that the last n\n            // (where n may be 0) have 1 more byte. Figure out where these start.\n            const shorterBlocksTotalCodewords = result[0].codewords.length;\n            let longerBlocksStartAt = result.length - 1;\n            // TYPESCRIPTPORT: check length is correct here\n            while (longerBlocksStartAt >= 0) {\n                const numCodewords = result[longerBlocksStartAt].codewords.length;\n                if (numCodewords === shorterBlocksTotalCodewords) {\n                    break;\n                }\n                longerBlocksStartAt--;\n            }\n            longerBlocksStartAt++;\n            const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();\n            // The last elements of result may be 1 element longer\n            // first fill out as many elements as all of them have\n            let rawCodewordsOffset = 0;\n            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            // Fill out the last data block in the longer ones\n            for (let j = longerBlocksStartAt; j < numResultBlocks; j++) {\n                result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n            }\n            // Now add in error correction blocks\n            const max = result[0].codewords.length;\n            for (let i = shorterBlocksNumDataCodewords; i < max; i++) {\n                for (let j = 0; j < numResultBlocks; j++) {\n                    const iOffset = j < longerBlocksStartAt ? i : i + 1;\n                    result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n                }\n            }\n            return result;\n        }\n        getNumDataCodewords() {\n            return this.numDataCodewords;\n        }\n        getCodewords() {\n            return this.codewords;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    var ModeValues;\n    (function (ModeValues) {\n        ModeValues[ModeValues[\"TERMINATOR\"] = 0] = \"TERMINATOR\";\n        ModeValues[ModeValues[\"NUMERIC\"] = 1] = \"NUMERIC\";\n        ModeValues[ModeValues[\"ALPHANUMERIC\"] = 2] = \"ALPHANUMERIC\";\n        ModeValues[ModeValues[\"STRUCTURED_APPEND\"] = 3] = \"STRUCTURED_APPEND\";\n        ModeValues[ModeValues[\"BYTE\"] = 4] = \"BYTE\";\n        ModeValues[ModeValues[\"ECI\"] = 5] = \"ECI\";\n        ModeValues[ModeValues[\"KANJI\"] = 6] = \"KANJI\";\n        ModeValues[ModeValues[\"FNC1_FIRST_POSITION\"] = 7] = \"FNC1_FIRST_POSITION\";\n        ModeValues[ModeValues[\"FNC1_SECOND_POSITION\"] = 8] = \"FNC1_SECOND_POSITION\";\n        /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n        ModeValues[ModeValues[\"HANZI\"] = 9] = \"HANZI\";\n    })(ModeValues || (ModeValues = {}));\n    /**\n     * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which\n     * data can be encoded to bits in the QR code standard.</p>\n     *\n     * @author Sean Owen\n     */\n    class Mode$1 {\n        constructor(value, stringValue, characterCountBitsForVersions, bits /*int*/) {\n            this.value = value;\n            this.stringValue = stringValue;\n            this.characterCountBitsForVersions = characterCountBitsForVersions;\n            this.bits = bits;\n            Mode$1.FOR_BITS.set(bits, this);\n            Mode$1.FOR_VALUE.set(value, this);\n        }\n        /**\n         * @param bits four bits encoding a QR Code data mode\n         * @return Mode encoded by these bits\n         * @throws IllegalArgumentException if bits do not correspond to a known mode\n         */\n        static forBits(bits /*int*/) {\n            const mode = Mode$1.FOR_BITS.get(bits);\n            if (undefined === mode) {\n                throw new IllegalArgumentException();\n            }\n            return mode;\n        }\n        /**\n         * @param version version in question\n         * @return number of bits used, in this QR Code symbol {@link Version}, to encode the\n         *         count of characters that will follow encoded in this Mode\n         */\n        getCharacterCountBits(version) {\n            const versionNumber = version.getVersionNumber();\n            let offset;\n            if (versionNumber <= 9) {\n                offset = 0;\n            }\n            else if (versionNumber <= 26) {\n                offset = 1;\n            }\n            else {\n                offset = 2;\n            }\n            return this.characterCountBitsForVersions[offset];\n        }\n        getValue() {\n            return this.value;\n        }\n        getBits() {\n            return this.bits;\n        }\n        equals(o) {\n            if (!(o instanceof Mode$1)) {\n                return false;\n            }\n            const other = o;\n            return this.value === other.value;\n        }\n        toString() {\n            return this.stringValue;\n        }\n    }\n    Mode$1.FOR_BITS = new Map();\n    Mode$1.FOR_VALUE = new Map();\n    Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...\n    Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);\n    Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);\n    Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported\n    Mode$1.BYTE = new Mode$1(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);\n    Mode$1.ECI = new Mode$1(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply\n    Mode$1.KANJI = new Mode$1(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);\n    Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);\n    Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);\n    /** See GBT 18284-2000; \"Hanzi\" is a transliteration of this mode name. */\n    Mode$1.HANZI = new Mode$1(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.io.UnsupportedEncodingException;*/\n    /*import java.util.ArrayList;*/\n    /*import java.util.Collection;*/\n    /*import java.util.List;*/\n    /*import java.util.Map;*/\n    /**\n     * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes\n     * in one QR Code. This class decodes the bits back into text.</p>\n     *\n     * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>\n     *\n     * @author Sean Owen\n     */\n    class DecodedBitStreamParser$1 {\n        static decode(bytes, version, ecLevel, hints) {\n            const bits = new BitSource(bytes);\n            let result = new StringBuilder();\n            const byteSegments = new Array(); // 1\n            // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below\n            let symbolSequence = -1;\n            let parityData = -1;\n            try {\n                let currentCharacterSetECI = null;\n                let fc1InEffect = false;\n                let mode;\n                do {\n                    // While still another segment to read...\n                    if (bits.available() < 4) {\n                        // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here\n                        mode = Mode$1.TERMINATOR;\n                    }\n                    else {\n                        const modeBits = bits.readBits(4);\n                        mode = Mode$1.forBits(modeBits); // mode is encoded by 4 bits\n                    }\n                    switch (mode) {\n                        case Mode$1.TERMINATOR:\n                            break;\n                        case Mode$1.FNC1_FIRST_POSITION:\n                        case Mode$1.FNC1_SECOND_POSITION:\n                            // We do little with FNC1 except alter the parsed result a bit according to the spec\n                            fc1InEffect = true;\n                            break;\n                        case Mode$1.STRUCTURED_APPEND:\n                            if (bits.available() < 16) {\n                                throw new FormatException();\n                            }\n                            // sequence number and parity is added later to the result metadata\n                            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue\n                            symbolSequence = bits.readBits(8);\n                            parityData = bits.readBits(8);\n                            break;\n                        case Mode$1.ECI:\n                            // Count doesn't apply to ECI\n                            const value = DecodedBitStreamParser$1.parseECIValue(bits);\n                            currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);\n                            if (currentCharacterSetECI === null) {\n                                throw new FormatException();\n                            }\n                            break;\n                        case Mode$1.HANZI:\n                            // First handle Hanzi mode which does not start with character count\n                            // Chinese mode contains a sub set indicator right after mode indicator\n                            const subset = bits.readBits(4);\n                            const countHanzi = bits.readBits(mode.getCharacterCountBits(version));\n                            if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {\n                                DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);\n                            }\n                            break;\n                        default:\n                            // \"Normal\" QR code modes:\n                            // How many characters will follow, encoded in this mode?\n                            const count = bits.readBits(mode.getCharacterCountBits(version));\n                            switch (mode) {\n                                case Mode$1.NUMERIC:\n                                    DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count);\n                                    break;\n                                case Mode$1.ALPHANUMERIC:\n                                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count, fc1InEffect);\n                                    break;\n                                case Mode$1.BYTE:\n                                    DecodedBitStreamParser$1.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);\n                                    break;\n                                case Mode$1.KANJI:\n                                    DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count);\n                                    break;\n                                default:\n                                    throw new FormatException();\n                            }\n                            break;\n                    }\n                } while (mode !== Mode$1.TERMINATOR);\n            }\n            catch (iae /*: IllegalArgumentException*/) {\n                // from readBits() calls\n                throw new FormatException();\n            }\n            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);\n        }\n        /**\n         * See specification GBT 18284-2000\n         */\n        static decodeHanziSegment(bits, result, count /*int*/) {\n            // Don't crash trying to read more bits than we have available.\n            if (count * 13 > bits.available()) {\n                throw new FormatException();\n            }\n            // Each character will require 2 bytes. Read the characters as 2-byte pairs\n            // and decode as GB2312 afterwards\n            const buffer = new Uint8Array(2 * count);\n            let offset = 0;\n            while (count > 0) {\n                // Each 13 bits encodes a 2-byte character\n                const twoBytes = bits.readBits(13);\n                let assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);\n                if (assembledTwoBytes < 0x003BF) {\n                    // In the 0xA1A1 to 0xAAFE range\n                    assembledTwoBytes += 0x0A1A1;\n                }\n                else {\n                    // In the 0xB0A1 to 0xFAFE range\n                    assembledTwoBytes += 0x0A6A1;\n                }\n                buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);\n                buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);\n                offset += 2;\n                count--;\n            }\n            try {\n                result.append(StringEncoding.decode(buffer, StringUtils.GB2312));\n                // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                throw new FormatException(ignored);\n            }\n        }\n        static decodeKanjiSegment(bits, result, count /*int*/) {\n            // Don't crash trying to read more bits than we have available.\n            if (count * 13 > bits.available()) {\n                throw new FormatException();\n            }\n            // Each character will require 2 bytes. Read the characters as 2-byte pairs\n            // and decode as Shift_JIS afterwards\n            const buffer = new Uint8Array(2 * count);\n            let offset = 0;\n            while (count > 0) {\n                // Each 13 bits encodes a 2-byte character\n                const twoBytes = bits.readBits(13);\n                let assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);\n                if (assembledTwoBytes < 0x01F00) {\n                    // In the 0x8140 to 0x9FFC range\n                    assembledTwoBytes += 0x08140;\n                }\n                else {\n                    // In the 0xE040 to 0xEBBF range\n                    assembledTwoBytes += 0x0C140;\n                }\n                buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);\n                buffer[offset + 1] = /*(byte) */ assembledTwoBytes;\n                offset += 2;\n                count--;\n            }\n            // Shift_JIS may not be supported in some environments:\n            try {\n                result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));\n                // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                throw new FormatException(ignored);\n            }\n        }\n        static decodeByteSegment(bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {\n            // Don't crash trying to read more bits than we have available.\n            if (8 * count > bits.available()) {\n                throw new FormatException();\n            }\n            const readBytes = new Uint8Array(count);\n            for (let i = 0; i < count; i++) {\n                readBytes[i] = /*(byte) */ bits.readBits(8);\n            }\n            let encoding;\n            if (currentCharacterSetECI === null) {\n                // The spec isn't clear on this mode; see\n                // section 6.4.5: t does not say which encoding to assuming\n                // upon decoding. I have seen ISO-8859-1 used as well as\n                // Shift_JIS -- without anything like an ECI designator to\n                // give a hint.\n                encoding = StringUtils.guessEncoding(readBytes, hints);\n            }\n            else {\n                encoding = currentCharacterSetECI.getName();\n            }\n            try {\n                result.append(StringEncoding.decode(readBytes, encoding));\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                throw new FormatException(ignored);\n            }\n            byteSegments.push(readBytes);\n        }\n        static toAlphaNumericChar(value /*int*/) {\n            if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {\n                throw new FormatException();\n            }\n            return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];\n        }\n        static decodeAlphanumericSegment(bits, result, count /*int*/, fc1InEffect) {\n            // Read two characters at a time\n            const start = result.length();\n            while (count > 1) {\n                if (bits.available() < 11) {\n                    throw new FormatException();\n                }\n                const nextTwoCharsBits = bits.readBits(11);\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));\n                count -= 2;\n            }\n            if (count === 1) {\n                // special case: one character left\n                if (bits.available() < 6) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));\n            }\n            // See section 6.4.8.1, 6.4.8.2\n            if (fc1InEffect) {\n                // We need to massage the result a bit if in an FNC1 mode:\n                for (let i = start; i < result.length(); i++) {\n                    if (result.charAt(i) === '%') {\n                        if (i < result.length() - 1 && result.charAt(i + 1) === '%') {\n                            // %% is rendered as %\n                            result.deleteCharAt(i + 1);\n                        }\n                        else {\n                            // In alpha mode, % should be converted to FNC1 separator 0x1D\n                            result.setCharAt(i, String.fromCharCode(0x1D));\n                        }\n                    }\n                }\n            }\n        }\n        static decodeNumericSegment(bits, result, count /*int*/) {\n            // Read three digits at a time\n            while (count >= 3) {\n                // Each 10 bits encodes three digits\n                if (bits.available() < 10) {\n                    throw new FormatException();\n                }\n                const threeDigitsBits = bits.readBits(10);\n                if (threeDigitsBits >= 1000) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));\n                count -= 3;\n            }\n            if (count === 2) {\n                // Two digits left over to read, encoded in 7 bits\n                if (bits.available() < 7) {\n                    throw new FormatException();\n                }\n                const twoDigitsBits = bits.readBits(7);\n                if (twoDigitsBits >= 100) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));\n            }\n            else if (count === 1) {\n                // One digit left over to read\n                if (bits.available() < 4) {\n                    throw new FormatException();\n                }\n                const digitBits = bits.readBits(4);\n                if (digitBits >= 10) {\n                    throw new FormatException();\n                }\n                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));\n            }\n        }\n        static parseECIValue(bits) {\n            const firstByte = bits.readBits(8);\n            if ((firstByte & 0x80) === 0) {\n                // just one byte\n                return firstByte & 0x7F;\n            }\n            if ((firstByte & 0xC0) === 0x80) {\n                // two bytes\n                const secondByte = bits.readBits(8);\n                return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;\n            }\n            if ((firstByte & 0xE0) === 0xC0) {\n                // three bytes\n                const secondThirdBytes = bits.readBits(16);\n                return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;\n            }\n            throw new FormatException();\n        }\n    }\n    /**\n     * See ISO 18004:2006, 6.4.4 Table 5\n     */\n    DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n    DecodedBitStreamParser$1.GB2312_SUBSET = 1;\n    // function Uint8ArrayToString(a: Uint8Array): string {\n    //     const CHUNK_SZ = 0x8000;\n    //     const c = new StringBuilder();\n    //     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {\n    //         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));\n    //     }\n    //     return c.toString();\n    // }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the\n     * decoding caller. Callers are expected to process this.\n     *\n     * @see com.google.zxing.common.DecoderResult#getOther()\n     */\n    class QRCodeDecoderMetaData {\n        constructor(mirrored) {\n            this.mirrored = mirrored;\n        }\n        /**\n         * @return true if the QR Code was mirrored.\n         */\n        isMirrored() {\n            return this.mirrored;\n        }\n        /**\n         * Apply the result points' order correction due to mirroring.\n         *\n         * @param points Array of points to apply mirror correction to.\n         */\n        applyMirroredCorrection(points) {\n            if (!this.mirrored || points === null || points.length < 3) {\n                return;\n            }\n            const bottomLeft = points[0];\n            points[0] = points[2];\n            points[2] = bottomLeft;\n            // No need to 'fix' top-left and alignment pattern.\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.Map;*/\n    /**\n     * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting\n     * the QR Code from an image.</p>\n     *\n     * @author Sean Owen\n     */\n    class Decoder$2 {\n        constructor() {\n            this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);\n        }\n        // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {\n        //   return decode(image, null)\n        // }\n        /**\n         * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.\n         * \"true\" is taken to mean a black module.</p>\n         *\n         * @param image booleans representing white/black QR Code modules\n         * @param hints decoding hints that should be used to influence decoding\n         * @return text and bytes encoded within the QR Code\n         * @throws FormatException if the QR Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        decodeBooleanArray(image, hints) {\n            return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);\n        }\n        // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {\n        //   return decode(bits, null)\n        // }\n        /**\n         * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or \"true\" is taken to mean a black module.</p>\n         *\n         * @param bits booleans representing white/black QR Code modules\n         * @param hints decoding hints that should be used to influence decoding\n         * @return text and bytes encoded within the QR Code\n         * @throws FormatException if the QR Code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        decodeBitMatrix(bits, hints) {\n            // Construct a parser and read version, error-correction level\n            const parser = new BitMatrixParser$1(bits);\n            let ex = null;\n            try {\n                return this.decodeBitMatrixParser(parser, hints);\n            }\n            catch (e /*: FormatException, ChecksumException*/) {\n                ex = e;\n            }\n            try {\n                // Revert the bit matrix\n                parser.remask();\n                // Will be attempting a mirrored reading of the version and format info.\n                parser.setMirror(true);\n                // Preemptively read the version.\n                parser.readVersion();\n                // Preemptively read the format information.\n                parser.readFormatInformation();\n                /*\n                 * Since we're here, this means we have successfully detected some kind\n                 * of version and format information when mirrored. This is a good sign,\n                 * that the QR code may be mirrored, and we should try once more with a\n                 * mirrored content.\n                 */\n                // Prepare for a mirrored reading.\n                parser.mirror();\n                const result = this.decodeBitMatrixParser(parser, hints);\n                // Success! Notify the caller that the code was mirrored.\n                result.setOther(new QRCodeDecoderMetaData(true));\n                return result;\n            }\n            catch (e /*FormatException | ChecksumException*/) {\n                // Throw the exception from the original reading\n                if (ex !== null) {\n                    throw ex;\n                }\n                throw e;\n            }\n        }\n        decodeBitMatrixParser(parser, hints) {\n            const version = parser.readVersion();\n            const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();\n            // Read codewords\n            const codewords = parser.readCodewords();\n            // Separate into data blocks\n            const dataBlocks = DataBlock$1.getDataBlocks(codewords, version, ecLevel);\n            // Count total number of data bytes\n            let totalBytes = 0;\n            for (const dataBlock of dataBlocks) {\n                totalBytes += dataBlock.getNumDataCodewords();\n            }\n            const resultBytes = new Uint8Array(totalBytes);\n            let resultOffset = 0;\n            // Error-correct and copy data blocks together into a stream of bytes\n            for (const dataBlock of dataBlocks) {\n                const codewordBytes = dataBlock.getCodewords();\n                const numDataCodewords = dataBlock.getNumDataCodewords();\n                this.correctErrors(codewordBytes, numDataCodewords);\n                for (let i = 0; i < numDataCodewords; i++) {\n                    resultBytes[resultOffset++] = codewordBytes[i];\n                }\n            }\n            // Decode the contents of that stream of bytes\n            return DecodedBitStreamParser$1.decode(resultBytes, version, ecLevel, hints);\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place using Reed-Solomon error correction.</p>\n         *\n         * @param codewordBytes data and error correction codewords\n         * @param numDataCodewords number of codewords that are data bytes\n         * @throws ChecksumException if error correction fails\n         */\n        correctErrors(codewordBytes, numDataCodewords /*int*/) {\n            // const numCodewords = codewordBytes.length;\n            // First read into an array of ints\n            const codewordsInts = new Int32Array(codewordBytes);\n            // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?\n            // const codewordsInts = new Int32Array(numCodewords)\n            // for (let i = 0; i < numCodewords; i++) {\n            //   codewordsInts[i] = codewordBytes[i] & 0xFF\n            // }\n            try {\n                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);\n            }\n            catch (ignored /*: ReedSolomonException*/) {\n                throw new ChecksumException();\n            }\n            // Copy back into array of bytes -- only need to worry about the bytes that were data\n            // We don't care about errors in the error-correction codewords\n            for (let i = 0; i < numDataCodewords; i++) {\n                codewordBytes[i] = /*(byte) */ codewordsInts[i];\n            }\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in\n     * all but the simplest QR Codes.</p>\n     *\n     * @author Sean Owen\n     */\n    class AlignmentPattern extends ResultPoint {\n        constructor(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {\n            super(posX, posY);\n            this.estimatedModuleSize = estimatedModuleSize;\n        }\n        /**\n         * <p>Determines if this alignment pattern \"about equals\" an alignment pattern at the stated\n         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n         */\n        aboutEquals(moduleSize /*float*/, i /*float*/, j /*float*/) {\n            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n            }\n            return false;\n        }\n        /**\n         * Combines this object's current estimate of a finder pattern position and module size\n         * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.\n         */\n        combineEstimate(i /*float*/, j /*float*/, newModuleSize /*float*/) {\n            const combinedX = (this.getX() + j) / 2.0;\n            const combinedY = (this.getY() + i) / 2.0;\n            const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;\n            return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.ArrayList;*/\n    /*import java.util.List;*/\n    /**\n     * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder\n     * patterns but are smaller and appear at regular intervals throughout the image.</p>\n     *\n     * <p>At the moment this only looks for the bottom-right alignment pattern.</p>\n     *\n     * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,\n     * pasted and stripped down here for maximum performance but does unfortunately duplicate\n     * some code.</p>\n     *\n     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>\n     *\n     * @author Sean Owen\n     */\n    class AlignmentPatternFinder {\n        /**\n         * <p>Creates a finder that will look in a portion of the whole image.</p>\n         *\n         * @param image image to search\n         * @param startX left column from which to start searching\n         * @param startY top row from which to start searching\n         * @param width width of region to search\n         * @param height height of region to search\n         * @param moduleSize estimated module size so far\n         */\n        constructor(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {\n            this.image = image;\n            this.startX = startX;\n            this.startY = startY;\n            this.width = width;\n            this.height = height;\n            this.moduleSize = moduleSize;\n            this.resultPointCallback = resultPointCallback;\n            this.possibleCenters = []; // new Array<any>(5))\n            // TYPESCRIPTPORT: array initialization without size as the length is checked below\n            this.crossCheckStateCount = new Int32Array(3);\n        }\n        /**\n         * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since\n         * it's pretty performance-critical and so is written to be fast foremost.</p>\n         *\n         * @return {@link AlignmentPattern} if found\n         * @throws NotFoundException if not found\n         */\n        find() {\n            const startX = this.startX;\n            const height = this.height;\n            const width = this.width;\n            const maxJ = startX + width;\n            const middleI = this.startY + (height / 2);\n            // We are looking for black/white/black modules in 1:1:1 ratio\n            // this tracks the number of black/white/black modules seen so far\n            const stateCount = new Int32Array(3);\n            const image = this.image;\n            for (let iGen = 0; iGen < height; iGen++) {\n                // Search from middle outwards\n                const i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));\n                stateCount[0] = 0;\n                stateCount[1] = 0;\n                stateCount[2] = 0;\n                let j = startX;\n                // Burn off leading white pixels before anything else; if we start in the middle of\n                // a white run, it doesn't make sense to count its length, since we don't know if the\n                // white run continued to the left of the start point\n                while (j < maxJ && !image.get(j, i)) {\n                    j++;\n                }\n                let currentState = 0;\n                while (j < maxJ) {\n                    if (image.get(j, i)) {\n                        // Black pixel\n                        if (currentState === 1) { // Counting black pixels\n                            stateCount[1]++;\n                        }\n                        else { // Counting white pixels\n                            if (currentState === 2) { // A winner?\n                                if (this.foundPatternCross(stateCount)) { // Yes\n                                    const confirmed = this.handlePossibleCenter(stateCount, i, j);\n                                    if (confirmed !== null) {\n                                        return confirmed;\n                                    }\n                                }\n                                stateCount[0] = stateCount[2];\n                                stateCount[1] = 1;\n                                stateCount[2] = 0;\n                                currentState = 1;\n                            }\n                            else {\n                                stateCount[++currentState]++;\n                            }\n                        }\n                    }\n                    else { // White pixel\n                        if (currentState === 1) { // Counting black pixels\n                            currentState++;\n                        }\n                        stateCount[currentState]++;\n                    }\n                    j++;\n                }\n                if (this.foundPatternCross(stateCount)) {\n                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n                    if (confirmed !== null) {\n                        return confirmed;\n                    }\n                }\n            }\n            // Hmm, nothing we saw was observed and confirmed twice. If we had\n            // any guess at all, return it.\n            if (this.possibleCenters.length !== 0) {\n                return this.possibleCenters[0];\n            }\n            throw new NotFoundException();\n        }\n        /**\n         * Given a count of black/white/black pixels just seen and an end position,\n         * figures the location of the center of this black/white/black run.\n         */\n        static centerFromEnd(stateCount, end /*int*/) {\n            return (end - stateCount[2]) - stateCount[1] / 2.0;\n        }\n        /**\n         * @param stateCount count of black/white/black pixels just read\n         * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios\n         *         used by alignment patterns to be considered a match\n         */\n        foundPatternCross(stateCount) {\n            const moduleSize = this.moduleSize;\n            const maxVariance = moduleSize / 2.0;\n            for (let i = 0; i < 3; i++) {\n                if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * <p>After a horizontal scan finds a potential alignment pattern, this method\n         * \"cross-checks\" by scanning down vertically through the center of the possible\n         * alignment pattern to see if the same proportion is detected.</p>\n         *\n         * @param startI row where an alignment pattern was detected\n         * @param centerJ center of the section that appears to cross an alignment pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         * observed in any reading state, based on the results of the horizontal scan\n         * @return vertical center of alignment pattern, or {@link Float#NaN} if not found\n         */\n        crossCheckVertical(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const image = this.image;\n            const maxI = image.getHeight();\n            const stateCount = this.crossCheckStateCount;\n            stateCount[0] = 0;\n            stateCount[1] = 0;\n            stateCount[2] = 0;\n            // Start counting up from center\n            let i = startI;\n            while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i--;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (i < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                i--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            // Now also count down from center\n            i = startI + 1;\n            while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i++;\n            }\n            if (i === maxI || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n                stateCount[2]++;\n                i++;\n            }\n            if (stateCount[2] > maxCount) {\n                return NaN;\n            }\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n                return NaN;\n            }\n            return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;\n        }\n        /**\n         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n         * cross check with a vertical scan, and if successful, will see if this pattern had been\n         * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have\n         * found the alignment pattern.</p>\n         *\n         * @param stateCount reading state module counts from horizontal scan\n         * @param i row where alignment pattern may be found\n         * @param j end of possible alignment pattern in row\n         * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not\n         */\n        handlePossibleCenter(stateCount, i /*int*/, j /*int*/) {\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n            const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);\n            const centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);\n            if (!isNaN(centerI)) {\n                const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n                for (const center of this.possibleCenters) {\n                    // Look for about the same center and module size:\n                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                    }\n                }\n                // Hadn't found this before; save it\n                const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n                this.possibleCenters.push(point);\n                if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                    this.resultPointCallback.foundPossibleResultPoint(point);\n                }\n            }\n            return null;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates a finder pattern, which are the three square patterns found in\n     * the corners of QR Codes. It also encapsulates a count of similar finder patterns,\n     * as a convenience to the finder's bookkeeping.</p>\n     *\n     * @author Sean Owen\n     */\n    class FinderPattern$1 extends ResultPoint {\n        // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {\n        //   this(posX, posY, estimatedModuleSize, 1)\n        // }\n        constructor(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {\n            super(posX, posY);\n            this.estimatedModuleSize = estimatedModuleSize;\n            this.count = count;\n            if (undefined === count) {\n                this.count = 1;\n            }\n        }\n        getEstimatedModuleSize() {\n            return this.estimatedModuleSize;\n        }\n        getCount() {\n            return this.count;\n        }\n        /*\n        void incrementCount() {\n          this.count++\n        }\n         */\n        /**\n         * <p>Determines if this finder pattern \"about equals\" a finder pattern at the stated\n         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>\n         */\n        aboutEquals(moduleSize /*float*/, i /*float*/, j /*float*/) {\n            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {\n                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);\n                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;\n            }\n            return false;\n        }\n        /**\n         * Combines this object's current estimate of a finder pattern position and module size\n         * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average\n         * based on count.\n         */\n        combineEstimate(i /*float*/, j /*float*/, newModuleSize /*float*/) {\n            const combinedCount = this.count + 1;\n            const combinedX = (this.count * this.getX() + j) / combinedCount;\n            const combinedY = (this.count * this.getY() + i) / combinedCount;\n            const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;\n            return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>Encapsulates information about finder patterns in an image, including the location of\n     * the three finder patterns, and their estimated module size.</p>\n     *\n     * @author Sean Owen\n     */\n    class FinderPatternInfo {\n        constructor(patternCenters) {\n            this.bottomLeft = patternCenters[0];\n            this.topLeft = patternCenters[1];\n            this.topRight = patternCenters[2];\n        }\n        getBottomLeft() {\n            return this.bottomLeft;\n        }\n        getTopLeft() {\n            return this.topLeft;\n        }\n        getTopRight() {\n            return this.topRight;\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.io.Serializable;*/\n    /*import java.util.ArrayList;*/\n    /*import java.util.Collections;*/\n    /*import java.util.Comparator;*/\n    /*import java.util.List;*/\n    /*import java.util.Map;*/\n    /**\n     * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square\n     * markers at three corners of a QR Code.</p>\n     *\n     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.\n     *\n     * @author Sean Owen\n     */\n    class FinderPatternFinder {\n        /**\n         * <p>Creates a finder that will search the image for three finder patterns.</p>\n         *\n         * @param image image to search\n         */\n        // public constructor(image: BitMatrix) {\n        //   this(image, null)\n        // }\n        constructor(image, resultPointCallback) {\n            this.image = image;\n            this.resultPointCallback = resultPointCallback;\n            this.possibleCenters = [];\n            this.crossCheckStateCount = new Int32Array(5);\n            this.resultPointCallback = resultPointCallback;\n        }\n        getImage() {\n            return this.image;\n        }\n        getPossibleCenters() {\n            return this.possibleCenters;\n        }\n        find(hints) {\n            const tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType$1.TRY_HARDER);\n            const pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE);\n            const image = this.image;\n            const maxI = image.getHeight();\n            const maxJ = image.getWidth();\n            // We are looking for black/white/black/white/black modules in\n            // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far\n            // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the\n            // image, and then account for the center being 3 modules in size. This gives the smallest\n            // number of pixels the center could be, so skip this often. When trying harder, look for all\n            // QR versions regardless of how dense they are.\n            let iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));\n            if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {\n                iSkip = FinderPatternFinder.MIN_SKIP;\n            }\n            let done = false;\n            const stateCount = new Int32Array(5);\n            for (let i = iSkip - 1; i < maxI && !done; i += iSkip) {\n                // Get a row of black/white values\n                stateCount[0] = 0;\n                stateCount[1] = 0;\n                stateCount[2] = 0;\n                stateCount[3] = 0;\n                stateCount[4] = 0;\n                let currentState = 0;\n                for (let j = 0; j < maxJ; j++) {\n                    if (image.get(j, i)) {\n                        // Black pixel\n                        if ((currentState & 1) === 1) { // Counting white pixels\n                            currentState++;\n                        }\n                        stateCount[currentState]++;\n                    }\n                    else { // White pixel\n                        if ((currentState & 1) === 0) { // Counting black pixels\n                            if (currentState === 4) { // A winner?\n                                if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes\n                                    const confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);\n                                    if (confirmed === true) {\n                                        // Start examining every other line. Checking each line turned out to be too\n                                        // expensive and didn't improve performance.\n                                        iSkip = 2;\n                                        if (this.hasSkipped === true) {\n                                            done = this.haveMultiplyConfirmedCenters();\n                                        }\n                                        else {\n                                            const rowSkip = this.findRowSkip();\n                                            if (rowSkip > stateCount[2]) {\n                                                // Skip rows between row of lower confirmed center\n                                                // and top of presumed third confirmed center\n                                                // but back up a bit to get a full chance of detecting\n                                                // it, entire width of center of finder pattern\n                                                // Skip by rowSkip, but back off by stateCount[2] (size of last center\n                                                // of pattern we saw) to be conservative, and also back off by iSkip which\n                                                // is about to be re-added\n                                                i += rowSkip - stateCount[2] - iSkip;\n                                                j = maxJ - 1;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        stateCount[0] = stateCount[2];\n                                        stateCount[1] = stateCount[3];\n                                        stateCount[2] = stateCount[4];\n                                        stateCount[3] = 1;\n                                        stateCount[4] = 0;\n                                        currentState = 3;\n                                        continue;\n                                    }\n                                    // Clear state to start looking again\n                                    currentState = 0;\n                                    stateCount[0] = 0;\n                                    stateCount[1] = 0;\n                                    stateCount[2] = 0;\n                                    stateCount[3] = 0;\n                                    stateCount[4] = 0;\n                                }\n                                else { // No, shift counts back by two\n                                    stateCount[0] = stateCount[2];\n                                    stateCount[1] = stateCount[3];\n                                    stateCount[2] = stateCount[4];\n                                    stateCount[3] = 1;\n                                    stateCount[4] = 0;\n                                    currentState = 3;\n                                }\n                            }\n                            else {\n                                stateCount[++currentState]++;\n                            }\n                        }\n                        else { // Counting white pixels\n                            stateCount[currentState]++;\n                        }\n                    }\n                }\n                if (FinderPatternFinder.foundPatternCross(stateCount)) {\n                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);\n                    if (confirmed === true) {\n                        iSkip = stateCount[0];\n                        if (this.hasSkipped) {\n                            // Found a third one\n                            done = this.haveMultiplyConfirmedCenters();\n                        }\n                    }\n                }\n            }\n            const patternInfo = this.selectBestPatterns();\n            ResultPoint.orderBestPatterns(patternInfo);\n            return new FinderPatternInfo(patternInfo);\n        }\n        /**\n         * Given a count of black/white/black/white/black pixels just seen and an end position,\n         * figures the location of the center of this run.\n         */\n        static centerFromEnd(stateCount, end /*int*/) {\n            return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;\n        }\n        /**\n         * @param stateCount count of black/white/black/white/black pixels just read\n         * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios\n         *         used by finder patterns to be considered a match\n         */\n        static foundPatternCross(stateCount) {\n            let totalModuleSize = 0;\n            for (let i = 0; i < 5; i++) {\n                const count = stateCount[i];\n                if (count === 0) {\n                    return false;\n                }\n                totalModuleSize += count;\n            }\n            if (totalModuleSize < 7) {\n                return false;\n            }\n            const moduleSize = totalModuleSize / 7.0;\n            const maxVariance = moduleSize / 2.0;\n            // Allow less than 50% variance from 1-1-3-1-1 proportions\n            return Math.abs(moduleSize - stateCount[0]) < maxVariance &&\n                Math.abs(moduleSize - stateCount[1]) < maxVariance &&\n                Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&\n                Math.abs(moduleSize - stateCount[3]) < maxVariance &&\n                Math.abs(moduleSize - stateCount[4]) < maxVariance;\n        }\n        getCrossCheckStateCount() {\n            const crossCheckStateCount = this.crossCheckStateCount;\n            crossCheckStateCount[0] = 0;\n            crossCheckStateCount[1] = 0;\n            crossCheckStateCount[2] = 0;\n            crossCheckStateCount[3] = 0;\n            crossCheckStateCount[4] = 0;\n            return crossCheckStateCount;\n        }\n        /**\n         * After a vertical and horizontal scan finds a potential finder pattern, this method\n         * \"cross-cross-cross-checks\" by scanning down diagonally through the center of the possible\n         * finder pattern to see if the same proportion is detected.\n         *\n         * @param startI row where a finder pattern was detected\n         * @param centerJ center of the section that appears to cross a finder pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         *  observed in any reading state, based on the results of the horizontal scan\n         * @param originalStateCountTotal The original state count total.\n         * @return true if proportions are withing expected limits\n         */\n        crossCheckDiagonal(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const stateCount = this.getCrossCheckStateCount();\n            // Start counting up, left from center finding black center mass\n            let i = 0;\n            const image = this.image;\n            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {\n                stateCount[2]++;\n                i++;\n            }\n            if (startI < i || centerJ < i) {\n                return false;\n            }\n            // Continue up, left finding white space\n            while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&\n                stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i++;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (startI < i || centerJ < i || stateCount[1] > maxCount) {\n                return false;\n            }\n            // Continue up, left finding black border\n            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&\n                stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                i++;\n            }\n            if (stateCount[0] > maxCount) {\n                return false;\n            }\n            const maxI = image.getHeight();\n            const maxJ = image.getWidth();\n            // Now also count down, right from center\n            i = 1;\n            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {\n                stateCount[2]++;\n                i++;\n            }\n            // Ran off the edge?\n            if (startI + i >= maxI || centerJ + i >= maxJ) {\n                return false;\n            }\n            while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&\n                stateCount[3] < maxCount) {\n                stateCount[3]++;\n                i++;\n            }\n            if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {\n                return false;\n            }\n            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&\n                stateCount[4] < maxCount) {\n                stateCount[4]++;\n                i++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return false;\n            }\n            // If we found a finder-pattern-like section, but its size is more than 100% different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];\n            return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&\n                FinderPatternFinder.foundPatternCross(stateCount);\n        }\n        /**\n         * <p>After a horizontal scan finds a potential finder pattern, this method\n         * \"cross-checks\" by scanning down vertically through the center of the possible\n         * finder pattern to see if the same proportion is detected.</p>\n         *\n         * @param startI row where a finder pattern was detected\n         * @param centerJ center of the section that appears to cross a finder pattern\n         * @param maxCount maximum reasonable number of modules that should be\n         * observed in any reading state, based on the results of the horizontal scan\n         * @return vertical center of finder pattern, or {@link Float#NaN} if not found\n         */\n        crossCheckVertical(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const image = this.image;\n            const maxI = image.getHeight();\n            const stateCount = this.getCrossCheckStateCount();\n            // Start counting up from center\n            let i = startI;\n            while (i >= 0 && image.get(centerJ, i)) {\n                stateCount[2]++;\n                i--;\n            }\n            if (i < 0) {\n                return NaN;\n            }\n            while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                i--;\n            }\n            // If already too many modules in this state or ran off the edge:\n            if (i < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                i--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            // Now also count down from center\n            i = startI + 1;\n            while (i < maxI && image.get(centerJ, i)) {\n                stateCount[2]++;\n                i++;\n            }\n            if (i === maxI) {\n                return NaN;\n            }\n            while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {\n                stateCount[3]++;\n                i++;\n            }\n            if (i === maxI || stateCount[3] >= maxCount) {\n                return NaN;\n            }\n            while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {\n                stateCount[4]++;\n                i++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return NaN;\n            }\n            // If we found a finder-pattern-like section, but its size is more than 40% different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n                stateCount[4];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n                return NaN;\n            }\n            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;\n        }\n        /**\n         * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,\n         * except it reads horizontally instead of vertically. This is used to cross-cross\n         * check a vertical cross check and locate the real center of the alignment pattern.</p>\n         */\n        crossCheckHorizontal(startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n            const image = this.image;\n            const maxJ = image.getWidth();\n            const stateCount = this.getCrossCheckStateCount();\n            let j = startJ;\n            while (j >= 0 && image.get(j, centerI)) {\n                stateCount[2]++;\n                j--;\n            }\n            if (j < 0) {\n                return NaN;\n            }\n            while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {\n                stateCount[1]++;\n                j--;\n            }\n            if (j < 0 || stateCount[1] > maxCount) {\n                return NaN;\n            }\n            while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {\n                stateCount[0]++;\n                j--;\n            }\n            if (stateCount[0] > maxCount) {\n                return NaN;\n            }\n            j = startJ + 1;\n            while (j < maxJ && image.get(j, centerI)) {\n                stateCount[2]++;\n                j++;\n            }\n            if (j === maxJ) {\n                return NaN;\n            }\n            while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {\n                stateCount[3]++;\n                j++;\n            }\n            if (j === maxJ || stateCount[3] >= maxCount) {\n                return NaN;\n            }\n            while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {\n                stateCount[4]++;\n                j++;\n            }\n            if (stateCount[4] >= maxCount) {\n                return NaN;\n            }\n            // If we found a finder-pattern-like section, but its size is significantly different than\n            // the original, assume it's a false positive\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n                stateCount[4];\n            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {\n                return NaN;\n            }\n            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;\n        }\n        /**\n         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n         * cross check with a vertical scan, and if successful, will, ah, cross-cross-check\n         * with another horizontal scan. This is needed primarily to locate the real horizontal\n         * center of the pattern in cases of extreme skew.\n         * And then we cross-cross-cross check with another diagonal scan.</p>\n         *\n         * <p>If that succeeds the finder pattern location is added to a list that tracks\n         * the number of times each location has been nearly-matched as a finder pattern.\n         * Each additional find is more evidence that the location is in fact a finder\n         * pattern center\n         *\n         * @param stateCount reading state module counts from horizontal scan\n         * @param i row where finder pattern may be found\n         * @param j end of possible finder pattern in row\n         * @param pureBarcode true if in \"pure barcode\" mode\n         * @return true if a finder pattern candidate was found this time\n         */\n        handlePossibleCenter(stateCount, i /*int*/, j /*int*/, pureBarcode) {\n            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +\n                stateCount[4];\n            let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);\n            let centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);\n            if (!isNaN(centerI)) {\n                // Re-cross check\n                centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);\n                if (!isNaN(centerJ) &&\n                    (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {\n                    const estimatedModuleSize = stateCountTotal / 7.0;\n                    let found = false;\n                    const possibleCenters = this.possibleCenters;\n                    for (let index = 0, length = possibleCenters.length; index < length; index++) {\n                        const center = possibleCenters[index];\n                        // Look for about the same center and module size:\n                        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n                            possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);\n                        possibleCenters.push(point);\n                        if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n                            this.resultPointCallback.foundPossibleResultPoint(point);\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * @return number of rows we could safely skip during scanning, based on the first\n         *         two finder patterns that have been located. In some cases their position will\n         *         allow us to infer that the third pattern must lie below a certain point farther\n         *         down in the image.\n         */\n        findRowSkip() {\n            const max = this.possibleCenters.length;\n            if (max <= 1) {\n                return 0;\n            }\n            let firstConfirmedCenter = null;\n            for (const center of this.possibleCenters) {\n                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    if (firstConfirmedCenter == null) {\n                        firstConfirmedCenter = center;\n                    }\n                    else {\n                        // We have two confirmed centers\n                        // How far down can we skip before resuming looking for the next\n                        // pattern? In the worst case, only the difference between the\n                        // difference in the x / y coordinates of the two centers.\n                        // This is the case where you find top left last.\n                        this.hasSkipped = true;\n                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -\n                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);\n                    }\n                }\n            }\n            return 0;\n        }\n        /**\n         * @return true iff we have found at least 3 finder patterns that have been detected\n         *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the\n         *         candidates is \"pretty similar\"\n         */\n        haveMultiplyConfirmedCenters() {\n            let confirmedCount = 0;\n            let totalModuleSize = 0.0;\n            const max = this.possibleCenters.length;\n            for (const pattern of this.possibleCenters) {\n                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {\n                    confirmedCount++;\n                    totalModuleSize += pattern.getEstimatedModuleSize();\n                }\n            }\n            if (confirmedCount < 3) {\n                return false;\n            }\n            // OK, we have at least 3 confirmed centers, but, it's possible that one is a \"false positive\"\n            // and that we need to keep looking. We detect this by asking if the estimated module sizes\n            // vary too much. We arbitrarily say that when the total deviation from average exceeds\n            // 5% of the total module size estimates, it's too much.\n            const average = totalModuleSize / max;\n            let totalDeviation = 0.0;\n            for (const pattern of this.possibleCenters) {\n                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);\n            }\n            return totalDeviation <= 0.05 * totalModuleSize;\n        }\n        /**\n         * @return the 3 best {@link FinderPattern}s from our list of candidates. The \"best\" are\n         *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module\n         *         size differs from the average among those patterns the least\n         * @throws NotFoundException if 3 such finder patterns do not exist\n         */\n        selectBestPatterns() {\n            const startSize = this.possibleCenters.length;\n            if (startSize < 3) {\n                // Couldn't find enough finder patterns\n                throw new NotFoundException();\n            }\n            const possibleCenters = this.possibleCenters;\n            let average;\n            // Filter outlier possibilities whose module size is too different\n            if (startSize > 3) {\n                // But we can only afford to do so if we have at least 4 possibilities to choose from\n                let totalModuleSize = 0.0;\n                let square = 0.0;\n                for (const center of this.possibleCenters) {\n                    const size = center.getEstimatedModuleSize();\n                    totalModuleSize += size;\n                    square += size * size;\n                }\n                average = totalModuleSize / startSize;\n                let stdDev = Math.sqrt(square / startSize - average * average);\n                possibleCenters.sort(\n                /**\n                 * <p>Orders by furthest from average</p>\n                 */\n                // FurthestFromAverageComparator implements Comparator<FinderPattern>\n                (center1, center2) => {\n                    const dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                    const dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                    return dA < dB ? -1 : dA > dB ? 1 : 0;\n                });\n                const limit = Math.max(0.2 * average, stdDev);\n                for (let i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {\n                    const pattern = possibleCenters[i];\n                    if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {\n                        possibleCenters.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n            if (possibleCenters.length > 3) {\n                // Throw away all but those first size candidate points we found.\n                let totalModuleSize = 0.0;\n                for (const possibleCenter of possibleCenters) {\n                    totalModuleSize += possibleCenter.getEstimatedModuleSize();\n                }\n                average = totalModuleSize / possibleCenters.length;\n                possibleCenters.sort(\n                /**\n                 * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>\n                 */\n                // CenterComparator implements Comparator<FinderPattern>\n                (center1, center2) => {\n                    if (center2.getCount() === center1.getCount()) {\n                        const dA = Math.abs(center2.getEstimatedModuleSize() - average);\n                        const dB = Math.abs(center1.getEstimatedModuleSize() - average);\n                        return dA < dB ? 1 : dA > dB ? -1 : 0;\n                    }\n                    else {\n                        return center2.getCount() - center1.getCount();\n                    }\n                });\n                possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway\n            }\n            return [\n                possibleCenters[0],\n                possibleCenters[1],\n                possibleCenters[2]\n            ];\n        }\n    }\n    FinderPatternFinder.CENTER_QUORUM = 2;\n    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center\n    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.Map;*/\n    /**\n     * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code\n     * is rotated or skewed, or partially obscured.</p>\n     *\n     * @author Sean Owen\n     */\n    class Detector$2 {\n        constructor(image) {\n            this.image = image;\n        }\n        getImage() {\n            return this.image;\n        }\n        getResultPointCallback() {\n            return this.resultPointCallback;\n        }\n        /**\n         * <p>Detects a QR Code in an image.</p>\n         *\n         * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n         * @throws NotFoundException if QR Code cannot be found\n         * @throws FormatException if a QR Code cannot be decoded\n         */\n        // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {\n        //   return detect(null)\n        // }\n        /**\n         * <p>Detects a QR Code in an image.</p>\n         *\n         * @param hints optional hints to detector\n         * @return {@link DetectorResult} encapsulating results of detecting a QR Code\n         * @throws NotFoundException if QR Code cannot be found\n         * @throws FormatException if a QR Code cannot be decoded\n         */\n        detect(hints) {\n            this.resultPointCallback = (hints === null || hints === undefined) ? null :\n                /*(ResultPointCallback) */ hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);\n            const finder = new FinderPatternFinder(this.image, this.resultPointCallback);\n            const info = finder.find(hints);\n            return this.processFinderPatternInfo(info);\n        }\n        processFinderPatternInfo(info) {\n            const topLeft = info.getTopLeft();\n            const topRight = info.getTopRight();\n            const bottomLeft = info.getBottomLeft();\n            const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);\n            if (moduleSize < 1.0) {\n                throw new NotFoundException('No pattern found in proccess finder.');\n            }\n            const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);\n            const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);\n            const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;\n            let alignmentPattern = null;\n            // Anything above version 1 has an alignment pattern\n            if (provisionalVersion.getAlignmentPatternCenters().length > 0) {\n                // Guess where a \"bottom right\" finder pattern would have been\n                const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();\n                const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();\n                // Estimate that alignment pattern is closer by 3 modules\n                // from \"bottom right\" to known top left location\n                const correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;\n                const estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));\n                const estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));\n                // Kind of arbitrary -- expand search radius before giving up\n                for (let i = 4; i <= 16; i <<= 1) {\n                    try {\n                        alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);\n                        break;\n                    }\n                    catch (re /*NotFoundException*/) {\n                        if (!(re instanceof NotFoundException)) {\n                            throw re;\n                        }\n                        // try next round\n                    }\n                }\n                // If we didn't find alignment pattern... well try anyway without it\n            }\n            const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);\n            const bits = Detector$2.sampleGrid(this.image, transform, dimension);\n            let points;\n            if (alignmentPattern === null) {\n                points = [bottomLeft, topLeft, topRight];\n            }\n            else {\n                points = [bottomLeft, topLeft, topRight, alignmentPattern];\n            }\n            return new DetectorResult(bits, points);\n        }\n        static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {\n            const dimMinusThree = dimension - 3.5;\n            let bottomRightX; /*float*/\n            let bottomRightY; /*float*/\n            let sourceBottomRightX; /*float*/\n            let sourceBottomRightY; /*float*/\n            if (alignmentPattern !== null) {\n                bottomRightX = alignmentPattern.getX();\n                bottomRightY = alignmentPattern.getY();\n                sourceBottomRightX = dimMinusThree - 3.0;\n                sourceBottomRightY = sourceBottomRightX;\n            }\n            else {\n                // Don't have an alignment pattern, just make up the bottom-right point\n                bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();\n                bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();\n                sourceBottomRightX = dimMinusThree;\n                sourceBottomRightY = dimMinusThree;\n            }\n            return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());\n        }\n        static sampleGrid(image, transform, dimension /*int*/) {\n            const sampler = GridSamplerInstance.getInstance();\n            return sampler.sampleGridWithTransform(image, dimension, dimension, transform);\n        }\n        /**\n         * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position\n         * of the finder patterns and estimated module size.</p>\n         */\n        static computeDimension(topLeft, topRight, bottomLeft, moduleSize /*float*/) {\n            const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);\n            const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);\n            let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;\n            switch (dimension & 0x03) { // mod 4\n                case 0:\n                    dimension++;\n                    break;\n                // 1? do nothing\n                case 2:\n                    dimension--;\n                    break;\n                case 3:\n                    throw new NotFoundException('Dimensions could be not found.');\n            }\n            return dimension;\n        }\n        /**\n         * <p>Computes an average estimated module size based on estimated derived from the positions\n         * of the three finder patterns.</p>\n         *\n         * @param topLeft detected top-left finder pattern center\n         * @param topRight detected top-right finder pattern center\n         * @param bottomLeft detected bottom-left finder pattern center\n         * @return estimated module size\n         */\n        calculateModuleSize(topLeft, topRight, bottomLeft) {\n            // Take the average\n            return (this.calculateModuleSizeOneWay(topLeft, topRight) +\n                this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;\n        }\n        /**\n         * <p>Estimates module size based on two finder patterns -- it uses\n         * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the\n         * width of each, measuring along the axis between their centers.</p>\n         */\n        calculateModuleSizeOneWay(pattern, otherPattern) {\n            const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), \n            /*(int) */ Math.floor(pattern.getY()), \n            /*(int) */ Math.floor(otherPattern.getX()), \n            /*(int) */ Math.floor(otherPattern.getY()));\n            const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), \n            /*(int) */ Math.floor(otherPattern.getY()), \n            /*(int) */ Math.floor(pattern.getX()), \n            /*(int) */ Math.floor(pattern.getY()));\n            if (isNaN(moduleSizeEst1)) {\n                return moduleSizeEst2 / 7.0;\n            }\n            if (isNaN(moduleSizeEst2)) {\n                return moduleSizeEst1 / 7.0;\n            }\n            // Average them, and divide by 7 since we've counted the width of 3 black modules,\n            // and 1 white and 1 black module on either side. Ergo, divide sum by 14.\n            return (moduleSizeEst1 + moduleSizeEst2) / 14.0;\n        }\n        /**\n         * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of\n         * a finder pattern by looking for a black-white-black run from the center in the direction\n         * of another point (another finder pattern center), and in the opposite direction too.\n         */\n        sizeOfBlackWhiteBlackRunBothWays(fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n            let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);\n            // Now count other way -- don't run off image though of course\n            let scale = 1.0;\n            let otherToX = fromX - (toX - fromX);\n            if (otherToX < 0) {\n                scale = fromX / /*(float) */ (fromX - otherToX);\n                otherToX = 0;\n            }\n            else if (otherToX >= this.image.getWidth()) {\n                scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);\n                otherToX = this.image.getWidth() - 1;\n            }\n            let otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);\n            scale = 1.0;\n            if (otherToY < 0) {\n                scale = fromY / /*(float) */ (fromY - otherToY);\n                otherToY = 0;\n            }\n            else if (otherToY >= this.image.getHeight()) {\n                scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);\n                otherToY = this.image.getHeight() - 1;\n            }\n            otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);\n            result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);\n            // Middle pixel is double-counted this way; subtract 1\n            return result - 1.0;\n        }\n        /**\n         * <p>This method traces a line from a point in the image, in the direction towards another point.\n         * It begins in a black region, and keeps going until it finds white, then black, then white again.\n         * It reports the distance from the start to this point.</p>\n         *\n         * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern\n         * may be skewed or rotated.</p>\n         */\n        sizeOfBlackWhiteBlackRun(fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {\n            // Mild variant of Bresenham's algorithm\n            // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n            const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);\n            if (steep) {\n                let temp = fromX;\n                fromX = fromY;\n                fromY = temp;\n                temp = toX;\n                toX = toY;\n                toY = temp;\n            }\n            const dx = Math.abs(toX - fromX);\n            const dy = Math.abs(toY - fromY);\n            let error = -dx / 2;\n            const xstep = fromX < toX ? 1 : -1;\n            const ystep = fromY < toY ? 1 : -1;\n            // In black pixels, looking for white, first or second time.\n            let state = 0;\n            // Loop up until x == toX, but not beyond\n            const xLimit = toX + xstep;\n            for (let x = fromX, y = fromY; x !== xLimit; x += xstep) {\n                const realX = steep ? y : x;\n                const realY = steep ? x : y;\n                // Does current pixel mean we have moved white to black or vice versa?\n                // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n                // color, advance to next state or end if we are in state 2 already\n                if ((state === 1) === this.image.get(realX, realY)) {\n                    if (state === 2) {\n                        return MathUtils.distance(x, y, fromX, fromY);\n                    }\n                    state++;\n                }\n                error += dy;\n                if (error > 0) {\n                    if (y === toY) {\n                        break;\n                    }\n                    y += ystep;\n                    error -= dx;\n                }\n            }\n            // Found black-white-black; give the benefit of the doubt that the next pixel outside the image\n            // is \"white\" so this last point at (toX+xStep,toY) is the right ending. This is really a\n            // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.\n            if (state === 2) {\n                return MathUtils.distance(toX + xstep, toY, fromX, fromY);\n            }\n            // else we didn't find even black-white-black; no estimate is really possible\n            return NaN;\n        }\n        /**\n         * <p>Attempts to locate an alignment pattern in a limited region of the image, which is\n         * guessed to contain it. This method uses {@link AlignmentPattern}.</p>\n         *\n         * @param overallEstModuleSize estimated module size so far\n         * @param estAlignmentX x coordinate of center of area probably containing alignment pattern\n         * @param estAlignmentY y coordinate of above\n         * @param allowanceFactor number of pixels in all directions to search from the center\n         * @return {@link AlignmentPattern} if found, or null otherwise\n         * @throws NotFoundException if an unexpected error occurs during detection\n         */\n        findAlignmentInRegion(overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {\n            // Look for an alignment pattern (3 modules in size) around where it\n            // should be\n            const allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);\n            const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);\n            const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);\n            if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {\n                throw new NotFoundException('Alignment top exceeds estimated module size.');\n            }\n            const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);\n            const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);\n            if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {\n                throw new NotFoundException('Alignment bottom exceeds estimated module size.');\n            }\n            const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);\n            return alignmentFinder.find();\n        }\n    }\n\n    /*\n     * Copyright 2007 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*import java.util.List;*/\n    /*import java.util.Map;*/\n    /**\n     * This implementation can detect and decode QR Codes in an image.\n     *\n     * @author Sean Owen\n     */\n    class QRCodeReader {\n        constructor() {\n            this.decoder = new Decoder$2();\n        }\n        getDecoder() {\n            return this.decoder;\n        }\n        /**\n         * Locates and decodes a QR code in an image.\n         *\n         * @return a representing: string the content encoded by the QR code\n         * @throws NotFoundException if a QR code cannot be found\n         * @throws FormatException if a QR code cannot be decoded\n         * @throws ChecksumException if error correction fails\n         */\n        /*@Override*/\n        // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n        //   return this.decode(image, null)\n        // }\n        /*@Override*/\n        decode(image, hints) {\n            let decoderResult;\n            let points;\n            if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE)) {\n                const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n                decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n                points = QRCodeReader.NO_POINTS;\n            }\n            else {\n                const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);\n                decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n                points = detectorResult.getPoints();\n            }\n            // If the code was mirrored: swap the bottom-left and the top-right points.\n            if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\n                decoderResult.getOther().applyMirroredCorrection(points);\n            }\n            const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.QR_CODE, undefined);\n            const byteSegments = decoderResult.getByteSegments();\n            if (byteSegments !== null) {\n                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);\n            }\n            const ecLevel = decoderResult.getECLevel();\n            if (ecLevel !== null) {\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);\n            }\n            if (decoderResult.hasStructuredAppend()) {\n                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n            }\n            return result;\n        }\n        /*@Override*/\n        reset() {\n            // do nothing\n        }\n        /**\n         * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n         * which contains only an unrotated, unskewed, image of a code, with some white border\n         * around it. This is a specialized method that works exceptionally fast in this special\n         * case.\n         *\n         * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n         */\n        static extractPureBits(image) {\n            const leftTopBlack = image.getTopLeftOnBit();\n            const rightBottomBlack = image.getBottomRightOnBit();\n            if (leftTopBlack === null || rightBottomBlack === null) {\n                throw new NotFoundException();\n            }\n            const moduleSize = this.moduleSize(leftTopBlack, image);\n            let top = leftTopBlack[1];\n            let bottom = rightBottomBlack[1];\n            let left = leftTopBlack[0];\n            let right = rightBottomBlack[0];\n            // Sanity check!\n            if (left >= right || top >= bottom) {\n                throw new NotFoundException();\n            }\n            if (bottom - top !== right - left) {\n                // Special case, where bottom-right module wasn't black so we found something else in the last row\n                // Assume it's a square, so use height as the width\n                right = left + (bottom - top);\n                if (right >= image.getWidth()) {\n                    // Abort if that would not make sense -- off image\n                    throw new NotFoundException();\n                }\n            }\n            const matrixWidth = Math.round((right - left + 1) / moduleSize);\n            const matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n            if (matrixWidth <= 0 || matrixHeight <= 0) {\n                throw new NotFoundException();\n            }\n            if (matrixHeight !== matrixWidth) {\n                // Only possibly decode square regions\n                throw new NotFoundException();\n            }\n            // Push in the \"border\" by half the module width so that we start\n            // sampling in the middle of the module. Just in case the image is a\n            // little off, this will help recover.\n            const nudge = /*(int) */ Math.floor(moduleSize / 2.0);\n            top += nudge;\n            left += nudge;\n            // But careful that this does not sample off the edge\n            // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n            // This is positive by how much the inner x loop below would be too large\n            const nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;\n            if (nudgedTooFarRight > 0) {\n                if (nudgedTooFarRight > nudge) {\n                    // Neither way fits; abort\n                    throw new NotFoundException();\n                }\n                left -= nudgedTooFarRight;\n            }\n            // See logic above\n            const nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n            if (nudgedTooFarDown > 0) {\n                if (nudgedTooFarDown > nudge) {\n                    // Neither way fits; abort\n                    throw new NotFoundException();\n                }\n                top -= nudgedTooFarDown;\n            }\n            // Now just read off the bits\n            const bits = new BitMatrix(matrixWidth, matrixHeight);\n            for (let y = 0; y < matrixHeight; y++) {\n                const iOffset = top + /*(int) */ Math.floor(y * moduleSize);\n                for (let x = 0; x < matrixWidth; x++) {\n                    if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {\n                        bits.set(x, y);\n                    }\n                }\n            }\n            return bits;\n        }\n        static moduleSize(leftTopBlack, image) {\n            const height = image.getHeight();\n            const width = image.getWidth();\n            let x = leftTopBlack[0];\n            let y = leftTopBlack[1];\n            let inBlack = true;\n            let transitions = 0;\n            while (x < width && y < height) {\n                if (inBlack !== image.get(x, y)) {\n                    if (++transitions === 5) {\n                        break;\n                    }\n                    inBlack = !inBlack;\n                }\n                x++;\n                y++;\n            }\n            if (x === width || y === height) {\n                throw new NotFoundException();\n            }\n            return (x - leftTopBlack[0]) / 7.0;\n        }\n    }\n    QRCodeReader.NO_POINTS = new Array();\n\n    /*\n    * Copyright 2009 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417Common {\n        PDF417Common() {\n        }\n        /**\n         * @param moduleBitCount values to sum\n         * @return sum of values\n         * @deprecated call {@link MathUtils#sum(int[])}\n         */\n        // @Deprecated\n        static getBitCountSum(moduleBitCount) {\n            return MathUtils.sum(moduleBitCount);\n        }\n        static toIntArray(list) {\n            if (list == null || !list.length) {\n                return PDF417Common.EMPTY_INT_ARRAY;\n            }\n            const result = new Int32Array(list.length);\n            let i = 0;\n            for (const integer of list) {\n                result[i++] = integer;\n            }\n            return result;\n        }\n        /**\n         * @param symbol encoded symbol to translate to a codeword\n         * @return the codeword corresponding to the symbol.\n         */\n        static getCodeword(symbol /*int*/) {\n            const i = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 0x3FFFF);\n            if (i < 0) {\n                return -1;\n            }\n            return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;\n        }\n    }\n    PDF417Common.NUMBER_OF_CODEWORDS = 929;\n    // Maximum Codewords (Data + Error).\n    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;\n    PDF417Common.MIN_ROWS_IN_BARCODE = 3;\n    PDF417Common.MAX_ROWS_IN_BARCODE = 90;\n    // One left row indication column + max 30 data columns + one right row indicator column\n    // public static /*final*/ MAX_CODEWORDS_IN_ROW: /*int*/ number = 32;\n    PDF417Common.MODULES_IN_CODEWORD = 17;\n    PDF417Common.MODULES_IN_STOP_PATTERN = 18;\n    PDF417Common.BARS_IN_MODULE = 8;\n    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);\n    /**\n     * The sorted table of all possible symbols. Extracted from the PDF417\n     * specification. The index of a symbol in this table corresponds to the\n     * index into the codeword table.\n     */\n    PDF417Common.SYMBOL_TABLE = Int32Array.from([\n        0x1025e, 0x1027a, 0x1029e, 0x102bc, 0x102f2, 0x102f4, 0x1032e, 0x1034e, 0x1035c, 0x10396, 0x103a6, 0x103ac,\n        0x10422, 0x10428, 0x10436, 0x10442, 0x10444, 0x10448, 0x10450, 0x1045e, 0x10466, 0x1046c, 0x1047a, 0x10482,\n        0x1049e, 0x104a0, 0x104bc, 0x104c6, 0x104d8, 0x104ee, 0x104f2, 0x104f4, 0x10504, 0x10508, 0x10510, 0x1051e,\n        0x10520, 0x1053c, 0x10540, 0x10578, 0x10586, 0x1058c, 0x10598, 0x105b0, 0x105be, 0x105ce, 0x105dc, 0x105e2,\n        0x105e4, 0x105e8, 0x105f6, 0x1062e, 0x1064e, 0x1065c, 0x1068e, 0x1069c, 0x106b8, 0x106de, 0x106fa, 0x10716,\n        0x10726, 0x1072c, 0x10746, 0x1074c, 0x10758, 0x1076e, 0x10792, 0x10794, 0x107a2, 0x107a4, 0x107a8, 0x107b6,\n        0x10822, 0x10828, 0x10842, 0x10848, 0x10850, 0x1085e, 0x10866, 0x1086c, 0x1087a, 0x10882, 0x10884, 0x10890,\n        0x1089e, 0x108a0, 0x108bc, 0x108c6, 0x108cc, 0x108d8, 0x108ee, 0x108f2, 0x108f4, 0x10902, 0x10908, 0x1091e,\n        0x10920, 0x1093c, 0x10940, 0x10978, 0x10986, 0x10998, 0x109b0, 0x109be, 0x109ce, 0x109dc, 0x109e2, 0x109e4,\n        0x109e8, 0x109f6, 0x10a08, 0x10a10, 0x10a1e, 0x10a20, 0x10a3c, 0x10a40, 0x10a78, 0x10af0, 0x10b06, 0x10b0c,\n        0x10b18, 0x10b30, 0x10b3e, 0x10b60, 0x10b7c, 0x10b8e, 0x10b9c, 0x10bb8, 0x10bc2, 0x10bc4, 0x10bc8, 0x10bd0,\n        0x10bde, 0x10be6, 0x10bec, 0x10c2e, 0x10c4e, 0x10c5c, 0x10c62, 0x10c64, 0x10c68, 0x10c76, 0x10c8e, 0x10c9c,\n        0x10cb8, 0x10cc2, 0x10cc4, 0x10cc8, 0x10cd0, 0x10cde, 0x10ce6, 0x10cec, 0x10cfa, 0x10d0e, 0x10d1c, 0x10d38,\n        0x10d70, 0x10d7e, 0x10d82, 0x10d84, 0x10d88, 0x10d90, 0x10d9e, 0x10da0, 0x10dbc, 0x10dc6, 0x10dcc, 0x10dd8,\n        0x10dee, 0x10df2, 0x10df4, 0x10e16, 0x10e26, 0x10e2c, 0x10e46, 0x10e58, 0x10e6e, 0x10e86, 0x10e8c, 0x10e98,\n        0x10eb0, 0x10ebe, 0x10ece, 0x10edc, 0x10f0a, 0x10f12, 0x10f14, 0x10f22, 0x10f28, 0x10f36, 0x10f42, 0x10f44,\n        0x10f48, 0x10f50, 0x10f5e, 0x10f66, 0x10f6c, 0x10fb2, 0x10fb4, 0x11022, 0x11028, 0x11042, 0x11048, 0x11050,\n        0x1105e, 0x1107a, 0x11082, 0x11084, 0x11090, 0x1109e, 0x110a0, 0x110bc, 0x110c6, 0x110cc, 0x110d8, 0x110ee,\n        0x110f2, 0x110f4, 0x11102, 0x1111e, 0x11120, 0x1113c, 0x11140, 0x11178, 0x11186, 0x11198, 0x111b0, 0x111be,\n        0x111ce, 0x111dc, 0x111e2, 0x111e4, 0x111e8, 0x111f6, 0x11208, 0x1121e, 0x11220, 0x11278, 0x112f0, 0x1130c,\n        0x11330, 0x1133e, 0x11360, 0x1137c, 0x1138e, 0x1139c, 0x113b8, 0x113c2, 0x113c8, 0x113d0, 0x113de, 0x113e6,\n        0x113ec, 0x11408, 0x11410, 0x1141e, 0x11420, 0x1143c, 0x11440, 0x11478, 0x114f0, 0x115e0, 0x1160c, 0x11618,\n        0x11630, 0x1163e, 0x11660, 0x1167c, 0x116c0, 0x116f8, 0x1171c, 0x11738, 0x11770, 0x1177e, 0x11782, 0x11784,\n        0x11788, 0x11790, 0x1179e, 0x117a0, 0x117bc, 0x117c6, 0x117cc, 0x117d8, 0x117ee, 0x1182e, 0x11834, 0x1184e,\n        0x1185c, 0x11862, 0x11864, 0x11868, 0x11876, 0x1188e, 0x1189c, 0x118b8, 0x118c2, 0x118c8, 0x118d0, 0x118de,\n        0x118e6, 0x118ec, 0x118fa, 0x1190e, 0x1191c, 0x11938, 0x11970, 0x1197e, 0x11982, 0x11984, 0x11990, 0x1199e,\n        0x119a0, 0x119bc, 0x119c6, 0x119cc, 0x119d8, 0x119ee, 0x119f2, 0x119f4, 0x11a0e, 0x11a1c, 0x11a38, 0x11a70,\n        0x11a7e, 0x11ae0, 0x11afc, 0x11b08, 0x11b10, 0x11b1e, 0x11b20, 0x11b3c, 0x11b40, 0x11b78, 0x11b8c, 0x11b98,\n        0x11bb0, 0x11bbe, 0x11bce, 0x11bdc, 0x11be2, 0x11be4, 0x11be8, 0x11bf6, 0x11c16, 0x11c26, 0x11c2c, 0x11c46,\n        0x11c4c, 0x11c58, 0x11c6e, 0x11c86, 0x11c98, 0x11cb0, 0x11cbe, 0x11cce, 0x11cdc, 0x11ce2, 0x11ce4, 0x11ce8,\n        0x11cf6, 0x11d06, 0x11d0c, 0x11d18, 0x11d30, 0x11d3e, 0x11d60, 0x11d7c, 0x11d8e, 0x11d9c, 0x11db8, 0x11dc4,\n        0x11dc8, 0x11dd0, 0x11dde, 0x11de6, 0x11dec, 0x11dfa, 0x11e0a, 0x11e12, 0x11e14, 0x11e22, 0x11e24, 0x11e28,\n        0x11e36, 0x11e42, 0x11e44, 0x11e50, 0x11e5e, 0x11e66, 0x11e6c, 0x11e82, 0x11e84, 0x11e88, 0x11e90, 0x11e9e,\n        0x11ea0, 0x11ebc, 0x11ec6, 0x11ecc, 0x11ed8, 0x11eee, 0x11f1a, 0x11f2e, 0x11f32, 0x11f34, 0x11f4e, 0x11f5c,\n        0x11f62, 0x11f64, 0x11f68, 0x11f76, 0x12048, 0x1205e, 0x12082, 0x12084, 0x12090, 0x1209e, 0x120a0, 0x120bc,\n        0x120d8, 0x120f2, 0x120f4, 0x12108, 0x1211e, 0x12120, 0x1213c, 0x12140, 0x12178, 0x12186, 0x12198, 0x121b0,\n        0x121be, 0x121e2, 0x121e4, 0x121e8, 0x121f6, 0x12204, 0x12210, 0x1221e, 0x12220, 0x12278, 0x122f0, 0x12306,\n        0x1230c, 0x12330, 0x1233e, 0x12360, 0x1237c, 0x1238e, 0x1239c, 0x123b8, 0x123c2, 0x123c8, 0x123d0, 0x123e6,\n        0x123ec, 0x1241e, 0x12420, 0x1243c, 0x124f0, 0x125e0, 0x12618, 0x1263e, 0x12660, 0x1267c, 0x126c0, 0x126f8,\n        0x12738, 0x12770, 0x1277e, 0x12782, 0x12784, 0x12790, 0x1279e, 0x127a0, 0x127bc, 0x127c6, 0x127cc, 0x127d8,\n        0x127ee, 0x12820, 0x1283c, 0x12840, 0x12878, 0x128f0, 0x129e0, 0x12bc0, 0x12c18, 0x12c30, 0x12c3e, 0x12c60,\n        0x12c7c, 0x12cc0, 0x12cf8, 0x12df0, 0x12e1c, 0x12e38, 0x12e70, 0x12e7e, 0x12ee0, 0x12efc, 0x12f04, 0x12f08,\n        0x12f10, 0x12f20, 0x12f3c, 0x12f40, 0x12f78, 0x12f86, 0x12f8c, 0x12f98, 0x12fb0, 0x12fbe, 0x12fce, 0x12fdc,\n        0x1302e, 0x1304e, 0x1305c, 0x13062, 0x13068, 0x1308e, 0x1309c, 0x130b8, 0x130c2, 0x130c8, 0x130d0, 0x130de,\n        0x130ec, 0x130fa, 0x1310e, 0x13138, 0x13170, 0x1317e, 0x13182, 0x13184, 0x13190, 0x1319e, 0x131a0, 0x131bc,\n        0x131c6, 0x131cc, 0x131d8, 0x131f2, 0x131f4, 0x1320e, 0x1321c, 0x13270, 0x1327e, 0x132e0, 0x132fc, 0x13308,\n        0x1331e, 0x13320, 0x1333c, 0x13340, 0x13378, 0x13386, 0x13398, 0x133b0, 0x133be, 0x133ce, 0x133dc, 0x133e2,\n        0x133e4, 0x133e8, 0x133f6, 0x1340e, 0x1341c, 0x13438, 0x13470, 0x1347e, 0x134e0, 0x134fc, 0x135c0, 0x135f8,\n        0x13608, 0x13610, 0x1361e, 0x13620, 0x1363c, 0x13640, 0x13678, 0x136f0, 0x1370c, 0x13718, 0x13730, 0x1373e,\n        0x13760, 0x1377c, 0x1379c, 0x137b8, 0x137c2, 0x137c4, 0x137c8, 0x137d0, 0x137de, 0x137e6, 0x137ec, 0x13816,\n        0x13826, 0x1382c, 0x13846, 0x1384c, 0x13858, 0x1386e, 0x13874, 0x13886, 0x13898, 0x138b0, 0x138be, 0x138ce,\n        0x138dc, 0x138e2, 0x138e4, 0x138e8, 0x13906, 0x1390c, 0x13930, 0x1393e, 0x13960, 0x1397c, 0x1398e, 0x1399c,\n        0x139b8, 0x139c8, 0x139d0, 0x139de, 0x139e6, 0x139ec, 0x139fa, 0x13a06, 0x13a0c, 0x13a18, 0x13a30, 0x13a3e,\n        0x13a60, 0x13a7c, 0x13ac0, 0x13af8, 0x13b0e, 0x13b1c, 0x13b38, 0x13b70, 0x13b7e, 0x13b88, 0x13b90, 0x13b9e,\n        0x13ba0, 0x13bbc, 0x13bcc, 0x13bd8, 0x13bee, 0x13bf2, 0x13bf4, 0x13c12, 0x13c14, 0x13c22, 0x13c24, 0x13c28,\n        0x13c36, 0x13c42, 0x13c48, 0x13c50, 0x13c5e, 0x13c66, 0x13c6c, 0x13c82, 0x13c84, 0x13c90, 0x13c9e, 0x13ca0,\n        0x13cbc, 0x13cc6, 0x13ccc, 0x13cd8, 0x13cee, 0x13d02, 0x13d04, 0x13d08, 0x13d10, 0x13d1e, 0x13d20, 0x13d3c,\n        0x13d40, 0x13d78, 0x13d86, 0x13d8c, 0x13d98, 0x13db0, 0x13dbe, 0x13dce, 0x13ddc, 0x13de4, 0x13de8, 0x13df6,\n        0x13e1a, 0x13e2e, 0x13e32, 0x13e34, 0x13e4e, 0x13e5c, 0x13e62, 0x13e64, 0x13e68, 0x13e76, 0x13e8e, 0x13e9c,\n        0x13eb8, 0x13ec2, 0x13ec4, 0x13ec8, 0x13ed0, 0x13ede, 0x13ee6, 0x13eec, 0x13f26, 0x13f2c, 0x13f3a, 0x13f46,\n        0x13f4c, 0x13f58, 0x13f6e, 0x13f72, 0x13f74, 0x14082, 0x1409e, 0x140a0, 0x140bc, 0x14104, 0x14108, 0x14110,\n        0x1411e, 0x14120, 0x1413c, 0x14140, 0x14178, 0x1418c, 0x14198, 0x141b0, 0x141be, 0x141e2, 0x141e4, 0x141e8,\n        0x14208, 0x14210, 0x1421e, 0x14220, 0x1423c, 0x14240, 0x14278, 0x142f0, 0x14306, 0x1430c, 0x14318, 0x14330,\n        0x1433e, 0x14360, 0x1437c, 0x1438e, 0x143c2, 0x143c4, 0x143c8, 0x143d0, 0x143e6, 0x143ec, 0x14408, 0x14410,\n        0x1441e, 0x14420, 0x1443c, 0x14440, 0x14478, 0x144f0, 0x145e0, 0x1460c, 0x14618, 0x14630, 0x1463e, 0x14660,\n        0x1467c, 0x146c0, 0x146f8, 0x1471c, 0x14738, 0x14770, 0x1477e, 0x14782, 0x14784, 0x14788, 0x14790, 0x147a0,\n        0x147bc, 0x147c6, 0x147cc, 0x147d8, 0x147ee, 0x14810, 0x14820, 0x1483c, 0x14840, 0x14878, 0x148f0, 0x149e0,\n        0x14bc0, 0x14c30, 0x14c3e, 0x14c60, 0x14c7c, 0x14cc0, 0x14cf8, 0x14df0, 0x14e38, 0x14e70, 0x14e7e, 0x14ee0,\n        0x14efc, 0x14f04, 0x14f08, 0x14f10, 0x14f1e, 0x14f20, 0x14f3c, 0x14f40, 0x14f78, 0x14f86, 0x14f8c, 0x14f98,\n        0x14fb0, 0x14fce, 0x14fdc, 0x15020, 0x15040, 0x15078, 0x150f0, 0x151e0, 0x153c0, 0x15860, 0x1587c, 0x158c0,\n        0x158f8, 0x159f0, 0x15be0, 0x15c70, 0x15c7e, 0x15ce0, 0x15cfc, 0x15dc0, 0x15df8, 0x15e08, 0x15e10, 0x15e20,\n        0x15e40, 0x15e78, 0x15ef0, 0x15f0c, 0x15f18, 0x15f30, 0x15f60, 0x15f7c, 0x15f8e, 0x15f9c, 0x15fb8, 0x1604e,\n        0x1605c, 0x1608e, 0x1609c, 0x160b8, 0x160c2, 0x160c4, 0x160c8, 0x160de, 0x1610e, 0x1611c, 0x16138, 0x16170,\n        0x1617e, 0x16184, 0x16188, 0x16190, 0x1619e, 0x161a0, 0x161bc, 0x161c6, 0x161cc, 0x161d8, 0x161f2, 0x161f4,\n        0x1620e, 0x1621c, 0x16238, 0x16270, 0x1627e, 0x162e0, 0x162fc, 0x16304, 0x16308, 0x16310, 0x1631e, 0x16320,\n        0x1633c, 0x16340, 0x16378, 0x16386, 0x1638c, 0x16398, 0x163b0, 0x163be, 0x163ce, 0x163dc, 0x163e2, 0x163e4,\n        0x163e8, 0x163f6, 0x1640e, 0x1641c, 0x16438, 0x16470, 0x1647e, 0x164e0, 0x164fc, 0x165c0, 0x165f8, 0x16610,\n        0x1661e, 0x16620, 0x1663c, 0x16640, 0x16678, 0x166f0, 0x16718, 0x16730, 0x1673e, 0x16760, 0x1677c, 0x1678e,\n        0x1679c, 0x167b8, 0x167c2, 0x167c4, 0x167c8, 0x167d0, 0x167de, 0x167e6, 0x167ec, 0x1681c, 0x16838, 0x16870,\n        0x168e0, 0x168fc, 0x169c0, 0x169f8, 0x16bf0, 0x16c10, 0x16c1e, 0x16c20, 0x16c3c, 0x16c40, 0x16c78, 0x16cf0,\n        0x16de0, 0x16e18, 0x16e30, 0x16e3e, 0x16e60, 0x16e7c, 0x16ec0, 0x16ef8, 0x16f1c, 0x16f38, 0x16f70, 0x16f7e,\n        0x16f84, 0x16f88, 0x16f90, 0x16f9e, 0x16fa0, 0x16fbc, 0x16fc6, 0x16fcc, 0x16fd8, 0x17026, 0x1702c, 0x17046,\n        0x1704c, 0x17058, 0x1706e, 0x17086, 0x1708c, 0x17098, 0x170b0, 0x170be, 0x170ce, 0x170dc, 0x170e8, 0x17106,\n        0x1710c, 0x17118, 0x17130, 0x1713e, 0x17160, 0x1717c, 0x1718e, 0x1719c, 0x171b8, 0x171c2, 0x171c4, 0x171c8,\n        0x171d0, 0x171de, 0x171e6, 0x171ec, 0x171fa, 0x17206, 0x1720c, 0x17218, 0x17230, 0x1723e, 0x17260, 0x1727c,\n        0x172c0, 0x172f8, 0x1730e, 0x1731c, 0x17338, 0x17370, 0x1737e, 0x17388, 0x17390, 0x1739e, 0x173a0, 0x173bc,\n        0x173cc, 0x173d8, 0x173ee, 0x173f2, 0x173f4, 0x1740c, 0x17418, 0x17430, 0x1743e, 0x17460, 0x1747c, 0x174c0,\n        0x174f8, 0x175f0, 0x1760e, 0x1761c, 0x17638, 0x17670, 0x1767e, 0x176e0, 0x176fc, 0x17708, 0x17710, 0x1771e,\n        0x17720, 0x1773c, 0x17740, 0x17778, 0x17798, 0x177b0, 0x177be, 0x177dc, 0x177e2, 0x177e4, 0x177e8, 0x17822,\n        0x17824, 0x17828, 0x17836, 0x17842, 0x17844, 0x17848, 0x17850, 0x1785e, 0x17866, 0x1786c, 0x17882, 0x17884,\n        0x17888, 0x17890, 0x1789e, 0x178a0, 0x178bc, 0x178c6, 0x178cc, 0x178d8, 0x178ee, 0x178f2, 0x178f4, 0x17902,\n        0x17904, 0x17908, 0x17910, 0x1791e, 0x17920, 0x1793c, 0x17940, 0x17978, 0x17986, 0x1798c, 0x17998, 0x179b0,\n        0x179be, 0x179ce, 0x179dc, 0x179e2, 0x179e4, 0x179e8, 0x179f6, 0x17a04, 0x17a08, 0x17a10, 0x17a1e, 0x17a20,\n        0x17a3c, 0x17a40, 0x17a78, 0x17af0, 0x17b06, 0x17b0c, 0x17b18, 0x17b30, 0x17b3e, 0x17b60, 0x17b7c, 0x17b8e,\n        0x17b9c, 0x17bb8, 0x17bc4, 0x17bc8, 0x17bd0, 0x17bde, 0x17be6, 0x17bec, 0x17c2e, 0x17c32, 0x17c34, 0x17c4e,\n        0x17c5c, 0x17c62, 0x17c64, 0x17c68, 0x17c76, 0x17c8e, 0x17c9c, 0x17cb8, 0x17cc2, 0x17cc4, 0x17cc8, 0x17cd0,\n        0x17cde, 0x17ce6, 0x17cec, 0x17d0e, 0x17d1c, 0x17d38, 0x17d70, 0x17d82, 0x17d84, 0x17d88, 0x17d90, 0x17d9e,\n        0x17da0, 0x17dbc, 0x17dc6, 0x17dcc, 0x17dd8, 0x17dee, 0x17e26, 0x17e2c, 0x17e3a, 0x17e46, 0x17e4c, 0x17e58,\n        0x17e6e, 0x17e72, 0x17e74, 0x17e86, 0x17e8c, 0x17e98, 0x17eb0, 0x17ece, 0x17edc, 0x17ee2, 0x17ee4, 0x17ee8,\n        0x17ef6, 0x1813a, 0x18172, 0x18174, 0x18216, 0x18226, 0x1823a, 0x1824c, 0x18258, 0x1826e, 0x18272, 0x18274,\n        0x18298, 0x182be, 0x182e2, 0x182e4, 0x182e8, 0x182f6, 0x1835e, 0x1837a, 0x183ae, 0x183d6, 0x18416, 0x18426,\n        0x1842c, 0x1843a, 0x18446, 0x18458, 0x1846e, 0x18472, 0x18474, 0x18486, 0x184b0, 0x184be, 0x184ce, 0x184dc,\n        0x184e2, 0x184e4, 0x184e8, 0x184f6, 0x18506, 0x1850c, 0x18518, 0x18530, 0x1853e, 0x18560, 0x1857c, 0x1858e,\n        0x1859c, 0x185b8, 0x185c2, 0x185c4, 0x185c8, 0x185d0, 0x185de, 0x185e6, 0x185ec, 0x185fa, 0x18612, 0x18614,\n        0x18622, 0x18628, 0x18636, 0x18642, 0x18650, 0x1865e, 0x1867a, 0x18682, 0x18684, 0x18688, 0x18690, 0x1869e,\n        0x186a0, 0x186bc, 0x186c6, 0x186cc, 0x186d8, 0x186ee, 0x186f2, 0x186f4, 0x1872e, 0x1874e, 0x1875c, 0x18796,\n        0x187a6, 0x187ac, 0x187d2, 0x187d4, 0x18826, 0x1882c, 0x1883a, 0x18846, 0x1884c, 0x18858, 0x1886e, 0x18872,\n        0x18874, 0x18886, 0x18898, 0x188b0, 0x188be, 0x188ce, 0x188dc, 0x188e2, 0x188e4, 0x188e8, 0x188f6, 0x1890c,\n        0x18930, 0x1893e, 0x18960, 0x1897c, 0x1898e, 0x189b8, 0x189c2, 0x189c8, 0x189d0, 0x189de, 0x189e6, 0x189ec,\n        0x189fa, 0x18a18, 0x18a30, 0x18a3e, 0x18a60, 0x18a7c, 0x18ac0, 0x18af8, 0x18b1c, 0x18b38, 0x18b70, 0x18b7e,\n        0x18b82, 0x18b84, 0x18b88, 0x18b90, 0x18b9e, 0x18ba0, 0x18bbc, 0x18bc6, 0x18bcc, 0x18bd8, 0x18bee, 0x18bf2,\n        0x18bf4, 0x18c22, 0x18c24, 0x18c28, 0x18c36, 0x18c42, 0x18c48, 0x18c50, 0x18c5e, 0x18c66, 0x18c7a, 0x18c82,\n        0x18c84, 0x18c90, 0x18c9e, 0x18ca0, 0x18cbc, 0x18ccc, 0x18cf2, 0x18cf4, 0x18d04, 0x18d08, 0x18d10, 0x18d1e,\n        0x18d20, 0x18d3c, 0x18d40, 0x18d78, 0x18d86, 0x18d98, 0x18dce, 0x18de2, 0x18de4, 0x18de8, 0x18e2e, 0x18e32,\n        0x18e34, 0x18e4e, 0x18e5c, 0x18e62, 0x18e64, 0x18e68, 0x18e8e, 0x18e9c, 0x18eb8, 0x18ec2, 0x18ec4, 0x18ec8,\n        0x18ed0, 0x18efa, 0x18f16, 0x18f26, 0x18f2c, 0x18f46, 0x18f4c, 0x18f58, 0x18f6e, 0x18f8a, 0x18f92, 0x18f94,\n        0x18fa2, 0x18fa4, 0x18fa8, 0x18fb6, 0x1902c, 0x1903a, 0x19046, 0x1904c, 0x19058, 0x19072, 0x19074, 0x19086,\n        0x19098, 0x190b0, 0x190be, 0x190ce, 0x190dc, 0x190e2, 0x190e8, 0x190f6, 0x19106, 0x1910c, 0x19130, 0x1913e,\n        0x19160, 0x1917c, 0x1918e, 0x1919c, 0x191b8, 0x191c2, 0x191c8, 0x191d0, 0x191de, 0x191e6, 0x191ec, 0x191fa,\n        0x19218, 0x1923e, 0x19260, 0x1927c, 0x192c0, 0x192f8, 0x19338, 0x19370, 0x1937e, 0x19382, 0x19384, 0x19390,\n        0x1939e, 0x193a0, 0x193bc, 0x193c6, 0x193cc, 0x193d8, 0x193ee, 0x193f2, 0x193f4, 0x19430, 0x1943e, 0x19460,\n        0x1947c, 0x194c0, 0x194f8, 0x195f0, 0x19638, 0x19670, 0x1967e, 0x196e0, 0x196fc, 0x19702, 0x19704, 0x19708,\n        0x19710, 0x19720, 0x1973c, 0x19740, 0x19778, 0x19786, 0x1978c, 0x19798, 0x197b0, 0x197be, 0x197ce, 0x197dc,\n        0x197e2, 0x197e4, 0x197e8, 0x19822, 0x19824, 0x19842, 0x19848, 0x19850, 0x1985e, 0x19866, 0x1987a, 0x19882,\n        0x19884, 0x19890, 0x1989e, 0x198a0, 0x198bc, 0x198cc, 0x198f2, 0x198f4, 0x19902, 0x19908, 0x1991e, 0x19920,\n        0x1993c, 0x19940, 0x19978, 0x19986, 0x19998, 0x199ce, 0x199e2, 0x199e4, 0x199e8, 0x19a08, 0x19a10, 0x19a1e,\n        0x19a20, 0x19a3c, 0x19a40, 0x19a78, 0x19af0, 0x19b18, 0x19b3e, 0x19b60, 0x19b9c, 0x19bc2, 0x19bc4, 0x19bc8,\n        0x19bd0, 0x19be6, 0x19c2e, 0x19c34, 0x19c4e, 0x19c5c, 0x19c62, 0x19c64, 0x19c68, 0x19c8e, 0x19c9c, 0x19cb8,\n        0x19cc2, 0x19cc8, 0x19cd0, 0x19ce6, 0x19cfa, 0x19d0e, 0x19d1c, 0x19d38, 0x19d70, 0x19d7e, 0x19d82, 0x19d84,\n        0x19d88, 0x19d90, 0x19da0, 0x19dcc, 0x19df2, 0x19df4, 0x19e16, 0x19e26, 0x19e2c, 0x19e46, 0x19e4c, 0x19e58,\n        0x19e74, 0x19e86, 0x19e8c, 0x19e98, 0x19eb0, 0x19ebe, 0x19ece, 0x19ee2, 0x19ee4, 0x19ee8, 0x19f0a, 0x19f12,\n        0x19f14, 0x19f22, 0x19f24, 0x19f28, 0x19f42, 0x19f44, 0x19f48, 0x19f50, 0x19f5e, 0x19f6c, 0x19f9a, 0x19fae,\n        0x19fb2, 0x19fb4, 0x1a046, 0x1a04c, 0x1a072, 0x1a074, 0x1a086, 0x1a08c, 0x1a098, 0x1a0b0, 0x1a0be, 0x1a0e2,\n        0x1a0e4, 0x1a0e8, 0x1a0f6, 0x1a106, 0x1a10c, 0x1a118, 0x1a130, 0x1a13e, 0x1a160, 0x1a17c, 0x1a18e, 0x1a19c,\n        0x1a1b8, 0x1a1c2, 0x1a1c4, 0x1a1c8, 0x1a1d0, 0x1a1de, 0x1a1e6, 0x1a1ec, 0x1a218, 0x1a230, 0x1a23e, 0x1a260,\n        0x1a27c, 0x1a2c0, 0x1a2f8, 0x1a31c, 0x1a338, 0x1a370, 0x1a37e, 0x1a382, 0x1a384, 0x1a388, 0x1a390, 0x1a39e,\n        0x1a3a0, 0x1a3bc, 0x1a3c6, 0x1a3cc, 0x1a3d8, 0x1a3ee, 0x1a3f2, 0x1a3f4, 0x1a418, 0x1a430, 0x1a43e, 0x1a460,\n        0x1a47c, 0x1a4c0, 0x1a4f8, 0x1a5f0, 0x1a61c, 0x1a638, 0x1a670, 0x1a67e, 0x1a6e0, 0x1a6fc, 0x1a702, 0x1a704,\n        0x1a708, 0x1a710, 0x1a71e, 0x1a720, 0x1a73c, 0x1a740, 0x1a778, 0x1a786, 0x1a78c, 0x1a798, 0x1a7b0, 0x1a7be,\n        0x1a7ce, 0x1a7dc, 0x1a7e2, 0x1a7e4, 0x1a7e8, 0x1a830, 0x1a860, 0x1a87c, 0x1a8c0, 0x1a8f8, 0x1a9f0, 0x1abe0,\n        0x1ac70, 0x1ac7e, 0x1ace0, 0x1acfc, 0x1adc0, 0x1adf8, 0x1ae04, 0x1ae08, 0x1ae10, 0x1ae20, 0x1ae3c, 0x1ae40,\n        0x1ae78, 0x1aef0, 0x1af06, 0x1af0c, 0x1af18, 0x1af30, 0x1af3e, 0x1af60, 0x1af7c, 0x1af8e, 0x1af9c, 0x1afb8,\n        0x1afc4, 0x1afc8, 0x1afd0, 0x1afde, 0x1b042, 0x1b05e, 0x1b07a, 0x1b082, 0x1b084, 0x1b088, 0x1b090, 0x1b09e,\n        0x1b0a0, 0x1b0bc, 0x1b0cc, 0x1b0f2, 0x1b0f4, 0x1b102, 0x1b104, 0x1b108, 0x1b110, 0x1b11e, 0x1b120, 0x1b13c,\n        0x1b140, 0x1b178, 0x1b186, 0x1b198, 0x1b1ce, 0x1b1e2, 0x1b1e4, 0x1b1e8, 0x1b204, 0x1b208, 0x1b210, 0x1b21e,\n        0x1b220, 0x1b23c, 0x1b240, 0x1b278, 0x1b2f0, 0x1b30c, 0x1b33e, 0x1b360, 0x1b39c, 0x1b3c2, 0x1b3c4, 0x1b3c8,\n        0x1b3d0, 0x1b3e6, 0x1b410, 0x1b41e, 0x1b420, 0x1b43c, 0x1b440, 0x1b478, 0x1b4f0, 0x1b5e0, 0x1b618, 0x1b660,\n        0x1b67c, 0x1b6c0, 0x1b738, 0x1b782, 0x1b784, 0x1b788, 0x1b790, 0x1b79e, 0x1b7a0, 0x1b7cc, 0x1b82e, 0x1b84e,\n        0x1b85c, 0x1b88e, 0x1b89c, 0x1b8b8, 0x1b8c2, 0x1b8c4, 0x1b8c8, 0x1b8d0, 0x1b8e6, 0x1b8fa, 0x1b90e, 0x1b91c,\n        0x1b938, 0x1b970, 0x1b97e, 0x1b982, 0x1b984, 0x1b988, 0x1b990, 0x1b99e, 0x1b9a0, 0x1b9cc, 0x1b9f2, 0x1b9f4,\n        0x1ba0e, 0x1ba1c, 0x1ba38, 0x1ba70, 0x1ba7e, 0x1bae0, 0x1bafc, 0x1bb08, 0x1bb10, 0x1bb20, 0x1bb3c, 0x1bb40,\n        0x1bb98, 0x1bbce, 0x1bbe2, 0x1bbe4, 0x1bbe8, 0x1bc16, 0x1bc26, 0x1bc2c, 0x1bc46, 0x1bc4c, 0x1bc58, 0x1bc72,\n        0x1bc74, 0x1bc86, 0x1bc8c, 0x1bc98, 0x1bcb0, 0x1bcbe, 0x1bcce, 0x1bce2, 0x1bce4, 0x1bce8, 0x1bd06, 0x1bd0c,\n        0x1bd18, 0x1bd30, 0x1bd3e, 0x1bd60, 0x1bd7c, 0x1bd9c, 0x1bdc2, 0x1bdc4, 0x1bdc8, 0x1bdd0, 0x1bde6, 0x1bdfa,\n        0x1be12, 0x1be14, 0x1be22, 0x1be24, 0x1be28, 0x1be42, 0x1be44, 0x1be48, 0x1be50, 0x1be5e, 0x1be66, 0x1be82,\n        0x1be84, 0x1be88, 0x1be90, 0x1be9e, 0x1bea0, 0x1bebc, 0x1becc, 0x1bef4, 0x1bf1a, 0x1bf2e, 0x1bf32, 0x1bf34,\n        0x1bf4e, 0x1bf5c, 0x1bf62, 0x1bf64, 0x1bf68, 0x1c09a, 0x1c0b2, 0x1c0b4, 0x1c11a, 0x1c132, 0x1c134, 0x1c162,\n        0x1c164, 0x1c168, 0x1c176, 0x1c1ba, 0x1c21a, 0x1c232, 0x1c234, 0x1c24e, 0x1c25c, 0x1c262, 0x1c264, 0x1c268,\n        0x1c276, 0x1c28e, 0x1c2c2, 0x1c2c4, 0x1c2c8, 0x1c2d0, 0x1c2de, 0x1c2e6, 0x1c2ec, 0x1c2fa, 0x1c316, 0x1c326,\n        0x1c33a, 0x1c346, 0x1c34c, 0x1c372, 0x1c374, 0x1c41a, 0x1c42e, 0x1c432, 0x1c434, 0x1c44e, 0x1c45c, 0x1c462,\n        0x1c464, 0x1c468, 0x1c476, 0x1c48e, 0x1c49c, 0x1c4b8, 0x1c4c2, 0x1c4c8, 0x1c4d0, 0x1c4de, 0x1c4e6, 0x1c4ec,\n        0x1c4fa, 0x1c51c, 0x1c538, 0x1c570, 0x1c57e, 0x1c582, 0x1c584, 0x1c588, 0x1c590, 0x1c59e, 0x1c5a0, 0x1c5bc,\n        0x1c5c6, 0x1c5cc, 0x1c5d8, 0x1c5ee, 0x1c5f2, 0x1c5f4, 0x1c616, 0x1c626, 0x1c62c, 0x1c63a, 0x1c646, 0x1c64c,\n        0x1c658, 0x1c66e, 0x1c672, 0x1c674, 0x1c686, 0x1c68c, 0x1c698, 0x1c6b0, 0x1c6be, 0x1c6ce, 0x1c6dc, 0x1c6e2,\n        0x1c6e4, 0x1c6e8, 0x1c712, 0x1c714, 0x1c722, 0x1c728, 0x1c736, 0x1c742, 0x1c744, 0x1c748, 0x1c750, 0x1c75e,\n        0x1c766, 0x1c76c, 0x1c77a, 0x1c7ae, 0x1c7d6, 0x1c7ea, 0x1c81a, 0x1c82e, 0x1c832, 0x1c834, 0x1c84e, 0x1c85c,\n        0x1c862, 0x1c864, 0x1c868, 0x1c876, 0x1c88e, 0x1c89c, 0x1c8b8, 0x1c8c2, 0x1c8c8, 0x1c8d0, 0x1c8de, 0x1c8e6,\n        0x1c8ec, 0x1c8fa, 0x1c90e, 0x1c938, 0x1c970, 0x1c97e, 0x1c982, 0x1c984, 0x1c990, 0x1c99e, 0x1c9a0, 0x1c9bc,\n        0x1c9c6, 0x1c9cc, 0x1c9d8, 0x1c9ee, 0x1c9f2, 0x1c9f4, 0x1ca38, 0x1ca70, 0x1ca7e, 0x1cae0, 0x1cafc, 0x1cb02,\n        0x1cb04, 0x1cb08, 0x1cb10, 0x1cb20, 0x1cb3c, 0x1cb40, 0x1cb78, 0x1cb86, 0x1cb8c, 0x1cb98, 0x1cbb0, 0x1cbbe,\n        0x1cbce, 0x1cbdc, 0x1cbe2, 0x1cbe4, 0x1cbe8, 0x1cbf6, 0x1cc16, 0x1cc26, 0x1cc2c, 0x1cc3a, 0x1cc46, 0x1cc58,\n        0x1cc72, 0x1cc74, 0x1cc86, 0x1ccb0, 0x1ccbe, 0x1ccce, 0x1cce2, 0x1cce4, 0x1cce8, 0x1cd06, 0x1cd0c, 0x1cd18,\n        0x1cd30, 0x1cd3e, 0x1cd60, 0x1cd7c, 0x1cd9c, 0x1cdc2, 0x1cdc4, 0x1cdc8, 0x1cdd0, 0x1cdde, 0x1cde6, 0x1cdfa,\n        0x1ce22, 0x1ce28, 0x1ce42, 0x1ce50, 0x1ce5e, 0x1ce66, 0x1ce7a, 0x1ce82, 0x1ce84, 0x1ce88, 0x1ce90, 0x1ce9e,\n        0x1cea0, 0x1cebc, 0x1cecc, 0x1cef2, 0x1cef4, 0x1cf2e, 0x1cf32, 0x1cf34, 0x1cf4e, 0x1cf5c, 0x1cf62, 0x1cf64,\n        0x1cf68, 0x1cf96, 0x1cfa6, 0x1cfac, 0x1cfca, 0x1cfd2, 0x1cfd4, 0x1d02e, 0x1d032, 0x1d034, 0x1d04e, 0x1d05c,\n        0x1d062, 0x1d064, 0x1d068, 0x1d076, 0x1d08e, 0x1d09c, 0x1d0b8, 0x1d0c2, 0x1d0c4, 0x1d0c8, 0x1d0d0, 0x1d0de,\n        0x1d0e6, 0x1d0ec, 0x1d0fa, 0x1d11c, 0x1d138, 0x1d170, 0x1d17e, 0x1d182, 0x1d184, 0x1d188, 0x1d190, 0x1d19e,\n        0x1d1a0, 0x1d1bc, 0x1d1c6, 0x1d1cc, 0x1d1d8, 0x1d1ee, 0x1d1f2, 0x1d1f4, 0x1d21c, 0x1d238, 0x1d270, 0x1d27e,\n        0x1d2e0, 0x1d2fc, 0x1d302, 0x1d304, 0x1d308, 0x1d310, 0x1d31e, 0x1d320, 0x1d33c, 0x1d340, 0x1d378, 0x1d386,\n        0x1d38c, 0x1d398, 0x1d3b0, 0x1d3be, 0x1d3ce, 0x1d3dc, 0x1d3e2, 0x1d3e4, 0x1d3e8, 0x1d3f6, 0x1d470, 0x1d47e,\n        0x1d4e0, 0x1d4fc, 0x1d5c0, 0x1d5f8, 0x1d604, 0x1d608, 0x1d610, 0x1d620, 0x1d640, 0x1d678, 0x1d6f0, 0x1d706,\n        0x1d70c, 0x1d718, 0x1d730, 0x1d73e, 0x1d760, 0x1d77c, 0x1d78e, 0x1d79c, 0x1d7b8, 0x1d7c2, 0x1d7c4, 0x1d7c8,\n        0x1d7d0, 0x1d7de, 0x1d7e6, 0x1d7ec, 0x1d826, 0x1d82c, 0x1d83a, 0x1d846, 0x1d84c, 0x1d858, 0x1d872, 0x1d874,\n        0x1d886, 0x1d88c, 0x1d898, 0x1d8b0, 0x1d8be, 0x1d8ce, 0x1d8e2, 0x1d8e4, 0x1d8e8, 0x1d8f6, 0x1d90c, 0x1d918,\n        0x1d930, 0x1d93e, 0x1d960, 0x1d97c, 0x1d99c, 0x1d9c2, 0x1d9c4, 0x1d9c8, 0x1d9d0, 0x1d9e6, 0x1d9fa, 0x1da0c,\n        0x1da18, 0x1da30, 0x1da3e, 0x1da60, 0x1da7c, 0x1dac0, 0x1daf8, 0x1db38, 0x1db82, 0x1db84, 0x1db88, 0x1db90,\n        0x1db9e, 0x1dba0, 0x1dbcc, 0x1dbf2, 0x1dbf4, 0x1dc22, 0x1dc42, 0x1dc44, 0x1dc48, 0x1dc50, 0x1dc5e, 0x1dc66,\n        0x1dc7a, 0x1dc82, 0x1dc84, 0x1dc88, 0x1dc90, 0x1dc9e, 0x1dca0, 0x1dcbc, 0x1dccc, 0x1dcf2, 0x1dcf4, 0x1dd04,\n        0x1dd08, 0x1dd10, 0x1dd1e, 0x1dd20, 0x1dd3c, 0x1dd40, 0x1dd78, 0x1dd86, 0x1dd98, 0x1ddce, 0x1dde2, 0x1dde4,\n        0x1dde8, 0x1de2e, 0x1de32, 0x1de34, 0x1de4e, 0x1de5c, 0x1de62, 0x1de64, 0x1de68, 0x1de8e, 0x1de9c, 0x1deb8,\n        0x1dec2, 0x1dec4, 0x1dec8, 0x1ded0, 0x1dee6, 0x1defa, 0x1df16, 0x1df26, 0x1df2c, 0x1df46, 0x1df4c, 0x1df58,\n        0x1df72, 0x1df74, 0x1df8a, 0x1df92, 0x1df94, 0x1dfa2, 0x1dfa4, 0x1dfa8, 0x1e08a, 0x1e092, 0x1e094, 0x1e0a2,\n        0x1e0a4, 0x1e0a8, 0x1e0b6, 0x1e0da, 0x1e10a, 0x1e112, 0x1e114, 0x1e122, 0x1e124, 0x1e128, 0x1e136, 0x1e142,\n        0x1e144, 0x1e148, 0x1e150, 0x1e166, 0x1e16c, 0x1e17a, 0x1e19a, 0x1e1b2, 0x1e1b4, 0x1e20a, 0x1e212, 0x1e214,\n        0x1e222, 0x1e224, 0x1e228, 0x1e236, 0x1e242, 0x1e248, 0x1e250, 0x1e25e, 0x1e266, 0x1e26c, 0x1e27a, 0x1e282,\n        0x1e284, 0x1e288, 0x1e290, 0x1e2a0, 0x1e2bc, 0x1e2c6, 0x1e2cc, 0x1e2d8, 0x1e2ee, 0x1e2f2, 0x1e2f4, 0x1e31a,\n        0x1e332, 0x1e334, 0x1e35c, 0x1e362, 0x1e364, 0x1e368, 0x1e3ba, 0x1e40a, 0x1e412, 0x1e414, 0x1e422, 0x1e428,\n        0x1e436, 0x1e442, 0x1e448, 0x1e450, 0x1e45e, 0x1e466, 0x1e46c, 0x1e47a, 0x1e482, 0x1e484, 0x1e490, 0x1e49e,\n        0x1e4a0, 0x1e4bc, 0x1e4c6, 0x1e4cc, 0x1e4d8, 0x1e4ee, 0x1e4f2, 0x1e4f4, 0x1e502, 0x1e504, 0x1e508, 0x1e510,\n        0x1e51e, 0x1e520, 0x1e53c, 0x1e540, 0x1e578, 0x1e586, 0x1e58c, 0x1e598, 0x1e5b0, 0x1e5be, 0x1e5ce, 0x1e5dc,\n        0x1e5e2, 0x1e5e4, 0x1e5e8, 0x1e5f6, 0x1e61a, 0x1e62e, 0x1e632, 0x1e634, 0x1e64e, 0x1e65c, 0x1e662, 0x1e668,\n        0x1e68e, 0x1e69c, 0x1e6b8, 0x1e6c2, 0x1e6c4, 0x1e6c8, 0x1e6d0, 0x1e6e6, 0x1e6fa, 0x1e716, 0x1e726, 0x1e72c,\n        0x1e73a, 0x1e746, 0x1e74c, 0x1e758, 0x1e772, 0x1e774, 0x1e792, 0x1e794, 0x1e7a2, 0x1e7a4, 0x1e7a8, 0x1e7b6,\n        0x1e812, 0x1e814, 0x1e822, 0x1e824, 0x1e828, 0x1e836, 0x1e842, 0x1e844, 0x1e848, 0x1e850, 0x1e85e, 0x1e866,\n        0x1e86c, 0x1e87a, 0x1e882, 0x1e884, 0x1e888, 0x1e890, 0x1e89e, 0x1e8a0, 0x1e8bc, 0x1e8c6, 0x1e8cc, 0x1e8d8,\n        0x1e8ee, 0x1e8f2, 0x1e8f4, 0x1e902, 0x1e904, 0x1e908, 0x1e910, 0x1e920, 0x1e93c, 0x1e940, 0x1e978, 0x1e986,\n        0x1e98c, 0x1e998, 0x1e9b0, 0x1e9be, 0x1e9ce, 0x1e9dc, 0x1e9e2, 0x1e9e4, 0x1e9e8, 0x1e9f6, 0x1ea04, 0x1ea08,\n        0x1ea10, 0x1ea20, 0x1ea40, 0x1ea78, 0x1eaf0, 0x1eb06, 0x1eb0c, 0x1eb18, 0x1eb30, 0x1eb3e, 0x1eb60, 0x1eb7c,\n        0x1eb8e, 0x1eb9c, 0x1ebb8, 0x1ebc2, 0x1ebc4, 0x1ebc8, 0x1ebd0, 0x1ebde, 0x1ebe6, 0x1ebec, 0x1ec1a, 0x1ec2e,\n        0x1ec32, 0x1ec34, 0x1ec4e, 0x1ec5c, 0x1ec62, 0x1ec64, 0x1ec68, 0x1ec8e, 0x1ec9c, 0x1ecb8, 0x1ecc2, 0x1ecc4,\n        0x1ecc8, 0x1ecd0, 0x1ece6, 0x1ecfa, 0x1ed0e, 0x1ed1c, 0x1ed38, 0x1ed70, 0x1ed7e, 0x1ed82, 0x1ed84, 0x1ed88,\n        0x1ed90, 0x1ed9e, 0x1eda0, 0x1edcc, 0x1edf2, 0x1edf4, 0x1ee16, 0x1ee26, 0x1ee2c, 0x1ee3a, 0x1ee46, 0x1ee4c,\n        0x1ee58, 0x1ee6e, 0x1ee72, 0x1ee74, 0x1ee86, 0x1ee8c, 0x1ee98, 0x1eeb0, 0x1eebe, 0x1eece, 0x1eedc, 0x1eee2,\n        0x1eee4, 0x1eee8, 0x1ef12, 0x1ef22, 0x1ef24, 0x1ef28, 0x1ef36, 0x1ef42, 0x1ef44, 0x1ef48, 0x1ef50, 0x1ef5e,\n        0x1ef66, 0x1ef6c, 0x1ef7a, 0x1efae, 0x1efb2, 0x1efb4, 0x1efd6, 0x1f096, 0x1f0a6, 0x1f0ac, 0x1f0ba, 0x1f0ca,\n        0x1f0d2, 0x1f0d4, 0x1f116, 0x1f126, 0x1f12c, 0x1f13a, 0x1f146, 0x1f14c, 0x1f158, 0x1f16e, 0x1f172, 0x1f174,\n        0x1f18a, 0x1f192, 0x1f194, 0x1f1a2, 0x1f1a4, 0x1f1a8, 0x1f1da, 0x1f216, 0x1f226, 0x1f22c, 0x1f23a, 0x1f246,\n        0x1f258, 0x1f26e, 0x1f272, 0x1f274, 0x1f286, 0x1f28c, 0x1f298, 0x1f2b0, 0x1f2be, 0x1f2ce, 0x1f2dc, 0x1f2e2,\n        0x1f2e4, 0x1f2e8, 0x1f2f6, 0x1f30a, 0x1f312, 0x1f314, 0x1f322, 0x1f328, 0x1f342, 0x1f344, 0x1f348, 0x1f350,\n        0x1f35e, 0x1f366, 0x1f37a, 0x1f39a, 0x1f3ae, 0x1f3b2, 0x1f3b4, 0x1f416, 0x1f426, 0x1f42c, 0x1f43a, 0x1f446,\n        0x1f44c, 0x1f458, 0x1f46e, 0x1f472, 0x1f474, 0x1f486, 0x1f48c, 0x1f498, 0x1f4b0, 0x1f4be, 0x1f4ce, 0x1f4dc,\n        0x1f4e2, 0x1f4e4, 0x1f4e8, 0x1f4f6, 0x1f506, 0x1f50c, 0x1f518, 0x1f530, 0x1f53e, 0x1f560, 0x1f57c, 0x1f58e,\n        0x1f59c, 0x1f5b8, 0x1f5c2, 0x1f5c4, 0x1f5c8, 0x1f5d0, 0x1f5de, 0x1f5e6, 0x1f5ec, 0x1f5fa, 0x1f60a, 0x1f612,\n        0x1f614, 0x1f622, 0x1f624, 0x1f628, 0x1f636, 0x1f642, 0x1f644, 0x1f648, 0x1f650, 0x1f65e, 0x1f666, 0x1f67a,\n        0x1f682, 0x1f684, 0x1f688, 0x1f690, 0x1f69e, 0x1f6a0, 0x1f6bc, 0x1f6cc, 0x1f6f2, 0x1f6f4, 0x1f71a, 0x1f72e,\n        0x1f732, 0x1f734, 0x1f74e, 0x1f75c, 0x1f762, 0x1f764, 0x1f768, 0x1f776, 0x1f796, 0x1f7a6, 0x1f7ac, 0x1f7ba,\n        0x1f7d2, 0x1f7d4, 0x1f89a, 0x1f8ae, 0x1f8b2, 0x1f8b4, 0x1f8d6, 0x1f8ea, 0x1f91a, 0x1f92e, 0x1f932, 0x1f934,\n        0x1f94e, 0x1f95c, 0x1f962, 0x1f964, 0x1f968, 0x1f976, 0x1f996, 0x1f9a6, 0x1f9ac, 0x1f9ba, 0x1f9ca, 0x1f9d2,\n        0x1f9d4, 0x1fa1a, 0x1fa2e, 0x1fa32, 0x1fa34, 0x1fa4e, 0x1fa5c, 0x1fa62, 0x1fa64, 0x1fa68, 0x1fa76, 0x1fa8e,\n        0x1fa9c, 0x1fab8, 0x1fac2, 0x1fac4, 0x1fac8, 0x1fad0, 0x1fade, 0x1fae6, 0x1faec, 0x1fb16, 0x1fb26, 0x1fb2c,\n        0x1fb3a, 0x1fb46, 0x1fb4c, 0x1fb58, 0x1fb6e, 0x1fb72, 0x1fb74, 0x1fb8a, 0x1fb92, 0x1fb94, 0x1fba2, 0x1fba4,\n        0x1fba8, 0x1fbb6, 0x1fbda\n    ]);\n    /**\n     * This table contains to codewords for all symbols.\n     */\n    PDF417Common.CODEWORD_TABLE = Int32Array.from([\n        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868, 865, 861, 859, 2511,\n        873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811, 810, 809, 2483, 807, 2482, 806, 2480, 815,\n        814, 813, 812, 2484, 817, 816, 1745, 1744, 1742, 1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752,\n        2739, 2737, 2728, 2727, 2725, 2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752,\n        1719, 692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341, 627, 2338, 651,\n        646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321, 594, 2319, 2317, 611, 610, 608, 606,\n        2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612, 616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909,\n        2509, 2507, 2504, 870, 867, 864, 860, 2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830,\n        2494, 827, 2492, 843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,\n        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740, 2738, 2786, 2784, 591,\n        588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545, 542, 539, 548, 1572, 1570, 481, 2245, 466,\n        2242, 462, 2239, 492, 485, 482, 2249, 496, 494, 1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419,\n        2202, 415, 2199, 432, 430, 427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155,\n        2152, 378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385, 1411, 384,\n        1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406, 2403, 750, 742, 738, 2414, 756,\n        753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684, 2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337,\n        2336, 2334, 2332, 1624, 2329, 1622, 640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653,\n        1651, 1649, 1655, 2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,\n        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876, 874, 1782, 2720, 2713,\n        2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675, 2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654,\n        2652, 2650, 2657, 2771, 1855, 2765, 2762, 1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142,\n        332, 2140, 345, 1375, 1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,\n        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308, 1320, 1318, 2052,\n        202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066, 1260, 1258, 1252, 231, 1248, 229, 1266,\n        1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991, 1988, 165, 164, 2007, 162, 2006, 159, 2003, 2000, 172, 171,\n        169, 2012, 166, 2010, 1186, 1184, 1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313,\n        2307, 2305, 592, 589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536, 529,\n        2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478, 2247, 470, 2244, 465, 2241,\n        493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187, 2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414,\n        412, 2197, 409, 2195, 405, 2193, 2190, 426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434,\n        1477, 1475, 2478, 2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,\n        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358, 2357, 2355, 2353,\n        1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687, 2374, 683, 2372, 701, 698, 705, 1691, 1689,\n        2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588, 2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573,\n        2570, 2567, 2577, 2525, 2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,\n        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824, 2673, 2671, 2669,\n        2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766, 2764, 143, 1987, 139, 1986, 135, 133,\n        131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985, 1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971,\n        1969, 122, 121, 119, 117, 1977, 114, 1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78,\n        1950, 1948, 1945, 94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,\n        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53, 1922, 1919, 66, 64,\n        1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047, 1045, 1043, 1050, 1049, 12, 10, 1869, 1867,\n        1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28, 1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989,\n        987, 984, 34, 995, 994, 992, 2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359,\n        343, 341, 338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324, 310, 308,\n        305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353, 1351, 1357, 2092, 2091, 2089,\n        2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252, 2098, 2095, 272, 269, 2108, 266, 2106, 281, 279,\n        277, 1317, 1315, 1313, 1310, 282, 1321, 1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205,\n        2051, 201, 2049, 2046, 2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,\n        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299, 1593, 2308, 2306, 590,\n        2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577, 574, 571, 2298, 582, 581, 1592, 2263, 2262,\n        2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273, 2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549,\n        1575, 1573, 2224, 2222, 2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,\n        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474, 2479, 2469, 2468, 2466,\n        2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728, 2460, 2458, 2456, 2463, 805, 804, 2428, 2427,\n        2425, 2423, 1725, 2420, 1724, 2417, 1722, 2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388,\n        2386, 2384, 1697, 2381, 1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,\n        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801, 1799, 2594, 2592,\n        2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560, 2557, 1798, 2554, 1796, 2574, 2572, 2569,\n        2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845, 2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695,\n        2704, 1817, 1811, 1810, 897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,\n        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645, 1643, 1640, 1648,\n        602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608, 1606, 613, 1615, 1613, 2328, 926, 924, 892,\n        886, 899, 857, 850, 2505, 1778, 824, 823, 821, 819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632,\n        2630, 2746, 2734, 2732, 2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486,\n        483, 1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468, 1465, 2210, 366,\n        363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407, 1405, 382, 1402, 380, 1417, 1415, 1412,\n        1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722, 2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684,\n        1681, 626, 624, 622, 2335, 620, 2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527,\n        894, 891, 888, 2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768, 2759,\n        2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296, 2126, 315, 312, 1347, 1342,\n        1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301, 1298, 276, 1312, 1309, 2115, 203, 2048, 195,\n        2045, 191, 2041, 213, 209, 2056, 1246, 1244, 1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997,\n        150, 1995, 147, 1992, 1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,\n        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588, 520, 518, 512, 2268,\n        508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479, 471, 489, 1526, 1523, 1520, 397, 395,\n        2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422, 1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779,\n        776, 773, 2397, 2394, 2390, 734, 728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688,\n        1685, 1683, 2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890, 2718,\n        2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760, 2758, 142, 141, 1139, 1138,\n        134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108, 105, 1972, 101, 1970, 120, 118, 115, 1109, 1108,\n        1106, 1104, 123, 1113, 1111, 82, 79, 1951, 75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98,\n        1069, 96, 1084, 1082, 1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,\n        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044, 1944, 1943, 1941, 11, 9,\n        1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968, 966, 963, 29, 960, 26, 23, 983, 981, 978, 975,\n        33, 971, 31, 990, 988, 985, 1906, 1904, 1902, 993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339,\n        1372, 1370, 294, 293, 291, 289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090,\n        239, 2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186, 2036, 183, 2033,\n        2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237, 1255, 2310, 2302, 2300, 2286, 2284,\n        2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256, 2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569,\n        1567, 2223, 2221, 2218, 2215, 1483, 2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467,\n        2465, 2451, 2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382, 2379,\n        1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601, 2584, 2583, 2581, 2579,\n        1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929, 2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688,\n        2686, 1815, 1809, 1808, 1774, 1756, 1754, 1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636,\n        1633, 1641, 598, 1605, 1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,\n        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458, 1455, 2208, 364, 361,\n        358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403, 1413, 2173, 2172, 772, 726, 723, 1712, 672,\n        669, 666, 682, 1678, 1675, 625, 623, 621, 618, 2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849,\n        848, 847, 846, 2497, 855, 852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343,\n        255, 251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224, 214, 1220, 210,\n        1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162, 1160, 1158, 1155, 161, 1152, 157,\n        1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018, 2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458,\n        447, 2227, 472, 1516, 1513, 1510, 398, 396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460,\n        2209, 769, 764, 720, 712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,\n        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127, 1125, 1124, 1122, 1127,\n        109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80, 76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060,\n        87, 1075, 1073, 1070, 1080, 1966, 1965, 46, 43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008,\n        51, 1029, 1027, 1024, 1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952,\n        949, 946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986, 1905, 1903, 350,\n        349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341, 1339, 1337, 1345, 243, 240, 237, 2086,\n        233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114, 190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231,\n        1229, 1226, 217, 1223, 1241, 2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499,\n        2254, 515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512, 2447, 798,\n        797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714, 2602, 2582, 2580, 2548, 2546,\n        2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771, 1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670,\n        1668, 1631, 1629, 1626, 1634, 1599, 1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504,\n        1501, 1498, 1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399, 1397, 1394,\n        1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363, 1361, 1333, 1328, 1336, 1286, 1281,\n        1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197, 1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150,\n        1148, 1146, 152, 1143, 149, 1140, 145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582,\n        510, 1556, 1553, 452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713, 1709,\n        662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118, 1123, 1097, 1096, 1094,\n        1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74, 1066, 1064, 1061, 1071, 1964, 1963, 1007,\n        1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015, 1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940,\n        938, 935, 932, 5, 2, 955, 953, 950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897,\n        1379, 325, 1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112, 188, 185,\n        181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553, 551, 1583, 505, 503, 500, 513,\n        1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505, 1502, 796, 763, 762, 760, 767, 711, 710, 708, 706,\n        2377, 718, 715, 1710, 2544, 917, 915, 2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204,\n        1390, 1388, 1385, 1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214, 1207,\n        1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015, 1579, 1549, 1546, 1495, 1487,\n        1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667, 1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062,\n        1962, 1960, 1005, 1003, 1000, 997, 38, 1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951,\n        948, 944, 1889, 1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275,\n        1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580, 501, 1551, 1548,\n        440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198, 1386, 2164, 2161, 1621, 1766, 2103, 1208,\n        2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009, 1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954,\n        1001, 998, 1924, 1921, 1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270,\n        2105, 1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700\n    ]);\n\n    /*\n    * Copyright 2007 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    // import java.util.List;\n    /**\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417DetectorResult {\n        constructor(bits, points) {\n            this.bits = bits;\n            this.points = points;\n        }\n        getBits() {\n            return this.bits;\n        }\n        getPoints() {\n            return this.points;\n        }\n    }\n\n    /*\n    * Copyright 2009 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    // import java.util.ArrayList;\n    // import java.util.Arrays;\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the\n     * PDF417 Code is rotated or skewed, or partially obscured.</p>\n     *\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Guenther Grau\n     */\n    /*public*/ /*final*/ class Detector$3 {\n        /**\n         * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>\n         *\n         * @param image barcode image to decode\n         * @param hints optional hints to detector\n         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n         * be found and returned\n         * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code\n         * @throws NotFoundException if no PDF417 Code can be found\n         */\n        static detectMultiple(image, hints, multiple) {\n            // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even\n            // different binarizers\n            // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);\n            let bitMatrix = image.getBlackMatrix();\n            let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);\n            if (!barcodeCoordinates.length) {\n                bitMatrix = bitMatrix.clone();\n                bitMatrix.rotate180();\n                barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);\n            }\n            return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);\n        }\n        /**\n         * Detects PDF417 codes in an image. Only checks 0 degree rotation\n         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will\n         * be found and returned\n         * @param bitMatrix bit matrix to detect barcodes in\n         * @return List of ResultPoint arrays containing the coordinates of found barcodes\n         */\n        static detect(multiple, bitMatrix) {\n            const barcodeCoordinates = new Array();\n            let row = 0;\n            let column = 0;\n            let foundBarcodeInRow = false;\n            while (row < bitMatrix.getHeight()) {\n                const vertices = Detector$3.findVertices(bitMatrix, row, column);\n                if (vertices[0] == null && vertices[3] == null) {\n                    if (!foundBarcodeInRow) {\n                        // we didn't find any barcode so that's the end of searching\n                        break;\n                    }\n                    // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly\n                    // below the lowest barcode we found so far.\n                    foundBarcodeInRow = false;\n                    column = 0;\n                    for (const barcodeCoordinate of barcodeCoordinates) {\n                        if (barcodeCoordinate[1] != null) {\n                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));\n                        }\n                        if (barcodeCoordinate[3] != null) {\n                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));\n                        }\n                    }\n                    row += Detector$3.ROW_STEP;\n                    continue;\n                }\n                foundBarcodeInRow = true;\n                barcodeCoordinates.push(vertices);\n                if (!multiple) {\n                    break;\n                }\n                // if we didn't find a right row indicator column, then continue the search for the next barcode after the\n                // start pattern of the barcode just found.\n                if (vertices[2] != null) {\n                    column = Math.trunc(vertices[2].getX());\n                    row = Math.trunc(vertices[2].getY());\n                }\n                else {\n                    column = Math.trunc(vertices[4].getX());\n                    row = Math.trunc(vertices[4].getY());\n                }\n            }\n            return barcodeCoordinates;\n        }\n        /**\n         * Locate the vertices and the codewords area of a black blob using the Start\n         * and Stop patterns as locators.\n         *\n         * @param matrix the scanned barcode image.\n         * @return an array containing the vertices:\n         *           vertices[0] x, y top left barcode\n         *           vertices[1] x, y bottom left barcode\n         *           vertices[2] x, y top right barcode\n         *           vertices[3] x, y bottom right barcode\n         *           vertices[4] x, y top left codeword area\n         *           vertices[5] x, y bottom left codeword area\n         *           vertices[6] x, y top right codeword area\n         *           vertices[7] x, y bottom right codeword area\n         */\n        static findVertices(matrix, startRow, startColumn) {\n            const height = matrix.getHeight();\n            const width = matrix.getWidth();\n            // const result = new ResultPoint[8];\n            const result = new Array(8);\n            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);\n            if (result[4] != null) {\n                startColumn = Math.trunc(result[4].getX());\n                startRow = Math.trunc(result[4].getY());\n            }\n            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);\n            return result;\n        }\n        static copyToResult(result, tmpResult, destinationIndexes) {\n            for (let i = 0; i < destinationIndexes.length; i++) {\n                result[destinationIndexes[i]] = tmpResult[i];\n            }\n        }\n        static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {\n            // const result = new ResultPoint[4];\n            const result = new Array(4);\n            let found = false;\n            const counters = new Int32Array(pattern.length);\n            for (; startRow < height; startRow += Detector$3.ROW_STEP) {\n                let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);\n                if (loc != null) {\n                    while (startRow > 0) {\n                        const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);\n                        if (previousRowLoc != null) {\n                            loc = previousRowLoc;\n                        }\n                        else {\n                            startRow++;\n                            break;\n                        }\n                    }\n                    result[0] = new ResultPoint(loc[0], startRow);\n                    result[1] = new ResultPoint(loc[1], startRow);\n                    found = true;\n                    break;\n                }\n            }\n            let stopRow = startRow + 1;\n            // Last row of the current symbol that contains pattern\n            if (found) {\n                let skippedRowCount = 0;\n                let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);\n                for (; stopRow < height; stopRow++) {\n                    const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);\n                    // a found pattern is only considered to belong to the same barcode if the start and end positions\n                    // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With\n                    // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly\n                    // larger drift and don't check for skipped rows.\n                    if (loc != null &&\n                        Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT &&\n                        Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {\n                        previousRowLoc = loc;\n                        skippedRowCount = 0;\n                    }\n                    else {\n                        if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {\n                            break;\n                        }\n                        else {\n                            skippedRowCount++;\n                        }\n                    }\n                }\n                stopRow -= skippedRowCount + 1;\n                result[2] = new ResultPoint(previousRowLoc[0], stopRow);\n                result[3] = new ResultPoint(previousRowLoc[1], stopRow);\n            }\n            if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {\n                Arrays.fill(result, null);\n            }\n            return result;\n        }\n        /**\n         * @param matrix row of black/white values to search\n         * @param column x position to start search\n         * @param row y position to start search\n         * @param width the number of pixels to search on this row\n         * @param pattern pattern of counts of number of black and white pixels that are\n         *                 being searched for as a pattern\n         * @param counters array of counters, as long as pattern, to re-use\n         * @return start/end horizontal offset of guard pattern, as an array of two ints.\n         */\n        static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {\n            Arrays.fillWithin(counters, 0, counters.length, 0);\n            let patternStart = column;\n            let pixelDrift = 0;\n            // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels\n            while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {\n                patternStart--;\n            }\n            let x = patternStart;\n            let counterPosition = 0;\n            let patternLength = pattern.length;\n            for (let isWhite = whiteFirst; x < width; x++) {\n                let pixel = matrix.get(x, row);\n                if (pixel !== isWhite) {\n                    counters[counterPosition]++;\n                }\n                else {\n                    if (counterPosition === patternLength - 1) {\n                        if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {\n                            return new Int32Array([patternStart, x]);\n                        }\n                        patternStart += counters[0] + counters[1];\n                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n                        counters[counterPosition - 1] = 0;\n                        counters[counterPosition] = 0;\n                        counterPosition--;\n                    }\n                    else {\n                        counterPosition++;\n                    }\n                    counters[counterPosition] = 1;\n                    isWhite = !isWhite;\n                }\n            }\n            if (counterPosition === patternLength - 1 &&\n                Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {\n                return new Int32Array([patternStart, x - 1]);\n            }\n            return null;\n        }\n        /**\n         * Determines how closely a set of observed counts of runs of black/white\n         * values matches a given target pattern. This is reported as the ratio of\n         * the total variance from the expected pattern proportions across all\n         * pattern elements, to the length of the pattern.\n         *\n         * @param counters observed counters\n         * @param pattern expected pattern\n         * @param maxIndividualVariance The most any counter can differ before we give up\n         * @return ratio of total variance between counters and pattern compared to total pattern size\n         */\n        static patternMatchVariance(counters, pattern, maxIndividualVariance) {\n            let numCounters = counters.length;\n            let total = 0;\n            let patternLength = 0;\n            for (let i = 0; i < numCounters; i++) {\n                total += counters[i];\n                patternLength += pattern[i];\n            }\n            if (total < patternLength) {\n                // If we don't even have one pixel per unit of bar width, assume this\n                // is too small to reliably match, so fail:\n                return /*Float.POSITIVE_INFINITY*/ Infinity;\n            }\n            // We're going to fake floating-point math in integers. We just need to use more bits.\n            // Scale up patternLength so that intermediate values below like scaledCounter will have\n            // more \"significant digits\".\n            let unitBarWidth = total / patternLength;\n            maxIndividualVariance *= unitBarWidth;\n            let totalVariance = 0.0;\n            for (let x = 0; x < numCounters; x++) {\n                let counter = counters[x];\n                let scaledPattern = pattern[x] * unitBarWidth;\n                let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;\n                if (variance > maxIndividualVariance) {\n                    return /*Float.POSITIVE_INFINITY*/ Infinity;\n                }\n                totalVariance += variance;\n            }\n            return totalVariance / total;\n        }\n    }\n    Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);\n    Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);\n    Detector$3.MAX_AVG_VARIANCE = 0.42;\n    Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;\n    // B S B S B S B S Bar/Space pattern\n    // 11111111 0 1 0 1 0 1 000\n    Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);\n    // 1111111 0 1 000 1 0 1 00 1\n    Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);\n    Detector$3.MAX_PIXEL_DRIFT = 3;\n    Detector$3.MAX_PATTERN_DRIFT = 5;\n    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.\n    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.\n    Detector$3.SKIPPED_ROW_COUNT_MAX = 25;\n    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least\n    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.\n    Detector$3.ROW_STEP = 5;\n    Detector$3.BARCODE_MIN_HEIGHT = 10;\n\n    /*\n    * Copyright 2012 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.GenericGFPoly\n     */\n    /*final*/ class ModulusPoly {\n        constructor(field, coefficients) {\n            if (coefficients.length === 0) {\n                throw new IllegalArgumentException();\n            }\n            this.field = field;\n            let coefficientsLength = /*int*/ coefficients.length;\n            if (coefficientsLength > 1 && coefficients[0] === 0) {\n                // Leading term must be non-zero for anything except the constant polynomial \"0\"\n                let firstNonZero = /*int*/ 1;\n                while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {\n                    firstNonZero++;\n                }\n                if (firstNonZero === coefficientsLength) {\n                    this.coefficients = new Int32Array([0]);\n                }\n                else {\n                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);\n                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);\n                }\n            }\n            else {\n                this.coefficients = coefficients;\n            }\n        }\n        getCoefficients() {\n            return this.coefficients;\n        }\n        /**\n         * @return degree of this polynomial\n         */\n        getDegree() {\n            return this.coefficients.length - 1;\n        }\n        /**\n         * @return true iff this polynomial is the monomial \"0\"\n         */\n        isZero() {\n            return this.coefficients[0] === 0;\n        }\n        /**\n         * @return coefficient of x^degree term in this polynomial\n         */\n        getCoefficient(degree) {\n            return this.coefficients[this.coefficients.length - 1 - degree];\n        }\n        /**\n         * @return evaluation of this polynomial at a given point\n         */\n        evaluateAt(a) {\n            if (a === 0) {\n                // Just return the x^0 coefficient\n                return this.getCoefficient(0);\n            }\n            if (a === 1) {\n                // Just the sum of the coefficients\n                let sum = /*int*/ 0;\n                for (let coefficient /*int*/ of this.coefficients) {\n                    sum = this.field.add(sum, coefficient);\n                }\n                return sum;\n            }\n            let result = /*int*/ this.coefficients[0];\n            let size = /*int*/ this.coefficients.length;\n            for (let i /*int*/ = 1; i < size; i++) {\n                result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);\n            }\n            return result;\n        }\n        add(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');\n            }\n            if (this.isZero()) {\n                return other;\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            let smallerCoefficients = this.coefficients;\n            let largerCoefficients = other.coefficients;\n            if (smallerCoefficients.length > largerCoefficients.length) {\n                let temp = smallerCoefficients;\n                smallerCoefficients = largerCoefficients;\n                largerCoefficients = temp;\n            }\n            let sumDiff = new Int32Array(largerCoefficients.length);\n            let lengthDiff = /*int*/ largerCoefficients.length - smallerCoefficients.length;\n            // Copy high-order terms only found in higher-degree polynomial's coefficients\n            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);\n            for (let i /*int*/ = lengthDiff; i < largerCoefficients.length; i++) {\n                sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);\n            }\n            return new ModulusPoly(this.field, sumDiff);\n        }\n        subtract(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');\n            }\n            if (other.isZero()) {\n                return this;\n            }\n            return this.add(other.negative());\n        }\n        multiply(other) {\n            if (other instanceof ModulusPoly) {\n                return this.multiplyOther(other);\n            }\n            return this.multiplyScalar(other);\n        }\n        multiplyOther(other) {\n            if (!this.field.equals(other.field)) {\n                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');\n            }\n            if (this.isZero() || other.isZero()) {\n                // return this.field.getZero();\n                return new ModulusPoly(this.field, new Int32Array([0]));\n            }\n            let aCoefficients = this.coefficients;\n            let aLength = /*int*/ aCoefficients.length;\n            let bCoefficients = other.coefficients;\n            let bLength = /*int*/ bCoefficients.length;\n            let product = new Int32Array(aLength + bLength - 1);\n            for (let i /*int*/ = 0; i < aLength; i++) {\n                let aCoeff = /*int*/ aCoefficients[i];\n                for (let j /*int*/ = 0; j < bLength; j++) {\n                    product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));\n                }\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        negative() {\n            let size = /*int*/ this.coefficients.length;\n            let negativeCoefficients = new Int32Array(size);\n            for (let i /*int*/ = 0; i < size; i++) {\n                negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);\n            }\n            return new ModulusPoly(this.field, negativeCoefficients);\n        }\n        multiplyScalar(scalar) {\n            if (scalar === 0) {\n                return new ModulusPoly(this.field, new Int32Array([0]));\n            }\n            if (scalar === 1) {\n                return this;\n            }\n            let size = /*int*/ this.coefficients.length;\n            let product = new Int32Array(size);\n            for (let i /*int*/ = 0; i < size; i++) {\n                product[i] = this.field.multiply(this.coefficients[i], scalar);\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        multiplyByMonomial(degree, coefficient) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return new ModulusPoly(this.field, new Int32Array([0]));\n            }\n            let size = /*int*/ this.coefficients.length;\n            let product = new Int32Array(size + degree);\n            for (let i /*int*/ = 0; i < size; i++) {\n                product[i] = this.field.multiply(this.coefficients[i], coefficient);\n            }\n            return new ModulusPoly(this.field, product);\n        }\n        /*\n        ModulusPoly[] divide(other: ModulusPoly) {\n          if (!field.equals(other.field)) {\n            throw new IllegalArgumentException(\"ModulusPolys do not have same ModulusGF field\");\n          }\n          if (other.isZero()) {\n            throw new IllegalArgumentException(\"Divide by 0\");\n          }\n      \n          let quotient: ModulusPoly = field.getZero();\n          let remainder: ModulusPoly = this;\n      \n          let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());\n          let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);\n      \n          while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {\n            let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();\n            let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);\n            let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);\n            let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);\n            quotient = quotient.add(iterationQuotient);\n            remainder = remainder.subtract(term);\n          }\n      \n          return new ModulusPoly[] { quotient, remainder };\n        }\n        */\n        // @Override\n        toString() {\n            let result = new StringBuilder( /*8 * this.getDegree()*/); // dynamic string size in JS\n            for (let degree /*int*/ = this.getDegree(); degree >= 0; degree--) {\n                let coefficient = /*int*/ this.getCoefficient(degree);\n                if (coefficient !== 0) {\n                    if (coefficient < 0) {\n                        result.append(' - ');\n                        coefficient = -coefficient;\n                    }\n                    else {\n                        if (result.length() > 0) {\n                            result.append(' + ');\n                        }\n                    }\n                    if (degree === 0 || coefficient !== 1) {\n                        result.append(coefficient);\n                    }\n                    if (degree !== 0) {\n                        if (degree === 1) {\n                            result.append('x');\n                        }\n                        else {\n                            result.append('x^');\n                            result.append(degree);\n                        }\n                    }\n                }\n            }\n            return result.toString();\n        }\n    }\n\n    class ModulusBase {\n        add(a, b) {\n            return (a + b) % this.modulus;\n        }\n        subtract(a, b) {\n            return (this.modulus + a - b) % this.modulus;\n        }\n        exp(a) {\n            return this.expTable[a];\n        }\n        log(a) {\n            if (a === 0) {\n                throw new IllegalArgumentException();\n            }\n            return this.logTable[a];\n        }\n        inverse(a) {\n            if (a === 0) {\n                throw new ArithmeticException();\n            }\n            return this.expTable[this.modulus - this.logTable[a] - 1];\n        }\n        multiply(a, b) {\n            if (a === 0 || b === 0) {\n                return 0;\n            }\n            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];\n        }\n        getSize() {\n            return this.modulus;\n        }\n        equals(o) {\n            return o === this;\n        }\n    }\n\n    /*\n     * Copyright 2012 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * <p>A field based on powers of a generator integer, modulo some modulus.</p>\n     *\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.GenericGF\n     */\n    /*public final*/ class ModulusGF extends ModulusBase {\n        // private /*final*/ modulus: /*int*/ number;\n        constructor(modulus, generator) {\n            super();\n            this.modulus = modulus;\n            this.expTable = new Int32Array(modulus);\n            this.logTable = new Int32Array(modulus);\n            let x = /*int*/ 1;\n            for (let i /*int*/ = 0; i < modulus; i++) {\n                this.expTable[i] = x;\n                x = (x * generator) % modulus;\n            }\n            for (let i /*int*/ = 0; i < modulus - 1; i++) {\n                this.logTable[this.expTable[i]] = i;\n            }\n            // logTable[0] == 0 but this should never be used\n            this.zero = new ModulusPoly(this, new Int32Array([0]));\n            this.one = new ModulusPoly(this, new Int32Array([1]));\n        }\n        getZero() {\n            return this.zero;\n        }\n        getOne() {\n            return this.one;\n        }\n        buildMonomial(degree, coefficient) {\n            if (degree < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (coefficient === 0) {\n                return this.zero;\n            }\n            let coefficients = new Int32Array(degree + 1);\n            coefficients[0] = coefficient;\n            return new ModulusPoly(this, coefficients);\n        }\n    }\n    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);\n\n    /*\n    * Copyright 2012 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * <p>PDF417 error correction implementation.</p>\n     *\n     * <p>This <a href=\"http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example\">example</a>\n     * is quite useful in understanding the algorithm.</p>\n     *\n     * @author Sean Owen\n     * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder\n     */\n    /*public final*/ class ErrorCorrection {\n        constructor() {\n            this.field = ModulusGF.PDF417_GF;\n        }\n        /**\n         * @param received received codewords\n         * @param numECCodewords number of those codewords used for EC\n         * @param erasures location of erasures\n         * @return number of errors\n         * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors\n         */\n        decode(received, numECCodewords, erasures) {\n            let poly = new ModulusPoly(this.field, received);\n            let S = new Int32Array(numECCodewords);\n            let error = false;\n            for (let i /*int*/ = numECCodewords; i > 0; i--) {\n                let evaluation = poly.evaluateAt(this.field.exp(i));\n                S[numECCodewords - i] = evaluation;\n                if (evaluation !== 0) {\n                    error = true;\n                }\n            }\n            if (!error) {\n                return 0;\n            }\n            let knownErrors = this.field.getOne();\n            if (erasures != null) {\n                for (const erasure of erasures) {\n                    let b = this.field.exp(received.length - 1 - erasure);\n                    // Add (1 - bx) term:\n                    let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b), 1]));\n                    knownErrors = knownErrors.multiply(term);\n                }\n            }\n            let syndrome = new ModulusPoly(this.field, S);\n            // syndrome = syndrome.multiply(knownErrors);\n            let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);\n            let sigma = sigmaOmega[0];\n            let omega = sigmaOmega[1];\n            // sigma = sigma.multiply(knownErrors);\n            let errorLocations = this.findErrorLocations(sigma);\n            let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);\n            for (let i /*int*/ = 0; i < errorLocations.length; i++) {\n                let position = received.length - 1 - this.field.log(errorLocations[i]);\n                if (position < 0) {\n                    throw ChecksumException.getChecksumInstance();\n                }\n                received[position] = this.field.subtract(received[position], errorMagnitudes[i]);\n            }\n            return errorLocations.length;\n        }\n        /**\n         *\n         * @param ModulusPoly\n         * @param a\n         * @param ModulusPoly\n         * @param b\n         * @param int\n         * @param R\n         * @throws ChecksumException\n         */\n        runEuclideanAlgorithm(a, b, R) {\n            // Assume a's degree is >= b's\n            if (a.getDegree() < b.getDegree()) {\n                let temp = a;\n                a = b;\n                b = temp;\n            }\n            let rLast = a;\n            let r = b;\n            let tLast = this.field.getZero();\n            let t = this.field.getOne();\n            // Run Euclidean algorithm until r's degree is less than R/2\n            while (r.getDegree() >= Math.round(R / 2)) {\n                let rLastLast = rLast;\n                let tLastLast = tLast;\n                rLast = r;\n                tLast = t;\n                // Divide rLastLast by rLast, with quotient in q and remainder in r\n                if (rLast.isZero()) {\n                    // Oops, Euclidean algorithm already terminated?\n                    throw ChecksumException.getChecksumInstance();\n                }\n                r = rLastLast;\n                let q = this.field.getZero();\n                let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());\n                let dltInverse = this.field.inverse(denominatorLeadingTerm);\n                while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {\n                    let degreeDiff = r.getDegree() - rLast.getDegree();\n                    let scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);\n                    q = q.add(this.field.buildMonomial(degreeDiff, scale));\n                    r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));\n                }\n                t = q.multiply(tLast).subtract(tLastLast).negative();\n            }\n            let sigmaTildeAtZero = t.getCoefficient(0);\n            if (sigmaTildeAtZero === 0) {\n                throw ChecksumException.getChecksumInstance();\n            }\n            let inverse = this.field.inverse(sigmaTildeAtZero);\n            let sigma = t.multiply(inverse);\n            let omega = r.multiply(inverse);\n            return [sigma, omega];\n        }\n        /**\n         *\n         * @param errorLocator\n         * @throws ChecksumException\n         */\n        findErrorLocations(errorLocator) {\n            // This is a direct application of Chien's search\n            let numErrors = errorLocator.getDegree();\n            let result = new Int32Array(numErrors);\n            let e = 0;\n            for (let i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {\n                if (errorLocator.evaluateAt(i) === 0) {\n                    result[e] = this.field.inverse(i);\n                    e++;\n                }\n            }\n            if (e !== numErrors) {\n                throw ChecksumException.getChecksumInstance();\n            }\n            return result;\n        }\n        findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {\n            let errorLocatorDegree = errorLocator.getDegree();\n            let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);\n            for (let i /*int*/ = 1; i <= errorLocatorDegree; i++) {\n                formalDerivativeCoefficients[errorLocatorDegree - i] =\n                    this.field.multiply(i, errorLocator.getCoefficient(i));\n            }\n            let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);\n            // This is directly applying Forney's Formula\n            let s = errorLocations.length;\n            let result = new Int32Array(s);\n            for (let i /*int*/ = 0; i < s; i++) {\n                let xiInverse = this.field.inverse(errorLocations[i]);\n                let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));\n                let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));\n                result[i] = this.field.multiply(numerator, denominator);\n            }\n            return result;\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class BoundingBox {\n        constructor(image, topLeft, bottomLeft, topRight, bottomRight) {\n            if (image instanceof BoundingBox) {\n                this.constructor_2(image);\n            }\n            else {\n                this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);\n            }\n        }\n        /**\n         *\n         * @param image\n         * @param topLeft\n         * @param bottomLeft\n         * @param topRight\n         * @param bottomRight\n         *\n         * @throws NotFoundException\n         */\n        constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {\n            const leftUnspecified = topLeft == null || bottomLeft == null;\n            const rightUnspecified = topRight == null || bottomRight == null;\n            if (leftUnspecified && rightUnspecified) {\n                throw new NotFoundException();\n            }\n            if (leftUnspecified) {\n                topLeft = new ResultPoint(0, topRight.getY());\n                bottomLeft = new ResultPoint(0, bottomRight.getY());\n            }\n            else if (rightUnspecified) {\n                topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());\n                bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());\n            }\n            this.image = image;\n            this.topLeft = topLeft;\n            this.bottomLeft = bottomLeft;\n            this.topRight = topRight;\n            this.bottomRight = bottomRight;\n            this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));\n            this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));\n            this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));\n            this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));\n        }\n        constructor_2(boundingBox) {\n            this.image = boundingBox.image;\n            this.topLeft = boundingBox.getTopLeft();\n            this.bottomLeft = boundingBox.getBottomLeft();\n            this.topRight = boundingBox.getTopRight();\n            this.bottomRight = boundingBox.getBottomRight();\n            this.minX = boundingBox.getMinX();\n            this.maxX = boundingBox.getMaxX();\n            this.minY = boundingBox.getMinY();\n            this.maxY = boundingBox.getMaxY();\n        }\n        /**\n         * @throws NotFoundException\n         */\n        static merge(leftBox, rightBox) {\n            if (leftBox == null) {\n                return rightBox;\n            }\n            if (rightBox == null) {\n                return leftBox;\n            }\n            return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);\n        }\n        /**\n         * @throws NotFoundException\n         */\n        addMissingRows(missingStartRows, missingEndRows, isLeft) {\n            let newTopLeft = this.topLeft;\n            let newBottomLeft = this.bottomLeft;\n            let newTopRight = this.topRight;\n            let newBottomRight = this.bottomRight;\n            if (missingStartRows > 0) {\n                let top = isLeft ? this.topLeft : this.topRight;\n                let newMinY = Math.trunc(top.getY() - missingStartRows);\n                if (newMinY < 0) {\n                    newMinY = 0;\n                }\n                let newTop = new ResultPoint(top.getX(), newMinY);\n                if (isLeft) {\n                    newTopLeft = newTop;\n                }\n                else {\n                    newTopRight = newTop;\n                }\n            }\n            if (missingEndRows > 0) {\n                let bottom = isLeft ? this.bottomLeft : this.bottomRight;\n                let newMaxY = Math.trunc(bottom.getY() + missingEndRows);\n                if (newMaxY >= this.image.getHeight()) {\n                    newMaxY = this.image.getHeight() - 1;\n                }\n                let newBottom = new ResultPoint(bottom.getX(), newMaxY);\n                if (isLeft) {\n                    newBottomLeft = newBottom;\n                }\n                else {\n                    newBottomRight = newBottom;\n                }\n            }\n            return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);\n        }\n        getMinX() {\n            return this.minX;\n        }\n        getMaxX() {\n            return this.maxX;\n        }\n        getMinY() {\n            return this.minY;\n        }\n        getMaxY() {\n            return this.maxY;\n        }\n        getTopLeft() {\n            return this.topLeft;\n        }\n        getTopRight() {\n            return this.topRight;\n        }\n        getBottomLeft() {\n            return this.bottomLeft;\n        }\n        getBottomRight() {\n            return this.bottomRight;\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.pdf417.decoder;\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class BarcodeMetadata {\n        constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {\n            this.columnCount = columnCount;\n            this.errorCorrectionLevel = errorCorrectionLevel;\n            this.rowCountUpperPart = rowCountUpperPart;\n            this.rowCountLowerPart = rowCountLowerPart;\n            this.rowCount = rowCountUpperPart + rowCountLowerPart;\n        }\n        getColumnCount() {\n            return this.columnCount;\n        }\n        getErrorCorrectionLevel() {\n            return this.errorCorrectionLevel;\n        }\n        getRowCount() {\n            return this.rowCount;\n        }\n        getRowCountUpperPart() {\n            return this.rowCountUpperPart;\n        }\n        getRowCountLowerPart() {\n            return this.rowCountLowerPart;\n        }\n    }\n\n    /**\n     * Java Formatter class polyfill that works in the JS way.\n     */\n    class Formatter {\n        constructor() {\n            this.buffer = '';\n        }\n        /**\n         *\n         * @see https://stackoverflow.com/a/13439711/4367683\n         *\n         * @param str\n         * @param arr\n         */\n        static form(str, arr) {\n            let i = -1;\n            function callback(exp, p0, p1, p2, p3, p4) {\n                if (exp === '%%')\n                    return '%';\n                if (arr[++i] === undefined)\n                    return undefined;\n                exp = p2 ? parseInt(p2.substr(1)) : undefined;\n                let base = p3 ? parseInt(p3.substr(1)) : undefined;\n                let val;\n                switch (p4) {\n                    case 's':\n                        val = arr[i];\n                        break;\n                    case 'c':\n                        val = arr[i][0];\n                        break;\n                    case 'f':\n                        val = parseFloat(arr[i]).toFixed(exp);\n                        break;\n                    case 'p':\n                        val = parseFloat(arr[i]).toPrecision(exp);\n                        break;\n                    case 'e':\n                        val = parseFloat(arr[i]).toExponential(exp);\n                        break;\n                    case 'x':\n                        val = parseInt(arr[i]).toString(base ? base : 16);\n                        break;\n                    case 'd':\n                        val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);\n                        break;\n                }\n                val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);\n                let size = parseInt(p1); /* padding size */\n                let ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */\n                while (val.length < size)\n                    val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n                return val;\n            }\n            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n            return str.replace(regex, callback);\n        }\n        /**\n         *\n         * @param append The new string to append.\n         * @param args Argumets values to be formated.\n         */\n        format(append, ...args) {\n            this.buffer += Formatter.form(append, args);\n        }\n        /**\n         * Returns the Formatter string value.\n         */\n        toString() {\n            return this.buffer;\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Guenther Grau\n     */\n    class DetectionResultColumn {\n        constructor(boundingBox) {\n            this.boundingBox = new BoundingBox(boundingBox);\n            // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];\n            this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);\n        }\n        /*final*/ getCodewordNearby(imageRow) {\n            let codeword = this.getCodeword(imageRow);\n            if (codeword != null) {\n                return codeword;\n            }\n            for (let i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {\n                let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;\n                if (nearImageRow >= 0) {\n                    codeword = this.codewords[nearImageRow];\n                    if (codeword != null) {\n                        return codeword;\n                    }\n                }\n                nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;\n                if (nearImageRow < this.codewords.length) {\n                    codeword = this.codewords[nearImageRow];\n                    if (codeword != null) {\n                        return codeword;\n                    }\n                }\n            }\n            return null;\n        }\n        /*final int*/ imageRowToCodewordIndex(imageRow) {\n            return imageRow - this.boundingBox.getMinY();\n        }\n        /*final void*/ setCodeword(imageRow, codeword) {\n            this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;\n        }\n        /*final*/ getCodeword(imageRow) {\n            return this.codewords[this.imageRowToCodewordIndex(imageRow)];\n        }\n        /*final*/ getBoundingBox() {\n            return this.boundingBox;\n        }\n        /*final*/ getCodewords() {\n            return this.codewords;\n        }\n        // @Override\n        toString() {\n            const formatter = new Formatter();\n            let row = 0;\n            for (const codeword of this.codewords) {\n                if (codeword == null) {\n                    formatter.format('%3d:    |   %n', row++);\n                    continue;\n                }\n                formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());\n            }\n            return formatter.toString();\n        }\n    }\n    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.ArrayList;\n    // import java.util.Collection;\n    // import java.util.HashMap;\n    // import java.util.Map;\n    // import java.util.Map.Entry;\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class BarcodeValue {\n        constructor() {\n            this.values = new Map();\n        }\n        /**\n         * Add an occurrence of a value\n         */\n        setValue(value) {\n            value = Math.trunc(value);\n            let confidence = this.values.get(value);\n            if (confidence == null) {\n                confidence = 0;\n            }\n            confidence++;\n            this.values.set(value, confidence);\n        }\n        /**\n         * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.\n         * @return an array of int, containing the values with the highest occurrence, or null, if no value was set\n         */\n        getValue() {\n            let maxConfidence = -1;\n            let result = new Array();\n            for (const [key, value] of this.values.entries()) {\n                const entry = {\n                    getKey: () => key,\n                    getValue: () => value,\n                };\n                if (entry.getValue() > maxConfidence) {\n                    maxConfidence = entry.getValue();\n                    result = [];\n                    result.push(entry.getKey());\n                }\n                else if (entry.getValue() === maxConfidence) {\n                    result.push(entry.getKey());\n                }\n            }\n            return PDF417Common.toIntArray(result);\n        }\n        getConfidence(value) {\n            return this.values.get(value);\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class DetectionResultRowIndicatorColumn extends DetectionResultColumn {\n        constructor(boundingBox, isLeft) {\n            super(boundingBox);\n            this._isLeft = isLeft;\n        }\n        setRowNumbers() {\n            for (let codeword /*Codeword*/ of this.getCodewords()) {\n                if (codeword != null) {\n                    codeword.setRowNumberAsRowIndicatorColumn();\n                }\n            }\n        }\n        // TODO implement properly\n        // TODO maybe we should add missing codewords to store the correct row number to make\n        // finding row numbers for other columns easier\n        // use row height count to make detection of invalid row numbers more reliable\n        adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {\n            let codewords = this.getCodewords();\n            this.setRowNumbers();\n            this.removeIncorrectCodewords(codewords, barcodeMetadata);\n            let boundingBox = this.getBoundingBox();\n            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n            // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and\n            // taller rows\n            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n            let barcodeRow = -1;\n            let maxRowHeight = 1;\n            let currentRowHeight = 0;\n            for (let codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let codeword = codewords[codewordsRow];\n                //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;\n                //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {\n                //        SimpleLog.log(LEVEL.WARNING,\n                //            \"Removing codeword, rowNumberSkew too high, codeword[\" + codewordsRow + \"]: Expected Row: \" +\n                //                expectedRowNumber + \", RealRow: \" + codeword.getRowNumber() + \", value: \" + codeword.getValue());\n                //        codewords[codewordsRow] = null;\n                //      }\n                let rowDifference = codeword.getRowNumber() - barcodeRow;\n                // TODO improve handling with case where first row indicator doesn't start with 0\n                if (rowDifference === 0) {\n                    currentRowHeight++;\n                }\n                else if (rowDifference === 1) {\n                    maxRowHeight = Math.max(maxRowHeight, currentRowHeight);\n                    currentRowHeight = 1;\n                    barcodeRow = codeword.getRowNumber();\n                }\n                else if (rowDifference < 0 ||\n                    codeword.getRowNumber() >= barcodeMetadata.getRowCount() ||\n                    rowDifference > codewordsRow) {\n                    codewords[codewordsRow] = null;\n                }\n                else {\n                    let checkedRows;\n                    if (maxRowHeight > 2) {\n                        checkedRows = (maxRowHeight - 2) * rowDifference;\n                    }\n                    else {\n                        checkedRows = rowDifference;\n                    }\n                    let closePreviousCodewordFound = checkedRows >= codewordsRow;\n                    for (let i /*int*/ = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {\n                        // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.\n                        // This should hopefully get rid of most problems already.\n                        closePreviousCodewordFound = codewords[codewordsRow - i] != null;\n                    }\n                    if (closePreviousCodewordFound) {\n                        codewords[codewordsRow] = null;\n                    }\n                    else {\n                        barcodeRow = codeword.getRowNumber();\n                        currentRowHeight = 1;\n                    }\n                }\n            }\n            // return (int) (averageRowHeight + 0.5);\n        }\n        getRowHeights() {\n            let barcodeMetadata = this.getBarcodeMetadata();\n            if (barcodeMetadata == null) {\n                return null;\n            }\n            this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);\n            let result = new Int32Array(barcodeMetadata.getRowCount());\n            for (let codeword /*Codeword*/ of this.getCodewords()) {\n                if (codeword != null) {\n                    let rowNumber = codeword.getRowNumber();\n                    if (rowNumber >= result.length) {\n                        // We have more rows than the barcode metadata allows for, ignore them.\n                        continue;\n                    }\n                    result[rowNumber]++;\n                } // else throw exception?\n            }\n            return result;\n        }\n        // TODO maybe we should add missing codewords to store the correct row number to make\n        // finding row numbers for other columns easier\n        // use row height count to make detection of invalid row numbers more reliable\n        adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {\n            let boundingBox = this.getBoundingBox();\n            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();\n            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();\n            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));\n            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));\n            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();\n            let codewords = this.getCodewords();\n            let barcodeRow = -1;\n            for (let codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let codeword = codewords[codewordsRow];\n                codeword.setRowNumberAsRowIndicatorColumn();\n                let rowDifference = codeword.getRowNumber() - barcodeRow;\n                // TODO improve handling with case where first row indicator doesn't start with 0\n                if (rowDifference === 0) ;\n                else if (rowDifference === 1) {\n                    barcodeRow = codeword.getRowNumber();\n                }\n                else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {\n                    codewords[codewordsRow] = null;\n                }\n                else {\n                    barcodeRow = codeword.getRowNumber();\n                }\n            }\n            // return (int) (averageRowHeight + 0.5);\n        }\n        getBarcodeMetadata() {\n            let codewords = this.getCodewords();\n            let barcodeColumnCount = new BarcodeValue();\n            let barcodeRowCountUpperPart = new BarcodeValue();\n            let barcodeRowCountLowerPart = new BarcodeValue();\n            let barcodeECLevel = new BarcodeValue();\n            for (let codeword /*Codeword*/ of codewords) {\n                if (codeword == null) {\n                    continue;\n                }\n                codeword.setRowNumberAsRowIndicatorColumn();\n                let rowIndicatorValue = codeword.getValue() % 30;\n                let codewordRowNumber = codeword.getRowNumber();\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch (codewordRowNumber % 3) {\n                    case 0:\n                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);\n                        break;\n                    case 1:\n                        barcodeECLevel.setValue(rowIndicatorValue / 3);\n                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);\n                        break;\n                    case 2:\n                        barcodeColumnCount.setValue(rowIndicatorValue + 1);\n                        break;\n                }\n            }\n            // Maybe we should check if we have ambiguous values?\n            if ((barcodeColumnCount.getValue().length === 0) ||\n                (barcodeRowCountUpperPart.getValue().length === 0) ||\n                (barcodeRowCountLowerPart.getValue().length === 0) ||\n                (barcodeECLevel.getValue().length === 0) ||\n                barcodeColumnCount.getValue()[0] < 1 ||\n                barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE ||\n                barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {\n                return null;\n            }\n            let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);\n            this.removeIncorrectCodewords(codewords, barcodeMetadata);\n            return barcodeMetadata;\n        }\n        removeIncorrectCodewords(codewords, barcodeMetadata) {\n            // Remove codewords which do not match the metadata\n            // TODO Maybe we should keep the incorrect codewords for the start and end positions?\n            for (let codewordRow /*int*/ = 0; codewordRow < codewords.length; codewordRow++) {\n                let codeword = codewords[codewordRow];\n                if (codewords[codewordRow] == null) {\n                    continue;\n                }\n                let rowIndicatorValue = codeword.getValue() % 30;\n                let codewordRowNumber = codeword.getRowNumber();\n                if (codewordRowNumber > barcodeMetadata.getRowCount()) {\n                    codewords[codewordRow] = null;\n                    continue;\n                }\n                if (!this._isLeft) {\n                    codewordRowNumber += 2;\n                }\n                switch (codewordRowNumber % 3) {\n                    case 0:\n                        if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                    case 1:\n                        if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() ||\n                            rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                    case 2:\n                        if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {\n                            codewords[codewordRow] = null;\n                        }\n                        break;\n                }\n            }\n        }\n        isLeft() {\n            return this._isLeft;\n        }\n        // @Override\n        toString() {\n            return 'IsLeft: ' + this._isLeft + '\\n' + super.toString();\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class DetectionResult {\n        constructor(barcodeMetadata, boundingBox) {\n            /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;\n            this.barcodeMetadata = barcodeMetadata;\n            this.barcodeColumnCount = barcodeMetadata.getColumnCount();\n            this.boundingBox = boundingBox;\n            // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];\n            this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);\n        }\n        getDetectionResultColumns() {\n            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);\n            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);\n            let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;\n            let previousUnadjustedCount;\n            do {\n                previousUnadjustedCount = unadjustedCodewordCount;\n                unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();\n            } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);\n            return this.detectionResultColumns;\n        }\n        adjustIndicatorColumnRowNumbers(detectionResultColumn) {\n            if (detectionResultColumn != null) {\n                detectionResultColumn\n                    .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);\n            }\n        }\n        // TODO ensure that no detected codewords with unknown row number are left\n        // we should be able to estimate the row height and use it as a hint for the row number\n        // we should also fill the rows top to bottom and bottom to top\n        /**\n         * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords\n         * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers\n         */\n        adjustRowNumbersAndGetCount() {\n            let unadjustedCount = this.adjustRowNumbersByRow();\n            if (unadjustedCount === 0) {\n                return 0;\n            }\n            for (let barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {\n                let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();\n                for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                    if (codewords[codewordsRow] == null) {\n                        continue;\n                    }\n                    if (!codewords[codewordsRow].hasValidRowNumber()) {\n                        this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        adjustRowNumbersByRow() {\n            this.adjustRowNumbersFromBothRI();\n            // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.\n            // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode\n            // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row\n            // number starts and ends.\n            let unadjustedCount = this.adjustRowNumbersFromLRI();\n            return unadjustedCount + this.adjustRowNumbersFromRRI();\n        }\n        adjustRowNumbersFromBothRI() {\n            if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n                return;\n            }\n            let LRIcodewords = this.detectionResultColumns[0].getCodewords();\n            let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n            for (let codewordsRow /*int*/ = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {\n                if (LRIcodewords[codewordsRow] != null &&\n                    RRIcodewords[codewordsRow] != null &&\n                    LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {\n                    for (let barcodeColumn /*int*/ = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {\n                        let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                        if (codeword == null) {\n                            continue;\n                        }\n                        codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());\n                        if (!codeword.hasValidRowNumber()) {\n                            this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;\n                        }\n                    }\n                }\n            }\n        }\n        adjustRowNumbersFromRRI() {\n            if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {\n                return 0;\n            }\n            let unadjustedCount = 0;\n            let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();\n            for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n                let invalidRowCounts = 0;\n                for (let barcodeColumn /*int*/ = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword != null) {\n                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                        if (!codeword.hasValidRowNumber()) {\n                            unadjustedCount++;\n                        }\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        adjustRowNumbersFromLRI() {\n            if (this.detectionResultColumns[0] == null) {\n                return 0;\n            }\n            let unadjustedCount = 0;\n            let codewords = this.detectionResultColumns[0].getCodewords();\n            for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {\n                if (codewords[codewordsRow] == null) {\n                    continue;\n                }\n                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();\n                let invalidRowCounts = 0;\n                for (let barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword != null) {\n                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);\n                        if (!codeword.hasValidRowNumber()) {\n                            unadjustedCount++;\n                        }\n                    }\n                }\n            }\n            return unadjustedCount;\n        }\n        static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {\n            if (codeword == null) {\n                return invalidRowCounts;\n            }\n            if (!codeword.hasValidRowNumber()) {\n                if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {\n                    codeword.setRowNumber(rowIndicatorRowNumber);\n                    invalidRowCounts = 0;\n                }\n                else {\n                    ++invalidRowCounts;\n                }\n            }\n            return invalidRowCounts;\n        }\n        adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {\n            if (!this.detectionResultColumns[barcodeColumn - 1]) {\n                return;\n            }\n            let codeword = codewords[codewordsRow];\n            let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();\n            let nextColumnCodewords = previousColumnCodewords;\n            if (this.detectionResultColumns[barcodeColumn + 1] != null) {\n                nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();\n            }\n            // let otherCodewords: Codeword[] = new Codeword[14];\n            let otherCodewords = new Array(14);\n            otherCodewords[2] = previousColumnCodewords[codewordsRow];\n            otherCodewords[3] = nextColumnCodewords[codewordsRow];\n            if (codewordsRow > 0) {\n                otherCodewords[0] = codewords[codewordsRow - 1];\n                otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];\n                otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];\n            }\n            if (codewordsRow > 1) {\n                otherCodewords[8] = codewords[codewordsRow - 2];\n                otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];\n                otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];\n            }\n            if (codewordsRow < codewords.length - 1) {\n                otherCodewords[1] = codewords[codewordsRow + 1];\n                otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];\n                otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];\n            }\n            if (codewordsRow < codewords.length - 2) {\n                otherCodewords[9] = codewords[codewordsRow + 2];\n                otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];\n                otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];\n            }\n            for (let otherCodeword of otherCodewords) {\n                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {\n                    return;\n                }\n            }\n        }\n        /**\n         * @return true, if row number was adjusted, false otherwise\n         */\n        static adjustRowNumber(codeword, otherCodeword) {\n            if (otherCodeword == null) {\n                return false;\n            }\n            if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {\n                codeword.setRowNumber(otherCodeword.getRowNumber());\n                return true;\n            }\n            return false;\n        }\n        getBarcodeColumnCount() {\n            return this.barcodeColumnCount;\n        }\n        getBarcodeRowCount() {\n            return this.barcodeMetadata.getRowCount();\n        }\n        getBarcodeECLevel() {\n            return this.barcodeMetadata.getErrorCorrectionLevel();\n        }\n        setBoundingBox(boundingBox) {\n            this.boundingBox = boundingBox;\n        }\n        getBoundingBox() {\n            return this.boundingBox;\n        }\n        setDetectionResultColumn(barcodeColumn, detectionResultColumn) {\n            this.detectionResultColumns[barcodeColumn] = detectionResultColumn;\n        }\n        getDetectionResultColumn(barcodeColumn) {\n            return this.detectionResultColumns[barcodeColumn];\n        }\n        // @Override\n        toString() {\n            let rowIndicatorColumn = this.detectionResultColumns[0];\n            if (rowIndicatorColumn == null) {\n                rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];\n            }\n            // try (\n            let formatter = new Formatter();\n            // ) {\n            for (let codewordsRow /*int*/ = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {\n                formatter.format('CW %3d:', codewordsRow);\n                for (let barcodeColumn /*int*/ = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {\n                    if (this.detectionResultColumns[barcodeColumn] == null) {\n                        formatter.format('    |   ');\n                        continue;\n                    }\n                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];\n                    if (codeword == null) {\n                        formatter.format('    |   ');\n                        continue;\n                    }\n                    formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());\n                }\n                formatter.format('%n');\n            }\n            return formatter.toString();\n            // }\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.pdf417.decoder;\n    /**\n     * @author Guenther Grau\n     */\n    /*final*/ class Codeword {\n        constructor(startX, endX, bucket, value) {\n            this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;\n            this.startX = Math.trunc(startX);\n            this.endX = Math.trunc(endX);\n            this.bucket = Math.trunc(bucket);\n            this.value = Math.trunc(value);\n        }\n        hasValidRowNumber() {\n            return this.isValidRowNumber(this.rowNumber);\n        }\n        isValidRowNumber(rowNumber) {\n            return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === (rowNumber % 3) * 3;\n        }\n        setRowNumberAsRowIndicatorColumn() {\n            this.rowNumber = Math.trunc((Math.trunc(this.value / 30)) * 3 + Math.trunc(this.bucket / 3));\n        }\n        getWidth() {\n            return this.endX - this.startX;\n        }\n        getStartX() {\n            return this.startX;\n        }\n        getEndX() {\n            return this.endX;\n        }\n        getBucket() {\n            return this.bucket;\n        }\n        getValue() {\n            return this.value;\n        }\n        getRowNumber() {\n            return this.rowNumber;\n        }\n        setRowNumber(rowNumber) {\n            this.rowNumber = rowNumber;\n        }\n        //   @Override\n        toString() {\n            return this.rowNumber + '|' + this.value;\n        }\n    }\n    Codeword.BARCODE_ROW_UNKNOWN = -1;\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * @author Guenther Grau\n     * @author creatale GmbH (christoph.schulz@creatale.de)\n     */\n    /*final*/ class PDF417CodewordDecoder {\n        /* @note\n         * this action have to be performed before first use of class\n         * - static constructor\n         * working with 32bit float (based from Java logic)\n        */\n        static initialize() {\n            // Pre-computes the symbol ratio table.\n            for ( /*int*/let i = 0; i < PDF417Common.SYMBOL_TABLE.length; i++) {\n                let currentSymbol = PDF417Common.SYMBOL_TABLE[i];\n                let currentBit = currentSymbol & 0x1;\n                for ( /*int*/let j = 0; j < PDF417Common.BARS_IN_MODULE; j++) {\n                    let size = 0.0;\n                    while ((currentSymbol & 0x1) === currentBit) {\n                        size += 1.0;\n                        currentSymbol >>= 1;\n                    }\n                    currentBit = currentSymbol & 0x1;\n                    if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {\n                        PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common.BARS_IN_MODULE);\n                    }\n                    PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common.MODULES_IN_CODEWORD);\n                }\n            }\n            this.bSymbolTableReady = true;\n        }\n        static getDecodedValue(moduleBitCount) {\n            let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));\n            if (decodedValue !== -1) {\n                return decodedValue;\n            }\n            return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);\n        }\n        static sampleBitCounts(moduleBitCount) {\n            let bitCountSum = MathUtils.sum(moduleBitCount);\n            let result = new Int32Array(PDF417Common.BARS_IN_MODULE);\n            let bitCountIndex = 0;\n            let sumPreviousBits = 0;\n            for ( /*int*/let i = 0; i < PDF417Common.MODULES_IN_CODEWORD; i++) {\n                let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) +\n                    (i * bitCountSum) / PDF417Common.MODULES_IN_CODEWORD;\n                if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {\n                    sumPreviousBits += moduleBitCount[bitCountIndex];\n                    bitCountIndex++;\n                }\n                result[bitCountIndex]++;\n            }\n            return result;\n        }\n        static getDecodedCodewordValue(moduleBitCount) {\n            let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);\n            return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;\n        }\n        static getBitValue(moduleBitCount) {\n            let result = /*long*/ 0;\n            for (let /*int*/ i = 0; i < moduleBitCount.length; i++) {\n                for ( /*int*/let bit = 0; bit < moduleBitCount[i]; bit++) {\n                    result = (result << 1) | (i % 2 === 0 ? 1 : 0);\n                }\n            }\n            return Math.trunc(result);\n        }\n        // working with 32bit float (as in Java)\n        static getClosestDecodedValue(moduleBitCount) {\n            let bitCountSum = MathUtils.sum(moduleBitCount);\n            let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);\n            if (bitCountSum > 1) {\n                for (let /*int*/ i = 0; i < bitCountRatios.length; i++) {\n                    bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);\n                }\n            }\n            let bestMatchError = Float.MAX_VALUE;\n            let bestMatch = -1;\n            if (!this.bSymbolTableReady) {\n                PDF417CodewordDecoder.initialize();\n            }\n            for ( /*int*/let j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {\n                let error = 0.0;\n                let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];\n                for ( /*int*/let k = 0; k < PDF417Common.BARS_IN_MODULE; k++) {\n                    let diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);\n                    error += Math.fround(diff * diff);\n                    if (error >= bestMatchError) {\n                        break;\n                    }\n                }\n                if (error < bestMatchError) {\n                    bestMatchError = error;\n                    bestMatch = PDF417Common.SYMBOL_TABLE[j];\n                }\n            }\n            return bestMatch;\n        }\n    }\n    // flag that the table is ready for use\n    PDF417CodewordDecoder.bSymbolTableReady = false;\n    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map(x => x = new Array(PDF417Common.BARS_IN_MODULE));\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.pdf417;\n    /**\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417ResultMetadata {\n        constructor() {\n            this.segmentCount = -1;\n            this.fileSize = -1;\n            this.timestamp = -1;\n            this.checksum = -1;\n        }\n        /**\n         * The Segment ID represents the segment of the whole file distributed over different symbols.\n         *\n         * @return File segment index\n         */\n        getSegmentIndex() {\n            return this.segmentIndex;\n        }\n        setSegmentIndex(segmentIndex) {\n            this.segmentIndex = segmentIndex;\n        }\n        /**\n         * Is the same for each related PDF417 symbol\n         *\n         * @return File ID\n         */\n        getFileId() {\n            return this.fileId;\n        }\n        setFileId(fileId) {\n            this.fileId = fileId;\n        }\n        /**\n         * @return always null\n         * @deprecated use dedicated already parsed fields\n         */\n        //   @Deprecated\n        getOptionalData() {\n            return this.optionalData;\n        }\n        /**\n         * @param optionalData old optional data format as int array\n         * @deprecated parse and use new fields\n         */\n        //   @Deprecated\n        setOptionalData(optionalData) {\n            this.optionalData = optionalData;\n        }\n        /**\n         * @return true if it is the last segment\n         */\n        isLastSegment() {\n            return this.lastSegment;\n        }\n        setLastSegment(lastSegment) {\n            this.lastSegment = lastSegment;\n        }\n        /**\n         * @return count of segments, -1 if not set\n         */\n        getSegmentCount() {\n            return this.segmentCount;\n        }\n        setSegmentCount(segmentCount /*int*/) {\n            this.segmentCount = segmentCount;\n        }\n        getSender() {\n            return this.sender || null;\n        }\n        setSender(sender) {\n            this.sender = sender;\n        }\n        getAddressee() {\n            return this.addressee || null;\n        }\n        setAddressee(addressee) {\n            this.addressee = addressee;\n        }\n        /**\n         * Filename of the encoded file\n         *\n         * @return filename\n         */\n        getFileName() {\n            return this.fileName;\n        }\n        setFileName(fileName) {\n            this.fileName = fileName;\n        }\n        /**\n         * filesize in bytes of the encoded file\n         *\n         * @return filesize in bytes, -1 if not set\n         */\n        getFileSize() {\n            return this.fileSize;\n        }\n        setFileSize(fileSize /*long*/) {\n            this.fileSize = fileSize;\n        }\n        /**\n         * 16-bit CRC checksum using CCITT-16\n         *\n         * @return crc checksum, -1 if not set\n         */\n        getChecksum() {\n            return this.checksum;\n        }\n        setChecksum(checksum /*int*/) {\n            this.checksum = checksum;\n        }\n        /**\n         * unix epock timestamp, elapsed seconds since 1970-01-01\n         *\n         * @return elapsed seconds, -1 if not set\n         */\n        getTimestamp() {\n            return this.timestamp;\n        }\n        setTimestamp(timestamp /*long*/) {\n            this.timestamp = timestamp;\n        }\n    }\n\n    /**\n     * Ponyfill for Java's Long class.\n     */\n    class Long {\n        /**\n         * Parses a string to a number, since JS has no really Int64.\n         *\n         * @param num Numeric string.\n         * @param radix Destination radix.\n         */\n        static parseLong(num, radix = undefined) {\n            return parseInt(num, radix);\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class NullPointerException extends Exception {\n    }\n    NullPointerException.kind = 'NullPointerException';\n\n    /*\n     * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.\n     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n     *\n     * This code is free software; you can redistribute it and/or modify it\n     * under the terms of the GNU General Public License version 2 only, as\n     * published by the Free Software Foundation.  Oracle designates this\n     * particular file as subject to the \"Classpath\" exception as provided\n     * by Oracle in the LICENSE file that accompanied this code.\n     *\n     * This code is distributed in the hope that it will be useful, but WITHOUT\n     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n     * version 2 for more details (a copy is included in the LICENSE file that\n     * accompanied this code).\n     *\n     * You should have received a copy of the GNU General Public License version\n     * 2 along with this work; if not, write to the Free Software Foundation,\n     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n     *\n     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n     * or visit www.oracle.com if you need additional information or have any\n     * questions.\n     */\n    // package java.io;\n    /**\n     * This abstract class is the superclass of all classes representing\n     * an output stream of bytes. An output stream accepts output bytes\n     * and sends them to some sink.\n     * <p>\n     * Applications that need to define a subclass of\n     * <code>OutputStream</code> must always provide at least a method\n     * that writes one byte of output.\n     *\n     * @author  Arthur van Hoff\n     * @see     java.io.BufferedOutputStream\n     * @see     java.io.ByteArrayOutputStream\n     * @see     java.io.DataOutputStream\n     * @see     java.io.FilterOutputStream\n     * @see     java.io.InputStream\n     * @see     java.io.OutputStream#write(int)\n     * @since   JDK1.0\n     */\n    /*public*/ class OutputStream /*implements Closeable, Flushable*/ {\n        /**\n         * Writes <code>b.length</code> bytes from the specified byte array\n         * to this output stream. The general contract for <code>write(b)</code>\n         * is that it should have exactly the same effect as the call\n         * <code>write(b, 0, b.length)</code>.\n         *\n         * @param      b   the data.\n         * @exception  IOException  if an I/O error occurs.\n         * @see        java.io.OutputStream#write(byte[], int, int)\n         */\n        writeBytes(b) {\n            this.writeBytesOffset(b, 0, b.length);\n        }\n        /**\n         * Writes <code>len</code> bytes from the specified byte array\n         * starting at offset <code>off</code> to this output stream.\n         * The general contract for <code>write(b, off, len)</code> is that\n         * some of the bytes in the array <code>b</code> are written to the\n         * output stream in order; element <code>b[off]</code> is the first\n         * byte written and <code>b[off+len-1]</code> is the last byte written\n         * by this operation.\n         * <p>\n         * The <code>write</code> method of <code>OutputStream</code> calls\n         * the write method of one argument on each of the bytes to be\n         * written out. Subclasses are encouraged to override this method and\n         * provide a more efficient implementation.\n         * <p>\n         * If <code>b</code> is <code>null</code>, a\n         * <code>NullPointerException</code> is thrown.\n         * <p>\n         * If <code>off</code> is negative, or <code>len</code> is negative, or\n         * <code>off+len</code> is greater than the length of the array\n         * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.\n         *\n         * @param      b     the data.\n         * @param      off   the start offset in the data.\n         * @param      len   the number of bytes to write.\n         * @exception  IOException  if an I/O error occurs. In particular,\n         *             an <code>IOException</code> is thrown if the output\n         *             stream is closed.\n         */\n        writeBytesOffset(b, off, len) {\n            if (b == null) {\n                throw new NullPointerException();\n            }\n            else if ((off < 0) || (off > b.length) || (len < 0) ||\n                ((off + len) > b.length) || ((off + len) < 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n            else if (len === 0) {\n                return;\n            }\n            for (let i = 0; i < len; i++) {\n                this.write(b[off + i]);\n            }\n        }\n        /**\n         * Flushes this output stream and forces any buffered output bytes\n         * to be written out. The general contract of <code>flush</code> is\n         * that calling it is an indication that, if any bytes previously\n         * written have been buffered by the implementation of the output\n         * stream, such bytes should immediately be written to their\n         * intended destination.\n         * <p>\n         * If the intended destination of this stream is an abstraction provided by\n         * the underlying operating system, for example a file, then flushing the\n         * stream guarantees only that bytes previously written to the stream are\n         * passed to the operating system for writing; it does not guarantee that\n         * they are actually written to a physical device such as a disk drive.\n         * <p>\n         * The <code>flush</code> method of <code>OutputStream</code> does nothing.\n         *\n         * @exception  IOException  if an I/O error occurs.\n         */\n        flush() {\n        }\n        /**\n         * Closes this output stream and releases any system resources\n         * associated with this stream. The general contract of <code>close</code>\n         * is that it closes the output stream. A closed stream cannot perform\n         * output operations and cannot be reopened.\n         * <p>\n         * The <code>close</code> method of <code>OutputStream</code> does nothing.\n         *\n         * @exception  IOException  if an I/O error occurs.\n         */\n        close() {\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class OutOfMemoryError extends Exception {\n    }\n\n    /*\n     * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.\n     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n     *\n     * This code is free software; you can redistribute it and/or modify it\n     * under the terms of the GNU General Public License version 2 only, as\n     * published by the Free Software Foundation.  Oracle designates this\n     * particular file as subject to the \"Classpath\" exception as provided\n     * by Oracle in the LICENSE file that accompanied this code.\n     *\n     * This code is distributed in the hope that it will be useful, but WITHOUT\n     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n     * version 2 for more details (a copy is included in the LICENSE file that\n     * accompanied this code).\n     *\n     * You should have received a copy of the GNU General Public License version\n     * 2 along with this work; if not, write to the Free Software Foundation,\n     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n     *\n     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n     * or visit www.oracle.com if you need additional information or have any\n     * questions.\n     */\n    /**\n     * This class implements an output stream in which the data is\n     * written into a byte array. The buffer automatically grows as data\n     * is written to it.\n     * The data can be retrieved using <code>toByteArray()</code> and\n     * <code>toString()</code>.\n     * <p>\n     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an <tt>IOException</tt>.\n     *\n     * @author  Arthur van Hoff\n     * @since   JDK1.0\n     */\n    /*public*/ class ByteArrayOutputStream extends OutputStream {\n        /**\n         * Creates a new byte array output stream. The buffer capacity is\n         * initially 32 bytes, though its size increases if necessary.\n         */\n        // public constructor() {\n        //     this(32);\n        // }\n        /**\n         * Creates a new byte array output stream, with a buffer capacity of\n         * the specified size, in bytes.\n         *\n         * @param   size   the initial size.\n         * @exception  IllegalArgumentException if size is negative.\n         */\n        constructor(size = 32) {\n            super();\n            /**\n             * The number of valid bytes in the buffer.\n             */\n            this.count = 0;\n            if (size < 0) {\n                throw new IllegalArgumentException('Negative initial size: '\n                    + size);\n            }\n            this.buf = new Uint8Array(size);\n        }\n        /**\n         * Increases the capacity if necessary to ensure that it can hold\n         * at least the number of elements specified by the minimum\n         * capacity argument.\n         *\n         * @param minCapacity the desired minimum capacity\n         * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is\n         * interpreted as a request for the unsatisfiably large capacity\n         * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.\n         */\n        ensureCapacity(minCapacity) {\n            // overflow-conscious code\n            if (minCapacity - this.buf.length > 0)\n                this.grow(minCapacity);\n        }\n        /**\n         * Increases the capacity to ensure that it can hold at least the\n         * number of elements specified by the minimum capacity argument.\n         *\n         * @param minCapacity the desired minimum capacity\n         */\n        grow(minCapacity) {\n            // overflow-conscious code\n            let oldCapacity = this.buf.length;\n            let newCapacity = oldCapacity << 1;\n            if (newCapacity - minCapacity < 0)\n                newCapacity = minCapacity;\n            if (newCapacity < 0) {\n                if (minCapacity < 0) // overflow\n                    throw new OutOfMemoryError();\n                newCapacity = Integer.MAX_VALUE;\n            }\n            this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);\n        }\n        /**\n         * Writes the specified byte to this byte array output stream.\n         *\n         * @param   b   the byte to be written.\n         */\n        write(b) {\n            this.ensureCapacity(this.count + 1);\n            this.buf[this.count] = /*(byte)*/ b;\n            this.count += 1;\n        }\n        /**\n         * Writes <code>len</code> bytes from the specified byte array\n         * starting at offset <code>off</code> to this byte array output stream.\n         *\n         * @param   b     the data.\n         * @param   off   the start offset in the data.\n         * @param   len   the number of bytes to write.\n         */\n        writeBytesOffset(b, off, len) {\n            if ((off < 0) || (off > b.length) || (len < 0) ||\n                ((off + len) - b.length > 0)) {\n                throw new IndexOutOfBoundsException();\n            }\n            this.ensureCapacity(this.count + len);\n            System.arraycopy(b, off, this.buf, this.count, len);\n            this.count += len;\n        }\n        /**\n         * Writes the complete contents of this byte array output stream to\n         * the specified output stream argument, as if by calling the output\n         * stream's write method using <code>out.write(buf, 0, count)</code>.\n         *\n         * @param      out   the output stream to which to write the data.\n         * @exception  IOException  if an I/O error occurs.\n         */\n        writeTo(out) {\n            out.writeBytesOffset(this.buf, 0, this.count);\n        }\n        /**\n         * Resets the <code>count</code> field of this byte array output\n         * stream to zero, so that all currently accumulated output in the\n         * output stream is discarded. The output stream can be used again,\n         * reusing the already allocated buffer space.\n         *\n         * @see     java.io.ByteArrayInputStream#count\n         */\n        reset() {\n            this.count = 0;\n        }\n        /**\n         * Creates a newly allocated byte array. Its size is the current\n         * size of this output stream and the valid contents of the buffer\n         * have been copied into it.\n         *\n         * @return  the current contents of this output stream, as a byte array.\n         * @see     java.io.ByteArrayOutputStream#size()\n         */\n        toByteArray() {\n            return Arrays.copyOfUint8Array(this.buf, this.count);\n        }\n        /**\n         * Returns the current size of the buffer.\n         *\n         * @return  the value of the <code>count</code> field, which is the number\n         *          of valid bytes in this output stream.\n         * @see     java.io.ByteArrayOutputStream#count\n         */\n        size() {\n            return this.count;\n        }\n        toString(param) {\n            if (!param) {\n                return this.toString_void();\n            }\n            if (typeof param === 'string') {\n                return this.toString_string(param);\n            }\n            return this.toString_number(param);\n        }\n        /**\n         * Converts the buffer's contents into a string decoding bytes using the\n         * platform's default character set. The length of the new <tt>String</tt>\n         * is a function of the character set, and hence may not be equal to the\n         * size of the buffer.\n         *\n         * <p> This method always replaces malformed-input and unmappable-character\n         * sequences with the default replacement string for the platform's\n         * default character set. The {@linkplain java.nio.charset.CharsetDecoder}\n         * class should be used when more control over the decoding process is\n         * required.\n         *\n         * @return String decoded from the buffer's contents.\n         * @since  JDK1.1\n         */\n        toString_void() {\n            return new String(this.buf /*, 0, this.count*/).toString();\n        }\n        /**\n         * Converts the buffer's contents into a string by decoding the bytes using\n         * the specified {@link java.nio.charset.Charset charsetName}. The length of\n         * the new <tt>String</tt> is a function of the charset, and hence may not be\n         * equal to the length of the byte array.\n         *\n         * <p> This method always replaces malformed-input and unmappable-character\n         * sequences with this charset's default replacement string. The {@link\n         * java.nio.charset.CharsetDecoder} class should be used when more control\n         * over the decoding process is required.\n         *\n         * @param  charsetName  the name of a supported\n         *              {@linkplain java.nio.charset.Charset </code>charset<code>}\n         * @return String decoded from the buffer's contents.\n         * @exception  UnsupportedEncodingException\n         *             If the named charset is not supported\n         * @since   JDK1.1\n         */\n        toString_string(charsetName) {\n            return new String(this.buf /*, 0, this.count, charsetName*/).toString();\n        }\n        /**\n         * Creates a newly allocated string. Its size is the current size of\n         * the output stream and the valid contents of the buffer have been\n         * copied into it. Each character <i>c</i> in the resulting string is\n         * constructed from the corresponding element <i>b</i> in the byte\n         * array such that:\n         * <blockquote><pre>\n         *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))\n         * </pre></blockquote>\n         *\n         * @deprecated This method does not properly convert bytes into characters.\n         * As of JDK&nbsp;1.1, the preferred way to do this is via the\n         * <code>toString(String enc)</code> method, which takes an encoding-name\n         * argument, or the <code>toString()</code> method, which uses the\n         * platform's default character encoding.\n         *\n         * @param      hibyte    the high byte of each resulting Unicode character.\n         * @return     the current contents of the output stream, as a string.\n         * @see        java.io.ByteArrayOutputStream#size()\n         * @see        java.io.ByteArrayOutputStream#toString(String)\n         * @see        java.io.ByteArrayOutputStream#toString()\n         */\n        // @Deprecated\n        toString_number(hibyte) {\n            return new String(this.buf /*, hibyte, 0, this.count*/).toString();\n        }\n        /**\n         * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in\n         * this class can be called after the stream has been closed without\n         * generating an <tt>IOException</tt>.\n         * <p>\n         *\n         * @throws IOException\n         */\n        close() {\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*private*/ var Mode$2;\n    (function (Mode) {\n        Mode[Mode[\"ALPHA\"] = 0] = \"ALPHA\";\n        Mode[Mode[\"LOWER\"] = 1] = \"LOWER\";\n        Mode[Mode[\"MIXED\"] = 2] = \"MIXED\";\n        Mode[Mode[\"PUNCT\"] = 3] = \"PUNCT\";\n        Mode[Mode[\"ALPHA_SHIFT\"] = 4] = \"ALPHA_SHIFT\";\n        Mode[Mode[\"PUNCT_SHIFT\"] = 5] = \"PUNCT_SHIFT\";\n    })(Mode$2 || (Mode$2 = {}));\n    /**\n     * Indirectly access the global BigInt constructor, it\n     * allows browsers that doesn't support BigInt to run\n     * the library without breaking due to \"undefined BigInt\"\n     * errors.\n     */\n    function getBigIntConstructor() {\n        if (typeof window !== 'undefined') {\n            return window['BigInt'] || null;\n        }\n        if (typeof __webpack_require__.g !== 'undefined') {\n            return __webpack_require__.g['BigInt'] || null;\n        }\n        if (typeof self !== 'undefined') {\n            return self['BigInt'] || null;\n        }\n        throw new Error('Can\\'t search globals for BigInt!');\n    }\n    /**\n     * Used to store the BigInt constructor.\n     */\n    let BigInteger;\n    /**\n     * This function creates a bigint value. It allows browsers\n     * that doesn't support BigInt to run the rest of the library\n     * by not directly accessing the BigInt constructor.\n     */\n    function createBigInt(num) {\n        if (typeof BigInteger === 'undefined') {\n            BigInteger = getBigIntConstructor();\n        }\n        if (BigInteger === null) {\n            throw new Error('BigInt is not supported!');\n        }\n        return BigInteger(num);\n    }\n    function getEXP900() {\n        // in Java - array with length = 16\n        let EXP900 = [];\n        EXP900[0] = createBigInt(1);\n        let nineHundred = createBigInt(900);\n        EXP900[1] = nineHundred;\n        // in Java - array with length = 16\n        for (let i /*int*/ = 2; i < 16; i++) {\n            EXP900[i] = EXP900[i - 1] * nineHundred;\n        }\n        return EXP900;\n    }\n    /**\n     * <p>This class contains the methods for decoding the PDF417 codewords.</p>\n     *\n     * @author SITA Lab (kevin.osullivan@sita.aero)\n     * @author Guenther Grau\n     */\n    /*final*/ class DecodedBitStreamParser$2 {\n        //   private DecodedBitStreamParser() {\n        // }\n        /**\n         *\n         * @param codewords\n         * @param ecLevel\n         *\n         * @throws FormatException\n         */\n        static decode(codewords, ecLevel) {\n            // pass encoding to result (will be used for decode symbols in byte mode)\n            let result = new StringBuilder('');\n            // let encoding: Charset = StandardCharsets.ISO_8859_1;\n            let encoding = CharacterSetECI.ISO8859_1;\n            /**\n             * @note the next command is specific from this TypeScript library\n             * because TS can't properly cast some values to char and\n             * convert it to string later correctly due to encoding\n             * differences from Java version. As reported here:\n             * https://github.com/zxing-js/library/pull/264/files#r382831593\n             */\n            result.enableDecoding(encoding);\n            // Get compaction mode\n            let codeIndex = 1;\n            let code = codewords[codeIndex++];\n            let resultMetadata = new PDF417ResultMetadata();\n            while (codeIndex < codewords[0]) {\n                switch (code) {\n                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                        result.append(/*(char)*/ codewords[codeIndex++]);\n                        break;\n                    case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                        codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);\n                        break;\n                    case DecodedBitStreamParser$2.ECI_CHARSET:\n                        let charsetECI = CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);\n                        // encoding = Charset.forName(charsetECI.getName());\n                        break;\n                    case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:\n                        // Can't do anything with generic ECI; skip its 2 characters\n                        codeIndex += 2;\n                        break;\n                    case DecodedBitStreamParser$2.ECI_USER_DEFINED:\n                        // Can't do anything with user ECI; skip its 1 character\n                        codeIndex++;\n                        break;\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);\n                        break;\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                        // Should not see these outside a macro block\n                        throw new FormatException();\n                    default:\n                        // Default to text compaction. During testing numerous barcodes\n                        // appeared to be missing the starting mode. In these cases defaulting\n                        // to text compaction seems to work.\n                        codeIndex--;\n                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);\n                        break;\n                }\n                if (codeIndex < codewords.length) {\n                    code = codewords[codeIndex++];\n                }\n                else {\n                    throw FormatException.getFormatInstance();\n                }\n            }\n            if (result.length() === 0) {\n                throw FormatException.getFormatInstance();\n            }\n            let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);\n            decoderResult.setOther(resultMetadata);\n            return decoderResult;\n        }\n        /**\n         *\n         * @param int\n         * @param param1\n         * @param codewords\n         * @param int\n         * @param codeIndex\n         * @param PDF417ResultMetadata\n         * @param resultMetadata\n         *\n         * @throws FormatException\n         */\n        // @SuppressWarnings(\"deprecation\")\n        static decodeMacroBlock(codewords, codeIndex, resultMetadata) {\n            if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {\n                // we must have at least two bytes left for the segment index\n                throw FormatException.getFormatInstance();\n            }\n            let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);\n            for (let i /*int*/ = 0; i < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {\n                segmentIndexArray[i] = codewords[codeIndex];\n            }\n            resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));\n            let fileId = new StringBuilder();\n            codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);\n            resultMetadata.setFileId(fileId.toString());\n            let optionalFieldsStart = -1;\n            if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {\n                optionalFieldsStart = codeIndex + 1;\n            }\n            while (codeIndex < codewords[0]) {\n                switch (codewords[codeIndex]) {\n                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        codeIndex++;\n                        switch (codewords[codeIndex]) {\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:\n                                let fileName = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);\n                                resultMetadata.setFileName(fileName.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:\n                                let sender = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);\n                                resultMetadata.setSender(sender.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:\n                                let addressee = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);\n                                resultMetadata.setAddressee(addressee.toString());\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:\n                                let segmentCount = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);\n                                resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:\n                                let timestamp = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);\n                                resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:\n                                let checksum = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);\n                                resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));\n                                break;\n                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:\n                                let fileSize = new StringBuilder();\n                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);\n                                resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));\n                                break;\n                            default:\n                                throw FormatException.getFormatInstance();\n                        }\n                        break;\n                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                        codeIndex++;\n                        resultMetadata.setLastSegment(true);\n                        break;\n                    default:\n                        throw FormatException.getFormatInstance();\n                }\n            }\n            // copy optional fields to additional options\n            if (optionalFieldsStart !== -1) {\n                let optionalFieldsLength = codeIndex - optionalFieldsStart;\n                if (resultMetadata.isLastSegment()) {\n                    // do not include terminator\n                    optionalFieldsLength--;\n                }\n                resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));\n            }\n            return codeIndex;\n        }\n        /**\n         * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be\n         * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as\n         * well as selected control characters.\n         *\n         * @param codewords The array of codewords (data + error)\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         */\n        static textCompaction(codewords, codeIndex, result) {\n            // 2 character per codeword\n            let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n            // Used to hold the byte compaction value if there is a mode shift\n            let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);\n            let index = 0;\n            let end = false;\n            while ((codeIndex < codewords[0]) && !end) {\n                let code = codewords[codeIndex++];\n                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                    textCompactionData[index] = code / 30;\n                    textCompactionData[index + 1] = code % 30;\n                    index += 2;\n                }\n                else {\n                    switch (code) {\n                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                            // reinitialize text compaction mode to alpha sub mode\n                            textCompactionData[index++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;\n                            break;\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                        case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                            // The Mode Shift codeword 913 shall cause a temporary\n                            // switch from Text Compaction mode to Byte Compaction mode.\n                            // This switch shall be in effect for only the next codeword,\n                            // after which the mode shall revert to the prevailing sub-mode\n                            // of the Text Compaction mode. Codeword 913 is only available\n                            // in Text Compaction mode; its use is described in 5.4.2.4.\n                            textCompactionData[index] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;\n                            code = codewords[codeIndex++];\n                            byteCompactionData[index] = code;\n                            index++;\n                            break;\n                    }\n                }\n            }\n            DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);\n            return codeIndex;\n        }\n        /**\n         * The Text Compaction mode includes all the printable ASCII characters\n         * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab\n         * (9: e), LF or line feed (10: e), and CR or carriage\n         * return (13: e). The Text Compaction mode also includes various latch\n         * and shift characters which are used exclusively within the mode. The Text\n         * Compaction mode encodes up to 2 characters per codeword. The compaction rules\n         * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode\n         * switches are defined in 5.4.2.3.\n         *\n         * @param textCompactionData The text compaction data.\n         * @param byteCompactionData The byte compaction data if there\n         *                           was a mode shift.\n         * @param length             The size of the text compaction and byte compaction data.\n         * @param result             The decoded data is appended to the result.\n         */\n        static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {\n            // Beginning from an initial state of the Alpha sub-mode\n            // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text\n            // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text\n            // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.\n            let subMode = Mode$2.ALPHA;\n            let priorToShiftMode = Mode$2.ALPHA;\n            let i = 0;\n            while (i < length) {\n                let subModeCh = textCompactionData[i];\n                let ch = /*char*/ '';\n                switch (subMode) {\n                    case Mode$2.ALPHA:\n                        // Alpha (alphabetic: uppercase)\n                        if (subModeCh < 26) {\n                            // Upper case Alpha Character\n                            // Note: 65 = 'A' ASCII -> there is byte code of symbol\n                            ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.LL:\n                                    subMode = Mode$2.LOWER;\n                                    break;\n                                case DecodedBitStreamParser$2.ML:\n                                    subMode = Mode$2.MIXED;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.LOWER:\n                        // Lower (alphabetic: lowercase)\n                        if (subModeCh < 26) {\n                            ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.AS:\n                                    // Shift to alpha\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.ALPHA_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.ML:\n                                    subMode = Mode$2.MIXED;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    // TODO Does this need to use the current character encoding? See other occurrences below\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.MIXED:\n                        // Mixed (punctuation: e)\n                        if (subModeCh < DecodedBitStreamParser$2.PL) {\n                            ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case DecodedBitStreamParser$2.PL:\n                                    subMode = Mode$2.PUNCT;\n                                    break;\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.LL:\n                                    subMode = Mode$2.LOWER;\n                                    break;\n                                case DecodedBitStreamParser$2.AL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.PS:\n                                    // Shift to punctuation\n                                    priorToShiftMode = subMode;\n                                    subMode = Mode$2.PUNCT_SHIFT;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.PUNCT:\n                        // Punctuation\n                        if (subModeCh < DecodedBitStreamParser$2.PAL) {\n                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case DecodedBitStreamParser$2.PAL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.ALPHA_SHIFT:\n                        // Restore sub-mode\n                        subMode = priorToShiftMode;\n                        if (subModeCh < 26) {\n                            ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case 26:\n                                    ch = ' ';\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                    case Mode$2.PUNCT_SHIFT:\n                        // Restore sub-mode\n                        subMode = priorToShiftMode;\n                        if (subModeCh < DecodedBitStreamParser$2.PAL) {\n                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];\n                        }\n                        else {\n                            switch (subModeCh) {\n                                case DecodedBitStreamParser$2.PAL:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:\n                                    // PS before Shift-to-Byte is used as a padding character,\n                                    // see 5.4.2.4 of the specification\n                                    result.append(/*(char)*/ byteCompactionData[i]);\n                                    break;\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                    subMode = Mode$2.ALPHA;\n                                    break;\n                            }\n                        }\n                        break;\n                }\n                // if (ch !== 0) {\n                if (ch !== '') {\n                    // Append decoded character to result\n                    result.append(ch);\n                }\n                i++;\n            }\n        }\n        /**\n         * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.\n         * This includes all ASCII characters value 0 to 127 inclusive and provides for international\n         * character set support.\n         *\n         * @param mode      The byte compaction mode i.e. 901 or 924\n         * @param codewords The array of codewords (data + error)\n         * @param encoding  Currently active character encoding\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         */\n        static /*int*/ byteCompaction(mode, codewords, encoding, codeIndex, result) {\n            let decodedBytes = new ByteArrayOutputStream();\n            let count = 0;\n            let value = /*long*/ 0;\n            let end = false;\n            switch (mode) {\n                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                    // Total number of Byte Compaction characters to be encoded\n                    // is not a multiple of 6\n                    let byteCompactedCodewords = new Int32Array(6);\n                    let nextCode = codewords[codeIndex++];\n                    while ((codeIndex < codewords[0]) && !end) {\n                        byteCompactedCodewords[count++] = nextCode;\n                        // Base 900\n                        value = 900 * value + nextCode;\n                        nextCode = codewords[codeIndex++];\n                        // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH\n                        switch (nextCode) {\n                            case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                                codeIndex--;\n                                end = true;\n                                break;\n                            default:\n                                if ((count % 5 === 0) && (count > 0)) {\n                                    // Decode every 5 codewords\n                                    // Convert to Base 256\n                                    for (let j /*int*/ = 0; j < 6; ++j) {\n                                        /* @note\n                                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                                         * So the next bitwise operation could not be done with simple numbers\n                                         */\n                                        decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                                    }\n                                    value = 0;\n                                    count = 0;\n                                }\n                                break;\n                        }\n                    }\n                    // if the end of all codewords is reached the last codeword needs to be added\n                    if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                        byteCompactedCodewords[count++] = nextCode;\n                    }\n                    // If Byte Compaction mode is invoked with codeword 901,\n                    // the last group of codewords is interpreted directly\n                    // as one byte per codeword, without compaction.\n                    for (let i /*int*/ = 0; i < count; i++) {\n                        decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);\n                    }\n                    break;\n                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                    // Total number of Byte Compaction characters to be encoded\n                    // is an integer multiple of 6\n                    while (codeIndex < codewords[0] && !end) {\n                        let code = codewords[codeIndex++];\n                        if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                            count++;\n                            // Base 900\n                            value = 900 * value + code;\n                        }\n                        else {\n                            switch (code) {\n                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:\n                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                                    codeIndex--;\n                                    end = true;\n                                    break;\n                            }\n                        }\n                        if ((count % 5 === 0) && (count > 0)) {\n                            // Decode every 5 codewords\n                            // Convert to Base 256\n                            /* @note\n                             * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.\n                             * So the next bitwise operation could not be done with simple numbers\n                            */\n                            for (let j /*int*/ = 0; j < 6; ++j) {\n                                decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));\n                            }\n                            value = 0;\n                            count = 0;\n                        }\n                    }\n                    break;\n            }\n            result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));\n            return codeIndex;\n        }\n        /**\n         * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.\n         *\n         * @param codewords The array of codewords (data + error)\n         * @param codeIndex The current index into the codeword array.\n         * @param result    The decoded data is appended to the result.\n         * @return The next index into the codeword array.\n         *\n         * @throws FormatException\n         */\n        static numericCompaction(codewords, codeIndex /*int*/, result) {\n            let count = 0;\n            let end = false;\n            let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);\n            while (codeIndex < codewords[0] && !end) {\n                let code = codewords[codeIndex++];\n                if (codeIndex === codewords[0]) {\n                    end = true;\n                }\n                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {\n                    numericCodewords[count] = code;\n                    count++;\n                }\n                else {\n                    switch (code) {\n                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:\n                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:\n                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:\n                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:\n                            codeIndex--;\n                            end = true;\n                            break;\n                    }\n                }\n                if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {\n                    // Re-invoking Numeric Compaction mode (by using codeword 902\n                    // while in Numeric Compaction mode) serves  to terminate the\n                    // current Numeric Compaction mode grouping as described in 5.4.4.2,\n                    // and then to start a new one grouping.\n                    result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));\n                    count = 0;\n                }\n            }\n            return codeIndex;\n        }\n        /**\n         * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.\n         *\n         * @param codewords The array of codewords\n         * @param count     The number of codewords\n         * @return The decoded string representing the Numeric data.\n         *\n         * EXAMPLE\n         * Encode the fifteen digit numeric string 000213298174000\n         * Prefix the numeric string with a 1 and set the initial value of\n         * t = 1 000 213 298 174 000\n         * Calculate codeword 0\n         * d0 = 1 000 213 298 174 000 mod 900 = 200\n         *\n         * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082\n         * Calculate codeword 1\n         * d1 = 1 111 348 109 082 mod 900 = 282\n         *\n         * t = 1 111 348 109 082 div 900 = 1 234 831 232\n         * Calculate codeword 2\n         * d2 = 1 234 831 232 mod 900 = 632\n         *\n         * t = 1 234 831 232 div 900 = 1 372 034\n         * Calculate codeword 3\n         * d3 = 1 372 034 mod 900 = 434\n         *\n         * t = 1 372 034 div 900 = 1 524\n         * Calculate codeword 4\n         * d4 = 1 524 mod 900 = 624\n         *\n         * t = 1 524 div 900 = 1\n         * Calculate codeword 5\n         * d5 = 1 mod 900 = 1\n         * t = 1 div 900 = 0\n         * Codeword sequence is: 1, 624, 434, 632, 282, 200\n         *\n         * Decode the above codewords involves\n         *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +\n         * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000\n         *\n         * Remove leading 1 =>  Result is 000213298174000\n         *\n         * @throws FormatException\n         */\n        static decodeBase900toBase10(codewords, count) {\n            let result = createBigInt(0);\n            for (let i /*int*/ = 0; i < count; i++) {\n                result += DecodedBitStreamParser$2.EXP900[count - i - 1] * createBigInt(codewords[i]);\n            }\n            let resultString = result.toString();\n            if (resultString.charAt(0) !== '1') {\n                throw new FormatException();\n            }\n            return resultString.substring(1);\n        }\n    }\n    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;\n    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;\n    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;\n    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;\n    DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;\n    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;\n    DecodedBitStreamParser$2.ECI_CHARSET = 927;\n    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;\n    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;\n    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;\n    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;\n    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;\n    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;\n    DecodedBitStreamParser$2.PL = 25;\n    DecodedBitStreamParser$2.LL = 27;\n    DecodedBitStreamParser$2.AS = 27;\n    DecodedBitStreamParser$2.ML = 28;\n    DecodedBitStreamParser$2.AL = 28;\n    DecodedBitStreamParser$2.PS = 29;\n    DecodedBitStreamParser$2.PAL = 29;\n    DecodedBitStreamParser$2.PUNCT_CHARS = ';<>@[\\\\]_`~!\\r\\t,:\\n-.$/\"|*()?{}\\'';\n    DecodedBitStreamParser$2.MIXED_CHARS = '0123456789&\\r\\t,:#-.$/+%*=^';\n    /**\n     * Table containing values for the exponent of 900.\n     * This is used in the numeric compaction decode algorithm.\n     */\n    DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];\n    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    // import java.util.ArrayList;\n    // import java.util.Collection;\n    // import java.util.Formatter;\n    // import java.util.List;\n    /**\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417ScanningDecoder {\n        constructor() { }\n        /**\n         * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern\n         *\n         * columns. That way width can be deducted from the pattern column.\n         * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider\n         * than it should be. This can happen if the scanner used a bad blackpoint.\n         *\n         * @param BitMatrix\n         * @param image\n         * @param ResultPoint\n         * @param imageTopLeft\n         * @param ResultPoint\n         * @param imageBottomLeft\n         * @param ResultPoint\n         * @param imageTopRight\n         * @param ResultPoint\n         * @param imageBottomRight\n         * @param int\n         * @param minCodewordWidth\n         * @param int\n         * @param maxCodewordWidth\n         *\n         * @throws NotFoundException\n         * @throws FormatException\n         * @throws ChecksumException\n         */\n        static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {\n            let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);\n            let leftRowIndicatorColumn = null;\n            let rightRowIndicatorColumn = null;\n            let detectionResult;\n            for (let firstPass /*boolean*/ = true;; firstPass = false) {\n                if (imageTopLeft != null) {\n                    leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);\n                }\n                if (imageTopRight != null) {\n                    rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);\n                }\n                detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);\n                if (detectionResult == null) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                let resultBox = detectionResult.getBoundingBox();\n                if (firstPass && resultBox != null &&\n                    (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {\n                    boundingBox = resultBox;\n                }\n                else {\n                    break;\n                }\n            }\n            detectionResult.setBoundingBox(boundingBox);\n            let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;\n            detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);\n            detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);\n            let leftToRight = leftRowIndicatorColumn != null;\n            for (let barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {\n                let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;\n                if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {\n                    // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.\n                    continue;\n                }\n                let detectionResultColumn;\n                if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {\n                    detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);\n                }\n                else {\n                    detectionResultColumn = new DetectionResultColumn(boundingBox);\n                }\n                detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);\n                let startColumn = -1;\n                let previousStartColumn = startColumn;\n                // TODO start at a row for which we know the start position, then detect upwards and downwards from there.\n                for (let imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {\n                    startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);\n                    if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {\n                        if (previousStartColumn === -1) {\n                            continue;\n                        }\n                        startColumn = previousStartColumn;\n                    }\n                    let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                    if (codeword != null) {\n                        detectionResultColumn.setCodeword(imageRow, codeword);\n                        previousStartColumn = startColumn;\n                        minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());\n                        maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());\n                    }\n                }\n            }\n            return PDF417ScanningDecoder.createDecoderResult(detectionResult);\n        }\n        /**\n         *\n         * @param leftRowIndicatorColumn\n         * @param rightRowIndicatorColumn\n         *\n         * @throws NotFoundException\n         */\n        static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {\n            if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {\n                return null;\n            }\n            let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);\n            if (barcodeMetadata == null) {\n                return null;\n            }\n            let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));\n            return new DetectionResult(barcodeMetadata, boundingBox);\n        }\n        /**\n         *\n         * @param rowIndicatorColumn\n         *\n         * @throws NotFoundException\n         */\n        static adjustBoundingBox(rowIndicatorColumn) {\n            if (rowIndicatorColumn == null) {\n                return null;\n            }\n            let rowHeights = rowIndicatorColumn.getRowHeights();\n            if (rowHeights == null) {\n                return null;\n            }\n            let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);\n            let missingStartRows = 0;\n            for (let rowHeight /*int*/ of rowHeights) {\n                missingStartRows += maxRowHeight - rowHeight;\n                if (rowHeight > 0) {\n                    break;\n                }\n            }\n            let codewords = rowIndicatorColumn.getCodewords();\n            for (let row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {\n                missingStartRows--;\n            }\n            let missingEndRows = 0;\n            for (let row /*int*/ = rowHeights.length - 1; row >= 0; row--) {\n                missingEndRows += maxRowHeight - rowHeights[row];\n                if (rowHeights[row] > 0) {\n                    break;\n                }\n            }\n            for (let row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {\n                missingEndRows--;\n            }\n            return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());\n        }\n        static getMax(values) {\n            let maxValue = -1;\n            for (let value /*int*/ of values) {\n                maxValue = Math.max(maxValue, value);\n            }\n            return maxValue;\n        }\n        static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {\n            let leftBarcodeMetadata;\n            if (leftRowIndicatorColumn == null ||\n                (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {\n                return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();\n            }\n            let rightBarcodeMetadata;\n            if (rightRowIndicatorColumn == null ||\n                (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {\n                return leftBarcodeMetadata;\n            }\n            if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&\n                leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&\n                leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {\n                return null;\n            }\n            return leftBarcodeMetadata;\n        }\n        static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {\n            let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);\n            for (let i /*int*/ = 0; i < 2; i++) {\n                let increment = i === 0 ? 1 : -1;\n                let startColumn = Math.trunc(Math.trunc(startPoint.getX()));\n                for (let imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&\n                    imageRow >= boundingBox.getMinY(); imageRow += increment) {\n                    let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);\n                    if (codeword != null) {\n                        rowIndicatorColumn.setCodeword(imageRow, codeword);\n                        if (leftToRight) {\n                            startColumn = codeword.getStartX();\n                        }\n                        else {\n                            startColumn = codeword.getEndX();\n                        }\n                    }\n                }\n            }\n            return rowIndicatorColumn;\n        }\n        /**\n         *\n         * @param detectionResult\n         * @param BarcodeValue\n         * @param param2\n         * @param param3\n         * @param barcodeMatrix\n         *\n         * @throws NotFoundException\n         */\n        static adjustCodewordCount(detectionResult, barcodeMatrix) {\n            let barcodeMatrix01 = barcodeMatrix[0][1];\n            let numberOfCodewords = barcodeMatrix01.getValue();\n            let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *\n                detectionResult.getBarcodeRowCount() -\n                PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());\n            if (numberOfCodewords.length === 0) {\n                if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n            }\n            else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {\n                // The calculated one is more reliable as it is derived from the row indicator columns\n                barcodeMatrix01.setValue(calculatedNumberOfCodewords);\n            }\n        }\n        /**\n         *\n         * @param detectionResult\n         *\n         * @throws FormatException\n         * @throws ChecksumException\n         * @throws NotFoundException\n         */\n        static createDecoderResult(detectionResult) {\n            let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);\n            PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);\n            let erasures /*Collection<Integer>*/ = new Array();\n            let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());\n            let ambiguousIndexValuesList = /*List<int[]>*/ [];\n            let ambiguousIndexesList = /*Collection<Integer>*/ new Array();\n            for (let row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {\n                for (let column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {\n                    let values = barcodeMatrix[row][column + 1].getValue();\n                    let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;\n                    if (values.length === 0) {\n                        erasures.push(codewordIndex);\n                    }\n                    else if (values.length === 1) {\n                        codewords[codewordIndex] = values[0];\n                    }\n                    else {\n                        ambiguousIndexesList.push(codewordIndex);\n                        ambiguousIndexValuesList.push(values);\n                    }\n                }\n            }\n            let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);\n            for (let i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {\n                ambiguousIndexValues[i] = ambiguousIndexValuesList[i];\n            }\n            return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);\n        }\n        /**\n         * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The\n         * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value\n         * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of\n         * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the\n         * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,\n         * so decoding the normal barcodes is not affected by this.\n         *\n         * @param erasureArray contains the indexes of erasures\n         * @param ambiguousIndexes array with the indexes that have more than one most likely value\n         * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must\n         * be the same length as the ambiguousIndexes array\n         *\n         * @throws FormatException\n         * @throws ChecksumException\n         */\n        static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {\n            let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);\n            let tries = 100;\n            while (tries-- > 0) {\n                for (let i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                    codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];\n                }\n                try {\n                    return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);\n                }\n                catch (err) {\n                    let ignored = err instanceof ChecksumException;\n                    if (!ignored) {\n                        throw err;\n                    }\n                }\n                if (ambiguousIndexCount.length === 0) {\n                    throw ChecksumException.getChecksumInstance();\n                }\n                for (let i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {\n                    if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {\n                        ambiguousIndexCount[i]++;\n                        break;\n                    }\n                    else {\n                        ambiguousIndexCount[i] = 0;\n                        if (i === ambiguousIndexCount.length - 1) {\n                            throw ChecksumException.getChecksumInstance();\n                        }\n                    }\n                }\n            }\n            throw ChecksumException.getChecksumInstance();\n        }\n        static createBarcodeMatrix(detectionResult) {\n            // let barcodeMatrix: BarcodeValue[][] =\n            // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];\n            let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));\n            for (let row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n                for (let column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n                    barcodeMatrix[row][column] = new BarcodeValue();\n                }\n            }\n            let column = 0;\n            for (let detectionResultColumn /*DetectionResultColumn*/ of detectionResult.getDetectionResultColumns()) {\n                if (detectionResultColumn != null) {\n                    for (let codeword /*Codeword*/ of detectionResultColumn.getCodewords()) {\n                        if (codeword != null) {\n                            let rowNumber = codeword.getRowNumber();\n                            if (rowNumber >= 0) {\n                                if (rowNumber >= barcodeMatrix.length) {\n                                    // We have more rows than the barcode metadata allows for, ignore them.\n                                    continue;\n                                }\n                                barcodeMatrix[rowNumber][column].setValue(codeword.getValue());\n                            }\n                        }\n                    }\n                }\n                column++;\n            }\n            return barcodeMatrix;\n        }\n        static isValidBarcodeColumn(detectionResult, barcodeColumn) {\n            return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;\n        }\n        static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {\n            let offset = leftToRight ? 1 : -1;\n            let codeword = null;\n            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);\n            }\n            if (codeword != null) {\n                return leftToRight ? codeword.getEndX() : codeword.getStartX();\n            }\n            codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);\n            if (codeword != null) {\n                return leftToRight ? codeword.getStartX() : codeword.getEndX();\n            }\n            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);\n            }\n            if (codeword != null) {\n                return leftToRight ? codeword.getEndX() : codeword.getStartX();\n            }\n            let skippedColumns = 0;\n            while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {\n                barcodeColumn -= offset;\n                for (let previousRowCodeword /*Codeword*/ of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {\n                    if (previousRowCodeword != null) {\n                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +\n                            offset *\n                                skippedColumns *\n                                (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());\n                    }\n                }\n                skippedColumns++;\n            }\n            return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();\n        }\n        static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {\n            startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n            // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length\n            // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.\n            // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate\n            // for the current position\n            let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);\n            if (moduleBitCount == null) {\n                return null;\n            }\n            let endColumn;\n            let codewordBitCount = MathUtils.sum(moduleBitCount);\n            if (leftToRight) {\n                endColumn = startColumn + codewordBitCount;\n            }\n            else {\n                for (let i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {\n                    let tmpCount = moduleBitCount[i];\n                    moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];\n                    moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;\n                }\n                endColumn = startColumn;\n                startColumn = endColumn - codewordBitCount;\n            }\n            // TODO implement check for width and correction of black and white bars\n            // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.\n            // should probably done only for codewords with a lot more than 17 bits.\n            // The following fixes 10-1.png, which has wide black bars and small white bars\n            //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {\n            //      if (i % 2 === 0) {\n            //        moduleBitCount[i]--;\n            //      } else {\n            //        moduleBitCount[i]++;\n            //      }\n            //    }\n            // We could also use the width of surrounding codewords for more accurate results, but this seems\n            // sufficient for now\n            if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {\n                // We could try to use the startX and endX position of the codeword in the same column in the previous row,\n                // create the bit count from it and normalize it to 8. This would help with single pixel errors.\n                return null;\n            }\n            let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);\n            let codeword = PDF417Common.getCodeword(decodedValue);\n            if (codeword === -1) {\n                return null;\n            }\n            return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);\n        }\n        static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {\n            let imageColumn = startColumn;\n            let moduleBitCount = new Int32Array(8);\n            let moduleNumber = 0;\n            let increment = leftToRight ? 1 : -1;\n            let previousPixelValue = leftToRight;\n            while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&\n                moduleNumber < moduleBitCount.length) {\n                if (image.get(imageColumn, imageRow) === previousPixelValue) {\n                    moduleBitCount[moduleNumber]++;\n                    imageColumn += increment;\n                }\n                else {\n                    moduleNumber++;\n                    previousPixelValue = !previousPixelValue;\n                }\n            }\n            if (moduleNumber === moduleBitCount.length ||\n                ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&\n                    moduleNumber === moduleBitCount.length - 1)) {\n                return moduleBitCount;\n            }\n            return null;\n        }\n        static getNumberOfECCodeWords(barcodeECLevel) {\n            return 2 << barcodeECLevel;\n        }\n        static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {\n            let correctedStartColumn = codewordStartColumn;\n            let increment = leftToRight ? -1 : 1;\n            // there should be no black pixels before the start column. If there are, then we need to start earlier.\n            for (let i /*int*/ = 0; i < 2; i++) {\n                while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&\n                    leftToRight === image.get(correctedStartColumn, imageRow)) {\n                    if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {\n                        return codewordStartColumn;\n                    }\n                    correctedStartColumn += increment;\n                }\n                increment = -increment;\n                leftToRight = !leftToRight;\n            }\n            return correctedStartColumn;\n        }\n        static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {\n            return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&\n                codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;\n        }\n        /**\n         * @throws FormatException,\n         * @throws ChecksumException\n         */\n        static decodeCodewords(codewords, ecLevel, erasures) {\n            if (codewords.length === 0) {\n                throw FormatException.getFormatInstance();\n            }\n            let numECCodewords = 1 << (ecLevel + 1);\n            let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);\n            PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);\n            // Decode the codewords\n            let decoderResult = DecodedBitStreamParser$2.decode(codewords, '' + ecLevel);\n            decoderResult.setErrorsCorrected(correctedErrorsCount);\n            decoderResult.setErasures(erasures.length);\n            return decoderResult;\n        }\n        /**\n         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to\n         * correct the errors in-place.</p>\n         *\n         * @param codewords   data and error correction codewords\n         * @param erasures positions of any known erasures\n         * @param numECCodewords number of error correction codewords that are available in codewords\n         * @throws ChecksumException if error correction fails\n         */\n        static correctErrors(codewords, erasures, numECCodewords) {\n            if (erasures != null &&\n                erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||\n                numECCodewords < 0 ||\n                numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {\n                // Too many errors or EC Codewords is corrupted\n                throw ChecksumException.getChecksumInstance();\n            }\n            return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);\n        }\n        /**\n         * Verify that all is OK with the codeword array.\n         * @throws FormatException\n         */\n        static verifyCodewordCount(codewords, numECCodewords) {\n            if (codewords.length < 4) {\n                // Codeword array size should be at least 4 allowing for\n                // Count CW, At least one Data CW, Error Correction CW, Error Correction CW\n                throw FormatException.getFormatInstance();\n            }\n            // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data\n            // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad\n            // codewords, but excluding the number of error correction codewords.\n            let numberOfCodewords = codewords[0];\n            if (numberOfCodewords > codewords.length) {\n                throw FormatException.getFormatInstance();\n            }\n            if (numberOfCodewords === 0) {\n                // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)\n                if (numECCodewords < codewords.length) {\n                    codewords[0] = codewords.length - numECCodewords;\n                }\n                else {\n                    throw FormatException.getFormatInstance();\n                }\n            }\n        }\n        static getBitCountForCodeword(codeword) {\n            let result = new Int32Array(8);\n            let previousValue = 0;\n            let i = result.length - 1;\n            while (true) {\n                if ((codeword & 0x1) !== previousValue) {\n                    previousValue = codeword & 0x1;\n                    i--;\n                    if (i < 0) {\n                        break;\n                    }\n                }\n                result[i]++;\n                codeword >>= 1;\n            }\n            return result;\n        }\n        static getCodewordBucketNumber(codeword) {\n            if (codeword instanceof Int32Array) {\n                return this.getCodewordBucketNumber_Int32Array(codeword);\n            }\n            return this.getCodewordBucketNumber_number(codeword);\n        }\n        static getCodewordBucketNumber_number(codeword) {\n            return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));\n        }\n        static getCodewordBucketNumber_Int32Array(moduleBitCount) {\n            return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;\n        }\n        static toString(barcodeMatrix) {\n            let formatter = new Formatter();\n            // try (let formatter = new Formatter()) {\n            for (let row /*int*/ = 0; row < barcodeMatrix.length; row++) {\n                formatter.format('Row %2d: ', row);\n                for (let column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {\n                    let barcodeValue = barcodeMatrix[row][column];\n                    if (barcodeValue.getValue().length === 0) {\n                        formatter.format('        ', null);\n                    }\n                    else {\n                        formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));\n                    }\n                }\n                formatter.format('%n');\n            }\n            return formatter.toString();\n            // }\n        }\n    }\n    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;\n    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;\n    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;\n    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // import java.util.ArrayList;\n    // import java.util.List;\n    // import java.util.Map;\n    /**\n     * This implementation can detect and decode PDF417 codes in an image.\n     *\n     * @author Guenther Grau\n     */\n    /*public final*/ class PDF417Reader {\n        // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);\n        /**\n         * Locates and decodes a PDF417 code in an image.\n         *\n         * @return a String representing the content encoded by the PDF417 code\n         * @throws NotFoundException if a PDF417 code cannot be found,\n         * @throws FormatException if a PDF417 cannot be decoded\n         * @throws ChecksumException\n         */\n        // @Override\n        decode(image, hints = null) {\n            let result = PDF417Reader.decode(image, hints, false);\n            if (result == null || result.length === 0 || result[0] == null) {\n                throw NotFoundException.getNotFoundInstance();\n            }\n            return result[0];\n        }\n        /**\n         *\n         * @param BinaryBitmap\n         * @param image\n         * @throws NotFoundException\n         */\n        //   @Override\n        decodeMultiple(image, hints = null) {\n            try {\n                return PDF417Reader.decode(image, hints, true);\n            }\n            catch (ignored) {\n                if (ignored instanceof FormatException || ignored instanceof ChecksumException) {\n                    throw NotFoundException.getNotFoundInstance();\n                }\n                throw ignored;\n            }\n        }\n        /**\n         *\n         * @param image\n         * @param hints\n         * @param multiple\n         *\n         * @throws NotFoundException\n         * @throws FormatException\n         * @throws ChecksumException\n         */\n        static decode(image, hints, multiple) {\n            const results = new Array();\n            const detectorResult = Detector$3.detectMultiple(image, hints, multiple);\n            for (const points of detectorResult.getPoints()) {\n                const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));\n                const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.PDF_417);\n                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());\n                const pdf417ResultMetadata = decoderResult.getOther();\n                if (pdf417ResultMetadata != null) {\n                    result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);\n                }\n                results.push(result);\n            }\n            return results.map(x => x);\n        }\n        static getMaxWidth(p1, p2) {\n            if (p1 == null || p2 == null) {\n                return 0;\n            }\n            return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n        }\n        static getMinWidth(p1, p2) {\n            if (p1 == null || p2 == null) {\n                return Integer.MAX_VALUE;\n            }\n            return Math.trunc(Math.abs(p1.getX() - p2.getX()));\n        }\n        static getMaxCodewordWidth(p) {\n            return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN)));\n        }\n        static getMinCodewordWidth(p) {\n            return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /\n                PDF417Common.MODULES_IN_STOP_PATTERN)));\n        }\n        // @Override\n        reset() {\n            // nothing needs to be reset\n        }\n    }\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class ReaderException extends Exception {\n    }\n    ReaderException.kind = 'ReaderException';\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * MultiFormatReader is a convenience class and the main entry point into the library for most uses.\n     * By default it attempts to decode all barcode formats that the library supports. Optionally, you\n     * can provide a hints object to request different behavior, for example only decoding QR codes.\n     *\n     * @author Sean Owen\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class MultiFormatReader {\n        /**\n         * Creates an instance of this class\n         * \n         * @param {Boolean} verbose if 'true' logs will be dumped to console, otherwise hidden.\n         * @param hints The hints to use, clearing the previous state.\n         */\n        constructor(verbose, hints) {\n            this.verbose = (verbose === true);\n            if (hints) {\n                this.setHints(hints);\n            }\n        }\n        /**\n         * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it\n         * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.\n         * Use setHints() followed by decodeWithState() for continuous scan applications.\n         *\n         * @param image The pixel data to decode\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */\n        /*@Override*/\n        // public decode(image: BinaryBitmap): Result {\n        //   setHints(null)\n        //   return decodeInternal(image)\n        // }\n        /**\n         * Decode an image using the hints provided. Does not honor existing state.\n         *\n         * @param image The pixel data to decode\n         * @param hints The hints to use, clearing the previous state.\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */\n        /*@Override*/\n        decode(image, hints) {\n            if (hints) {\n                this.setHints(hints);\n            }\n            return this.decodeInternal(image);\n        }\n        /**\n         * Decode an image using the state set up by calling setHints() previously. Continuous scan\n         * clients will get a <b>large</b> speed increase by using this instead of decode().\n         *\n         * @param image The pixel data to decode\n         * @return The contents of the image\n         *\n         * @throws NotFoundException Any errors which occurred\n         */\n        decodeWithState(image) {\n            // Make sure to set up the default state so we don't crash\n            if (this.readers === null || this.readers === undefined) {\n                this.setHints(null);\n            }\n            return this.decodeInternal(image);\n        }\n        /**\n         * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls\n         * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This\n         * is important for performance in continuous scan clients.\n         *\n         * @param hints The set of hints to use for subsequent calls to decode(image)\n         */\n        setHints(hints) {\n            this.hints = hints;\n            const tryHarder = !isNullOrUndefined(hints)\n                && hints.get(DecodeHintType$1.TRY_HARDER) === true;\n            const formats = isNullOrUndefined(hints) ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);\n            const readers = new Array();\n            if (!isNullOrUndefined(formats)) {\n                const addOneDReader = formats.some(f => {\n                    return (\n                        f === BarcodeFormat$1.UPC_A ||\n                        f === BarcodeFormat$1.UPC_E ||\n                        f === BarcodeFormat$1.EAN_13 ||\n                        f === BarcodeFormat$1.EAN_8 ||\n                        f === BarcodeFormat$1.CODABAR ||\n                        f === BarcodeFormat$1.CODE_39 ||\n                        f === BarcodeFormat$1.CODE_93 ||\n                        f === BarcodeFormat$1.CODE_128 ||\n                        f === BarcodeFormat$1.ITF ||\n                        f === BarcodeFormat$1.RSS_14 ||\n                        f === BarcodeFormat$1.RSS_EXPANDED);\n                });\n                // Put 1D readers upfront in \"normal\" mode\n                if (addOneDReader && !tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n                if (formats.includes(BarcodeFormat$1.QR_CODE)) {\n                    readers.push(new QRCodeReader());\n                }\n                if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {\n                    readers.push(new DataMatrixReader());\n                }\n                if (formats.includes(BarcodeFormat$1.AZTEC)) {\n                    readers.push(new AztecReader());\n                }\n                if (formats.includes(BarcodeFormat$1.PDF_417)) {\n                    readers.push(new PDF417Reader());\n                }\n                // if (formats.includes(BarcodeFormat.MAXICODE)) {\n                //    readers.push(new MaxiCodeReader())\n                // }\n                // At end in \"try harder\" mode\n                if (addOneDReader && tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n            }\n            if (readers.length === 0) {\n                if (!tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n                readers.push(new QRCodeReader());\n                readers.push(new DataMatrixReader());\n                readers.push(new AztecReader());\n                readers.push(new PDF417Reader());\n                // readers.push(new MaxiCodeReader())\n                if (tryHarder) {\n                    readers.push(new MultiFormatOneDReader(hints, this.verbose));\n                }\n            }\n            this.readers = readers; // .toArray(new Reader[readers.size()])\n        }\n        /*@Override*/\n        reset() {\n            if (this.readers !== null) {\n                for (const reader of this.readers) {\n                    reader.reset();\n                }\n            }\n        }\n        /**\n         * @throws NotFoundException\n         */\n        decodeInternal(image) {\n            if (this.readers === null) {\n                throw new ReaderException('No readers where selected, nothing can be read.');\n            }\n            for (const reader of this.readers) {\n                // Trying to decode with ${reader} reader.\n                try {\n                    return reader.decode(image, this.hints);\n                }\n                catch (ex) {\n                    if (ex instanceof ReaderException) {\n                        continue;\n                    }\n                    // Bad Exception.\n                }\n            }\n            throw new NotFoundException('No MultiFormat Readers were able to detect the code.');\n        }\n    }\n\n    class BrowserMultiFormatReader extends BrowserCodeReader {\n        constructor(hints = null, timeBetweenScansMillis = 500) {\n            const reader = new MultiFormatReader();\n            reader.setHints(hints);\n            super(reader, timeBetweenScansMillis);\n        }\n        /**\n         * Overwrite decodeBitmap to call decodeWithState, which will pay\n         * attention to the hints set in the constructor function\n         */\n        decodeBitmap(binaryBitmap) {\n            return this.reader.decodeWithState(binaryBitmap);\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */\n    class BrowserPDF417Reader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserPDF417Reader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new PDF417Reader(), timeBetweenScansMillis);\n        }\n    }\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     *\n     * QR Code reader to use from browser.\n     */\n    class BrowserQRCodeReader extends BrowserCodeReader {\n        /**\n         * Creates an instance of BrowserQRCodeReader.\n         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries\n         */\n        constructor(timeBetweenScansMillis = 500) {\n            super(new QRCodeReader(), timeBetweenScansMillis);\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /*namespace com.google.zxing {*/\n    /**\n     * These are a set of hints that you may pass to Writers to specify their behavior.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    var EncodeHintType;\n    (function (EncodeHintType) {\n        /**\n         * Specifies what degree of error correction to use, for example in QR Codes.\n         * Type depends on the encoder. For example for QR codes it's type\n         * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.\n         * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.\n         * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.\n         * In all cases, it can also be a {@link String} representation of the desired value as well.\n         * Note: an Aztec symbol should have a minimum of 25% EC words.\n         */\n        EncodeHintType[EncodeHintType[\"ERROR_CORRECTION\"] = 0] = \"ERROR_CORRECTION\";\n        /**\n         * Specifies what character encoding to use where applicable (type {@link String})\n         */\n        EncodeHintType[EncodeHintType[\"CHARACTER_SET\"] = 1] = \"CHARACTER_SET\";\n        /**\n         * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})\n         */\n        EncodeHintType[EncodeHintType[\"DATA_MATRIX_SHAPE\"] = 2] = \"DATA_MATRIX_SHAPE\";\n        /**\n         * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n         *\n         * @deprecated use width/height params in\n         * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}\n         */\n        /*@Deprecated*/\n        EncodeHintType[EncodeHintType[\"MIN_SIZE\"] = 3] = \"MIN_SIZE\";\n        /**\n         * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.\n         *\n         * @deprecated without replacement\n         */\n        /*@Deprecated*/\n        EncodeHintType[EncodeHintType[\"MAX_SIZE\"] = 4] = \"MAX_SIZE\";\n        /**\n         * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary\n         * by format; for example it controls margin before and after the barcode horizontally for\n         * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).\n         */\n        EncodeHintType[EncodeHintType[\"MARGIN\"] = 5] = \"MARGIN\";\n        /**\n         * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or \"true\" or \"false\"\n         * {@link String} value).\n         */\n        EncodeHintType[EncodeHintType[\"PDF417_COMPACT\"] = 6] = \"PDF417_COMPACT\";\n        /**\n         * Specifies what compaction mode to use for PDF417 (type\n         * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its\n         * enum values).\n         */\n        EncodeHintType[EncodeHintType[\"PDF417_COMPACTION\"] = 7] = \"PDF417_COMPACTION\";\n        /**\n         * Specifies the minimum and maximum number of rows and columns for PDF417 (type\n         * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).\n         */\n        EncodeHintType[EncodeHintType[\"PDF417_DIMENSIONS\"] = 8] = \"PDF417_DIMENSIONS\";\n        /**\n         * Specifies the required number of layers for an Aztec code.\n         * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.\n         * 0 indicates to use the minimum number of layers (the default).\n         * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.\n         * (Type {@link Integer}, or {@link String} representation of the integer value).\n         */\n        EncodeHintType[EncodeHintType[\"AZTEC_LAYERS\"] = 9] = \"AZTEC_LAYERS\";\n        /**\n         * Specifies the exact version of QR code to be encoded.\n         * (Type {@link Integer}, or {@link String} representation of the integer value).\n         */\n        EncodeHintType[EncodeHintType[\"QR_VERSION\"] = 10] = \"QR_VERSION\";\n    })(EncodeHintType || (EncodeHintType = {}));\n    var EncodeHintType$1 = EncodeHintType;\n\n    /**\n     * <p>Implements Reed-Solomon encoding, as the name implies.</p>\n     *\n     * @author Sean Owen\n     * @author William Rucklidge\n     */\n    class ReedSolomonEncoder {\n        /**\n         * A reed solomon error-correcting encoding constructor is created by\n         * passing as Galois Field with of size equal to the number of code\n         * words (symbols) in the alphabet (the number of values in each\n         * element of arrays that are encoded/decoded).\n         * @param field A galois field with a number of elements equal to the size\n         * of the alphabet of symbols to encode.\n         */\n        constructor(field) {\n            this.field = field;\n            this.cachedGenerators = [];\n            this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));\n        }\n        buildGenerator(degree /*int*/) {\n            const cachedGenerators = this.cachedGenerators;\n            if (degree >= cachedGenerators.length) {\n                let lastGenerator = cachedGenerators[cachedGenerators.length - 1];\n                const field = this.field;\n                for (let d = cachedGenerators.length; d <= degree; d++) {\n                    const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));\n                    cachedGenerators.push(nextGenerator);\n                    lastGenerator = nextGenerator;\n                }\n            }\n            return cachedGenerators[degree];\n        }\n        /**\n         * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders\n         * to detect and correct errors that may have been introduced when the resulting\n         * data is stored or transmitted.</p>\n         *\n         * @param toEncode array used for both and output. Caller initializes the array with\n         * the code words (symbols) to be encoded followed by empty elements allocated to make\n         * space for error-correction code words in the encoded output. The array contains\n         * the encdoded output when encode returns. Code words are encoded as numbers from\n         * 0 to n-1, where n is the number of possible code words (symbols), as determined\n         * by the size of the Galois Field passed in the constructor of this object.\n         * @param ecBytes the number of elements reserved in the array (first parameter)\n         * to store error-correction code words. Thus, the number of code words (symbols)\n         * to encode in the first parameter is thus toEncode.length - ecBytes.\n         * Note, the use of \"bytes\" in the name of this parameter is misleading, as there may\n         * be more or fewer than 256 symbols being encoded, as determined by the number of\n         * elements in the Galois Field passed as a constructor to this object.\n         * @throws IllegalArgumentException thrown in response to validation errros.\n         */\n        encode(toEncode, ecBytes /*int*/) {\n            if (ecBytes === 0) {\n                throw new IllegalArgumentException('No error correction bytes');\n            }\n            const dataBytes = toEncode.length - ecBytes;\n            if (dataBytes <= 0) {\n                throw new IllegalArgumentException('No data bytes provided');\n            }\n            const generator = this.buildGenerator(ecBytes);\n            const infoCoefficients = new Int32Array(dataBytes);\n            System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);\n            let info = new GenericGFPoly(this.field, infoCoefficients);\n            info = info.multiplyByMonomial(ecBytes, 1);\n            const remainder = info.divide(generator)[1];\n            const coefficients = remainder.getCoefficients();\n            const numZeroCoefficients = ecBytes - coefficients.length;\n            for (let i = 0; i < numZeroCoefficients; i++) {\n                toEncode[dataBytes + i] = 0;\n            }\n            System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);\n        }\n    }\n\n    /**\n     * @author Satoru Takabayashi\n     * @author Daniel Switkin\n     * @author Sean Owen\n     */\n    class MaskUtil {\n        constructor() {\n            // do nothing\n        }\n        /**\n         * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and\n         * give penalty to them. Example: 00000 or 11111.\n         */\n        static applyMaskPenaltyRule1(matrix) {\n            return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);\n        }\n        /**\n         * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give\n         * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a\n         * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.\n         */\n        static applyMaskPenaltyRule2(matrix) {\n            let penalty = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for (let y = 0; y < height - 1; y++) {\n                const arrayY = array[y];\n                for (let x = 0; x < width - 1; x++) {\n                    const value = arrayY[x];\n                    if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {\n                        penalty++;\n                    }\n                }\n            }\n            return MaskUtil.N2 * penalty;\n        }\n        /**\n         * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4\n         * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we\n         * find patterns like 000010111010000, we give penalty once.\n         */\n        static applyMaskPenaltyRule3(matrix) {\n            let numPenalties = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const arrayY = array[y]; // We can at least optimize this access\n                    if (x + 6 < width &&\n                        arrayY[x] === 1 &&\n                        arrayY[x + 1] === 0 &&\n                        arrayY[x + 2] === 1 &&\n                        arrayY[x + 3] === 1 &&\n                        arrayY[x + 4] === 1 &&\n                        arrayY[x + 5] === 0 &&\n                        arrayY[x + 6] === 1 &&\n                        (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {\n                        numPenalties++;\n                    }\n                    if (y + 6 < height &&\n                        array[y][x] === 1 &&\n                        array[y + 1][x] === 0 &&\n                        array[y + 2][x] === 1 &&\n                        array[y + 3][x] === 1 &&\n                        array[y + 4][x] === 1 &&\n                        array[y + 5][x] === 0 &&\n                        array[y + 6][x] === 1 &&\n                        (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {\n                        numPenalties++;\n                    }\n                }\n            }\n            return numPenalties * MaskUtil.N3;\n        }\n        static isWhiteHorizontal(rowArray, from /*int*/, to /*int*/) {\n            from = Math.max(from, 0);\n            to = Math.min(to, rowArray.length);\n            for (let i = from; i < to; i++) {\n                if (rowArray[i] === 1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static isWhiteVertical(array, col /*int*/, from /*int*/, to /*int*/) {\n            from = Math.max(from, 0);\n            to = Math.min(to, array.length);\n            for (let i = from; i < to; i++) {\n                if (array[i][col] === 1) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give\n         * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.\n         */\n        static applyMaskPenaltyRule4(matrix) {\n            let numDarkCells = 0;\n            const array = matrix.getArray();\n            const width = matrix.getWidth();\n            const height = matrix.getHeight();\n            for (let y = 0; y < height; y++) {\n                const arrayY = array[y];\n                for (let x = 0; x < width; x++) {\n                    if (arrayY[x] === 1) {\n                        numDarkCells++;\n                    }\n                }\n            }\n            const numTotalCells = matrix.getHeight() * matrix.getWidth();\n            const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);\n            return fivePercentVariances * MaskUtil.N4;\n        }\n        /**\n         * Return the mask bit for \"getMaskPattern\" at \"x\" and \"y\". See 8.8 of JISX0510:2004 for mask\n         * pattern conditions.\n         */\n        static getDataMaskBit(maskPattern /*int*/, x /*int*/, y /*int*/) {\n            let intermediate; /*int*/\n            let temp; /*int*/\n            switch (maskPattern) {\n                case 0:\n                    intermediate = (y + x) & 0x1;\n                    break;\n                case 1:\n                    intermediate = y & 0x1;\n                    break;\n                case 2:\n                    intermediate = x % 3;\n                    break;\n                case 3:\n                    intermediate = (y + x) % 3;\n                    break;\n                case 4:\n                    intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;\n                    break;\n                case 5:\n                    temp = y * x;\n                    intermediate = (temp & 0x1) + (temp % 3);\n                    break;\n                case 6:\n                    temp = y * x;\n                    intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;\n                    break;\n                case 7:\n                    temp = y * x;\n                    intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;\n                    break;\n                default:\n                    throw new IllegalArgumentException('Invalid mask pattern: ' + maskPattern);\n            }\n            return intermediate === 0;\n        }\n        /**\n         * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both\n         * vertical and horizontal orders respectively.\n         */\n        static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {\n            let penalty = 0;\n            const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\n            const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\n            const array = matrix.getArray();\n            for (let i = 0; i < iLimit; i++) {\n                let numSameBitCells = 0;\n                let prevBit = -1;\n                for (let j = 0; j < jLimit; j++) {\n                    const bit = isHorizontal ? array[i][j] : array[j][i];\n                    if (bit === prevBit) {\n                        numSameBitCells++;\n                    }\n                    else {\n                        if (numSameBitCells >= 5) {\n                            penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                        }\n                        numSameBitCells = 1; // Include the cell itself.\n                        prevBit = bit;\n                    }\n                }\n                if (numSameBitCells >= 5) {\n                    penalty += MaskUtil.N1 + (numSameBitCells - 5);\n                }\n            }\n            return penalty;\n        }\n    }\n    // Penalty weights from section 6.8.2.1\n    MaskUtil.N1 = 3;\n    MaskUtil.N2 = 3;\n    MaskUtil.N3 = 40;\n    MaskUtil.N4 = 10;\n\n    /**\n     * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned\n     * -1, 0, and 1, I'm going to use less memory and go with bytes.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class ByteMatrix {\n        constructor(width /*int*/, height /*int*/) {\n            this.width = width;\n            this.height = height;\n            const bytes = new Array(height); // [height][width]\n            for (let i = 0; i !== height; i++) {\n                bytes[i] = new Uint8Array(width);\n            }\n            this.bytes = bytes;\n        }\n        getHeight() {\n            return this.height;\n        }\n        getWidth() {\n            return this.width;\n        }\n        get(x /*int*/, y /*int*/) {\n            return this.bytes[y][x];\n        }\n        /**\n         * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)\n         */\n        getArray() {\n            return this.bytes;\n        }\n        // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside\n        setNumber(x /*int*/, y /*int*/, value /*byte|int*/) {\n            this.bytes[y][x] = value;\n        }\n        // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {\n        //   bytes[y][x] = (byte) value\n        // }\n        setBoolean(x /*int*/, y /*int*/, value) {\n            this.bytes[y][x] = /*(byte) */ (value ? 1 : 0);\n        }\n        clear(value /*byte*/) {\n            for (const aByte of this.bytes) {\n                Arrays.fill(aByte, value);\n            }\n        }\n        equals(o) {\n            if (!(o instanceof ByteMatrix)) {\n                return false;\n            }\n            const other = o;\n            if (this.width !== other.width) {\n                return false;\n            }\n            if (this.height !== other.height) {\n                return false;\n            }\n            for (let y = 0, height = this.height; y < height; ++y) {\n                const bytesY = this.bytes[y];\n                const otherBytesY = other.bytes[y];\n                for (let x = 0, width = this.width; x < width; ++x) {\n                    if (bytesY[x] !== otherBytesY[x]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        /*@Override*/\n        toString() {\n            const result = new StringBuilder(); // (2 * width * height + 2)\n            for (let y = 0, height = this.height; y < height; ++y) {\n                const bytesY = this.bytes[y];\n                for (let x = 0, width = this.width; x < width; ++x) {\n                    switch (bytesY[x]) {\n                        case 0:\n                            result.append(' 0');\n                            break;\n                        case 1:\n                            result.append(' 1');\n                            break;\n                        default:\n                            result.append('  ');\n                            break;\n                    }\n                }\n                result.append('\\n');\n            }\n            return result.toString();\n        }\n    }\n\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */\n    class QRCode {\n        constructor() {\n            this.maskPattern = -1;\n        }\n        getMode() {\n            return this.mode;\n        }\n        getECLevel() {\n            return this.ecLevel;\n        }\n        getVersion() {\n            return this.version;\n        }\n        getMaskPattern() {\n            return this.maskPattern;\n        }\n        getMatrix() {\n            return this.matrix;\n        }\n        /*@Override*/\n        toString() {\n            const result = new StringBuilder(); // (200)\n            result.append('<<\\n');\n            result.append(' mode: ');\n            result.append(this.mode ? this.mode.toString() : 'null');\n            result.append('\\n ecLevel: ');\n            result.append(this.ecLevel ? this.ecLevel.toString() : 'null');\n            result.append('\\n version: ');\n            result.append(this.version ? this.version.toString() : 'null');\n            result.append('\\n maskPattern: ');\n            result.append(this.maskPattern.toString());\n            if (this.matrix) {\n                result.append('\\n matrix:\\n');\n                result.append(this.matrix.toString());\n            }\n            else {\n                result.append('\\n matrix: null\\n');\n            }\n            result.append('>>\\n');\n            return result.toString();\n        }\n        setMode(value) {\n            this.mode = value;\n        }\n        setECLevel(value) {\n            this.ecLevel = value;\n        }\n        setVersion(version) {\n            this.version = version;\n        }\n        setMaskPattern(value /*int*/) {\n            this.maskPattern = value;\n        }\n        setMatrix(value) {\n            this.matrix = value;\n        }\n        // Check if \"mask_pattern\" is valid.\n        static isValidMaskPattern(maskPattern /*int*/) {\n            return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;\n        }\n    }\n    QRCode.NUM_MASK_PATTERNS = 8;\n\n    /**\n     * Custom Error class of type Exception.\n     */\n    class WriterException extends Exception {\n    }\n    WriterException.kind = 'WriterException';\n\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */\n    class MatrixUtil {\n        constructor() {\n            // do nothing\n        }\n        // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).\n        //\n        // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding\n        // with the ByteMatrix initialized all to zero.\n        static clearMatrix(matrix) {\n            // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255\n            matrix.clear(/*(byte) */ /*-1*/ 255);\n        }\n        // Build 2D matrix of QR Code from \"dataBits\" with \"ecLevel\", \"version\" and \"getMaskPattern\". On\n        // success, store the result in \"matrix\" and return true.\n        static buildMatrix(dataBits, ecLevel, version, maskPattern /*int*/, matrix) {\n            MatrixUtil.clearMatrix(matrix);\n            MatrixUtil.embedBasicPatterns(version, matrix);\n            // Type information appear with any version.\n            MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);\n            // Version info appear if version >= 7.\n            MatrixUtil.maybeEmbedVersionInfo(version, matrix);\n            // Data should be embedded at end.\n            MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);\n        }\n        // Embed basic patterns. On success, modify the matrix and return true.\n        // The basic patterns are:\n        // - Position detection patterns\n        // - Timing patterns\n        // - Dark dot at the left bottom corner\n        // - Position adjustment patterns, if need be\n        static embedBasicPatterns(version, matrix) {\n            // Let's get started with embedding big squares at corners.\n            MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);\n            // Then, embed the dark dot at the left bottom corner.\n            MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);\n            // Position adjustment patterns appear if version >= 2.\n            MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);\n            // Timing patterns should be embedded after position adj. patterns.\n            MatrixUtil.embedTimingPatterns(matrix);\n        }\n        // Embed type information. On success, modify the matrix.\n        static embedTypeInfo(ecLevel, maskPattern /*int*/, matrix) {\n            const typeInfoBits = new BitArray();\n            MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);\n            for (let i = 0, size = typeInfoBits.getSize(); i < size; ++i) {\n                // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in\n                // \"typeInfoBits\".\n                const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);\n                // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).\n                const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];\n                const x1 = coordinates[0];\n                const y1 = coordinates[1];\n                matrix.setBoolean(x1, y1, bit);\n                if (i < 8) {\n                    // Right top corner.\n                    const x2 = matrix.getWidth() - i - 1;\n                    const y2 = 8;\n                    matrix.setBoolean(x2, y2, bit);\n                }\n                else {\n                    // Left bottom corner.\n                    const x2 = 8;\n                    const y2 = matrix.getHeight() - 7 + (i - 8);\n                    matrix.setBoolean(x2, y2, bit);\n                }\n            }\n        }\n        // Embed version information if need be. On success, modify the matrix and return true.\n        // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.\n        static maybeEmbedVersionInfo(version, matrix) {\n            if (version.getVersionNumber() < 7) { // Version info is necessary if version >= 7.\n                return; // Don't need version info.\n            }\n            const versionInfoBits = new BitArray();\n            MatrixUtil.makeVersionInfoBits(version, versionInfoBits);\n            let bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.\n            for (let i = 0; i < 6; ++i) {\n                for (let j = 0; j < 3; ++j) {\n                    // Place bits in LSB (least significant bit) to MSB order.\n                    const bit = versionInfoBits.get(bitIndex);\n                    bitIndex--;\n                    // Left bottom corner.\n                    matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);\n                    // Right bottom corner.\n                    matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);\n                }\n            }\n        }\n        // Embed \"dataBits\" using \"getMaskPattern\". On success, modify the matrix and return true.\n        // For debugging purposes, it skips masking process if \"getMaskPattern\" is -1(TYPESCRIPTPORT: 255).\n        // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.\n        static embedDataBits(dataBits, maskPattern /*int*/, matrix) {\n            let bitIndex = 0;\n            let direction = -1;\n            // Start from the right bottom cell.\n            let x = matrix.getWidth() - 1;\n            let y = matrix.getHeight() - 1;\n            while (x > 0) {\n                // Skip the vertical timing pattern.\n                if (x === 6) {\n                    x -= 1;\n                }\n                while (y >= 0 && y < matrix.getHeight()) {\n                    for (let i = 0; i < 2; ++i) {\n                        const xx = x - i;\n                        // Skip the cell if it's not empty.\n                        if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {\n                            continue;\n                        }\n                        let bit;\n                        if (bitIndex < dataBits.getSize()) {\n                            bit = dataBits.get(bitIndex);\n                            ++bitIndex;\n                        }\n                        else {\n                            // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described\n                            // in 8.4.9 of JISX0510:2004 (p. 24).\n                            bit = false;\n                        }\n                        // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).\n                        if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {\n                            bit = !bit;\n                        }\n                        matrix.setBoolean(xx, y, bit);\n                    }\n                    y += direction;\n                }\n                direction = -direction; // Reverse the direction.\n                y += direction;\n                x -= 2; // Move to the left.\n            }\n            // All bits should be consumed.\n            if (bitIndex !== dataBits.getSize()) {\n                throw new WriterException('Not all bits consumed: ' + bitIndex + '/' + dataBits.getSize());\n            }\n        }\n        // Return the position of the most significant bit set (one: to) in the \"value\". The most\n        // significant bit is position 32. If there is no bit set, return 0. Examples:\n        // - findMSBSet(0) => 0\n        // - findMSBSet(1) => 1\n        // - findMSBSet(255) => 8\n        static findMSBSet(value /*int*/) {\n            return 32 - Integer.numberOfLeadingZeros(value);\n        }\n        // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for \"value\" using polynomial \"poly\". The BCH\n        // code is used for encoding type information and version information.\n        // Example: Calculation of version information of 7.\n        // f(x) is created from 7.\n        //   - 7 = 000111 in 6 bits\n        //   - f(x) = x^2 + x^1 + x^0\n        // g(x) is given by the standard (p. 67)\n        //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1\n        // Multiply f(x) by x^(18 - 6)\n        //   - f'(x) = f(x) * x^(18 - 6)\n        //   - f'(x) = x^14 + x^13 + x^12\n        // Calculate the remainder of f'(x) / g(x)\n        //         x^2\n        //         __________________________________________________\n        //   g(x) )x^14 + x^13 + x^12\n        //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2\n        //         --------------------------------------------------\n        //                              x^11 + x^10 + x^7 + x^4 + x^2\n        //\n        // The remainder is x^11 + x^10 + x^7 + x^4 + x^2\n        // Encode it in binary: 110010010100\n        // The return value is 0xc94 (1100 1001 0100)\n        //\n        // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit\n        // operations. We don't care if coefficients are positive or negative.\n        static calculateBCHCode(value /*int*/, poly /*int*/) {\n            if (poly === 0) {\n                throw new IllegalArgumentException('0 polynomial');\n            }\n            // If poly is \"1 1111 0010 0101\" (version info poly), msbSetInPoly is 13. We'll subtract 1\n            // from 13 to make it 12.\n            const msbSetInPoly = MatrixUtil.findMSBSet(poly);\n            value <<= msbSetInPoly - 1;\n            // Do the division business using exclusive-or operations.\n            while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {\n                value ^= poly << (MatrixUtil.findMSBSet(value) - msbSetInPoly);\n            }\n            // Now the \"value\" is the remainder (i.e. the BCH code)\n            return value;\n        }\n        // Make bit vector of type information. On success, store the result in \"bits\" and return true.\n        // Encode error correction level and mask pattern. See 8.9 of\n        // JISX0510:2004 (p.45) for details.\n        static makeTypeInfoBits(ecLevel, maskPattern /*int*/, bits) {\n            if (!QRCode.isValidMaskPattern(maskPattern)) {\n                throw new WriterException('Invalid mask pattern');\n            }\n            const typeInfo = (ecLevel.getBits() << 3) | maskPattern;\n            bits.appendBits(typeInfo, 5);\n            const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);\n            bits.appendBits(bchCode, 10);\n            const maskBits = new BitArray();\n            maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);\n            bits.xor(maskBits);\n            if (bits.getSize() !== 15) { // Just in case.\n                throw new WriterException('should not happen but we got: ' + bits.getSize());\n            }\n        }\n        // Make bit vector of version information. On success, store the result in \"bits\" and return true.\n        // See 8.10 of JISX0510:2004 (p.45) for details.\n        static makeVersionInfoBits(version, bits) {\n            bits.appendBits(version.getVersionNumber(), 6);\n            const bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);\n            bits.appendBits(bchCode, 12);\n            if (bits.getSize() !== 18) { // Just in case.\n                throw new WriterException('should not happen but we got: ' + bits.getSize());\n            }\n        }\n        // Check if \"value\" is empty.\n        static isEmpty(value /*int*/) {\n            return value === 255; // -1\n        }\n        static embedTimingPatterns(matrix) {\n            // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical\n            // separation patterns (1: size). Thus, 8 = 7 + 1.\n            for (let i = 8; i < matrix.getWidth() - 8; ++i) {\n                const bit = (i + 1) % 2;\n                // Horizontal line.\n                if (MatrixUtil.isEmpty(matrix.get(i, 6))) {\n                    matrix.setNumber(i, 6, bit);\n                }\n                // Vertical line.\n                if (MatrixUtil.isEmpty(matrix.get(6, i))) {\n                    matrix.setNumber(6, i, bit);\n                }\n            }\n        }\n        // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)\n        static embedDarkDotAtLeftBottomCorner(matrix) {\n            if (matrix.get(8, matrix.getHeight() - 8) === 0) {\n                throw new WriterException();\n            }\n            matrix.setNumber(8, matrix.getHeight() - 8, 1);\n        }\n        static embedHorizontalSeparationPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let x = 0; x < 8; ++x) {\n                if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {\n                    throw new WriterException();\n                }\n                matrix.setNumber(xStart + x, yStart, 0);\n            }\n        }\n        static embedVerticalSeparationPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let y = 0; y < 7; ++y) {\n                if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {\n                    throw new WriterException();\n                }\n                matrix.setNumber(xStart, yStart + y, 0);\n            }\n        }\n        static embedPositionAdjustmentPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let y = 0; y < 5; ++y) {\n                const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];\n                for (let x = 0; x < 5; ++x) {\n                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n                }\n            }\n        }\n        static embedPositionDetectionPattern(xStart /*int*/, yStart /*int*/, matrix) {\n            for (let y = 0; y < 7; ++y) {\n                const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];\n                for (let x = 0; x < 7; ++x) {\n                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);\n                }\n            }\n        }\n        // Embed position detection patterns and surrounding vertical/horizontal separators.\n        static embedPositionDetectionPatternsAndSeparators(matrix) {\n            // Embed three big squares at corners.\n            const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;\n            // Left top corner.\n            MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);\n            // Right top corner.\n            MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);\n            // Embed horizontal separation patterns around the squares.\n            const hspWidth = 8;\n            // Left top corner.\n            MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);\n            // Right top corner.\n            MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);\n            // Embed vertical separation patterns around the squares.\n            const vspSize = 7;\n            // Left top corner.\n            MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);\n            // Right top corner.\n            MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);\n            // Left bottom corner.\n            MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);\n        }\n        // Embed position adjustment patterns if need be.\n        static maybeEmbedPositionAdjustmentPatterns(version, matrix) {\n            if (version.getVersionNumber() < 2) { // The patterns appear if version >= 2\n                return;\n            }\n            const index = version.getVersionNumber() - 1;\n            const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];\n            for (let i = 0, length = coordinates.length; i !== length; i++) {\n                const y = coordinates[i];\n                if (y >= 0) {\n                    for (let j = 0; j !== length; j++) {\n                        const x = coordinates[j];\n                        if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {\n                            // If the cell is unset, we embed the position adjustment pattern here.\n                            // -2 is necessary since the x/y coordinates point to the center of the pattern, not the\n                            // left top corner.\n                            MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([\n        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),\n        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),\n        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),\n        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),\n    ]);\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([\n        Int32Array.from([1, 1, 1, 1, 1]),\n        Int32Array.from([1, 0, 0, 0, 1]),\n        Int32Array.from([1, 0, 1, 0, 1]),\n        Int32Array.from([1, 0, 0, 0, 1]),\n        Int32Array.from([1, 1, 1, 1, 1]),\n    ]);\n    // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.\n    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([\n        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),\n        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),\n        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),\n        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),\n        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),\n        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),\n        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),\n        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),\n        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),\n        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),\n        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),\n        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),\n        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),\n        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),\n        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),\n        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),\n        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),\n        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),\n        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),\n        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),\n        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),\n        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),\n        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),\n        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),\n        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),\n        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),\n        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),\n        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),\n        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),\n        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),\n    ]);\n    // Type info cells at the left top corner.\n    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([\n        Int32Array.from([8, 0]),\n        Int32Array.from([8, 1]),\n        Int32Array.from([8, 2]),\n        Int32Array.from([8, 3]),\n        Int32Array.from([8, 4]),\n        Int32Array.from([8, 5]),\n        Int32Array.from([8, 7]),\n        Int32Array.from([8, 8]),\n        Int32Array.from([7, 8]),\n        Int32Array.from([5, 8]),\n        Int32Array.from([4, 8]),\n        Int32Array.from([3, 8]),\n        Int32Array.from([2, 8]),\n        Int32Array.from([1, 8]),\n        Int32Array.from([0, 8]),\n    ]);\n    // From Appendix D in JISX0510:2004 (p. 67)\n    MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101\n    // From Appendix C in JISX0510:2004 (p.65).\n    MatrixUtil.TYPE_INFO_POLY = 0x537;\n    MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;\n\n    /*namespace com.google.zxing.qrcode.encoder {*/\n    class BlockPair {\n        constructor(dataBytes, errorCorrectionBytes) {\n            this.dataBytes = dataBytes;\n            this.errorCorrectionBytes = errorCorrectionBytes;\n        }\n        getDataBytes() {\n            return this.dataBytes;\n        }\n        getErrorCorrectionBytes() {\n            return this.errorCorrectionBytes;\n        }\n    }\n\n    /*import java.io.UnsupportedEncodingException;*/\n    /*import java.util.ArrayList;*/\n    /*import java.util.Collection;*/\n    /*import java.util.Map;*/\n    /**\n     * @author satorux@google.com (Satoru Takabayashi) - creator\n     * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n     */\n    class Encoder {\n        // TYPESCRIPTPORT: changed to UTF8, the default for js\n        constructor() { }\n        // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n        // Basically it applies four rules and summate all penalties.\n        static calculateMaskPenalty(matrix) {\n            return MaskUtil.applyMaskPenaltyRule1(matrix)\n                + MaskUtil.applyMaskPenaltyRule2(matrix)\n                + MaskUtil.applyMaskPenaltyRule3(matrix)\n                + MaskUtil.applyMaskPenaltyRule4(matrix);\n        }\n        /**\n         * @param content text to encode\n         * @param ecLevel error correction level to use\n         * @return {@link QRCode} representing the encoded QR code\n         * @throws WriterException if encoding can't succeed, because of for example invalid content\n         *   or configuration\n         */\n        // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n        //   return encode(content, ecLevel, null)\n        // }\n        static encode(content, ecLevel, hints = null) {\n            // Determine what character encoding has been specified by the caller, if any\n            let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n            const hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType$1.CHARACTER_SET);\n            if (hasEncodingHint) {\n                encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();\n            }\n            // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n            // multiple modes / segments even if that were more efficient. Twould be nice.\n            const mode = this.chooseMode(content, encoding);\n            // This will store the header information, like mode and\n            // length, as well as \"header\" segments like an ECI segment.\n            const headerBits = new BitArray();\n            // Append ECI segment if applicable\n            if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n                const eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n                if (eci !== undefined) {\n                    this.appendECI(eci, headerBits);\n                }\n            }\n            // (With ECI in place,) Write the mode marker\n            this.appendModeInfo(mode, headerBits);\n            // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n            // main payload yet.\n            const dataBits = new BitArray();\n            this.appendBytes(content, mode, dataBits, encoding);\n            let version;\n            if (hints !== null && undefined !== hints.get(EncodeHintType$1.QR_VERSION)) {\n                const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);\n                version = Version$1.getVersionForNumber(versionNumber);\n                const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n                if (!this.willFit(bitsNeeded, version, ecLevel)) {\n                    throw new WriterException('Data too big for requested version');\n                }\n            }\n            else {\n                version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n            }\n            const headerAndDataBits = new BitArray();\n            headerAndDataBits.appendBitArray(headerBits);\n            // Find \"length\" of main segment and write it\n            const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;\n            this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);\n            // Put data together into the overall payload\n            headerAndDataBits.appendBitArray(dataBits);\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            const numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();\n            // Terminate the bits properly.\n            this.terminateBits(numDataBytes, headerAndDataBits);\n            // Interleave data bits with error correction code.\n            const finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n            const qrCode = new QRCode();\n            qrCode.setECLevel(ecLevel);\n            qrCode.setMode(mode);\n            qrCode.setVersion(version);\n            //  Choose the mask pattern and set to \"qrCode\".\n            const dimension = version.getDimensionForVersion();\n            const matrix = new ByteMatrix(dimension, dimension);\n            const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n            qrCode.setMaskPattern(maskPattern);\n            // Build the matrix and set it to \"qrCode\".\n            MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n            qrCode.setMatrix(matrix);\n            return qrCode;\n        }\n        /**\n         * Decides the smallest version of QR code that will contain all of the provided data.\n         *\n         * @throws WriterException if the data cannot fit in any version\n         */\n        static recommendVersion(ecLevel, mode, headerBits, dataBits) {\n            // Hard part: need to know version to know how many bits length takes. But need to know how many\n            // bits it takes to know version. First we take a guess at version by assuming version will be\n            // the minimum, 1:\n            const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));\n            const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);\n            // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n            const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n            return this.chooseVersion(bitsNeeded, ecLevel);\n        }\n        static calculateBitsNeeded(mode, headerBits, dataBits, version) {\n            return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n        }\n        /**\n         * @return the code point of the table used in alphanumeric mode or\n         *  -1 if there is no corresponding code in the table.\n         */\n        static getAlphanumericCode(code /*int*/) {\n            if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n                return Encoder.ALPHANUMERIC_TABLE[code];\n            }\n            return -1;\n        }\n        // public static chooseMode(content: string): Mode {\n        //   return chooseMode(content, null);\n        // }\n        /**\n         * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n         * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n         */\n        static chooseMode(content, encoding = null) {\n            if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n                // Choose Kanji mode if all input are double-byte characters\n                return Mode$1.KANJI;\n            }\n            let hasNumeric = false;\n            let hasAlphanumeric = false;\n            for (let i = 0, length = content.length; i < length; ++i) {\n                const c = content.charAt(i);\n                if (Encoder.isDigit(c)) {\n                    hasNumeric = true;\n                }\n                else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n                    hasAlphanumeric = true;\n                }\n                else {\n                    return Mode$1.BYTE;\n                }\n            }\n            if (hasAlphanumeric) {\n                return Mode$1.ALPHANUMERIC;\n            }\n            if (hasNumeric) {\n                return Mode$1.NUMERIC;\n            }\n            return Mode$1.BYTE;\n        }\n        static isOnlyDoubleByteKanji(content) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS); // content.getBytes(\"Shift_JIS\"))\n            }\n            catch (ignored /*: UnsupportedEncodingException*/) {\n                return false;\n            }\n            const length = bytes.length;\n            if (length % 2 !== 0) {\n                return false;\n            }\n            for (let i = 0; i < length; i += 2) {\n                const byte1 = bytes[i] & 0xFF;\n                if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        static chooseMaskPattern(bits, ecLevel, version, matrix) {\n            let minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n            let bestMaskPattern = -1;\n            // We try all mask patterns to choose the best one.\n            for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {\n                MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n                let penalty = this.calculateMaskPenalty(matrix);\n                if (penalty < minPenalty) {\n                    minPenalty = penalty;\n                    bestMaskPattern = maskPattern;\n                }\n            }\n            return bestMaskPattern;\n        }\n        static chooseVersion(numInputBits /*int*/, ecLevel) {\n            for (let versionNum = 1; versionNum <= 40; versionNum++) {\n                const version = Version$1.getVersionForNumber(versionNum);\n                if (Encoder.willFit(numInputBits, version, ecLevel)) {\n                    return version;\n                }\n            }\n            throw new WriterException('Data too big');\n        }\n        /**\n         * @return true if the number of input bits will fit in a code with the specified version and\n         * error correction level.\n         */\n        static willFit(numInputBits /*int*/, version, ecLevel) {\n            // In the following comments, we use numbers of Version 7-H.\n            // numBytes = 196\n            const numBytes = version.getTotalCodewords();\n            // getNumECBytes = 130\n            const ecBlocks = version.getECBlocksForLevel(ecLevel);\n            const numEcBytes = ecBlocks.getTotalECCodewords();\n            // getNumDataBytes = 196 - 130 = 66\n            const numDataBytes = numBytes - numEcBytes;\n            const totalInputBytes = (numInputBits + 7) / 8;\n            return numDataBytes >= totalInputBytes;\n        }\n        /**\n         * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n         */\n        static terminateBits(numDataBytes /*int*/, bits) {\n            const capacity = numDataBytes * 8;\n            if (bits.getSize() > capacity) {\n                throw new WriterException('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +\n                    capacity);\n            }\n            for (let i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n                bits.appendBit(false);\n            }\n            // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n            // If the last byte isn't 8-bit aligned, we'll add padding bits.\n            const numBitsInLastByte = bits.getSize() & 0x07;\n            if (numBitsInLastByte > 0) {\n                for (let i = numBitsInLastByte; i < 8; i++) {\n                    bits.appendBit(false);\n                }\n            }\n            // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n            const numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n            for (let i = 0; i < numPaddingBytes; ++i) {\n                bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n            }\n            if (bits.getSize() !== capacity) {\n                throw new WriterException('Bits size does not equal capacity');\n            }\n        }\n        /**\n         * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n         * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n         * JISX0510:2004 (p.30)\n         */\n        static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {\n            if (blockID >= numRSBlocks) {\n                throw new WriterException('Block ID too large');\n            }\n            // numRsBlocksInGroup2 = 196 % 5 = 1\n            const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;\n            // numRsBlocksInGroup1 = 5 - 1 = 4\n            const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;\n            // numTotalBytesInGroup1 = 196 / 5 = 39\n            const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);\n            // numTotalBytesInGroup2 = 39 + 1 = 40\n            const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;\n            // numDataBytesInGroup1 = 66 / 5 = 13\n            const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);\n            // numDataBytesInGroup2 = 13 + 1 = 14\n            const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n            // numEcBytesInGroup1 = 39 - 13 = 26\n            const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n            // numEcBytesInGroup2 = 40 - 14 = 26\n            const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n            // Sanity checks.\n            // 26 = 26\n            if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n                throw new WriterException('EC bytes mismatch');\n            }\n            // 5 = 4 + 1.\n            if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n                throw new WriterException('RS blocks mismatch');\n            }\n            // 196 = (13 + 26) * 4 + (14 + 26) * 1\n            if (numTotalBytes !==\n                ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                    numRsBlocksInGroup1) +\n                    ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                        numRsBlocksInGroup2)) {\n                throw new WriterException('Total bytes mismatch');\n            }\n            if (blockID < numRsBlocksInGroup1) {\n                numDataBytesInBlock[0] = numDataBytesInGroup1;\n                numECBytesInBlock[0] = numEcBytesInGroup1;\n            }\n            else {\n                numDataBytesInBlock[0] = numDataBytesInGroup2;\n                numECBytesInBlock[0] = numEcBytesInGroup2;\n            }\n        }\n        /**\n         * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n         * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n         */\n        static interleaveWithECBytes(bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {\n            // \"bits\" must have \"getNumDataBytes\" bytes of data.\n            if (bits.getSizeInBytes() !== numDataBytes) {\n                throw new WriterException('Number of bits and data bytes does not match');\n            }\n            // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n            // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n            let dataBytesOffset = 0;\n            let maxNumDataBytes = 0;\n            let maxNumEcBytes = 0;\n            // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n            const blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n            for (let i = 0; i < numRSBlocks; ++i) {\n                const numDataBytesInBlock = new Int32Array(1);\n                const numEcBytesInBlock = new Int32Array(1);\n                Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n                const size = numDataBytesInBlock[0];\n                const dataBytes = new Uint8Array(size);\n                bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n                const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n                blocks.push(new BlockPair(dataBytes, ecBytes));\n                maxNumDataBytes = Math.max(maxNumDataBytes, size);\n                maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n                dataBytesOffset += numDataBytesInBlock[0];\n            }\n            if (numDataBytes !== dataBytesOffset) {\n                throw new WriterException('Data bytes does not match offset');\n            }\n            const result = new BitArray();\n            // First, place data blocks.\n            for (let i = 0; i < maxNumDataBytes; ++i) {\n                for (const block of blocks) {\n                    const dataBytes = block.getDataBytes();\n                    if (i < dataBytes.length) {\n                        result.appendBits(dataBytes[i], 8);\n                    }\n                }\n            }\n            // Then, place error correction blocks.\n            for (let i = 0; i < maxNumEcBytes; ++i) {\n                for (const block of blocks) {\n                    const ecBytes = block.getErrorCorrectionBytes();\n                    if (i < ecBytes.length) {\n                        result.appendBits(ecBytes[i], 8);\n                    }\n                }\n            }\n            if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.\n                throw new WriterException('Interleaving error: ' + numTotalBytes + ' and ' +\n                    result.getSizeInBytes() + ' differ.');\n            }\n            return result;\n        }\n        static generateECBytes(dataBytes, numEcBytesInBlock /*int*/) {\n            const numDataBytes = dataBytes.length;\n            const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n            for (let i = 0; i < numDataBytes; i++) {\n                toEncode[i] = dataBytes[i] & 0xFF;\n            }\n            new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n            const ecBytes = new Uint8Array(numEcBytesInBlock);\n            for (let i = 0; i < numEcBytesInBlock; i++) {\n                ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];\n            }\n            return ecBytes;\n        }\n        /**\n         * Append mode info. On success, store the result in \"bits\".\n         */\n        static appendModeInfo(mode, bits) {\n            bits.appendBits(mode.getBits(), 4);\n        }\n        /**\n         * Append length info. On success, store the result in \"bits\".\n         */\n        static appendLengthInfo(numLetters /*int*/, version, mode, bits) {\n            const numBits = mode.getCharacterCountBits(version);\n            if (numLetters >= (1 << numBits)) {\n                throw new WriterException(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n            }\n            bits.appendBits(numLetters, numBits);\n        }\n        /**\n         * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n         */\n        static appendBytes(content, mode, bits, encoding) {\n            switch (mode) {\n                case Mode$1.NUMERIC:\n                    Encoder.appendNumericBytes(content, bits);\n                    break;\n                case Mode$1.ALPHANUMERIC:\n                    Encoder.appendAlphanumericBytes(content, bits);\n                    break;\n                case Mode$1.BYTE:\n                    Encoder.append8BitBytes(content, bits, encoding);\n                    break;\n                case Mode$1.KANJI:\n                    Encoder.appendKanjiBytes(content, bits);\n                    break;\n                default:\n                    throw new WriterException('Invalid mode: ' + mode);\n            }\n        }\n        static getDigit(singleCharacter) {\n            return singleCharacter.charCodeAt(0) - 48;\n        }\n        static isDigit(singleCharacter) {\n            const cn = Encoder.getDigit(singleCharacter);\n            return cn >= 0 && cn <= 9;\n        }\n        static appendNumericBytes(content, bits) {\n            const length = content.length;\n            let i = 0;\n            while (i < length) {\n                const num1 = Encoder.getDigit(content.charAt(i));\n                if (i + 2 < length) {\n                    // Encode three numeric letters in ten bits.\n                    const num2 = Encoder.getDigit(content.charAt(i + 1));\n                    const num3 = Encoder.getDigit(content.charAt(i + 2));\n                    bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n                    i += 3;\n                }\n                else if (i + 1 < length) {\n                    // Encode two numeric letters in seven bits.\n                    const num2 = Encoder.getDigit(content.charAt(i + 1));\n                    bits.appendBits(num1 * 10 + num2, 7);\n                    i += 2;\n                }\n                else {\n                    // Encode one numeric letter in four bits.\n                    bits.appendBits(num1, 4);\n                    i++;\n                }\n            }\n        }\n        static appendAlphanumericBytes(content, bits) {\n            const length = content.length;\n            let i = 0;\n            while (i < length) {\n                const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n                if (code1 === -1) {\n                    throw new WriterException();\n                }\n                if (i + 1 < length) {\n                    const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n                    if (code2 === -1) {\n                        throw new WriterException();\n                    }\n                    // Encode two alphanumeric letters in 11 bits.\n                    bits.appendBits(code1 * 45 + code2, 11);\n                    i += 2;\n                }\n                else {\n                    // Encode one alphanumeric letter in six bits.\n                    bits.appendBits(code1, 6);\n                    i++;\n                }\n            }\n        }\n        static append8BitBytes(content, bits, encoding) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, encoding);\n            }\n            catch (uee /*: UnsupportedEncodingException*/) {\n                throw new WriterException(uee);\n            }\n            for (let i = 0, length = bytes.length; i !== length; i++) {\n                const b = bytes[i];\n                bits.appendBits(b, 8);\n            }\n        }\n        /**\n         * @throws WriterException\n         */\n        static appendKanjiBytes(content, bits) {\n            let bytes;\n            try {\n                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);\n            }\n            catch (uee /*: UnsupportedEncodingException*/) {\n                throw new WriterException(uee);\n            }\n            const length = bytes.length;\n            for (let i = 0; i < length; i += 2) {\n                const byte1 = bytes[i] & 0xFF;\n                const byte2 = bytes[i + 1] & 0xFF;\n                const code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;\n                let subtracted = -1;\n                if (code >= 0x8140 && code <= 0x9ffc) {\n                    subtracted = code - 0x8140;\n                }\n                else if (code >= 0xe040 && code <= 0xebbf) {\n                    subtracted = code - 0xc140;\n                }\n                if (subtracted === -1) {\n                    throw new WriterException('Invalid byte sequence');\n                }\n                const encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);\n                bits.appendBits(encoded, 13);\n            }\n        }\n        static appendECI(eci, bits) {\n            bits.appendBits(Mode$1.ECI.getBits(), 4);\n            // This is correct for values up to 127, which is all we need now.\n            bits.appendBits(eci.getValue(), 8);\n        }\n    }\n    // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    ]);\n    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName(); // \"ISO-8859-1\"\n\n    /**\n     * @deprecated Moving to @zxing/browser\n     */\n    class BrowserQRCodeSvgWriter {\n        /**\n         * Writes and renders a QRCode SVG element.\n         *\n         * @param contents\n         * @param width\n         * @param height\n         * @param hints\n         */\n        write(contents, width, height, hints = null) {\n            if (contents.length === 0) {\n                throw new IllegalArgumentException('Found empty contents');\n            }\n            // if (format != BarcodeFormat.QR_CODE) {\n            //   throw new IllegalArgumentException(\"Can only encode QR_CODE, but got \" + format)\n            // }\n            if (width < 0 || height < 0) {\n                throw new IllegalArgumentException('Requested dimensions are too small: ' + width + 'x' + height);\n            }\n            let errorCorrectionLevel = ErrorCorrectionLevel.L;\n            let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;\n            if (hints !== null) {\n                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {\n                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {\n                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);\n                }\n            }\n            const code = Encoder.encode(contents, errorCorrectionLevel, hints);\n            return this.renderResult(code, width, height, quietZone);\n        }\n        /**\n         * Renders the result and then appends it to the DOM.\n         */\n        writeToDom(containerElement, contents, width, height, hints = null) {\n            if (typeof containerElement === 'string') {\n                containerElement = document.querySelector(containerElement);\n            }\n            const svgElement = this.write(contents, width, height, hints);\n            if (containerElement)\n                containerElement.appendChild(svgElement);\n        }\n        /**\n         * Note that the input matrix uses 0 == white, 1 == black.\n         * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n         */\n        renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {\n            const input = code.getMatrix();\n            if (input === null) {\n                throw new IllegalStateException();\n            }\n            const inputWidth = input.getWidth();\n            const inputHeight = input.getHeight();\n            const qrWidth = inputWidth + (quietZone * 2);\n            const qrHeight = inputHeight + (quietZone * 2);\n            const outputWidth = Math.max(width, qrWidth);\n            const outputHeight = Math.max(height, qrHeight);\n            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n            // handle all the padding from 100x100 (the actual QR) up to 200x160.\n            const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n            const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n            const svgElement = this.createSVGElement(outputWidth, outputHeight);\n            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n                // Write the contents of this row of the barcode\n                for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                    if (input.get(inputX, inputY) === 1) {\n                        const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);\n                        svgElement.appendChild(svgRectElement);\n                    }\n                }\n            }\n            return svgElement;\n        }\n        /**\n         * Creates a SVG element.\n         *\n         * @param w SVG's width attribute\n         * @param h SVG's height attribute\n         */\n        createSVGElement(w, h) {\n            const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'svg');\n            svgElement.setAttributeNS(null, 'height', w.toString());\n            svgElement.setAttributeNS(null, 'width', h.toString());\n            return svgElement;\n        }\n        /**\n         * Creates a SVG rect element.\n         *\n         * @param x Element's x coordinate\n         * @param y Element's y coordinate\n         * @param w Element's width attribute\n         * @param h Element's height attribute\n         */\n        createSvgRectElement(x, y, w, h) {\n            const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'rect');\n            rect.setAttributeNS(null, 'x', x.toString());\n            rect.setAttributeNS(null, 'y', y.toString());\n            rect.setAttributeNS(null, 'height', w.toString());\n            rect.setAttributeNS(null, 'width', h.toString());\n            rect.setAttributeNS(null, 'fill', '#000000');\n            return rect;\n        }\n    }\n    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;\n    /**\n     * SVG markup NameSpace\n     */\n    BrowserQRCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';\n\n    /*import java.util.Map;*/\n    /**\n     * This object renders a QR Code as a BitMatrix 2D array of greyscale values.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class QRCodeWriter {\n        /*@Override*/\n        // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix\n        //     /*throws WriterException */ {\n        //   return encode(contents, format, width, height, null)\n        // }\n        /*@Override*/\n        encode(contents, format, width /*int*/, height /*int*/, hints) {\n            if (contents.length === 0) {\n                throw new IllegalArgumentException('Found empty contents');\n            }\n            if (format !== BarcodeFormat$1.QR_CODE) {\n                throw new IllegalArgumentException('Can only encode QR_CODE, but got ' + format);\n            }\n            if (width < 0 || height < 0) {\n                throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);\n            }\n            let errorCorrectionLevel = ErrorCorrectionLevel.L;\n            let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;\n            if (hints !== null) {\n                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {\n                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {\n                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);\n                }\n            }\n            const code = Encoder.encode(contents, errorCorrectionLevel, hints);\n            return QRCodeWriter.renderResult(code, width, height, quietZone);\n        }\n        // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses\n        // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n        static renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {\n            const input = code.getMatrix();\n            if (input === null) {\n                throw new IllegalStateException();\n            }\n            const inputWidth = input.getWidth();\n            const inputHeight = input.getHeight();\n            const qrWidth = inputWidth + (quietZone * 2);\n            const qrHeight = inputHeight + (quietZone * 2);\n            const outputWidth = Math.max(width, qrWidth);\n            const outputHeight = Math.max(height, qrHeight);\n            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));\n            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n            // handle all the padding from 100x100 (the actual QR) up to 200x160.\n            const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);\n            const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);\n            const output = new BitMatrix(outputWidth, outputHeight);\n            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n                // Write the contents of this row of the barcode\n                for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                    if (input.get(inputX, inputY) === 1) {\n                        output.setRegion(outputX, outputY, multiple, multiple);\n                    }\n                }\n            }\n            return output;\n        }\n    }\n    QRCodeWriter.QUIET_ZONE_SIZE = 4;\n\n    /*import java.util.Map;*/\n    /**\n     * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat\n     * requested and encodes the barcode with the supplied contents.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class MultiFormatWriter {\n        /*@Override*/\n        // public encode(contents: string,\n        //                         format: BarcodeFormat,\n        //                         width: number /*int*/,\n        //                         height: number /*int*/): BitMatrix /*throws WriterException */ {\n        //   return encode(contents, format, width, height, null)\n        // }\n        /*@Override*/\n        encode(contents, format, width /*int*/, height /*int*/, hints) {\n            let writer;\n            switch (format) {\n                // case BarcodeFormat.EAN_8:\n                //   writer = new EAN8Writer()\n                //   break\n                // case BarcodeFormat.UPC_E:\n                //   writer = new UPCEWriter()\n                //   break\n                // case BarcodeFormat.EAN_13:\n                //   writer = new EAN13Writer()\n                //   break\n                // case BarcodeFormat.UPC_A:\n                //   writer = new UPCAWriter()\n                //   break\n                case BarcodeFormat$1.QR_CODE:\n                    writer = new QRCodeWriter();\n                    break;\n                // case BarcodeFormat.CODE_39:\n                //   writer = new Code39Writer()\n                //   break\n                // case BarcodeFormat.CODE_93:\n                //   writer = new Code93Writer()\n                //   break\n                // case BarcodeFormat.CODE_128:\n                //   writer = new Code128Writer()\n                //   break\n                // case BarcodeFormat.ITF:\n                //   writer = new ITFWriter()\n                //   break\n                // case BarcodeFormat.PDF_417:\n                //   writer = new PDF417Writer()\n                //   break\n                // case BarcodeFormat.CODABAR:\n                //   writer = new CodaBarWriter()\n                //   break\n                // case BarcodeFormat.DATA_MATRIX:\n                //   writer = new DataMatrixWriter()\n                //   break\n                // case BarcodeFormat.AZTEC:\n                //   writer = new AztecWriter()\n                //   break\n                default:\n                    throw new IllegalArgumentException('No encoder available for format ' + format);\n            }\n            return writer.encode(contents, format, width, height, hints);\n        }\n    }\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This object extends LuminanceSource around an array of YUV data returned from the camera driver,\n     * with the option to crop to a rectangle within the full data. This can be used to exclude\n     * superfluous pixels around the perimeter and speed up decoding.\n     *\n     * It works for any pixel format where the Y channel is planar and appears first, including\n     * YCbCr_420_SP and YCbCr_422_SP.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     */\n    class PlanarYUVLuminanceSource extends LuminanceSource {\n        constructor(yuvData, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/, width /*int*/, height /*int*/, reverseHorizontal) {\n            super(width, height);\n            this.yuvData = yuvData;\n            this.dataWidth = dataWidth;\n            this.dataHeight = dataHeight;\n            this.left = left;\n            this.top = top;\n            if (left + width > dataWidth || top + height > dataHeight) {\n                throw new IllegalArgumentException('Crop rectangle does not fit within image data.');\n            }\n            if (reverseHorizontal) {\n                this.reverseHorizontal(width, height);\n            }\n        }\n        /*@Override*/\n        getRow(y /*int*/, row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException('Requested row is outside the image: ' + y);\n            }\n            const width = this.getWidth();\n            if (row === null || row === undefined || row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            const offset = (y + this.top) * this.dataWidth + this.left;\n            System.arraycopy(this.yuvData, offset, row, 0, width);\n            return row;\n        }\n        /*@Override*/\n        getMatrix() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            // If the caller asks for the entire underlying image, save the copy and give them the\n            // original data. The docs specifically warn that result.length must be ignored.\n            if (width === this.dataWidth && height === this.dataHeight) {\n                return this.yuvData;\n            }\n            const area = width * height;\n            const matrix = new Uint8ClampedArray(area);\n            let inputOffset = this.top * this.dataWidth + this.left;\n            // If the width matches the full width of the underlying data, perform a single copy.\n            if (width === this.dataWidth) {\n                System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);\n                return matrix;\n            }\n            // Otherwise copy one cropped row at a time.\n            for (let y = 0; y < height; y++) {\n                const outputOffset = y * width;\n                System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);\n                inputOffset += this.dataWidth;\n            }\n            return matrix;\n        }\n        /*@Override*/\n        isCropSupported() {\n            return true;\n        }\n        /*@Override*/\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);\n        }\n        renderThumbnail() {\n            const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            const pixels = new Int32Array(width * height);\n            const yuv = this.yuvData;\n            let inputOffset = this.top * this.dataWidth + this.left;\n            for (let y = 0; y < height; y++) {\n                const outputOffset = y * width;\n                for (let x = 0; x < width; x++) {\n                    const grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;\n                    pixels[outputOffset + x] = 0xFF000000 | (grey * 0x00010101);\n                }\n                inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n            }\n            return pixels;\n        }\n        /**\n         * @return width of image from {@link #renderThumbnail()}\n         */\n        getThumbnailWidth() {\n            return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        }\n        /**\n         * @return height of image from {@link #renderThumbnail()}\n         */\n        getThumbnailHeight() {\n            return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;\n        }\n        reverseHorizontal(width /*int*/, height /*int*/) {\n            const yuvData = this.yuvData;\n            for (let y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {\n                const middle = rowStart + width / 2;\n                for (let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {\n                    const temp = yuvData[x1];\n                    yuvData[x1] = yuvData[x2];\n                    yuvData[x2] = temp;\n                }\n            }\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;\n\n    /*\n     * Copyright 2009 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This class is used to help decode images from files which arrive as RGB data from\n     * an ARGB pixel array. It does not support rotation.\n     *\n     * @author dswitkin@google.com (Daniel Switkin)\n     * @author Betaminos\n     */\n    class RGBLuminanceSource extends LuminanceSource {\n        constructor(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {\n            super(width, height);\n            this.dataWidth = dataWidth;\n            this.dataHeight = dataHeight;\n            this.left = left;\n            this.top = top;\n            if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array\n                const size = width * height;\n                const luminancesUint8Array = new Uint8ClampedArray(size);\n                for (let offset = 0; offset < size; offset++) {\n                    const pixel = luminances[offset];\n                    const r = (pixel >> 16) & 0xff; // red\n                    const g2 = (pixel >> 7) & 0x1fe; // 2 * green\n                    const b = pixel & 0xff; // blue\n                    // Calculate green-favouring average cheaply\n                    luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;\n                }\n                this.luminances = luminancesUint8Array;\n            }\n            else {\n                this.luminances = luminances;\n            }\n            if (undefined === dataWidth) {\n                this.dataWidth = width;\n            }\n            if (undefined === dataHeight) {\n                this.dataHeight = height;\n            }\n            if (undefined === left) {\n                this.left = 0;\n            }\n            if (undefined === top) {\n                this.top = 0;\n            }\n            if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {\n                throw new IllegalArgumentException('Crop rectangle does not fit within image data.');\n            }\n        }\n        /*@Override*/\n        getRow(y /*int*/, row) {\n            if (y < 0 || y >= this.getHeight()) {\n                throw new IllegalArgumentException('Requested row is outside the image: ' + y);\n            }\n            const width = this.getWidth();\n            if (row === null || row === undefined || row.length < width) {\n                row = new Uint8ClampedArray(width);\n            }\n            const offset = (y + this.top) * this.dataWidth + this.left;\n            System.arraycopy(this.luminances, offset, row, 0, width);\n            return row;\n        }\n        /*@Override*/\n        getMatrix() {\n            const width = this.getWidth();\n            const height = this.getHeight();\n            // If the caller asks for the entire underlying image, save the copy and give them the\n            // original data. The docs specifically warn that result.length must be ignored.\n            if (width === this.dataWidth && height === this.dataHeight) {\n                return this.luminances;\n            }\n            const area = width * height;\n            const matrix = new Uint8ClampedArray(area);\n            let inputOffset = this.top * this.dataWidth + this.left;\n            // If the width matches the full width of the underlying data, perform a single copy.\n            if (width === this.dataWidth) {\n                System.arraycopy(this.luminances, inputOffset, matrix, 0, area);\n                return matrix;\n            }\n            // Otherwise copy one cropped row at a time.\n            for (let y = 0; y < height; y++) {\n                const outputOffset = y * width;\n                System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);\n                inputOffset += this.dataWidth;\n            }\n            return matrix;\n        }\n        /*@Override*/\n        isCropSupported() {\n            return true;\n        }\n        /*@Override*/\n        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {\n            return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);\n        }\n        invert() {\n            return new InvertedLuminanceSource(this);\n        }\n    }\n\n    /**\n     * Just to make a shortcut between Java code and TS code.\n     */\n    class Charset extends CharacterSetECI {\n        static forName(name) {\n            return this.getCharacterSetECIByName(name);\n        }\n    }\n\n    /**\n     * Just to make a shortcut between Java code and TS code.\n     */\n    class StandardCharsets {\n    }\n    StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * Aztec 2D code representation\n     *\n     * @author Rustam Abdullaev\n     */\n    /*public final*/ class AztecCode {\n        /**\n         * @return {@code true} if compact instead of full mode\n         */\n        isCompact() {\n            return this.compact;\n        }\n        setCompact(compact) {\n            this.compact = compact;\n        }\n        /**\n         * @return size in pixels (width and height)\n         */\n        getSize() {\n            return this.size;\n        }\n        setSize(size) {\n            this.size = size;\n        }\n        /**\n         * @return number of levels\n         */\n        getLayers() {\n            return this.layers;\n        }\n        setLayers(layers) {\n            this.layers = layers;\n        }\n        /**\n         * @return number of data codewords\n         */\n        getCodeWords() {\n            return this.codeWords;\n        }\n        setCodeWords(codeWords) {\n            this.codeWords = codeWords;\n        }\n        /**\n         * @return the symbol image\n         */\n        getMatrix() {\n            return this.matrix;\n        }\n        setMatrix(matrix) {\n            this.matrix = matrix;\n        }\n    }\n\n    class Collections {\n        /**\n         * The singletonList(T) method is used to return an immutable list containing only the specified object.\n         */\n        static singletonList(item) {\n            return [item];\n        }\n        /**\n         * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.\n         */\n        static min(collection, comparator) {\n            return collection.sort(comparator)[0];\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    class Token {\n        constructor(previous) {\n            this.previous = previous;\n        }\n        getPrevious() {\n            return this.previous;\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /*final*/ class SimpleToken extends Token {\n        constructor(previous, value, bitCount) {\n            super(previous);\n            this.value = value;\n            this.bitCount = bitCount;\n        }\n        /**\n         * @Override\n         */\n        appendTo(bitArray, text) {\n            bitArray.appendBits(this.value, this.bitCount);\n        }\n        add(value, bitCount) {\n            return new SimpleToken(this, value, bitCount);\n        }\n        addBinaryShift(start, byteCount) {\n            // no-op can't binary shift a simple token\n            console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token');\n            return new SimpleToken(this, start, byteCount);\n        }\n        /**\n         * @Override\n         */\n        toString() {\n            let value = this.value & ((1 << this.bitCount) - 1);\n            value |= 1 << this.bitCount;\n            return '<' + Integer.toBinaryString(value | (1 << this.bitCount)).substring(1) + '>';\n        }\n    }\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /*final*/ class BinaryShiftToken extends SimpleToken {\n        constructor(previous, binaryShiftStart, binaryShiftByteCount) {\n            super(previous, 0, 0);\n            this.binaryShiftStart = binaryShiftStart;\n            this.binaryShiftByteCount = binaryShiftByteCount;\n        }\n        /**\n         * @Override\n         */\n        appendTo(bitArray, text) {\n            for (let i = 0; i < this.binaryShiftByteCount; i++) {\n                if (i === 0 || (i === 31 && this.binaryShiftByteCount <= 62)) {\n                    // We need a header before the first character, and before\n                    // character 31 when the total byte code is <= 62\n                    bitArray.appendBits(31, 5); // BINARY_SHIFT\n                    if (this.binaryShiftByteCount > 62) {\n                        bitArray.appendBits(this.binaryShiftByteCount - 31, 16);\n                    }\n                    else if (i === 0) {\n                        // 1 <= binaryShiftByteCode <= 62\n                        bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);\n                    }\n                    else {\n                        // 32 <= binaryShiftCount <= 62 and i == 31\n                        bitArray.appendBits(this.binaryShiftByteCount - 31, 5);\n                    }\n                }\n                bitArray.appendBits(text[this.binaryShiftStart + i], 8);\n            }\n        }\n        addBinaryShift(start, byteCount) {\n            // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n            return new BinaryShiftToken(this, start, byteCount);\n        }\n        /**\n         * @Override\n         */\n        toString() {\n            return '<' + this.binaryShiftStart + '::' + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + '>';\n        }\n    }\n\n    function addBinaryShift(token, start, byteCount) {\n        // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);\n        return new BinaryShiftToken(token, start, byteCount);\n    }\n    function add(token, value, bitCount) {\n        return new SimpleToken(token, value, bitCount);\n    }\n\n    const /*final*/ MODE_NAMES = [\n        'UPPER',\n        'LOWER',\n        'DIGIT',\n        'MIXED',\n        'PUNCT'\n    ];\n    const /*final*/ MODE_UPPER = 0; // 5 bits\n    const /*final*/ MODE_LOWER = 1; // 5 bits\n    const /*final*/ MODE_DIGIT = 2; // 4 bits\n    const /*final*/ MODE_MIXED = 3; // 5 bits\n    const /*final*/ MODE_PUNCT = 4; // 5 bits\n    const EMPTY_TOKEN = new SimpleToken(null, 0, 0);\n\n    // The Latch Table shows, for each pair of Modes, the optimal method for\n    // getting from one mode to another.  In the worst possible case, this can\n    // be up to 14 bits.  In the best possible case, we are already there!\n    // The high half-word of each entry gives the number of bits.\n    // The low half-word of each entry are the actual bits necessary to change\n    const LATCH_TABLE = [\n        Int32Array.from([\n            0,\n            (5 << 16) + 28,\n            (5 << 16) + 30,\n            (5 << 16) + 29,\n            (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (9 << 16) + (30 << 4) + 14,\n            0,\n            (5 << 16) + 30,\n            (5 << 16) + 29,\n            (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (4 << 16) + 14,\n            (9 << 16) + (14 << 5) + 28,\n            0,\n            (9 << 16) + (14 << 5) + 29,\n            (14 << 16) + (14 << 10) + (29 << 5) + 30\n            // DIGIT -> UPPER -> MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (5 << 16) + 29,\n            (5 << 16) + 28,\n            (10 << 16) + (29 << 5) + 30,\n            0,\n            (5 << 16) + 30 // MIXED -> PUNCT\n        ]),\n        Int32Array.from([\n            (5 << 16) + 31,\n            (10 << 16) + (31 << 5) + 28,\n            (10 << 16) + (31 << 5) + 30,\n            (10 << 16) + (31 << 5) + 29,\n            0\n        ])\n    ];\n\n    function static_SHIFT_TABLE(SHIFT_TABLE) {\n        for (let table /*Int32Array*/ of SHIFT_TABLE) {\n            Arrays.fill(table, -1);\n        }\n        SHIFT_TABLE[MODE_UPPER][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_LOWER][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_LOWER][MODE_UPPER] = 28;\n        SHIFT_TABLE[MODE_MIXED][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_DIGIT][MODE_PUNCT] = 0;\n        SHIFT_TABLE[MODE_DIGIT][MODE_UPPER] = 15;\n        return SHIFT_TABLE;\n    }\n    const /*final*/ SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6)); // mode shift codes, per table\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * State represents all information about a sequence necessary to generate the current output.\n     * Note that a state is immutable.\n     */\n    /*final*/ class State {\n        constructor(token, mode, binaryBytes, bitCount) {\n            this.token = token;\n            this.mode = mode;\n            this.binaryShiftByteCount = binaryBytes;\n            this.bitCount = bitCount;\n            // Make sure we match the token\n            // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n            //    (binaryShiftByteCount === 0 ? 0 :\n            //     binaryShiftByteCount <= 31 ? 10 :\n            //     binaryShiftByteCount <= 62 ? 20 : 21);\n            // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n        }\n        getMode() {\n            return this.mode;\n        }\n        getToken() {\n            return this.token;\n        }\n        getBinaryShiftByteCount() {\n            return this.binaryShiftByteCount;\n        }\n        getBitCount() {\n            return this.bitCount;\n        }\n        // Create a new state representing this state with a latch to a (not\n        // necessary different) mode, and then a code.\n        latchAndAppend(mode, value) {\n            // assert binaryShiftByteCount === 0;\n            let bitCount = this.bitCount;\n            let token = this.token;\n            if (mode !== this.mode) {\n                let latch = LATCH_TABLE[this.mode][mode];\n                token = add(token, latch & 0xffff, latch >> 16);\n                bitCount += latch >> 16;\n            }\n            let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;\n            token = add(token, value, latchModeBitCount);\n            return new State(token, mode, 0, bitCount + latchModeBitCount);\n        }\n        // Create a new state representing this state, with a temporary shift\n        // to a different mode to output a single value.\n        shiftAndAppend(mode, value) {\n            // assert binaryShiftByteCount === 0 && this.mode !== mode;\n            let token = this.token;\n            let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;\n            // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n            token = add(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n            token = add(token, value, 5);\n            return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n        }\n        // Create a new state representing this state, but an additional character\n        // output in Binary Shift mode.\n        addBinaryShiftChar(index) {\n            let token = this.token;\n            let mode = this.mode;\n            let bitCount = this.bitCount;\n            if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {\n                // assert binaryShiftByteCount === 0;\n                let latch = LATCH_TABLE[mode][MODE_UPPER];\n                token = add(token, latch & 0xffff, latch >> 16);\n                bitCount += latch >> 16;\n                mode = MODE_UPPER;\n            }\n            let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31\n                ? 18\n                : this.binaryShiftByteCount === 62\n                    ? 9\n                    : 8;\n            let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n            if (result.binaryShiftByteCount === 2047 + 31) {\n                // The string is as long as it's allowed to be.  We should end it.\n                result = result.endBinaryShift(index + 1);\n            }\n            return result;\n        }\n        // Create the state identical to this one, but we are no longer in\n        // Binary Shift mode.\n        endBinaryShift(index) {\n            if (this.binaryShiftByteCount === 0) {\n                return this;\n            }\n            let token = this.token;\n            token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);\n            // assert token.getTotalBitCount() === this.bitCount;\n            return new State(token, this.mode, 0, this.bitCount);\n        }\n        // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n        // state under all possible circumstances.\n        isBetterThanOrEqualTo(other) {\n            let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);\n            if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n                // add additional B/S encoding cost of other, if any\n                newModeBitCount +=\n                    State.calculateBinaryShiftCost(other) -\n                        State.calculateBinaryShiftCost(this);\n            }\n            else if (this.binaryShiftByteCount > other.binaryShiftByteCount &&\n                other.binaryShiftByteCount > 0) {\n                // maximum possible additional cost (it: h)\n                newModeBitCount += 10;\n            }\n            return newModeBitCount <= other.bitCount;\n        }\n        toBitArray(text) {\n            // Reverse the tokens, so that they are in the order that they should\n            // be output\n            let symbols = [];\n            for (let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {\n                symbols.unshift(token);\n            }\n            let bitArray = new BitArray();\n            // Add each token to the result.\n            for (const symbol of symbols) {\n                symbol.appendTo(bitArray, text);\n            }\n            // assert bitArray.getSize() === this.bitCount;\n            return bitArray;\n        }\n        /**\n         * @Override\n         */\n        toString() {\n            return StringUtils.format('%s bits=%d bytes=%d', MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n        }\n        static calculateBinaryShiftCost(state) {\n            if (state.binaryShiftByteCount > 62) {\n                return 21; // B/S with extended length\n            }\n            if (state.binaryShiftByteCount > 31) {\n                return 20; // two B/S\n            }\n            if (state.binaryShiftByteCount > 0) {\n                return 10; // one B/S\n            }\n            return 0;\n        }\n    }\n    State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);\n\n    function static_CHAR_MAP(CHAR_MAP) {\n        const spaceCharCode = StringUtils.getCharCode(' ');\n        const pointCharCode = StringUtils.getCharCode('.');\n        const commaCharCode = StringUtils.getCharCode(',');\n        CHAR_MAP[MODE_UPPER][spaceCharCode] = 1;\n        const zUpperCharCode = StringUtils.getCharCode('Z');\n        const aUpperCharCode = StringUtils.getCharCode('A');\n        for (let c = aUpperCharCode; c <= zUpperCharCode; c++) {\n            CHAR_MAP[MODE_UPPER][c] = c - aUpperCharCode + 2;\n        }\n        CHAR_MAP[MODE_LOWER][spaceCharCode] = 1;\n        const zLowerCharCode = StringUtils.getCharCode('z');\n        const aLowerCharCode = StringUtils.getCharCode('a');\n        for (let c = aLowerCharCode; c <= zLowerCharCode; c++) {\n            CHAR_MAP[MODE_LOWER][c] = c - aLowerCharCode + 2;\n        }\n        CHAR_MAP[MODE_DIGIT][spaceCharCode] = 1;\n        const nineCharCode = StringUtils.getCharCode('9');\n        const zeroCharCode = StringUtils.getCharCode('0');\n        for (let c = zeroCharCode; c <= nineCharCode; c++) {\n            CHAR_MAP[MODE_DIGIT][c] = c - zeroCharCode + 2;\n        }\n        CHAR_MAP[MODE_DIGIT][commaCharCode] = 12;\n        CHAR_MAP[MODE_DIGIT][pointCharCode] = 13;\n        const mixedTable = [\n            '\\x00',\n            ' ',\n            '\\x01',\n            '\\x02',\n            '\\x03',\n            '\\x04',\n            '\\x05',\n            '\\x06',\n            '\\x07',\n            '\\b',\n            '\\t',\n            '\\n',\n            '\\x0b',\n            '\\f',\n            '\\r',\n            '\\x1b',\n            '\\x1c',\n            '\\x1d',\n            '\\x1e',\n            '\\x1f',\n            '@',\n            '\\\\',\n            '^',\n            '_',\n            '`',\n            '|',\n            '~',\n            '\\x7f'\n        ];\n        for (let i = 0; i < mixedTable.length; i++) {\n            CHAR_MAP[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])] = i;\n        }\n        const punctTable = [\n            '\\x00',\n            '\\r',\n            '\\x00',\n            '\\x00',\n            '\\x00',\n            '\\x00',\n            '!',\n            '\\'',\n            '#',\n            '$',\n            '%',\n            '&',\n            '\\'',\n            '(',\n            ')',\n            '*',\n            '+',\n            ',',\n            '-',\n            '.',\n            '/',\n            ':',\n            ';',\n            '<',\n            '=',\n            '>',\n            '?',\n            '[',\n            ']',\n            '{',\n            '}'\n        ];\n        for (let i = 0; i < punctTable.length; i++) {\n            if (StringUtils.getCharCode(punctTable[i]) > 0) {\n                CHAR_MAP[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])] = i;\n            }\n        }\n        return CHAR_MAP;\n    }\n    const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    /**\n     * This produces nearly optimal encodings of text into the first-level of\n     * encoding used by Aztec code.\n     *\n     * It uses a dynamic algorithm.  For each prefix of the string, it determines\n     * a set of encodings that could lead to this prefix.  We repeatedly add a\n     * character and generate a new set of optimal encodings until we have read\n     * through the entire input.\n     *\n     * @author Frank Yellin\n     * @author Rustam Abdullaev\n     */\n    /*public final*/ class HighLevelEncoder {\n        constructor(text) {\n            this.text = text;\n        }\n        /**\n         * @return text represented by this encoder encoded as a {@link BitArray}\n         */\n        encode() {\n            const spaceCharCode = StringUtils.getCharCode(' ');\n            const lineBreakCharCode = StringUtils.getCharCode('\\n');\n            let states = Collections.singletonList(State.INITIAL_STATE);\n            for (let index = 0; index < this.text.length; index++) {\n                let pairCode;\n                let nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n                switch (this.text[index]) {\n                    case StringUtils.getCharCode('\\r'):\n                        pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n                        break;\n                    case StringUtils.getCharCode('.'):\n                        pairCode = nextChar === spaceCharCode ? 3 : 0;\n                        break;\n                    case StringUtils.getCharCode(','):\n                        pairCode = nextChar === spaceCharCode ? 4 : 0;\n                        break;\n                    case StringUtils.getCharCode(':'):\n                        pairCode = nextChar === spaceCharCode ? 5 : 0;\n                        break;\n                    default:\n                        pairCode = 0;\n                }\n                if (pairCode > 0) {\n                    // We have one of the four special PUNCT pairs.  Treat them specially.\n                    // Get a new set of states for the two new characters.\n                    states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n                    index++;\n                }\n                else {\n                    // Get a new set of states for the new character.\n                    states = this.updateStateListForChar(states, index);\n                }\n            }\n            // We are left with a set of states.  Find the shortest one.\n            const minState = Collections.min(states, (a, b) => {\n                return a.getBitCount() - b.getBitCount();\n            });\n            // Convert it to a bit array, and return.\n            return minState.toBitArray(this.text);\n        }\n        // We update a set of states for a new character by updating each state\n        // for the new character, merging the results, and then removing the\n        // non-optimal states.\n        updateStateListForChar(states, index) {\n            const result = [];\n            for (let state /*State*/ of states) {\n                this.updateStateForChar(state, index, result);\n            }\n            return HighLevelEncoder.simplifyStates(result);\n        }\n        // Return a set of states that represent the possible ways of updating this\n        // state for the next character.  The resulting set of states are added to\n        // the \"result\" list.\n        updateStateForChar(state, index, result) {\n            let ch = (this.text[index] & 0xff);\n            let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;\n            let stateNoBinary = null;\n            for (let mode /*int*/ = 0; mode <= MODE_PUNCT; mode++) {\n                let charInMode = CHAR_MAP[mode][ch];\n                if (charInMode > 0) {\n                    if (stateNoBinary == null) {\n                        // Only create stateNoBinary the first time it's required.\n                        stateNoBinary = state.endBinaryShift(index);\n                    }\n                    // Try generating the character by latching to its mode\n                    if (!charInCurrentTable ||\n                        mode === state.getMode() ||\n                        mode === MODE_DIGIT) {\n                        // If the character is in the current table, we don't want to latch to\n                        // any other mode except possibly digit (which uses only 4 bits).  Any\n                        // other latch would be equally successful *after* this character, and\n                        // so wouldn't save any bits.\n                        const latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n                        result.push(latchState);\n                    }\n                    // Try generating the character by switching to its mode.\n                    if (!charInCurrentTable &&\n                        SHIFT_TABLE[state.getMode()][mode] >= 0) {\n                        // It never makes sense to temporarily shift to another mode if the\n                        // character exists in the current mode.  That can never save bits.\n                        const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n                        result.push(shiftState);\n                    }\n                }\n            }\n            if (state.getBinaryShiftByteCount() > 0 ||\n                CHAR_MAP[state.getMode()][ch] === 0) {\n                // It's never worthwhile to go into binary shift mode if you're not already\n                // in binary shift mode, and the character exists in your current mode.\n                // That can never save bits over just outputting the char in the current mode.\n                let binaryState = state.addBinaryShiftChar(index);\n                result.push(binaryState);\n            }\n        }\n        static updateStateListForPair(states, index, pairCode) {\n            const result = [];\n            for (let state /*State*/ of states) {\n                this.updateStateForPair(state, index, pairCode, result);\n            }\n            return this.simplifyStates(result);\n        }\n        static updateStateForPair(state, index, pairCode, result) {\n            let stateNoBinary = state.endBinaryShift(index);\n            // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n            result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));\n            if (state.getMode() !== MODE_PUNCT) {\n                // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n                // Every state except C.MODE_PUNCT (handled above) can shift\n                result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));\n            }\n            if (pairCode === 3 || pairCode === 4) {\n                // both characters are in DIGITS.  Sometimes better to just add two digits\n                let digitState = stateNoBinary\n                    .latchAndAppend(MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n                    .latchAndAppend(MODE_DIGIT, 1); // space in DIGIT\n                result.push(digitState);\n            }\n            if (state.getBinaryShiftByteCount() > 0) {\n                // It only makes sense to do the characters as binary if we're already\n                // in binary mode.\n                let binaryState = state\n                    .addBinaryShiftChar(index)\n                    .addBinaryShiftChar(index + 1);\n                result.push(binaryState);\n            }\n        }\n        static simplifyStates(states) {\n            let result = [];\n            for (const newState of states) {\n                let add = true;\n                for (const oldState of result) {\n                    if (oldState.isBetterThanOrEqualTo(newState)) {\n                        add = false;\n                        break;\n                    }\n                    if (newState.isBetterThanOrEqualTo(oldState)) {\n                        // iterator.remove();\n                        result = result.filter(x => x !== oldState); // remove old state\n                    }\n                }\n                if (add) {\n                    result.push(newState);\n                }\n            }\n            return result;\n        }\n    }\n\n    /*\n     * Copyright 2013 ZXing authors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *      http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n    // package com.google.zxing.aztec.encoder;\n    // import com.google.zxing.common.BitArray;\n    // import com.google.zxing.common.BitMatrix;\n    // import com.google.zxing.common.reedsolomon.GenericGF;\n    // import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;\n    /**\n     * Generates Aztec 2D barcodes.\n     *\n     * @author Rustam Abdullaev\n     */\n    /*public final*/ class Encoder$1 {\n        constructor() {\n        }\n        /**\n         * Encodes the given binary content as an Aztec symbol\n         *\n         * @param data input data string\n         * @return Aztec symbol matrix with metadata\n         */\n        static encodeBytes(data) {\n            return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);\n        }\n        /**\n         * Encodes the given binary content as an Aztec symbol\n         *\n         * @param data input data string\n         * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n         *                      a minimum of 23% + 3 words is recommended)\n         * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n         * @return Aztec symbol matrix with metadata\n         */\n        static encode(data, minECCPercent, userSpecifiedLayers) {\n            // High-level encode\n            let bits = new HighLevelEncoder(data).encode();\n            // stuff bits and choose symbol size\n            let eccBits = Integer.truncDivision((bits.getSize() * minECCPercent), 100) + 11;\n            let totalSizeBits = bits.getSize() + eccBits;\n            let compact;\n            let layers;\n            let totalBitsInLayer;\n            let wordSize;\n            let stuffedBits;\n            if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {\n                compact = userSpecifiedLayers < 0;\n                layers = Math.abs(userSpecifiedLayers);\n                if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {\n                    throw new IllegalArgumentException(StringUtils.format('Illegal value %s for layers', userSpecifiedLayers));\n                }\n                totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);\n                wordSize = Encoder$1.WORD_SIZE[layers];\n                let usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n                stuffedBits = Encoder$1.stuffBits(bits, wordSize);\n                if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {\n                    throw new IllegalArgumentException('Data to large for user specified layer');\n                }\n                if (compact && stuffedBits.getSize() > wordSize * 64) {\n                    // Compact format only allows 64 data words, though C4 can hold more words than that\n                    throw new IllegalArgumentException('Data to large for user specified layer');\n                }\n            }\n            else {\n                wordSize = 0;\n                stuffedBits = null;\n                // We look at the possible table sizes in the order Compact1, Compact2, Compact3,\n                // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)\n                // is the same size, but has more data.\n                for (let i /*int*/ = 0;; i++) {\n                    if (i > Encoder$1.MAX_NB_BITS) {\n                        throw new IllegalArgumentException('Data too large for an Aztec code');\n                    }\n                    compact = i <= 3;\n                    layers = compact ? i + 1 : i;\n                    totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);\n                    if (totalSizeBits > totalBitsInLayer) {\n                        continue;\n                    }\n                    // [Re]stuff the bits if this is the first opportunity, or if the\n                    // wordSize has changed\n                    if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {\n                        wordSize = Encoder$1.WORD_SIZE[layers];\n                        stuffedBits = Encoder$1.stuffBits(bits, wordSize);\n                    }\n                    let usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);\n                    if (compact && stuffedBits.getSize() > wordSize * 64) {\n                        // Compact format only allows 64 data words, though C4 can hold more words than that\n                        continue;\n                    }\n                    if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {\n                        break;\n                    }\n                }\n            }\n            let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);\n            // generate mode message\n            let messageSizeInWords = stuffedBits.getSize() / wordSize;\n            let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);\n            // allocate symbol\n            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines\n            let alignmentMap = new Int32Array(baseMatrixSize);\n            let matrixSize;\n            if (compact) {\n                // no alignment marks in compact mode, alignmentMap is a no-op\n                matrixSize = baseMatrixSize;\n                for (let i /*int*/ = 0; i < alignmentMap.length; i++) {\n                    alignmentMap[i] = i;\n                }\n            }\n            else {\n                matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);\n                let origCenter = Integer.truncDivision(baseMatrixSize, 2);\n                let center = Integer.truncDivision(matrixSize, 2);\n                for (let i /*int*/ = 0; i < origCenter; i++) {\n                    let newOffset = i + Integer.truncDivision(i, 15);\n                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;\n                    alignmentMap[origCenter + i] = center + newOffset + 1;\n                }\n            }\n            let matrix = new BitMatrix(matrixSize);\n            // draw data bits\n            for (let i /*int*/ = 0, rowOffset = 0; i < layers; i++) {\n                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);\n                for (let j /*int*/ = 0; j < rowSize; j++) {\n                    let columnOffset = j * 2;\n                    for (let k /*int*/ = 0; k < 2; k++) {\n                        if (messageBits.get(rowOffset + columnOffset + k)) {\n                            matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {\n                            matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {\n                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);\n                        }\n                        if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {\n                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);\n                        }\n                    }\n                }\n                rowOffset += rowSize * 8;\n            }\n            // draw mode message\n            Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);\n            // draw alignment marks\n            if (compact) {\n                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);\n            }\n            else {\n                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);\n                for (let i /*int*/ = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {\n                    for (let k /*int*/ = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {\n                        matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);\n                        matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);\n                        matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);\n                        matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);\n                    }\n                }\n            }\n            let aztec = new AztecCode();\n            aztec.setCompact(compact);\n            aztec.setSize(matrixSize);\n            aztec.setLayers(layers);\n            aztec.setCodeWords(messageSizeInWords);\n            aztec.setMatrix(matrix);\n            return aztec;\n        }\n        static drawBullsEye(matrix, center, size) {\n            for (let i /*int*/ = 0; i < size; i += 2) {\n                for (let j /*int*/ = center - i; j <= center + i; j++) {\n                    matrix.set(j, center - i);\n                    matrix.set(j, center + i);\n                    matrix.set(center - i, j);\n                    matrix.set(center + i, j);\n                }\n            }\n            matrix.set(center - size, center - size);\n            matrix.set(center - size + 1, center - size);\n            matrix.set(center - size, center - size + 1);\n            matrix.set(center + size, center - size);\n            matrix.set(center + size, center - size + 1);\n            matrix.set(center + size, center + size - 1);\n        }\n        static generateModeMessage(compact, layers, messageSizeInWords) {\n            let modeMessage = new BitArray();\n            if (compact) {\n                modeMessage.appendBits(layers - 1, 2);\n                modeMessage.appendBits(messageSizeInWords - 1, 6);\n                modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);\n            }\n            else {\n                modeMessage.appendBits(layers - 1, 5);\n                modeMessage.appendBits(messageSizeInWords - 1, 11);\n                modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);\n            }\n            return modeMessage;\n        }\n        static drawModeMessage(matrix, compact, matrixSize, modeMessage) {\n            let center = Integer.truncDivision(matrixSize, 2);\n            if (compact) {\n                for (let i /*int*/ = 0; i < 7; i++) {\n                    let offset = center - 3 + i;\n                    if (modeMessage.get(i)) {\n                        matrix.set(offset, center - 5);\n                    }\n                    if (modeMessage.get(i + 7)) {\n                        matrix.set(center + 5, offset);\n                    }\n                    if (modeMessage.get(20 - i)) {\n                        matrix.set(offset, center + 5);\n                    }\n                    if (modeMessage.get(27 - i)) {\n                        matrix.set(center - 5, offset);\n                    }\n                }\n            }\n            else {\n                for (let i /*int*/ = 0; i < 10; i++) {\n                    let offset = center - 5 + i + Integer.truncDivision(i, 5);\n                    if (modeMessage.get(i)) {\n                        matrix.set(offset, center - 7);\n                    }\n                    if (modeMessage.get(i + 10)) {\n                        matrix.set(center + 7, offset);\n                    }\n                    if (modeMessage.get(29 - i)) {\n                        matrix.set(offset, center + 7);\n                    }\n                    if (modeMessage.get(39 - i)) {\n                        matrix.set(center - 7, offset);\n                    }\n                }\n            }\n        }\n        static generateCheckWords(bitArray, totalBits, wordSize) {\n            // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed\n            let messageSizeInWords = bitArray.getSize() / wordSize;\n            let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));\n            let totalWords = Integer.truncDivision(totalBits, wordSize);\n            let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);\n            rs.encode(messageWords, totalWords - messageSizeInWords);\n            let startPad = totalBits % wordSize;\n            let messageBits = new BitArray();\n            messageBits.appendBits(0, startPad);\n            for (const messageWord /*: int*/ of Array.from(messageWords)) {\n                messageBits.appendBits(messageWord, wordSize);\n            }\n            return messageBits;\n        }\n        static bitsToWords(stuffedBits, wordSize, totalWords) {\n            let message = new Int32Array(totalWords);\n            let i;\n            let n;\n            for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {\n                let value = 0;\n                for (let j /*int*/ = 0; j < wordSize; j++) {\n                    value |= stuffedBits.get(i * wordSize + j) ? (1 << wordSize - j - 1) : 0;\n                }\n                message[i] = value;\n            }\n            return message;\n        }\n        static getGF(wordSize) {\n            switch (wordSize) {\n                case 4:\n                    return GenericGF.AZTEC_PARAM;\n                case 6:\n                    return GenericGF.AZTEC_DATA_6;\n                case 8:\n                    return GenericGF.AZTEC_DATA_8;\n                case 10:\n                    return GenericGF.AZTEC_DATA_10;\n                case 12:\n                    return GenericGF.AZTEC_DATA_12;\n                default:\n                    throw new IllegalArgumentException('Unsupported word size ' + wordSize);\n            }\n        }\n        static stuffBits(bits, wordSize) {\n            let out = new BitArray();\n            let n = bits.getSize();\n            let mask = (1 << wordSize) - 2;\n            for (let i /*int*/ = 0; i < n; i += wordSize) {\n                let word = 0;\n                for (let j /*int*/ = 0; j < wordSize; j++) {\n                    if (i + j >= n || bits.get(i + j)) {\n                        word |= 1 << (wordSize - 1 - j);\n                    }\n                }\n                if ((word & mask) === mask) {\n                    out.appendBits(word & mask, wordSize);\n                    i--;\n                }\n                else if ((word & mask) === 0) {\n                    out.appendBits(word | 1, wordSize);\n                    i--;\n                }\n                else {\n                    out.appendBits(word, wordSize);\n                }\n            }\n            return out;\n        }\n        static totalBitsInLayer(layers, compact) {\n            return ((compact ? 88 : 112) + 16 * layers) * layers;\n        }\n    }\n    Encoder$1.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words\n    Encoder$1.DEFAULT_AZTEC_LAYERS = 0;\n    Encoder$1.MAX_NB_BITS = 32;\n    Encoder$1.MAX_NB_BITS_COMPACT = 4;\n    Encoder$1.WORD_SIZE = Int32Array.from([\n        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n        12, 12, 12, 12, 12, 12, 12, 12, 12, 12\n    ]);\n\n    /*\n    * Copyright 2013 ZXing authors\n    *\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    *      http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    */\n    /**\n     * Renders an Aztec code as a {@link BitMatrix}.\n     */\n    /*public final*/ class AztecWriter {\n        // @Override\n        encode(contents, format, width, height) {\n            return this.encodeWithHints(contents, format, width, height, null);\n        }\n        // @Override\n        encodeWithHints(contents, format, width, height, hints) {\n            let charset = StandardCharsets.ISO_8859_1;\n            let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;\n            let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;\n            if (hints != null) {\n                if (hints.has(EncodeHintType$1.CHARACTER_SET)) {\n                    charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());\n                }\n                if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {\n                    eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());\n                }\n                if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {\n                    layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());\n                }\n            }\n            return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);\n        }\n        static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {\n            if (format !== BarcodeFormat$1.AZTEC) {\n                throw new IllegalArgumentException('Can only encode AZTEC, but got ' + format);\n            }\n            let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);\n            return AztecWriter.renderResult(aztec, width, height);\n        }\n        static renderResult(code, width, height) {\n            let input = code.getMatrix();\n            if (input == null) {\n                throw new IllegalStateException();\n            }\n            let inputWidth = input.getWidth();\n            let inputHeight = input.getHeight();\n            let outputWidth = Math.max(width, inputWidth);\n            let outputHeight = Math.max(height, inputHeight);\n            let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);\n            let leftPadding = (outputWidth - (inputWidth * multiple)) / 2;\n            let topPadding = (outputHeight - (inputHeight * multiple)) / 2;\n            let output = new BitMatrix(outputWidth, outputHeight);\n            for (let inputY /*int*/ = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n                // Write the contents of this row of the barcode\n                for (let inputX /*int*/ = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n                    if (input.get(inputX, inputY)) {\n                        output.setRegion(outputX, outputY, multiple, multiple);\n                    }\n                }\n            }\n            return output;\n        }\n    }\n\n    exports.AbstractExpandedDecoder = AbstractExpandedDecoder;\n    exports.ArgumentException = ArgumentException;\n    exports.ArithmeticException = ArithmeticException;\n    exports.AztecCode = AztecCode;\n    exports.AztecCodeReader = AztecReader;\n    exports.AztecCodeWriter = AztecWriter;\n    exports.AztecDecoder = Decoder;\n    exports.AztecDetector = Detector;\n    exports.AztecDetectorResult = AztecDetectorResult;\n    exports.AztecEncoder = Encoder$1;\n    exports.AztecHighLevelEncoder = HighLevelEncoder;\n    exports.AztecPoint = Point;\n    exports.BarcodeFormat = BarcodeFormat$1;\n    exports.Binarizer = Binarizer;\n    exports.BinaryBitmap = BinaryBitmap;\n    exports.BitArray = BitArray;\n    exports.BitMatrix = BitMatrix;\n    exports.BitSource = BitSource;\n    exports.BrowserAztecCodeReader = BrowserAztecCodeReader;\n    exports.BrowserBarcodeReader = BrowserBarcodeReader;\n    exports.BrowserCodeReader = BrowserCodeReader;\n    exports.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;\n    exports.BrowserMultiFormatReader = BrowserMultiFormatReader;\n    exports.BrowserPDF417Reader = BrowserPDF417Reader;\n    exports.BrowserQRCodeReader = BrowserQRCodeReader;\n    exports.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;\n    exports.CharacterSetECI = CharacterSetECI;\n    exports.ChecksumException = ChecksumException;\n    exports.Code128Reader = Code128Reader;\n    exports.Code39Reader = Code39Reader;\n    exports.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;\n    exports.DataMatrixReader = DataMatrixReader;\n    exports.DecodeHintType = DecodeHintType$1;\n    exports.DecoderResult = DecoderResult;\n    exports.DefaultGridSampler = DefaultGridSampler;\n    exports.DetectorResult = DetectorResult;\n    exports.EAN13Reader = EAN13Reader;\n    exports.EncodeHintType = EncodeHintType$1;\n    exports.Exception = Exception;\n    exports.FormatException = FormatException;\n    exports.GenericGF = GenericGF;\n    exports.GenericGFPoly = GenericGFPoly;\n    exports.GlobalHistogramBinarizer = GlobalHistogramBinarizer;\n    exports.GridSampler = GridSampler;\n    exports.GridSamplerInstance = GridSamplerInstance;\n    exports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;\n    exports.HybridBinarizer = HybridBinarizer;\n    exports.ITFReader = ITFReader;\n    exports.IllegalArgumentException = IllegalArgumentException;\n    exports.IllegalStateException = IllegalStateException;\n    exports.InvertedLuminanceSource = InvertedLuminanceSource;\n    exports.LuminanceSource = LuminanceSource;\n    exports.MathUtils = MathUtils;\n    exports.MultiFormatOneDReader = MultiFormatOneDReader;\n    exports.MultiFormatReader = MultiFormatReader;\n    exports.MultiFormatWriter = MultiFormatWriter;\n    exports.NotFoundException = NotFoundException;\n    exports.OneDReader = OneDReader;\n    exports.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;\n    exports.PDF417DecoderErrorCorrection = ErrorCorrection;\n    exports.PDF417Reader = PDF417Reader;\n    exports.PDF417ResultMetadata = PDF417ResultMetadata;\n    exports.PerspectiveTransform = PerspectiveTransform;\n    exports.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;\n    exports.QRCodeByteMatrix = ByteMatrix;\n    exports.QRCodeDataMask = DataMask;\n    exports.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;\n    exports.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;\n    exports.QRCodeDecoderFormatInformation = FormatInformation;\n    exports.QRCodeEncoder = Encoder;\n    exports.QRCodeEncoderQRCode = QRCode;\n    exports.QRCodeMaskUtil = MaskUtil;\n    exports.QRCodeMatrixUtil = MatrixUtil;\n    exports.QRCodeMode = Mode$1;\n    exports.QRCodeReader = QRCodeReader;\n    exports.QRCodeVersion = Version$1;\n    exports.QRCodeWriter = QRCodeWriter;\n    exports.RGBLuminanceSource = RGBLuminanceSource;\n    exports.RSS14Reader = RSS14Reader;\n    exports.RSSExpandedReader = RSSExpandedReader;\n    exports.ReaderException = ReaderException;\n    exports.ReedSolomonDecoder = ReedSolomonDecoder;\n    exports.ReedSolomonEncoder = ReedSolomonEncoder;\n    exports.ReedSolomonException = ReedSolomonException;\n    exports.Result = Result;\n    exports.ResultMetadataType = ResultMetadataType$1;\n    exports.ResultPoint = ResultPoint;\n    exports.StringUtils = StringUtils;\n    exports.UnsupportedOperationException = UnsupportedOperationException;\n    exports.VideoInputDevice = VideoInputDevice;\n    exports.WhiteRectangleDetector = WhiteRectangleDetector;\n    exports.WriterException = WriterException;\n    exports.ZXingArrays = Arrays;\n    exports.ZXingCharset = Charset;\n    exports.ZXingInteger = Integer;\n    exports.ZXingStandardCharsets = StandardCharsets;\n    exports.ZXingStringBuilder = StringBuilder;\n    exports.ZXingStringEncoding = StringEncoding;\n    exports.ZXingSystem = System;\n    exports.createAbstractExpandedDecoder = createDecoder;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWw1LXFyY29kZS90aGlyZF9wYXJ0eS96eGluZy1qcy51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbDUtcXJjb2RlL3RoaXJkX3BhcnR5L3p4aW5nLWpzLnVtZC5qcz84ZTA5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuWlhpbmcgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4UHJvdG8odGFyZ2V0LCBwcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuICAgICAgICBzZXRQcm90b3R5cGVPZiA/IHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG90eXBlKSA6ICh0YXJnZXQuX19wcm90b19fID0gcHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuKSB7XG4gICAgICAgIGlmIChmbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmbiA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIEN1c3RvbUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEN1c3RvbUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCAnbmFtZScsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogX25ld1RhcmdldC5uYW1lLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpeFByb3RvKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmaXhTdGFjayhfdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBDdXN0b21FcnJvcjtcbiAgICB9KShFcnJvcik7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgRXhjZXB0aW9uIGV4dGVuZHMgQ3VzdG9tRXJyb3Ige1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIEV4Y2VwdGlvbiB0byBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseVxuICAgICAgICAgKiB3aXRoIHNvbWUgbWVzc2FnZSBhbmQgcHJvdG90eXBlIGRlZmluaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0S2luZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBleC5raW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0J3MgdHlwZWQgYXMgc3RyaW5nIHNvIGl0IGNhbiBiZSBleHRlbmRlZCBhbmQgb3ZlcnJpZGVuLlxuICAgICAqL1xuICAgIEV4Y2VwdGlvbi5raW5kID0gJ0V4Y2VwdGlvbic7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgQXJndW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBBcmd1bWVudEV4Y2VwdGlvbi5raW5kID0gJ0FyZ3VtZW50RXhjZXB0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24ua2luZCA9ICdJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICBjbGFzcyBCaW5hcnlCaXRtYXAge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaW5hcml6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJpemVyID0gYmluYXJpemVyO1xuICAgICAgICAgICAgaWYgKGJpbmFyaXplciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0JpbmFyaXplciBtdXN0IGJlIG5vbi1udWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgYml0bWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBUaGUgaGVpZ2h0IG9mIHRoZSBiaXRtYXAuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIG9uZSByb3cgb2YgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQgZGF0YS4gTWF5IGFjdHVhbGx5IGRvIHRoZSBjb252ZXJzaW9uLCBvciByZXR1cm5cbiAgICAgICAgICogY2FjaGVkIGRhdGEuIENhbGxlcnMgc2hvdWxkIGFzc3VtZSB0aGlzIG1ldGhvZCBpcyBleHBlbnNpdmUgYW5kIGNhbGwgaXQgYXMgc2VsZG9tIGFzIHBvc3NpYmxlLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZGVjb2RpbmcgMUQgYmFyY29kZXMgYW5kIG1heSBjaG9vc2UgdG8gYXBwbHkgc2hhcnBlbmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHkgVGhlIHJvdyB0byBmZXRjaCwgd2hpY2ggbXVzdCBiZSBpbiBbMCwgYml0bWFwIGhlaWdodClcbiAgICAgICAgICogQHBhcmFtIHJvdyBBbiBvcHRpb25hbCBwcmVhbGxvY2F0ZWQgYXJyYXkuIElmIG51bGwgb3IgdG9vIHNtYWxsLCBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgICAqICAgICAgICAgICAgSWYgdXNlZCwgdGhlIEJpbmFyaXplciB3aWxsIGNhbGwgQml0QXJyYXkuY2xlYXIoKS4gQWx3YXlzIHVzZSB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBhcnJheSBvZiBiaXRzIGZvciB0aGlzIHJvdyAodHJ1ZSBtZWFucyBibGFjaykuXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgcm93IGNhbid0IGJlIGJpbmFyaXplZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmxhY2tSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRCbGFja1Jvdyh5LCByb3cpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIDJEIGFycmF5IG9mIGx1bWluYW5jZSBkYXRhIHRvIDEgYml0LiBBcyBhYm92ZSwgYXNzdW1lIHRoaXMgbWV0aG9kIGlzIGV4cGVuc2l2ZVxuICAgICAgICAgKiBhbmQgZG8gbm90IGNhbGwgaXQgcmVwZWF0ZWRseS4gVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGRlY29kaW5nIDJEIGJhcmNvZGVzIGFuZCBtYXkgb3JcbiAgICAgICAgICogbWF5IG5vdCBhcHBseSBzaGFycGVuaW5nLiBUaGVyZWZvcmUsIGEgcm93IGZyb20gdGhpcyBtYXRyaXggbWF5IG5vdCBiZSBpZGVudGljYWwgdG8gb25lXG4gICAgICAgICAqIGZldGNoZWQgdXNpbmcgZ2V0QmxhY2tSb3coKSwgc28gZG9uJ3QgbWl4IGFuZCBtYXRjaCBiZXR3ZWVuIHRoZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIDJEIGFycmF5IG9mIGJpdHMgZm9yIHRoZSBpbWFnZSAodHJ1ZSBtZWFucyBibGFjaykuXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgaW1hZ2UgY2FuJ3QgYmUgYmluYXJpemVkIHRvIG1ha2UgYSBtYXRyaXhcbiAgICAgICAgICovXG4gICAgICAgIGdldEJsYWNrTWF0cml4KCkge1xuICAgICAgICAgICAgLy8gVGhlIG1hdHJpeCBpcyBjcmVhdGVkIG9uIGRlbWFuZCB0aGUgZmlyc3QgdGltZSBpdCBpcyByZXF1ZXN0ZWQsIHRoZW4gY2FjaGVkLiBUaGVyZSBhcmUgdHdvXG4gICAgICAgICAgICAvLyByZWFzb25zIGZvciB0aGlzOlxuICAgICAgICAgICAgLy8gMS4gVGhpcyB3b3JrIHdpbGwgbmV2ZXIgYmUgZG9uZSBpZiB0aGUgY2FsbGVyIG9ubHkgaW5zdGFsbHMgMUQgUmVhZGVyIG9iamVjdHMsIG9yIGlmIGFcbiAgICAgICAgICAgIC8vICAgIDFEIFJlYWRlciBmaW5kcyBhIGJhcmNvZGUgYmVmb3JlIHRoZSAyRCBSZWFkZXJzIHJ1bi5cbiAgICAgICAgICAgIC8vIDIuIFRoaXMgd29yayB3aWxsIG9ubHkgYmUgZG9uZSBvbmNlIGV2ZW4gaWYgdGhlIGNhbGxlciBpbnN0YWxscyBtdWx0aXBsZSAyRCBSZWFkZXJzLlxuICAgICAgICAgICAgaWYgKHRoaXMubWF0cml4ID09PSBudWxsIHx8IHRoaXMubWF0cml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeCA9IHRoaXMuYmluYXJpemVyLmdldEJsYWNrTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIGJpdG1hcCBjYW4gYmUgY3JvcHBlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlzQ3JvcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5pc0Nyb3BTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBjcm9wcGVkIGltYWdlIGRhdGEuIEltcGxlbWVudGF0aW9ucyBtYXkga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICogb3JpZ2luYWwgZGF0YSByYXRoZXIgdGhhbiBhIGNvcHkuIE9ubHkgY2FsbGFibGUgaWYgaXNDcm9wU3VwcG9ydGVkKCkgaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRXaWR0aCgpKVxuICAgICAgICAgKiBAcGFyYW0gdG9wIFRoZSB0b3AgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRIZWlnaHQoKSlcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEByZXR1cm4gQSBjcm9wcGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTb3VyY2UgPSB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5jcm9wKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIGJpdG1hcCBzdXBwb3J0cyBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzUm90YXRlU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmlzUm90YXRlU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDkwIGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U291cmNlID0gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlCaXRtYXAodGhpcy5iaW5hcml6ZXIuY3JlYXRlQmluYXJpemVyKG5ld1NvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA0NSBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXG4gICAgICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U291cmNlID0gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxhY2tNYXRyaXgoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUgLyo6IE5vdEZvdW5kRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgQ2hlY2tzdW1FeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgICAgICBzdGF0aWMgZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDaGVja3N1bUV4Y2VwdGlvbi5raW5kID0gJ0NoZWNrc3VtRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBoaWVyYXJjaHkgcHJvdmlkZXMgYSBzZXQgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGx1bWluYW5jZSBkYXRhIHRvIDEgYml0IGRhdGEuXG4gICAgICogSXQgYWxsb3dzIHRoZSBhbGdvcml0aG0gdG8gdmFyeSBwb2x5bW9ycGhpY2FsbHksIGZvciBleGFtcGxlIGFsbG93aW5nIGEgdmVyeSBleHBlbnNpdmVcbiAgICAgKiB0aHJlc2hvbGRpbmcgdGVjaG5pcXVlIGZvciBzZXJ2ZXJzIGFuZCBhIGZhc3Qgb25lIGZvciBtb2JpbGUuIEl0IGFsc28gcGVybWl0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiB0byB2YXJ5LCBlLmcuIGEgSk5JIHZlcnNpb24gZm9yIEFuZHJvaWQgYW5kIGEgSmF2YSBmYWxsYmFjayB2ZXJzaW9uIGZvciBvdGhlciBwbGF0Zm9ybXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEJpbmFyaXplciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0THVtaW5hbmNlU291cmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldFdpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldEhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgU3lzdGVtIHtcbiAgICAgICAgLy8gcHVibGljIHN0YXRpYyB2b2lkIGFycmF5Y29weShPYmplY3Qgc3JjLCBpbnQgc3JjUG9zLCBPYmplY3QgZGVzdCwgaW50IGRlc3RQb3MsIGludCBsZW5ndGgpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhIGNvcHkgb2YgYSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcnJheWNvcHkoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVE9ETzogYmV0dGVyIHVzZSBzcGxpdCBvciBzZXQ/XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGN1cnJlbnRUaW1lTWlsbGlzKCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ua2luZCA9ICdJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uJztcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gZXh0ZW5kcyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5kZXggPSB1bmRlZmluZWQsIG1lc3NhZ2UgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ua2luZCA9ICdBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nO1xuXG4gICAgY2xhc3MgQXJyYXlzIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXlcbiAgICAgICAgICogb2YgaW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxuICAgICAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSB0byBiZSBzdG9yZWQgaW4gYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbGwoYSwgdmFsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBhW2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ25zIHRoZSBzcGVjaWZpZWQgaW50IHZhbHVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIHJhbmdlIG9mIHRoZSBzcGVjaWZpZWQgYXJyYXkgb2YgaW50cy4gIFRoZSByYW5nZSB0byBiZSBmaWxsZWRcbiAgICAgICAgICogZXh0ZW5kcyBmcm9tIGluZGV4IHtAY29kZSBmcm9tSW5kZXh9LCBpbmNsdXNpdmUsIHRvIGluZGV4XG4gICAgICAgICAqIHtAY29kZSB0b0luZGV4fSwgZXhjbHVzaXZlLiAgKElmIHtAY29kZSBmcm9tSW5kZXg9PXRvSW5kZXh9LCB0aGVcbiAgICAgICAgICogcmFuZ2UgdG8gYmUgZmlsbGVkIGlzIGVtcHR5LilcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxuICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCAoaW5jbHVzaXZlKSB0byBiZVxuICAgICAgICAgKiAgICAgICAgZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gdG9JbmRleCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCAoZXhjbHVzaXZlKSB0byBiZVxuICAgICAgICAgKiAgICAgICAgZmlsbGVkIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gdmFsIHRoZSB2YWx1ZSB0byBiZSBzdG9yZWQgaW4gYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICAgICAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiB7QGNvZGUgZnJvbUluZGV4ID4gdG9JbmRleH1cbiAgICAgICAgICogQHRocm93cyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gaWYge0Bjb2RlIGZyb21JbmRleCA8IDB9IG9yXG4gICAgICAgICAqICAgICAgICAge0Bjb2RlIHRvSW5kZXggPiBhLmxlbmd0aH1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaWxsV2l0aGluKGEsIGZyb21JbmRleCwgdG9JbmRleCwgdmFsKSB7XG4gICAgICAgICAgICBBcnJheXMucmFuZ2VDaGVjayhhLmxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPCB0b0luZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgYVtpXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHRoYXQge0Bjb2RlIGZyb21JbmRleH0gYW5kIHtAY29kZSB0b0luZGV4fSBhcmUgaW5cbiAgICAgICAgICogdGhlIHJhbmdlIGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZXkgYXJlbid0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJhbmdlQ2hlY2soYXJyYXlMZW5ndGgsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICAgICAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdmcm9tSW5kZXgoJyArIGZyb21JbmRleCArICcpID4gdG9JbmRleCgnICsgdG9JbmRleCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oZnJvbUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0luZGV4ID4gYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uKHRvSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhc0xpc3QoLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNyZWF0ZShyb3dzLCBjb2xzLCB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGFyciA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHJvd3MgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcCh4ID0+IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSkuZmlsbCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjcmVhdGVJbnQzMkFycmF5KHJvd3MsIGNvbHMsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgYXJyID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogcm93cyB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKHggPT4gSW50MzJBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2xzIH0pLmZpbGwodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZXF1YWxzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlY29uZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmlyc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWNvbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBmaXJzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFtpXSAhPT0gc2Vjb25kW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaGFzaENvZGUoYSkge1xuICAgICAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAxO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAzMSAqIHJlc3VsdCArIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmaWxsVWludDhBcnJheShhLCB2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvcHlPZihvcmlnaW5hbCwgbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuc2xpY2UoMCwgbmV3TGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY29weU9mVWludDhBcnJheShvcmlnaW5hbCwgbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoIDw9IG5ld0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuZXdBcnJheS5zZXQob3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5zbGljZSgwLCBuZXdMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjb3B5T2ZSYW5nZShvcmlnaW5hbCwgZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgSW50MzJBcnJheShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShvcmlnaW5hbCwgZnJvbSwgY29weSwgMCwgbmV3TGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2Ygb2YgdGhlIGVsZW1lbnQgaW4gYSBzb3J0ZWQgYXJyYXkgb3IgKC1uLTEpIHdoZXJlIG4gaXMgdGhlIGluc2VydGlvbiBwb2ludFxuICAgICAgICAqIGZvciB0aGUgbmV3IGVsZW1lbnQuXG4gICAgICAgICogUGFyYW1ldGVyczpcbiAgICAgICAgKiAgICAgYXIgLSBBIHNvcnRlZCBhcnJheVxuICAgICAgICAqICAgICBlbCAtIEFuIGVsZW1lbnQgdG8gc2VhcmNoIGZvclxuICAgICAgICAqICAgICBjb21wYXJhdG9yIC0gQSBjb21wYXJhdG9yIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gdGFrZXMgdHdvIGFyZ3VtZW50czogKGEsIGIpIGFuZCByZXR1cm5zOlxuICAgICAgICAqICAgICAgICBhIG5lZ2F0aXZlIG51bWJlciAgaWYgYSBpcyBsZXNzIHRoYW4gYjtcbiAgICAgICAgKiAgICAgICAgMCBpZiBhIGlzIGVxdWFsIHRvIGI7XG4gICAgICAgICogICAgICAgIGEgcG9zaXRpdmUgbnVtYmVyIG9mIGEgaXMgZ3JlYXRlciB0aGFuIGIuXG4gICAgICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2F0ZSBlbGVtZW50cy4gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgZXF1YWwgZWxlbWVudHMgaW4gdGhlIGFycmF5LFxuICAgICAgICAqIHRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgdGhlIGluZGV4IG9mIGFueSBvbmUgb2YgdGhlIGVxdWFsIGVsZW1lbnRzLlxuICAgICAgICAqXG4gICAgICAgICogaHR0cDovL2pzZmlkZGxlLm5ldC9hcnl6aG92L3BrZnN0NTUwL1xuICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYmluYXJ5U2VhcmNoKGFyLCBlbCwgY29tcGFyYXRvcikge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IgPSBBcnJheXMubnVtYmVyQ29tcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtID0gMDtcbiAgICAgICAgICAgIGxldCBuID0gYXIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChtIDw9IG4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gKG4gKyBtKSA+PiAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoZWwsIGFyW2tdKTtcbiAgICAgICAgICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtID0gayArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IGsgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC1tIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbnVtYmVyQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb255ZmlsbCBmb3IgSmF2YSdzIEludGVnZXIgY2xhc3MuXG4gICAgICovXG4gICAgY2xhc3MgSW50ZWdlciB7XG4gICAgICAgIHN0YXRpYyBudW1iZXJPZlRyYWlsaW5nWmVyb3MoaSkge1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgICAgICBsZXQgbiA9IDMxO1xuICAgICAgICAgICAgeSA9IGkgPDwgMTY7XG4gICAgICAgICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG4gLT0gMTY7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gaSA8PCA4O1xuICAgICAgICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBuIC09IDg7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gaSA8PCA0O1xuICAgICAgICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBuIC09IDQ7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ID0gaSA8PCAyO1xuICAgICAgICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBuIC09IDI7XG4gICAgICAgICAgICAgICAgaSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbiAtICgoaSA8PCAxKSA+Pj4gMzEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBudW1iZXJPZkxlYWRpbmdaZXJvcyhpKSB7XG4gICAgICAgICAgICAvLyBIRCwgRmlndXJlIDUtNlxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbiA9IDE7XG4gICAgICAgICAgICBpZiAoaSA+Pj4gMTYgPT09IDApIHtcbiAgICAgICAgICAgICAgICBuICs9IDE2O1xuICAgICAgICAgICAgICAgIGkgPDw9IDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj4+IDI0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbiArPSA4O1xuICAgICAgICAgICAgICAgIGkgPDw9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+Pj4gMjggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuICs9IDQ7XG4gICAgICAgICAgICAgICAgaSA8PD0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4+PiAzMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG4gKz0gMjtcbiAgICAgICAgICAgICAgICBpIDw8PSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiAtPSBpID4+PiAzMTtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b0hleFN0cmluZyhpKSB7XG4gICAgICAgICAgICByZXR1cm4gaS50b1N0cmluZygxNik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvQmluYXJ5U3RyaW5nKGludE51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJzZUludChTdHJpbmcoaW50TnVtYmVyKSwgMikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBvbmUtYml0cyBpbiB0aGUgdHdvJ3MgY29tcGxlbWVudCBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUuIFRoaXMgZnVuY3Rpb24gaXMgc29tZXRpbWVzIHJlZmVycmVkIHRvIGFzIHRoZSBwb3B1bGF0aW9uIGNvdW50LlxuICAgICAgICAvLyBSZXR1cm5zOlxuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIG9uZS1iaXRzIGluIHRoZSB0d28ncyBjb21wbGVtZW50IGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGludCB2YWx1ZS5cbiAgICAgICAgc3RhdGljIGJpdENvdW50KGkpIHtcbiAgICAgICAgICAgIC8vIEhELCBGaWd1cmUgNS0yXG4gICAgICAgICAgICBpID0gaSAtICgoaSA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgICAgICAgICAgIGkgPSAoaSAmIDB4MzMzMzMzMzMpICsgKChpID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICAgICAgICAgICAgaSA9IChpICsgKGkgPj4+IDQpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgICAgICBpID0gaSArIChpID4+PiA4KTtcbiAgICAgICAgICAgIGkgPSBpICsgKGkgPj4+IDE2KTtcbiAgICAgICAgICAgIHJldHVybiBpICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgdHJ1bmNEaXZpc2lvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMoZGl2aWRlbmQgLyBkaXZpc29yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgQSBzdHJpbmcgdG8gYW4gaW50ZWdlci5cbiAgICAgICAgICogQHBhcmFtIHMgQSBzdHJpbmcgdG8gY29udmVydCBpbnRvIGEgbnVtYmVyLlxuICAgICAgICAgKiBAcGFyYW0gcmFkaXggQSB2YWx1ZSBiZXR3ZWVuIDIgYW5kIDM2IHRoYXQgc3BlY2lmaWVzIHRoZSBiYXNlIG9mIHRoZSBudW1iZXIgaW4gbnVtU3RyaW5nLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzdXBwbGllZCwgc3RyaW5ncyB3aXRoIGEgcHJlZml4IG9mICcweCcgYXJlIGNvbnNpZGVyZWQgaGV4YWRlY2ltYWwuIEFsbCBvdGhlciBzdHJpbmdzIGFyZSBjb25zaWRlcmVkIGRlY2ltYWwuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGFyc2VJbnQobnVtLCByYWRpeCA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSwgcmFkaXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEludGVnZXIuTUlOX1ZBTFVFXzMyX0JJVFMgPSAtMjE0NzQ4MzY0ODtcbiAgICBJbnRlZ2VyLk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgLyoqXG4gICAgICogPHA+QSBzaW1wbGUsIGZhc3QgYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgY29tcGFjdGx5IGJ5IGFuIGFycmF5IG9mIGludHMgaW50ZXJuYWxseS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEJpdEFycmF5IC8qaW1wbGVtZW50cyBDbG9uZWFibGUqLyB7XG4gICAgICAgIC8vIEZvciB0ZXN0aW5nIG9ubHlcbiAgICAgICAgY29uc3RydWN0b3Ioc2l6ZSAvKmludCovLCBiaXRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYml0cyB8fCBudWxsID09PSBiaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IEJpdEFycmF5Lm1ha2VBcnJheShzaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGdldFNpemVJbkJ5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuc2l6ZSArIDcpIC8gOCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQ2FwYWNpdHkoc2l6ZSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IHRoaXMuYml0cy5sZW5ndGggKiAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0JpdHMgPSBCaXRBcnJheS5tYWtlQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmJpdHMsIDAsIG5ld0JpdHMsIDAsIHRoaXMuYml0cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpIGJpdCB0byBnZXRcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiBiaXQgaSBpcyBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldChpIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gJiAoMSA8PCAoaSAmIDB4MUYpKSkgIT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYml0IGkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpIGJpdCB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIHNldChpIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildIHw9IDEgPDwgKGkgJiAweDFGKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgYml0IGkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpIGJpdCB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZsaXAoaSAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSBePSAxIDw8IChpICYgMHgxRik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBmcm9tIGZpcnN0IGJpdCB0byBjaGVja1xuICAgICAgICAgKiBAcmV0dXJuIGluZGV4IG9mIGZpcnN0IGJpdCB0aGF0IGlzIHNldCwgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gaW5kZXgsIG9yIHNpemUgaWYgbm9uZSBhcmUgc2V0XG4gICAgICAgICAqICBhdCBvciBiZXlvbmQgdGhpcyBnaXZlbiBpbmRleFxuICAgICAgICAgKiBAc2VlICNnZXROZXh0VW5zZXQoaW50KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TmV4dFNldChmcm9tIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbSA+PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgbGV0IGJpdHNPZmZzZXQgPSBNYXRoLmZsb29yKGZyb20gLyAzMik7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJpdHMgPSBiaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3RcbiAgICAgICAgICAgIGN1cnJlbnRCaXRzICY9IH4oKDEgPDwgKGZyb20gJiAweDFGKSkgLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJpdHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRCaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Qml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoYml0c09mZnNldCAqIDMyKSArIEludGVnZXIubnVtYmVyT2ZUcmFpbGluZ1plcm9zKGN1cnJlbnRCaXRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPiBzaXplID8gc2l6ZSA6IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGZyb20gaW5kZXggdG8gc3RhcnQgbG9va2luZyBmb3IgdW5zZXQgYml0XG4gICAgICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCB1bnNldCBiaXQsIG9yIHtAY29kZSBzaXplfSBpZiBub25lIGFyZSB1bnNldCB1bnRpbCB0aGUgZW5kXG4gICAgICAgICAqIEBzZWUgI2dldE5leHRTZXQoaW50KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TmV4dFVuc2V0KGZyb20gLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgYml0c09mZnNldCA9IE1hdGguZmxvb3IoZnJvbSAvIDMyKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qml0cyA9IH5iaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3RcbiAgICAgICAgICAgIGN1cnJlbnRCaXRzICY9IH4oKDEgPDwgKGZyb20gJiAweDFGKSkgLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJpdHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRCaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Qml0cyA9IH5iaXRzW2JpdHNPZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGJpdHNPZmZzZXQgKiAzMikgKyBJbnRlZ2VyLm51bWJlck9mVHJhaWxpbmdaZXJvcyhjdXJyZW50Qml0cyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID4gc2l6ZSA/IHNpemUgOiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYSBibG9jayBvZiAzMiBiaXRzLCBzdGFydGluZyBhdCBiaXQgaS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGkgZmlyc3QgYml0IHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0gbmV3Qml0cyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBuZXh0IDMyIGJpdHMuIE5vdGUgYWdhaW4gdGhhdCB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0XG4gICAgICAgICAqIGNvcnJlc3BvbmRzIHRvIGJpdCBpLCB0aGUgbmV4dC1sZWFzdC1zaWduaWZpY2FudCB0byBpKzEsIGFuZCBzbyBvbi5cbiAgICAgICAgICovXG4gICAgICAgIHNldEJ1bGsoaSAvKmludCovLCBuZXdCaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildID0gbmV3Qml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhIHJhbmdlIG9mIGJpdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBvZiByYW5nZSwgaW5jbHVzaXZlLlxuICAgICAgICAgKiBAcGFyYW0gZW5kIGVuZCBvZiByYW5nZSwgZXhjbHVzaXZlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRSYW5nZShzdGFydCAvKmludCovLCBlbmQgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZC0tOyAvLyB3aWxsIGJlIGVhc2llciB0byB0cmVhdCB0aGlzIGFzIHRoZSBsYXN0IGFjdHVhbGx5IHNldCBiaXQgLS0gaW5jbHVzaXZlXG4gICAgICAgICAgICBjb25zdCBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW50ID0gTWF0aC5mbG9vcihlbmQgLyAzMik7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW50OyBpIDw9IGxhc3RJbnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qml0ID0gaSA+IGZpcnN0SW50ID8gMCA6IHN0YXJ0ICYgMHgxRjtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7XG4gICAgICAgICAgICAgICAgLy8gT25lcyBmcm9tIGZpcnN0Qml0IHRvIGxhc3RCaXQsIGluY2x1c2l2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMiA8PCBsYXN0Qml0KSAtICgxIDw8IGZpcnN0Qml0KTtcbiAgICAgICAgICAgICAgICBiaXRzW2ldIHw9IG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMuYml0cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJpdHNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnQgbWV0aG9kIHRvIGNoZWNrIGlmIGEgcmFuZ2Ugb2YgYml0cyBpcyBzZXQsIG9yIG5vdCBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBvZiByYW5nZSwgaW5jbHVzaXZlLlxuICAgICAgICAgKiBAcGFyYW0gZW5kIGVuZCBvZiByYW5nZSwgZXhjbHVzaXZlXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBpZiB0cnVlLCBjaGVja3MgdGhhdCBiaXRzIGluIHJhbmdlIGFyZSBzZXQsIG90aGVyd2lzZSBjaGVja3MgdGhhdCB0aGV5IGFyZSBub3Qgc2V0XG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGFsbCBiaXRzIGFyZSBzZXQgb3Igbm90IHNldCBpbiByYW5nZSwgYWNjb3JkaW5nIHRvIHZhbHVlIGFyZ3VtZW50XG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGVuZCBpcyBsZXNzIHRoYW4gc3RhcnQgb3IgdGhlIHJhbmdlIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBpc1JhbmdlKHN0YXJ0IC8qaW50Ki8sIGVuZCAvKmludCovLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSByYW5nZSBtYXRjaGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQtLTsgLy8gd2lsbCBiZSBlYXNpZXIgdG8gdHJlYXQgdGhpcyBhcyB0aGUgbGFzdCBhY3R1YWxseSBzZXQgYml0IC0tIGluY2x1c2l2ZVxuICAgICAgICAgICAgY29uc3QgZmlyc3RJbnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gMzIpO1xuICAgICAgICAgICAgY29uc3QgbGFzdEludCA9IE1hdGguZmxvb3IoZW5kIC8gMzIpO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmaXJzdEludDsgaSA8PSBsYXN0SW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJpdCA9IGkgPiBmaXJzdEludCA/IDAgOiBzdGFydCAmIDB4MUY7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEJpdCA9IGkgPCBsYXN0SW50ID8gMzEgOiBlbmQgJiAweDFGO1xuICAgICAgICAgICAgICAgIC8vIE9uZXMgZnJvbSBmaXJzdEJpdCB0byBsYXN0Qml0LCBpbmNsdXNpdmVcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDIgPDwgbGFzdEJpdCkgLSAoMSA8PCBmaXJzdEJpdCkgJiAweEZGRkZGRkZGO1xuICAgICAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiAmIDB4RkZGRkZGRkYgYWRkZWQgdG8gZGlzY2FyZCBhbnl0aGluZyBhZnRlciAzMiBiaXRzLCBhcyBFUyBoYXMgNTMgYml0c1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiB3ZSdyZSBsb29raW5nIGZvciAxcyBhbmQgdGhlIG1hc2tlZCBiaXRzW2ldIGlzbid0IGFsbCAxcyAoaXM6IHRoYXQsXG4gICAgICAgICAgICAgICAgLy8gZXF1YWxzIHRoZSBtYXNrLCBvciB3ZSdyZSBsb29raW5nIGZvciAwcyBhbmQgdGhlIG1hc2tlZCBwb3J0aW9uIGlzIG5vdCBhbGwgMHNcbiAgICAgICAgICAgICAgICBpZiAoKGJpdHNbaV0gJiBtYXNrKSAhPT0gKHZhbHVlID8gbWFzayA6IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRCaXQoYml0KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIDEpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKHRoaXMuc2l6ZSAvIDMyKV0gfD0gMSA8PCAodGhpcy5zaXplICYgMHgxRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kcyB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYml0cywgZnJvbSB2YWx1ZSwgaW4gb3JkZXIgZnJvbSBtb3N0LXNpZ25pZmljYW50IHRvXG4gICAgICAgICAqIGxlYXN0LXNpZ25pZmljYW50LiBGb3IgZXhhbXBsZSwgYXBwZW5kaW5nIDYgYml0cyBmcm9tIDB4MDAwMDAxRSB3aWxsIGFwcGVuZCB0aGUgYml0c1xuICAgICAgICAgKiAwLCAxLCAxLCAxLCAxLCAwIGluIHRoYXQgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB7QGNvZGUgaW50fSBjb250YWluaW5nIGJpdHMgdG8gYXBwZW5kXG4gICAgICAgICAqIEBwYXJhbSBudW1CaXRzIGJpdHMgZnJvbSB2YWx1ZSB0byBhcHBlbmRcbiAgICAgICAgICovXG4gICAgICAgIGFwcGVuZEJpdHModmFsdWUgLyppbnQqLywgbnVtQml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDAgfHwgbnVtQml0cyA+IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTnVtIGJpdHMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDMyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIG51bUJpdHMpO1xuICAgICAgICAgICAgLy8gY29uc3QgYXBwZW5kQml0ID0gdGhpcy5hcHBlbmRCaXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBudW1CaXRzTGVmdCA9IG51bUJpdHM7IG51bUJpdHNMZWZ0ID4gMDsgbnVtQml0c0xlZnQtLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQml0KCgodmFsdWUgPj4gKG51bUJpdHNMZWZ0IC0gMSkpICYgMHgwMSkgPT09IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGVuZEJpdEFycmF5KG90aGVyKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlclNpemUgPSBvdGhlci5zaXplO1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLnNpemUgKyBvdGhlclNpemUpO1xuICAgICAgICAgICAgLy8gY29uc3QgYXBwZW5kQml0ID0gdGhpcy5hcHBlbmRCaXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRCaXQob3RoZXIuZ2V0KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdTaXplcyBkb25cXCd0IG1hdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGJpdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBpbnQgY291bGQgYmUgaW5jb21wbGV0ZSAoaS5lLiBub3QgaGF2ZSAzMiBiaXRzIGluXG4gICAgICAgICAgICAgICAgLy8gaXQpIGJ1dCB0aGVyZSBpcyBubyBwcm9ibGVtIHNpbmNlIDAgWE9SIDAgPT0gMC5cbiAgICAgICAgICAgICAgICBiaXRzW2ldIF49IG90aGVyLmJpdHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRPZmZzZXQgZmlyc3QgYml0IHRvIHN0YXJ0IHdyaXRpbmdcbiAgICAgICAgICogQHBhcmFtIGFycmF5IGFycmF5IHRvIHdyaXRlIGludG8uIEJ5dGVzIGFyZSB3cml0dGVuIG1vc3Qtc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdC4gVGhpcyBpcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgICogIG9mIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiwgd2hpY2ggaXMgZXhwb3NlZCBieSB7QGxpbmsgI2dldEJpdEFycmF5KCl9XG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXQgcG9zaXRpb24gaW4gYXJyYXkgdG8gc3RhcnQgd3JpdGluZ1xuICAgICAgICAgKiBAcGFyYW0gbnVtQnl0ZXMgaG93IG1hbnkgYnl0ZXMgdG8gd3JpdGVcbiAgICAgICAgICovXG4gICAgICAgIHRvQnl0ZXMoYml0T2Zmc2V0IC8qaW50Ki8sIGFycmF5LCBvZmZzZXQgLyppbnQqLywgbnVtQnl0ZXMgLyppbnQqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1CeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRoZUJ5dGUgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChiaXRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVCeXRlIHw9IDEgPDwgKDcgLSBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiaXRPZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaV0gPSAvKihieXRlKSovIHRoZUJ5dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdW5kZXJseWluZyBhcnJheSBvZiBpbnRzLiBUaGUgZmlyc3QgZWxlbWVudCBob2xkcyB0aGUgZmlyc3QgMzIgYml0cywgYW5kIHRoZSBsZWFzdFxuICAgICAgICAgKiAgICAgICAgIHNpZ25pZmljYW50IGJpdCBpcyBiaXQgMC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJpdEFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV2ZXJzZXMgYWxsIGJpdHMgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0JpdHMgPSBuZXcgSW50MzJBcnJheSh0aGlzLmJpdHMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIHJldmVyc2UgYWxsIGludCdzIGZpcnN0XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLmZsb29yKCh0aGlzLnNpemUgLSAxKSAvIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEJpdHNMZW4gPSBsZW4gKyAxO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkQml0c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHggPSBiaXRzW2ldO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gMSkgJiAweDU1NTU1NTU1KSB8ICgoeCAmIDB4NTU1NTU1NTUpIDw8IDEpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gMikgJiAweDMzMzMzMzMzKSB8ICgoeCAmIDB4MzMzMzMzMzMpIDw8IDIpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gNCkgJiAweDBmMGYwZjBmKSB8ICgoeCAmIDB4MGYwZjBmMGYpIDw8IDQpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gOCkgJiAweDAwZmYwMGZmKSB8ICgoeCAmIDB4MDBmZjAwZmYpIDw8IDgpO1xuICAgICAgICAgICAgICAgIHggPSAoKHggPj4gMTYpICYgMHgwMDAwZmZmZikgfCAoKHggJiAweDAwMDBmZmZmKSA8PCAxNik7XG4gICAgICAgICAgICAgICAgbmV3Qml0c1tsZW4gLSBpXSA9IC8qKGludCkqLyB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IGNvcnJlY3QgdGhlIGludCdzIGlmIHRoZSBiaXQgc2l6ZSBpc24ndCBhIG11bHRpcGxlIG9mIDMyXG4gICAgICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvbGRCaXRzTGVuICogMzIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gb2xkQml0c0xlbiAqIDMyIC0gdGhpcy5zaXplO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50SW50ID0gbmV3Qml0c1swXSA+Pj4gbGVmdE9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9sZEJpdHNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW50ID0gbmV3Qml0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEludCB8PSBuZXh0SW50IDw8ICgzMiAtIGxlZnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBuZXdCaXRzW2kgLSAxXSA9IGN1cnJlbnRJbnQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnQgPSBuZXh0SW50ID4+PiBsZWZ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdCaXRzW29sZEJpdHNMZW4gLSAxXSA9IGN1cnJlbnRJbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXdCaXRzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtYWtlQXJyYXkoc2l6ZSAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoTWF0aC5mbG9vcigoc2l6ZSArIDMxKSAvIDMyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEJpdEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IG90aGVyLnNpemUgJiYgQXJyYXlzLmVxdWFscyh0aGlzLmJpdHMsIG90aGVyLmJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gMzEgKiB0aGlzLnNpemUgKyBBcnJheXMuaGFzaENvZGUodGhpcy5iaXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHNpemUgPSB0aGlzLnNpemU7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGkgJiAweDA3KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5nZXQoaSkgPyAnWCcgOiAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpdEFycmF5KHRoaXMuc2l6ZSwgdGhpcy5iaXRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRlcyBhIHR5cGUgb2YgaGludCB0aGF0IGEgY2FsbGVyIG1heSBwYXNzIHRvIGEgYmFyY29kZSByZWFkZXIgdG8gaGVscCBpdFxuICAgICAqIG1vcmUgcXVpY2tseSBvciBhY2N1cmF0ZWx5IGRlY29kZSBpdC4gSXQgaXMgdXAgdG8gaW1wbGVtZW50YXRpb25zIHRvIGRlY2lkZSB3aGF0LFxuICAgICAqIGlmIGFueXRoaW5nLCB0byBkbyB3aXRoIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHN1cHBsaWVkLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBzZWUgUmVhZGVyI2RlY29kZShCaW5hcnlCaXRtYXAsamF2YS51dGlsLk1hcClcbiAgICAgKi9cbiAgICB2YXIgRGVjb2RlSGludFR5cGU7XG4gICAgKGZ1bmN0aW9uIChEZWNvZGVIaW50VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5zcGVjaWZpZWQsIGFwcGxpY2F0aW9uLXNwZWNpZmljIGhpbnQuIE1hcHMgdG8gYW4gdW5zcGVjaWZpZWQge0BsaW5rIE9iamVjdH0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIk9USEVSXCJdID0gMF0gPSBcIk9USEVSXCI7IC8qKE9iamVjdC5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogSW1hZ2UgaXMgYSBwdXJlIG1vbm9jaHJvbWUgaW1hZ2Ugb2YgYSBiYXJjb2RlLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XG4gICAgICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiUFVSRV9CQVJDT0RFXCJdID0gMV0gPSBcIlBVUkVfQkFSQ09ERVwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbWFnZSBpcyBrbm93biB0byBiZSBvZiBvbmUgb2YgYSBmZXcgcG9zc2libGUgZm9ybWF0cy5cbiAgICAgICAgICogTWFwcyB0byBhIHtAbGluayBMaXN0fSBvZiB7QGxpbmsgQmFyY29kZUZvcm1hdH1zLlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJQT1NTSUJMRV9GT1JNQVRTXCJdID0gMl0gPSBcIlBPU1NJQkxFX0ZPUk1BVFNcIjsgLyooTGlzdC5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlbmQgbW9yZSB0aW1lIHRvIHRyeSB0byBmaW5kIGEgYmFyY29kZTsgb3B0aW1pemUgZm9yIGFjY3VyYWN5LCBub3Qgc3BlZWQuXG4gICAgICAgICAqIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bzsgdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJUUllfSEFSREVSXCJdID0gM10gPSBcIlRSWV9IQVJERVJcIjsgLyooVm9pZC5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoYXQgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZSB3aGVuIGRlY29kaW5nLCB3aGVyZSBhcHBsaWNhYmxlICh0eXBlIFN0cmluZylcbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQ0hBUkFDVEVSX1NFVFwiXSA9IDRdID0gXCJDSEFSQUNURVJfU0VUXCI7IC8qKFN0cmluZy5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dlZCBsZW5ndGhzIG9mIGVuY29kZWQgZGF0YSAtLSByZWplY3QgYW55dGhpbmcgZWxzZS4gTWFwcyB0byBhbiB7QGNvZGUgSW50MzJBcnJheX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkFMTE9XRURfTEVOR1RIU1wiXSA9IDVdID0gXCJBTExPV0VEX0xFTkdUSFNcIjsgLyooSW50MzJBcnJheS5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQXNzdW1lIENvZGUgMzkgY29kZXMgZW1wbG95IGEgY2hlY2sgZGlnaXQuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcbiAgICAgICAgICogdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxuICAgICAgICAgKi9cbiAgICAgICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJBU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVFwiXSA9IDZdID0gXCJBU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVFwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3N1bWUgdGhlIGJhcmNvZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGFzIGEgR1MxIGJhcmNvZGUsIGFuZCBtb2RpZnkgYmVoYXZpb3IgYXMgbmVlZGVkLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSB0aGlzIGFmZmVjdHMgRk5DMSBoYW5kbGluZyBmb3IgQ29kZSAxMjggKGFrYSBHUzEtMTI4KS4gRG9lc24ndCBtYXR0ZXIgd2hhdCBpdCBtYXBzIHRvO1xuICAgICAgICAgKiB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXG4gICAgICAgICAqL1xuICAgICAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkFTU1VNRV9HUzFcIl0gPSA3XSA9IFwiQVNTVU1FX0dTMVwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCByZXR1cm4gdGhlIHN0YXJ0IGFuZCBlbmQgZGlnaXRzIGluIGEgQ29kYWJhciBiYXJjb2RlIGluc3RlYWQgb2Ygc3RyaXBwaW5nIHRoZW0uIFRoZXlcbiAgICAgICAgICogYXJlIGFscGhhLCB3aGVyZWFzIHRoZSByZXN0IGFyZSBudW1lcmljLiBCeSBkZWZhdWx0LCB0aGV5IGFyZSBzdHJpcHBlZCwgYnV0IHRoaXMgY2F1c2VzIHRoZW1cbiAgICAgICAgICogdG8gbm90IGJlLiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87IHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiUkVUVVJOX0NPREFCQVJfU1RBUlRfRU5EXCJdID0gOF0gPSBcIlJFVFVSTl9DT0RBQkFSX1NUQVJUX0VORFwiOyAvKihWb2lkLmNsYXNzKSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FsbGVyIG5lZWRzIHRvIGJlIG5vdGlmaWVkIHZpYSBjYWxsYmFjayB3aGVuIGEgcG9zc2libGUge0BsaW5rIFJlc3VsdFBvaW50fVxuICAgICAgICAgKiBpcyBmb3VuZC4gTWFwcyB0byBhIHtAbGluayBSZXN1bHRQb2ludENhbGxiYWNrfS5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcIl0gPSA5XSA9IFwiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcIjsgLyooUmVzdWx0UG9pbnRDYWxsYmFjay5jbGFzcykqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dlZCBleHRlbnNpb24gbGVuZ3RocyBmb3IgRUFOIG9yIFVQQyBiYXJjb2Rlcy4gT3RoZXIgZm9ybWF0cyB3aWxsIGlnbm9yZSB0aGlzLlxuICAgICAgICAgKiBNYXBzIHRvIGFuIHtAY29kZSBJbnQzMkFycmF5fSBvZiB0aGUgYWxsb3dlZCBleHRlbnNpb24gbGVuZ3RocywgZm9yIGV4YW1wbGUgWzJdLCBbNV0sIG9yIFsyLCA1XS5cbiAgICAgICAgICogSWYgaXQgaXMgb3B0aW9uYWwgdG8gaGF2ZSBhbiBleHRlbnNpb24sIGRvIG5vdCBzZXQgdGhpcyBoaW50LiBJZiB0aGlzIGlzIHNldCxcbiAgICAgICAgICogYW5kIGEgVVBDIG9yIEVBTiBiYXJjb2RlIGlzIGZvdW5kIGJ1dCBhbiBleHRlbnNpb24gaXMgbm90LCB0aGVuIG5vIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkXG4gICAgICAgICAqIGF0IGFsbC5cbiAgICAgICAgICovXG4gICAgICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQUxMT1dFRF9FQU5fRVhURU5TSU9OU1wiXSA9IDEwXSA9IFwiQUxMT1dFRF9FQU5fRVhURU5TSU9OU1wiOyAvKihJbnQzMkFycmF5LmNsYXNzKSovXG4gICAgICAgIC8vIEVuZCBvZiBlbnVtZXJhdGlvbiB2YWx1ZXMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHR5cGUgdGhlIGhpbnQgaXMgZXhwZWN0aW5nLlxuICAgICAgICAgKiBBbW9uZyB0aGUgcG9zc2libGUgdmFsdWVzIHRoZSB7QGxpbmsgVm9pZH0gc3RhbmRzIG91dCBhcyBiZWluZyB1c2VkIGZvclxuICAgICAgICAgKiBoaW50cyB0aGF0IGRvIG5vdCBleHBlY3QgYSB2YWx1ZSB0byBiZSBzdXBwbGllZCAoZmxhZyBoaW50cykuIFN1Y2ggaGludHNcbiAgICAgICAgICogd2lsbCBwb3NzaWJseSBoYXZlIHRoZWlyIHZhbHVlIGlnbm9yZWQsIG9yIHJlcGxhY2VkIGJ5IGFcbiAgICAgICAgICoge0BsaW5rIEJvb2xlYW4jVFJVRX0uIEhpbnQgc3VwcGxpZXJzIHNob3VsZCBwcm9iYWJseSB1c2VcbiAgICAgICAgICoge0BsaW5rIEJvb2xlYW4jVFJVRX0gYXMgZGlyZWN0ZWQgYnkgdGhlIGFjdHVhbCBoaW50IGRvY3VtZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwcml2YXRlIHZhbHVlVHlwZTogQ2xhc3M8Pz5cbiAgICAgICAgLy8gRGVjb2RlSGludFR5cGUodmFsdWVUeXBlOiBDbGFzczw/Pikge1xuICAgICAgICAvLyAgIHRoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gcHVibGljIGdldFZhbHVlVHlwZSgpOiBDbGFzczw/PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIHZhbHVlVHlwZVxuICAgICAgICAvLyB9XG4gICAgfSkoRGVjb2RlSGludFR5cGUgfHwgKERlY29kZUhpbnRUeXBlID0ge30pKTtcbiAgICB2YXIgRGVjb2RlSGludFR5cGUkMSA9IERlY29kZUhpbnRUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIEZvcm1hdEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgICAgIHN0YXRpYyBnZXRGb3JtYXRJbnN0YW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRm9ybWF0RXhjZXB0aW9uLmtpbmQgPSAnRm9ybWF0RXhjZXB0aW9uJztcblxuICAgIC8qaW1wb3J0IGphdmEudXRpbC5IYXNoTWFwOyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIHZhciBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzO1xuICAgIChmdW5jdGlvbiAoQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycykge1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJDcDQzN1wiXSA9IDBdID0gXCJDcDQzN1wiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzFcIl0gPSAxXSA9IFwiSVNPODg1OV8xXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMlwiXSA9IDJdID0gXCJJU084ODU5XzJcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8zXCJdID0gM10gPSBcIklTTzg4NTlfM1wiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzRcIl0gPSA0XSA9IFwiSVNPODg1OV80XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfNVwiXSA9IDVdID0gXCJJU084ODU5XzVcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV82XCJdID0gNl0gPSBcIklTTzg4NTlfNlwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzdcIl0gPSA3XSA9IFwiSVNPODg1OV83XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfOFwiXSA9IDhdID0gXCJJU084ODU5XzhcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV85XCJdID0gOV0gPSBcIklTTzg4NTlfOVwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzEwXCJdID0gMTBdID0gXCJJU084ODU5XzEwXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTFcIl0gPSAxMV0gPSBcIklTTzg4NTlfMTFcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xM1wiXSA9IDEyXSA9IFwiSVNPODg1OV8xM1wiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJJU084ODU5XzE0XCJdID0gMTNdID0gXCJJU084ODU5XzE0XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIklTTzg4NTlfMTVcIl0gPSAxNF0gPSBcIklTTzg4NTlfMTVcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNlwiXSA9IDE1XSA9IFwiSVNPODg1OV8xNlwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJTSklTXCJdID0gMTZdID0gXCJTSklTXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MFwiXSA9IDE3XSA9IFwiQ3AxMjUwXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MVwiXSA9IDE4XSA9IFwiQ3AxMjUxXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MlwiXSA9IDE5XSA9IFwiQ3AxMjUyXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1NlwiXSA9IDIwXSA9IFwiQ3AxMjU2XCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIlVuaWNvZGVCaWdVbm1hcmtlZFwiXSA9IDIxXSA9IFwiVW5pY29kZUJpZ1VubWFya2VkXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIlVURjhcIl0gPSAyMl0gPSBcIlVURjhcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQVNDSUlcIl0gPSAyM10gPSBcIkFTQ0lJXCI7XG4gICAgICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkJpZzVcIl0gPSAyNF0gPSBcIkJpZzVcIjtcbiAgICAgICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiR0IxODAzMFwiXSA9IDI1XSA9IFwiR0IxODAzMFwiO1xuICAgICAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJFVUNfS1JcIl0gPSAyNl0gPSBcIkVVQ19LUlwiO1xuICAgIH0pKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgfHwgKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRlcyBhIENoYXJhY3RlciBTZXQgRUNJLCBhY2NvcmRpbmcgdG8gXCJFeHRlbmRlZCBDaGFubmVsIEludGVycHJldGF0aW9uc1wiIDUuMy4xLjFcbiAgICAgKiBvZiBJU08gMTgwMDQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIENoYXJhY3RlclNldEVDSSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlSWRlbnRpZmllciwgdmFsdWVzUGFyYW0sIG5hbWUsIC4uLm90aGVyRW5jb2RpbmdOYW1lcykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUlkZW50aWZpZXIgPSB2YWx1ZUlkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNQYXJhbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IEludDMyQXJyYXkuZnJvbShbdmFsdWVzUGFyYW1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzUGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lcztcbiAgICAgICAgICAgIENoYXJhY3RlclNldEVDSS5WQUxVRV9JREVOVElGSUVSX1RPX0VDSS5zZXQodmFsdWVJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgICAgICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSS5zZXQobmFtZSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFU19UT19FQ0kuc2V0KHYsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBvdGhlck5hbWUgb2Ygb3RoZXJFbmNvZGluZ05hbWVzKSB7XG4gICAgICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLnNldChvdGhlck5hbWUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoYXJhY3RlclNldEVDSSh2YWx1ZTogbnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgLy8gICB0aGlzKG5ldyBJbnQzMkFycmF5IHt2YWx1ZX0pXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlOiBudW1iZXIgLyppbnQqLywgU3RyaW5nLi4uIG90aGVyRW5jb2RpbmdOYW1lcykge1xuICAgICAgICAvLyAgIHRoaXMudmFsdWVzID0gbmV3IEludDMyQXJyYXkge3ZhbHVlfVxuICAgICAgICAvLyAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQ2hhcmFjdGVyU2V0RUNJKHZhbHVlczogSW50MzJBcnJheSwgU3RyaW5nLi4uIG90aGVyRW5jb2RpbmdOYW1lcykge1xuICAgICAgICAvLyAgIHRoaXMudmFsdWVzID0gdmFsdWVzXG4gICAgICAgIC8vICAgdGhpcy5vdGhlckVuY29kaW5nTmFtZXMgPSBvdGhlckVuY29kaW5nTmFtZXNcbiAgICAgICAgLy8gfVxuICAgICAgICBnZXRWYWx1ZUlkZW50aWZpZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBjaGFyYWN0ZXIgc2V0IEVDSSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHtAY29kZSBDaGFyYWN0ZXJTZXRFQ0l9IHJlcHJlc2VudGluZyBFQ0kgb2YgZ2l2ZW4gdmFsdWUsIG9yIG51bGwgaWYgaXQgaXMgbGVnYWwgYnV0XG4gICAgICAgICAqICAgdW5zdXBwb3J0ZWRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgRUNJIHZhbHVlIGlzIGludmFsaWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlKHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gOTAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbignaW5jb3JlY3QgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjaGFyYWN0ZXJTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCdpbmNvcmVjdCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYXJhY3RlclNldDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG5hbWUgY2hhcmFjdGVyIHNldCBFQ0kgZW5jb2RpbmcgbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIENoYXJhY3RlclNldEVDSSByZXByZXNlbnRpbmcgRUNJIGZvciBjaGFyYWN0ZXIgZW5jb2RpbmcsIG9yIG51bGwgaWYgaXQgaXMgbGVnYWxcbiAgICAgICAgICogICBidXQgdW5zdXBwb3J0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUobmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNoYXJhY3RlclNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oJ2luY29yZWN0IHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0O1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQ2hhcmFjdGVyU2V0RUNJKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5hbWUoKSA9PT0gb3RoZXIuZ2V0TmFtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENoYXJhY3RlclNldEVDSS5WQUxVRV9JREVOVElGSUVSX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSSA9IG5ldyBNYXAoKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuTkFNRV9UT19FQ0kgPSBuZXcgTWFwKCk7XG4gICAgLy8gRW51bSBuYW1lIGlzIGEgSmF2YSBlbmNvZGluZyB2YWxpZCBmb3IgamF2YS5sYW5nIGFuZCBqYXZhLmlvXG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoYW5nZWQgdGhlIG1haW4gbGFiZWwgZm9yIElTTyBhcyB0aGUgVGV4dEVuY29kZXIgZGlkIG5vdCByZWNvZ25pemVkIHRoZW0gaW4gdGhlIGZvcm0gZnJvbSBqYXZhXG4gICAgLy8gKGVnIElTTzg4NTlfMSBtdXN0IGJlIElTTzg4NTkxIG9yIElTTzg4NTktMSBvciBJU08tODg1OS0xKVxuICAgIC8vIGxhdGVyIG9uOiB3ZWxsLCBleGNlcHQgMTYgd2ljaCBkb2VzIG5vdCB3b3JrIHdpdGggSVNPODg1OTE2IHNvIHVzZWQgSVNPLTg4NTktMSBmb3JtIGZvciBkZWZhdWx0XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwNDM3ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwNDM3LCBJbnQzMkFycmF5LmZyb20oWzAsIDJdKSwgJ0NwNDM3Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEsIEludDMyQXJyYXkuZnJvbShbMSwgM10pLCAnSVNPLTg4NTktMScsICdJU084ODU5MScsICdJU084ODU5XzEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8yID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMiwgNCwgJ0lTTy04ODU5LTInLCAnSVNPODg1OTInLCAnSVNPODg1OV8yJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzMsIDUsICdJU08tODg1OS0zJywgJ0lTTzg4NTkzJywgJ0lTTzg4NTlfMycpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV80LCA2LCAnSVNPLTg4NTktNCcsICdJU084ODU5NCcsICdJU084ODU5XzQnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV81ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfNSwgNywgJ0lTTy04ODU5LTUnLCAnSVNPODg1OTUnLCAnSVNPODg1OV81Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzYsIDgsICdJU08tODg1OS02JywgJ0lTTzg4NTk2JywgJ0lTTzg4NTlfNicpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzcgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV83LCA5LCAnSVNPLTg4NTktNycsICdJU084ODU5NycsICdJU084ODU5XzcnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV84ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfOCwgMTAsICdJU08tODg1OS04JywgJ0lTTzg4NTk4JywgJ0lTTzg4NTlfOCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzkgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV85LCAxMSwgJ0lTTy04ODU5LTknLCAnSVNPODg1OTknLCAnSVNPODg1OV85Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xMCwgMTIsICdJU08tODg1OS0xMCcsICdJU084ODU5MTAnLCAnSVNPODg1OV8xMCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzExID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTEsIDEzLCAnSVNPLTg4NTktMTEnLCAnSVNPODg1OTExJywgJ0lTTzg4NTlfMTEnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEzLCAxNSwgJ0lTTy04ODU5LTEzJywgJ0lTTzg4NTkxMycsICdJU084ODU5XzEzJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTQgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV8xNCwgMTYsICdJU08tODg1OS0xNCcsICdJU084ODU5MTQnLCAnSVNPODg1OV8xNCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzE1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMTUsIDE3LCAnSVNPLTg4NTktMTUnLCAnSVNPODg1OTE1JywgJ0lTTzg4NTlfMTUnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE2LCAxOCwgJ0lTTy04ODU5LTE2JywgJ0lTTzg4NTkxNicsICdJU084ODU5XzE2Jyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLlNKSVMgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuU0pJUywgMjAsICdTSklTJywgJ1NoaWZ0X0pJUycpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjUwLCAyMSwgJ0NwMTI1MCcsICd3aW5kb3dzLTEyNTAnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUxID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MSwgMjIsICdDcDEyNTEnLCAnd2luZG93cy0xMjUxJyk7XG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwMTI1MiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5DcDEyNTIsIDIzLCAnQ3AxMjUyJywgJ3dpbmRvd3MtMTI1MicpO1xuICAgIENoYXJhY3RlclNldEVDSS5DcDEyNTYgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQ3AxMjU2LCAyNCwgJ0NwMTI1NicsICd3aW5kb3dzLTEyNTYnKTtcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVW5pY29kZUJpZ1VubWFya2VkID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLlVuaWNvZGVCaWdVbm1hcmtlZCwgMjUsICdVbmljb2RlQmlnVW5tYXJrZWQnLCAnVVRGLTE2QkUnLCAnVW5pY29kZUJpZycpO1xuICAgIENoYXJhY3RlclNldEVDSS5VVEY4ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLlVURjgsIDI2LCAnVVRGOCcsICdVVEYtOCcpO1xuICAgIENoYXJhY3RlclNldEVDSS5BU0NJSSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5BU0NJSSwgSW50MzJBcnJheS5mcm9tKFsyNywgMTcwXSksICdBU0NJSScsICdVUy1BU0NJSScpO1xuICAgIENoYXJhY3RlclNldEVDSS5CaWc1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkJpZzUsIDI4LCAnQmlnNScpO1xuICAgIENoYXJhY3RlclNldEVDSS5HQjE4MDMwID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkdCMTgwMzAsIDI5LCAnR0IxODAzMCcsICdHQjIzMTInLCAnRVVDX0NOJywgJ0dCSycpO1xuICAgIENoYXJhY3RlclNldEVDSS5FVUNfS1IgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuRVVDX0tSLCAzMCwgJ0VVQ19LUicsICdFVUMtS1InKTtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLmtpbmQgPSAnVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogUmVzcG9uc2libGUgZm9yIGVuL2RlY29kaW5nIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2xhc3MgU3RyaW5nRW5jb2Rpbmcge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBzb21lIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZShieXRlcywgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nTmFtZSA9IHRoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbURlY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21EZWNvZGVyKGJ5dGVzLCBlbmNvZGluZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5jcmVhc2VzIGJyb3dzZXIgc3VwcG9ydC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc2hvdWxkRGVjb2RlT25GYWxsYmFjayhlbmNvZGluZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRmFsbGJhY2soYnl0ZXMsIGVuY29kaW5nTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nTmFtZSkuZGVjb2RlKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBkZWNvZGluZyBtZXRob2Qgc2hvdWxkIHVzZSB0aGUgZmFsbGJhY2sgZm9yIGRlY29kaW5nXG4gICAgICAgICAqIG9uY2UgTm9kZSBUZXh0RGVjb2RlciBkb2Vzbid0IHN1cHBvcnQgYWxsIGVuY29kaW5nIGZvcm1hdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbmNvZGluZ05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBzaG91bGREZWNvZGVPbkZhbGxiYWNrKGVuY29kaW5nTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICFTdHJpbmdFbmNvZGluZy5pc0Jyb3dzZXIoKSAmJiBlbmNvZGluZ05hbWUgPT09ICdJU08tODg1OS0xJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyBzb21lIHN0cmluZyBpbnRvIGEgVWludDhBcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBlbmNvZGUocywgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nTmFtZSA9IHRoaXMuZW5jb2RpbmdOYW1lKGVuY29kaW5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21FbmNvZGVyKHMsIGVuY29kaW5nTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmNyZWFzZXMgYnJvd3NlciBzdXBwb3J0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVGYWxsYmFjayhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRleHRFbmNvZGVyIG9ubHkgZW5jb2RlcyB0byBVVEY4IGJ5IGRlZmF1bHQgYXMgc3BlY2lmaWVkIGJ5IGVuY29kaW5nLnNwZWMud2hhdHdnLm9yZ1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNCcm93c2VyKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IFdpbmRvd10nKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHZhbHVlIGZyb20gc29tZSBlbmNvZGluZyBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kaW5nTmFtZShlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGVuY29kaW5nXG4gICAgICAgICAgICAgICAgOiBlbmNvZGluZy5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgY2hhcmFjdGVyIHNldCBmcm9tIHNvbWUgZW5jb2RpbmcgY2hhcmFjdGVyIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBlbmNvZGluZ0NoYXJhY3RlclNldChlbmNvZGluZykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nIGluc3RhbmNlb2YgQ2hhcmFjdGVyU2V0RUNJKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIGEgZmFsbGJhY2sgZm9yIHRoZSBuYXRpdmUgZGVjb2RpbmcgZnVuY2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVGYWxsYmFjayhieXRlcywgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IHRoaXMuZW5jb2RpbmdDaGFyYWN0ZXJTZXQoZW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKFN0cmluZ0VuY29kaW5nLmlzRGVjb2RlRmFsbGJhY2tTdXBwb3J0ZWQoY2hhcmFjdGVyU2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoID0gYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzICs9ICclJyArIGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0kuVW5pY29kZUJpZ1VubWFya2VkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbihgRW5jb2RpbmcgJHt0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZyl9IG5vdCBzdXBwb3J0ZWQgYnkgZmFsbGJhY2suYCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzRGVjb2RlRmFsbGJhY2tTdXBwb3J0ZWQoY2hhcmFjdGVyU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0kuVVRGOCkgfHxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJTZXQuZXF1YWxzKENoYXJhY3RlclNldEVDSS5JU084ODU5XzEpIHx8XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0kuQVNDSUkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIGEgZmFsbGJhY2sgZm9yIHRoZSBuYXRpdmUgZW5jb2RpbmcgZnVuY2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTcxOTI4NDUvNDM2NzY4M1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZUZhbGxiYWNrKHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRVUklzdHJpbmcgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSkpO1xuICAgICAgICAgICAgY29uc3QgY2hhckxpc3QgPSBlbmNvZGVkVVJJc3RyaW5nLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIGNvbnN0IHVpbnRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHVpbnRBcnJheS5wdXNoKGNoYXJMaXN0W2ldLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHVpbnRBcnJheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAoQykgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDb21tb24gc3RyaW5nLXJlbGF0ZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIEFsZXggRHVwcmVcbiAgICAgKi9cbiAgICBjbGFzcyBTdHJpbmdVdGlscyB7XG4gICAgICAgIC8vIFNISUZUX0pJUy5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpIHx8XG4gICAgICAgIC8vIEVVQ19KUC5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpO1xuICAgICAgICBzdGF0aWMgY2FzdEFzTm9uVXRmOENoYXIoY29kZSwgZW5jb2RpbmcgPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJU08gODg1OS0xIGlzIHRoZSBKYXZhIGRlZmF1bHQgYXMgVVRGLTggaXMgSmF2YVNjcmlwdHNcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gc2VlIHRoaXMgbWV0aG9kIGFzIGEgSmF2YSB2ZXJzaW9uIG9mIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbmNvZGluZyA/IGVuY29kaW5nLmdldE5hbWUoKSA6IHRoaXMuSVNPODg1OTE7XG4gICAgICAgICAgICAvLyB1c2UgcGFzc2VkIGZvcm1hdCAoZnJvbUNoYXJDb2RlIHdpbGwgcmV0dXJuIFVURjggZW5jb2RpbmcpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nRW5jb2RpbmcuZGVjb2RlKG5ldyBVaW50OEFycmF5KFtjb2RlXSksIGUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZXMgYnl0ZXMgZW5jb2RpbmcgYSBzdHJpbmcsIHdob3NlIGVuY29kaW5nIHNob3VsZCBiZSBndWVzc2VkXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBkZWNvZGUgaGludHMgaWYgYXBwbGljYWJsZVxuICAgICAgICAgKiBAcmV0dXJuIG5hbWUgb2YgZ3Vlc3NlZCBlbmNvZGluZzsgYXQgdGhlIG1vbWVudCB3aWxsIG9ubHkgZ3Vlc3Mgb25lIG9mOlxuICAgICAgICAgKiAge0BsaW5rICNTSElGVF9KSVN9LCB7QGxpbmsgI1VURjh9LCB7QGxpbmsgI0lTTzg4NTkxfSwgb3IgdGhlIHBsYXRmb3JtXG4gICAgICAgICAqICBkZWZhdWx0IGVuY29kaW5nIGlmIG5vbmUgb2YgdGhlc2UgY2FuIHBvc3NpYmx5IGJlIGNvcnJlY3RcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBndWVzc0VuY29kaW5nKGJ5dGVzLCBoaW50cykge1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIG5vdywgbWVyZWx5IHRyaWVzIHRvIGRpc3Rpbmd1aXNoIElTTy04ODU5LTEsIFVURi04IGFuZCBTaGlmdF9KSVMsXG4gICAgICAgICAgICAvLyB3aGljaCBzaG91bGQgYmUgYnkgZmFyIHRoZSBtb3N0IGNvbW1vbiBlbmNvZGluZ3MuXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2FuQmVJU084ODU5MSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgY2FuQmVTaGlmdEpJUyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgY2FuQmVVVEY4ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB1dGY4Qnl0ZXNMZWZ0ID0gMDtcbiAgICAgICAgICAgIC8vIGludCB1dGY4TG93Q2hhcnMgPSAwXG4gICAgICAgICAgICBsZXQgdXRmMkJ5dGVzQ2hhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHV0ZjNCeXRlc0NoYXJzID0gMDtcbiAgICAgICAgICAgIGxldCB1dGY0Qnl0ZXNDaGFycyA9IDA7XG4gICAgICAgICAgICBsZXQgc2ppc0J5dGVzTGVmdCA9IDA7XG4gICAgICAgICAgICAvLyBpbnQgc2ppc0xvd0NoYXJzID0gMFxuICAgICAgICAgICAgbGV0IHNqaXNLYXRha2FuYUNoYXJzID0gMDtcbiAgICAgICAgICAgIC8vIGludCBzamlzRG91YmxlQnl0ZXNDaGFycyA9IDBcbiAgICAgICAgICAgIGxldCBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIGludCBpc29Mb3dDaGFycyA9IDBcbiAgICAgICAgICAgIC8vIGludCBpc29IaWdoQ2hhcnMgPSAwXG4gICAgICAgICAgICBsZXQgaXNvSGlnaE90aGVyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHV0Zjhib20gPSBieXRlcy5sZW5ndGggPiAzICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gPT09IC8qKGJ5dGUpICovIDB4RUYgJiZcbiAgICAgICAgICAgICAgICBieXRlc1sxXSA9PT0gLyooYnl0ZSkgKi8gMHhCQiAmJlxuICAgICAgICAgICAgICAgIGJ5dGVzWzJdID09PSAvKihieXRlKSAqLyAweEJGO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggJiYgKGNhbkJlSVNPODg1OTEgfHwgY2FuQmVTaGlmdEpJUyB8fCBjYW5CZVVURjgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgICAgICAvLyBVVEYtOCBzdHVmZlxuICAgICAgICAgICAgICAgIGlmIChjYW5CZVVURjgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0ZjhCeXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodmFsdWUgJiAweDgwKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4NDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVVVEY4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MjApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjJCeXRlc0NoYXJzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDEwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmM0J5dGVzQ2hhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDA4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjRCeXRlc0NoYXJzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXRmOExvd0NoYXJzKytcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJU08tODg1OS0xIHN0dWZmXG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlSVNPODg1OTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMHg3RiAmJiB2YWx1ZSA8IDB4QTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlSVNPODg1OTEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4OUYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4QzAgfHwgdmFsdWUgPT09IDB4RDcgfHwgdmFsdWUgPT09IDB4RjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc29IaWdoT3RoZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpc29IaWdoQ2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc29Mb3dDaGFycysrXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2hpZnRfSklTIHN0dWZmXG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlU2hpZnRKSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNqaXNCeXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDQwIHx8IHZhbHVlID09PSAweDdGIHx8IHZhbHVlID4gMHhGQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlU2hpZnRKSVMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNCeXRlc0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMHg4MCB8fCB2YWx1ZSA9PT0gMHhBMCB8fCB2YWx1ZSA+IDB4RUYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlU2hpZnRKSVMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4QTAgJiYgdmFsdWUgPCAweEUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzS2F0YWthbmFDaGFycysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA+IHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID0gc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNCeXRlc0xlZnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNqaXNEb3VibGVCeXRlc0NoYXJzKytcbiAgICAgICAgICAgICAgICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGggPiBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ppc01heERvdWJsZUJ5dGVzV29yZExlbmd0aCA9IHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzamlzTG93Q2hhcnMrK1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVVURjggJiYgdXRmOEJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTICYmIHNqaXNCeXRlc0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWFzeSAtLSBpZiB0aGVyZSBpcyBCT00gb3IgYXQgbGVhc3QgMSB2YWxpZCBub3Qtc2luZ2xlIGJ5dGUgY2hhcmFjdGVyIChhbmQgbm8gZXZpZGVuY2UgaXQgY2FuJ3QgYmUgVVRGLTgpLCBkb25lXG4gICAgICAgICAgICBpZiAoY2FuQmVVVEY4ICYmICh1dGY4Ym9tIHx8IHV0ZjJCeXRlc0NoYXJzICsgdXRmM0J5dGVzQ2hhcnMgKyB1dGY0Qnl0ZXNDaGFycyA+IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlVURjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFYXN5IC0tIGlmIGFzc3VtaW5nIFNoaWZ0X0pJUyBvciBhdCBsZWFzdCAzIHZhbGlkIGNvbnNlY3V0aXZlIG5vdC1hc2NpaSBjaGFyYWN0ZXJzIChhbmQgbm8gZXZpZGVuY2UgaXQgY2FuJ3QgYmUpLCBkb25lXG4gICAgICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUyAmJiAoU3RyaW5nVXRpbHMuQVNTVU1FX1NISUZUX0pJUyB8fCBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID49IDMgfHwgc2ppc01heERvdWJsZUJ5dGVzV29yZExlbmd0aCA+PSAzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5TSElGVF9KSVM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXN0aW5ndWlzaGluZyBTaGlmdF9KSVMgYW5kIElTTy04ODU5LTEgY2FuIGJlIGEgbGl0dGxlIHRvdWdoIGZvciBzaG9ydCB3b3Jkcy4gVGhlIGNydWRlIGhldXJpc3RpYyBpczpcbiAgICAgICAgICAgIC8vIC0gSWYgd2Ugc2F3XG4gICAgICAgICAgICAvLyAgIC0gb25seSB0d28gY29uc2VjdXRpdmUga2F0YWthbmEgY2hhcnMgaW4gdGhlIHdob2xlIHRleHQsIG9yXG4gICAgICAgICAgICAvLyAgIC0gYXQgbGVhc3QgMTAlIG9mIGJ5dGVzIHRoYXQgY291bGQgYmUgXCJ1cHBlclwiIG5vdC1hbHBoYW51bWVyaWMgTGF0aW4xLFxuICAgICAgICAgICAgLy8gLSB0aGVuIHdlIGNvbmNsdWRlIFNoaWZ0X0pJUywgZWxzZSBJU08tODg1OS0xXG4gICAgICAgICAgICBpZiAoY2FuQmVJU084ODU5MSAmJiBjYW5CZVNoaWZ0SklTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID09PSAyICYmIHNqaXNLYXRha2FuYUNoYXJzID09PSAyKSB8fCBpc29IaWdoT3RoZXIgKiAxMCA+PSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmdVdGlscy5TSElGVF9KSVMgOiBTdHJpbmdVdGlscy5JU084ODU5MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IGluIG9yZGVyIElTTy04ODU5LTEsIFNoaWZ0IEpJUywgVVRGLTggYW5kIGZhbGwgYmFjayB0byBkZWZhdWx0IHBsYXRmb3JtIGVuY29kaW5nXG4gICAgICAgICAgICBpZiAoY2FuQmVJU084ODU5MSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5JU084ODU5MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlNISUZUX0pJUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5CZVVURjgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuVVRGODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdGFrZSBhIHdpbGQgZ3Vlc3Mgd2l0aCBwbGF0Zm9ybSBlbmNvZGluZ1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEzNDM5NzExLzQzNjc2ODNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFwcGVuZCBUaGUgbmV3IHN0cmluZyB0byBhcHBlbmQuXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZXRzIHZhbHVlcyB0byBiZSBmb3JtYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmb3JtYXQoYXBwZW5kLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXhwLCBwMCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwID09PSAnJSUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWysraV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBleHAgPSBwMiA/IHBhcnNlSW50KHAyLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBwMyA/IHBhcnNlSW50KHAzLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZ3NbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvRml4ZWQoZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJnc1tpXSkudG9QcmVjaXNpb24oZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJnc1tpXSkudG9FeHBvbmVudGlhbChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQoYXJnc1tpXSkudG9TdHJpbmcoYmFzZSA/IGJhc2UgOiAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHBhcnNlSW50KGFyZ3NbaV0sIGJhc2UgPyBiYXNlIDogMTApLnRvUHJlY2lzaW9uKGV4cCkpLnRvRml4ZWQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeSh2YWwpIDogKCt2YWwpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQocDEpOyAvKiBwYWRkaW5nIHNpemUgKi9cbiAgICAgICAgICAgICAgICBsZXQgY2ggPSBwMSAmJiAocDFbMF0gKyAnJykgPT09ICcwJyA/ICcwJyA6ICcgJzsgLyogaXNudWxsPyAqL1xuICAgICAgICAgICAgICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcDAgIT09IHVuZGVmaW5lZCA/IHZhbCArIGNoIDogY2ggKyB2YWw7IC8qIGlzbWludXM/ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZWdleCA9IC8lKC0pPygwP1swLTldKyk/KFsuXVswLTldKyk/KFsjXVswLTldKyk/KFtzY2ZwZXhkJV0pL2c7XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kLnJlcGxhY2UocmVnZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRCeXRlcyhzdHIsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nRW5jb2RpbmcuZW5jb2RlKHN0ciwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjaGFyY29kZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9yIGF0IGluZGV4IHplcm8uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0Q2hhckNvZGUoc3RyLCBpbmRleCA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgY2hhciBmb3IgZ2l2ZW4gY2hhcmNvZGVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRDaGFyQXQoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdHJpbmdVdGlscy5TSElGVF9KSVMgPSBDaGFyYWN0ZXJTZXRFQ0kuU0pJUy5nZXROYW1lKCk7IC8vIFwiU0pJU1wiXG4gICAgU3RyaW5nVXRpbHMuR0IyMzEyID0gJ0dCMjMxMic7XG4gICAgU3RyaW5nVXRpbHMuSVNPODg1OTEgPSBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xLmdldE5hbWUoKTsgLy8gXCJJU084ODU5XzFcIlxuICAgIFN0cmluZ1V0aWxzLkVVQ19KUCA9ICdFVUNfSlAnO1xuICAgIFN0cmluZ1V0aWxzLlVURjggPSBDaGFyYWN0ZXJTZXRFQ0kuVVRGOC5nZXROYW1lKCk7IC8vIFwiVVRGOFwiXG4gICAgU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORyA9IFN0cmluZ1V0aWxzLlVURjg7IC8vIFwiVVRGOFwiLy9DaGFyc2V0LmRlZmF1bHRDaGFyc2V0KCkubmFtZSgpXG4gICAgU3RyaW5nVXRpbHMuQVNTVU1FX1NISUZUX0pJUyA9IGZhbHNlO1xuXG4gICAgY2xhc3MgU3RyaW5nQnVpbGRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZhbHVlID0gJycpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVEZWNvZGluZyhlbmNvZGluZykge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlICs9IHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgcGFzc2VkIGZvcm1hdCAoZnJvbUNoYXJDb2RlIHdpbGwgcmV0dXJuIFVURjggZW5jb2RpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSArPSBTdHJpbmdVdGlscy5jYXN0QXNOb25VdGY4Q2hhcihzLCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RseSBjb252ZXJ0cyBmcm9tIFVURi04LCBidXQgbm90IG90aGVyIGVuY29kaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZENoYXJzKHN0ciwgb2Zmc2V0LCBsZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IG9mZnNldCA8IG9mZnNldCArIGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoc3RyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjaGFyQXQobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuY2hhckF0KG4pO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZUNoYXJBdChuKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgbikgKyB0aGlzLnZhbHVlLnN1YnN0cmluZyhuICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2hhckF0KG4sIGMpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIGMgKyB0aGlzLnZhbHVlLnN1YnN0cihuICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic3RyaW5nKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQG5vdGUgaGVscGVyIG1ldGhvZCBmb3IgUlNTIEV4cGFuZGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZXRMZW5ndGhUb1plcm8oKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQobiwgYykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc3Vic3RyKDAsIG4pICsgYyArIHRoaXMudmFsdWUuc3Vic3RyKG4gKyBjLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlJlcHJlc2VudHMgYSAyRCBtYXRyaXggb2YgYml0cy4gSW4gZnVuY3Rpb24gYXJndW1lbnRzIGJlbG93LCBhbmQgdGhyb3VnaG91dCB0aGUgY29tbW9uXG4gICAgICogbW9kdWxlLCB4IGlzIHRoZSBjb2x1bW4gcG9zaXRpb24sIGFuZCB5IGlzIHRoZSByb3cgcG9zaXRpb24uIFRoZSBvcmRlcmluZyBpcyBhbHdheXMgeCwgeS5cbiAgICAgKiBUaGUgb3JpZ2luIGlzIGF0IHRoZSB0b3AtbGVmdC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5JbnRlcm5hbGx5IHRoZSBiaXRzIGFyZSByZXByZXNlbnRlZCBpbiBhIDEtRCBhcnJheSBvZiAzMi1iaXQgaW50cy4gSG93ZXZlciwgZWFjaCByb3cgYmVnaW5zXG4gICAgICogd2l0aCBhIG5ldyBpbnQuIFRoaXMgaXMgZG9uZSBpbnRlbnRpb25hbGx5IHNvIHRoYXQgd2UgY2FuIGNvcHkgb3V0IGEgcm93IGludG8gYSBCaXRBcnJheSB2ZXJ5XG4gICAgICogZWZmaWNpZW50bHkuPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhlIG9yZGVyaW5nIG9mIGJpdHMgaXMgcm93LW1ham9yLiBXaXRoaW4gZWFjaCBpbnQsIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXRzIGFyZSB1c2VkIGZpcnN0LFxuICAgICAqIG1lYW5pbmcgdGhleSByZXByZXNlbnQgbG93ZXIgeCB2YWx1ZXMuIFRoaXMgaXMgY29tcGF0aWJsZSB3aXRoIEJpdEFycmF5J3MgaW1wbGVtZW50YXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEJpdE1hdHJpeCAvKmltcGxlbWVudHMgQ2xvbmVhYmxlKi8ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBlbXB0eSBzcXVhcmUge0BsaW5rIEJpdE1hdHJpeH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkaW1lbnNpb24gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKGRpbWVuc2lvbjogbnVtYmVyIC8qaW50Ki8pIHtcbiAgICAgICAgLy8gICB0aGlzKGRpbWVuc2lvbiwgZGltZW5zaW9uKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IHtAbGluayBCaXRNYXRyaXh9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggYml0IG1hdHJpeCB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0IGJpdCBtYXRyaXggaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciAvKmludCovLCBoZWlnaHQ6IG51bWJlciAvKmludCovKSB7XG4gICAgICAgIC8vICAgaWYgKHdpZHRoIDwgMSB8fCBoZWlnaHQgPCAxKSB7XG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiQm90aCBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIilcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIC8vICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgLy8gICB0aGlzLnJvd1NpemUgPSAod2lkdGggKyAzMSkgLyAzMlxuICAgICAgICAvLyAgIGJpdHMgPSBuZXcgaW50W3Jvd1NpemUgKiBoZWlnaHRdO1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCByb3dTaXplIC8qaW50Ki8sIGJpdHMpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBoZWlnaHQgfHwgbnVsbCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDEgfHwgaGVpZ2h0IDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0JvdGggZGltZW5zaW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSByb3dTaXplIHx8IG51bGwgPT09IHJvd1NpemUpIHtcbiAgICAgICAgICAgICAgICByb3dTaXplID0gTWF0aC5mbG9vcigod2lkdGggKyAzMSkgLyAzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvd1NpemUgPSByb3dTaXplO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYml0cyB8fCBudWxsID09PSBiaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gbmV3IEludDMyQXJyYXkodGhpcy5yb3dTaXplICogdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcnByZXRzIGEgMkQgYXJyYXkgb2YgYm9vbGVhbnMgYXMgYSB7QGxpbmsgQml0TWF0cml4fSwgd2hlcmUgXCJ0cnVlXCIgbWVhbnMgYW4gXCJvblwiIGJpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIHBhcnNlXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBiaXRzIG9mIHRoZSBpbWFnZSwgYXMgYSByb3ctbWFqb3IgMkQgYXJyYXkuIEVsZW1lbnRzIGFyZSBhcnJheXMgcmVwcmVzZW50aW5nIHJvd3NcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgQml0TWF0cml4fSByZXByZXNlbnRhdGlvbiBvZiBpbWFnZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHBhcnNlRnJvbUJvb2xlYW5BcnJheShpbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVswXS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gbmV3IEJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUkgPSBpbWFnZVtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlSVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoaiwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIHBhcnNlXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdSZXByZXNlbnRhdGlvblxuICAgICAgICAgKiBAcGFyYW0gc2V0U3RyaW5nXG4gICAgICAgICAqIEBwYXJhbSB1bnNldFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHBhcnNlRnJvbVN0cmluZyhzdHJpbmdSZXByZXNlbnRhdGlvbiwgc2V0U3RyaW5nLCB1bnNldFN0cmluZykge1xuICAgICAgICAgICAgaWYgKHN0cmluZ1JlcHJlc2VudGF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignc3RyaW5nUmVwcmVzZW50YXRpb24gY2Fubm90IGJlIG51bGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQXJyYXkoc3RyaW5nUmVwcmVzZW50YXRpb24ubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBiaXRzUG9zID0gMDtcbiAgICAgICAgICAgIGxldCByb3dTdGFydFBvcyA9IDA7XG4gICAgICAgICAgICBsZXQgcm93TGVuZ3RoID0gLTE7XG4gICAgICAgICAgICBsZXQgblJvd3MgPSAwO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgc3RyaW5nUmVwcmVzZW50YXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXFxuJyB8fFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbi5jaGFyQXQocG9zKSA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0xlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dMZW5ndGggPSBiaXRzUG9zIC0gcm93U3RhcnRQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiaXRzUG9zIC0gcm93U3RhcnRQb3MgIT09IHJvd0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ3JvdyBsZW5ndGhzIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93U3RhcnRQb3MgPSBiaXRzUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgblJvd3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcywgcG9zICsgc2V0U3RyaW5nLmxlbmd0aCkgPT09IHNldFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gc2V0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tiaXRzUG9zXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJpdHNQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcywgcG9zICsgdW5zZXRTdHJpbmcubGVuZ3RoKSA9PT0gdW5zZXRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IHVuc2V0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tiaXRzUG9zXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBiaXRzUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdpbGxlZ2FsIGNoYXJhY3RlciBlbmNvdW50ZXJlZDogJyArIHN0cmluZ1JlcHJlc2VudGF0aW9uLnN1YnN0cmluZyhwb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBFT0wgYXQgZW5kP1xuICAgICAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChyb3dMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IGJpdHNQb3MgLSByb3dTdGFydFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYml0c1BvcyAtIHJvd1N0YXJ0UG9zICE9PSByb3dMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigncm93IGxlbmd0aHMgZG8gbm90IG1hdGNoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5Sb3dzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgQml0TWF0cml4KHJvd0xlbmd0aCwgblJvd3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUG9zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYml0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KE1hdGguZmxvb3IoaSAlIHJvd0xlbmd0aCksIE1hdGguZmxvb3IoaSAvIHJvd0xlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkdldHMgdGhlIHJlcXVlc3RlZCBiaXQsIHdoZXJlIHRydWUgbWVhbnMgYmxhY2suPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geCBUaGUgaG9yaXpvbnRhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggY29sdW1uKVxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgdmVydGljYWwgY29tcG9uZW50IChpLmUuIHdoaWNoIHJvdylcbiAgICAgICAgICogQHJldHVybiB2YWx1ZSBvZiBnaXZlbiBiaXQgaW4gbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXQoeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyBNYXRoLmZsb29yKHggLyAzMik7XG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmJpdHNbb2Zmc2V0XSA+Pj4gKHggJiAweDFmKSkgJiAxKSAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+U2V0cyB0aGUgZ2l2ZW4gYml0IHRvIHRydWUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geCBUaGUgaG9yaXpvbnRhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggY29sdW1uKVxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgdmVydGljYWwgY29tcG9uZW50IChpLmUuIHdoaWNoIHJvdylcbiAgICAgICAgICovXG4gICAgICAgIHNldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIHw9ICgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRjtcbiAgICAgICAgfVxuICAgICAgICB1bnNldCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdICY9IH4oKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RmxpcHMgdGhlIGdpdmVuIGJpdC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvbXBvbmVudCAoaS5lLiB3aGljaCBjb2x1bW4pXG4gICAgICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxuICAgICAgICAgKi9cbiAgICAgICAgZmxpcCh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcbiAgICAgICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIF49ICgoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGNsdXNpdmUtb3IgKFhPUik6IEZsaXAgdGhlIGJpdCBpbiB0aGlzIHtAY29kZSBCaXRNYXRyaXh9IGlmIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAqIG1hc2sgYml0IGlzIHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1hc2sgWE9SIG1hc2tcbiAgICAgICAgICovXG4gICAgICAgIHhvcihtYXNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gbWFzay5nZXRXaWR0aCgpIHx8IHRoaXMuaGVpZ2h0ICE9PSBtYXNrLmdldEhlaWdodCgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5yb3dTaXplICE9PSBtYXNrLmdldFJvd1NpemUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2lucHV0IG1hdHJpeCBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93QXJyYXkgPSBuZXcgQml0QXJyYXkoTWF0aC5mbG9vcih0aGlzLndpZHRoIC8gMzIpICsgMSk7XG4gICAgICAgICAgICBjb25zdCByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHJvd1NpemU7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gbWFzay5nZXRSb3coeSwgcm93QXJyYXkpLmdldEJpdEFycmF5KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3dTaXplOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYml0c1tvZmZzZXQgKyB4XSBePSByb3dbeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGJpdHMgKHNldHMgdG8gZmFsc2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXIoKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gYml0cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYml0c1tpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlNldHMgYSBzcXVhcmUgcmVnaW9uIG9mIHRoZSBiaXQgbWF0cml4IHRvIHRydWUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCBUaGUgaG9yaXpvbnRhbCBwb3NpdGlvbiB0byBiZWdpbiBhdCAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0gdG9wIFRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB0byBiZWdpbiBhdCAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWdpb25cbiAgICAgICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWdpb25cbiAgICAgICAgICovXG4gICAgICAgIHNldFJlZ2lvbihsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHRvcCA8IDAgfHwgbGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdMZWZ0IGFuZCB0b3AgbXVzdCBiZSBub25uZWdhdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDEgfHwgd2lkdGggPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGJvdHRvbSA+IHRoaXMuaGVpZ2h0IHx8IHJpZ2h0ID4gdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RoZSByZWdpb24gbXVzdCBmaXQgaW5zaWRlIHRoZSBtYXRyaXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHRvcDsgeSA8IGJvdHRvbTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHJvd1NpemU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IGxlZnQ7IHggPCByaWdodDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdHNbb2Zmc2V0ICsgTWF0aC5mbG9vcih4IC8gMzIpXSB8PSAoKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmFzdCBtZXRob2QgdG8gcmV0cmlldmUgb25lIHJvdyBvZiBkYXRhIGZyb20gdGhlIG1hdHJpeCBhcyBhIEJpdEFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geSBUaGUgcm93IHRvIHJldHJpZXZlXG4gICAgICAgICAqIEBwYXJhbSByb3cgQW4gb3B0aW9uYWwgY2FsbGVyLWFsbG9jYXRlZCBCaXRBcnJheSwgd2lsbCBiZSBhbGxvY2F0ZWQgaWYgbnVsbCBvciB0b28gc21hbGxcbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIEJpdEFycmF5IC0gdGhpcyByZWZlcmVuY2Ugc2hvdWxkIGFsd2F5cyBiZSB1c2VkIGV2ZW4gd2hlbiBwYXNzaW5nXG4gICAgICAgICAqICAgICAgICAgeW91ciBvd24gcm93XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93LmdldFNpemUoKSA8IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBuZXcgQml0QXJyYXkodGhpcy53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHJvd1NpemU7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvd1NpemU7IHgrKykge1xuICAgICAgICAgICAgICAgIHJvdy5zZXRCdWxrKHggKiAzMiwgYml0c1tvZmZzZXQgKyB4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geSByb3cgdG8gc2V0XG4gICAgICAgICAqIEBwYXJhbSByb3cge0BsaW5rIEJpdEFycmF5fSB0byBjb3B5IGZyb21cbiAgICAgICAgICovXG4gICAgICAgIHNldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShyb3cuZ2V0Qml0QXJyYXkoKSwgMCwgdGhpcy5iaXRzLCB5ICogdGhpcy5yb3dTaXplLCB0aGlzLnJvd1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RpZmllcyB0aGlzIHtAY29kZSBCaXRNYXRyaXh9IHRvIHJlcHJlc2VudCB0aGUgc2FtZSBidXQgcm90YXRlZCAxODAgZGVncmVlc1xuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlMTgwKCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgbGV0IHRvcFJvdyA9IG5ldyBCaXRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICBsZXQgYm90dG9tUm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBNYXRoLmZsb29yKChoZWlnaHQgKyAxKSAvIDIpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSB0aGlzLmdldFJvdyhpLCB0b3BSb3cpO1xuICAgICAgICAgICAgICAgIGJvdHRvbVJvdyA9IHRoaXMuZ2V0Um93KGhlaWdodCAtIDEgLSBpLCBib3R0b21Sb3cpO1xuICAgICAgICAgICAgICAgIHRvcFJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgYm90dG9tUm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJvdyhpLCBib3R0b21Sb3cpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Um93KGhlaWdodCAtIDEgLSBpLCB0b3BSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiBkZXRlY3RpbmcgdGhlIGVuY2xvc2luZyByZWN0YW5nbGUgb2YgYSAncHVyZScgYmFyY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGNvZGUgbGVmdCx0b3Asd2lkdGgsaGVpZ2h0fSBlbmNsb3NpbmcgcmVjdGFuZ2xlIG9mIGFsbCAxIGJpdHMsIG9yIG51bGwgaWYgaXQgaXMgYWxsIHdoaXRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbmNsb3NpbmdSZWN0YW5nbGUoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gdGhpcy5iaXRzO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSB3aWR0aDtcbiAgICAgICAgICAgIGxldCB0b3AgPSBoZWlnaHQ7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSAtMTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4MzIgPSAwOyB4MzIgPCByb3dTaXplOyB4MzIrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aGVCaXRzID0gYml0c1t5ICogcm93U2l6ZSArIHgzMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVCaXRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA8IHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA+IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeDMyICogMzIgPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCgodGhlQml0cyA8PCAoMzEgLSBiaXQpKSAmIDB4RkZGRkZGRkYpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHgzMiAqIDMyICsgYml0KSA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHgzMiAqIDMyICsgYml0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4MzIgKiAzMiArIDMxID4gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYml0ID0gMzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0aGVCaXRzID4+PiBiaXQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHgzMiAqIDMyICsgYml0KSA+IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0geDMyICogMzIgKyBiaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbGVmdCB8fCBib3R0b20gPCB0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW2xlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0ICsgMSwgYm90dG9tIC0gdG9wICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiBkZXRlY3RpbmcgYSBjb3JuZXIgb2YgYSAncHVyZScgYmFyY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGNvZGUgeCx5fSBjb29yZGluYXRlIG9mIHRvcC1sZWZ0LW1vc3QgMSBiaXQsIG9yIG51bGwgaWYgaXQgaXMgYWxsIHdoaXRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUb3BMZWZ0T25CaXQoKSB7XG4gICAgICAgICAgICBjb25zdCByb3dTaXplID0gdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuYml0cztcbiAgICAgICAgICAgIGxldCBiaXRzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0IDwgYml0cy5sZW5ndGggJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJpdHNPZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzT2Zmc2V0ID09PSBiaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeSA9IGJpdHNPZmZzZXQgLyByb3dTaXplO1xuICAgICAgICAgICAgbGV0IHggPSAoYml0c09mZnNldCAlIHJvd1NpemUpICogMzI7XG4gICAgICAgICAgICBjb25zdCB0aGVCaXRzID0gYml0c1tiaXRzT2Zmc2V0XTtcbiAgICAgICAgICAgIGxldCBiaXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCgodGhlQml0cyA8PCAoMzEgLSBiaXQpKSAmIDB4RkZGRkZGRkYpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYml0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ICs9IGJpdDtcbiAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3gsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCb3R0b21SaWdodE9uQml0KCkge1xuICAgICAgICAgICAgY29uc3Qgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSB0aGlzLmJpdHM7XG4gICAgICAgICAgICBsZXQgYml0c09mZnNldCA9IGJpdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0ID49IDAgJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJpdHNPZmZzZXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoYml0c09mZnNldCAvIHJvd1NpemUpO1xuICAgICAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKGJpdHNPZmZzZXQgJSByb3dTaXplKSAqIDMyO1xuICAgICAgICAgICAgY29uc3QgdGhlQml0cyA9IGJpdHNbYml0c09mZnNldF07XG4gICAgICAgICAgICBsZXQgYml0ID0gMzE7XG4gICAgICAgICAgICB3aGlsZSAoKHRoZUJpdHMgPj4+IGJpdCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBiaXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gYml0O1xuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBoZWlnaHQgb2YgdGhlIG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByb3cgc2l6ZSBvZiB0aGUgbWF0cml4XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb3dTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQml0TWF0cml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0ICYmIHRoaXMucm93U2l6ZSA9PT0gb3RoZXIucm93U2l6ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5cy5lcXVhbHModGhpcy5iaXRzLCBvdGhlci5iaXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIHRoaXMud2lkdGg7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy5yb3dTaXplO1xuICAgICAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIEFycmF5cy5oYXNoQ29kZSh0aGlzLmJpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIFwiWFwiIGZvciBzZXQgYW5kIFwiIFwiIGZvciB1bnNldCBiaXRzXG4gICAgICAgICAqL1xuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIC8vIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICAvLyAgIHJldHVybiB0b1N0cmluZyhcIjogXCJYLCBcIiAgXCIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0XG4gICAgICAgICAqIEBwYXJhbSB1bnNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiB1bnNldCBiaXRcbiAgICAgICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW50aXJlIG1hdHJpeCB1dGlsaXppbmcgZ2l2ZW4gc3RyaW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIHRvU3RyaW5nKHNldFN0cmluZzogc3RyaW5nID0gXCJYIFwiLCB1bnNldFN0cmluZzogc3RyaW5nID0gXCIgIFwiKTogc3RyaW5nIHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5idWlsZFRvU3RyaW5nKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIFwiXFxuXCIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0XG4gICAgICAgICAqIEBwYXJhbSB1bnNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiB1bnNldCBiaXRcbiAgICAgICAgICogQHBhcmFtIGxpbmVTZXBhcmF0b3IgbmV3bGluZSBjaGFyYWN0ZXIgaW4gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGVudGlyZSBtYXRyaXggdXRpbGl6aW5nIGdpdmVuIHN0cmluZ3MgYW5kIGxpbmUgc2VwYXJhdG9yXG4gICAgICAgICAqIEBkZXByZWNhdGVkIGNhbGwge0BsaW5rICN0b1N0cmluZyhTdHJpbmcsU3RyaW5nKX0gb25seSwgd2hpY2ggdXNlcyBcXG4gbGluZSBzZXBhcmF0b3IgYWx3YXlzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBARGVwcmVjYXRlZFxuICAgICAgICB0b1N0cmluZyhzZXRTdHJpbmcgPSAnWCAnLCB1bnNldFN0cmluZyA9ICcgICcsIGxpbmVTZXBhcmF0b3IgPSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRUb1N0cmluZyhzZXRTdHJpbmcsIHVuc2V0U3RyaW5nLCBsaW5lU2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZFRvU3RyaW5nKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIGxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgLy8gcmVzdWx0LmFwcGVuZChsaW5lU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLmdldCh4LCB5KSA/IHNldFN0cmluZyA6IHVuc2V0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChsaW5lU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGNsb25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaXRNYXRyaXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucm93U2l6ZSwgdGhpcy5iaXRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIE5vdEZvdW5kRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICAgICAgc3RhdGljIGdldE5vdEZvdW5kSW5zdGFuY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTm90Rm91bmRFeGNlcHRpb24ua2luZCA9ICdOb3RGb3VuZEV4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgQmluYXJpemVyIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIG9sZCBaWGluZyBnbG9iYWwgaGlzdG9ncmFtIGFwcHJvYWNoLiBJdCBpcyBzdWl0YWJsZVxuICAgICAqIGZvciBsb3ctZW5kIG1vYmlsZSBkZXZpY2VzIHdoaWNoIGRvbid0IGhhdmUgZW5vdWdoIENQVSBvciBtZW1vcnkgdG8gdXNlIGEgbG9jYWwgdGhyZXNob2xkaW5nXG4gICAgICogYWxnb3JpdGhtLiBIb3dldmVyLCBiZWNhdXNlIGl0IHBpY2tzIGEgZ2xvYmFsIGJsYWNrIHBvaW50LCBpdCBjYW5ub3QgaGFuZGxlIGRpZmZpY3VsdCBzaGFkb3dzXG4gICAgICogYW5kIGdyYWRpZW50cy5cbiAgICAgKlxuICAgICAqIEZhc3RlciBtb2JpbGUgZGV2aWNlcyBhbmQgYWxsIGRlc2t0b3AgYXBwbGljYXRpb25zIHNob3VsZCBwcm9iYWJseSB1c2UgSHlicmlkQmluYXJpemVyIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyIGV4dGVuZHMgQmluYXJpemVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICAgICAgdGhpcy5sdW1pbmFuY2VzID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkVNUFRZO1xuICAgICAgICAgICAgdGhpcy5idWNrZXRzID0gbmV3IEludDMyQXJyYXkoR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CVUNLRVRTKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBsaWVzIHNpbXBsZSBzaGFycGVuaW5nIHRvIHRoZSByb3cgZGF0YSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSAxRCBSZWFkZXJzLlxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldEJsYWNrUm93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChyb3cgPT09IHVuZGVmaW5lZCB8fCByb3cgPT09IG51bGwgfHwgcm93LmdldFNpemUoKSA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbml0QXJyYXlzKHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRSb3coeSwgdGhpcy5sdW1pbmFuY2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQnVja2V0cyA9IHRoaXMuYnVja2V0cztcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGxvY2FsQnVja2V0c1sobG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZikgPj4gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9TSElGVF0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJsYWNrUG9pbnQgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuZXN0aW1hdGVCbGFja1BvaW50KGxvY2FsQnVja2V0cyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAzKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB2ZXJ5IHNtYWxsIGltYWdlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvY2FsTHVtaW5hbmNlc1t4XSAmIDB4ZmYpIDwgYmxhY2tQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnNldCh4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gbG9jYWxMdW1pbmFuY2VzWzBdICYgMHhmZjtcbiAgICAgICAgICAgICAgICBsZXQgY2VudGVyID0gbG9jYWxMdW1pbmFuY2VzWzFdICYgMHhmZjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMTsgeCA8IHdpZHRoIC0gMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbG9jYWxMdW1pbmFuY2VzW3ggKyAxXSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc2ltcGxlIC0xIDQgLTEgYm94IGZpbHRlciB3aXRoIGEgd2VpZ2h0IG9mIDIuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKGNlbnRlciAqIDQpIC0gbGVmdCAtIHJpZ2h0KSAvIDIgPCBibGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuc2V0KHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3Qgc2hhcnBlbiB0aGUgZGF0YSwgYXMgdGhpcyBjYWxsIGlzIGludGVuZGVkIHRvIG9ubHkgYmUgdXNlZCBieSAyRCBSZWFkZXJzLlxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldEJsYWNrTWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRMdW1pbmFuY2VTb3VyY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gc291cmNlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBzb3VyY2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgQml0TWF0cml4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgLy8gUXVpY2tseSBjYWxjdWxhdGVzIHRoZSBoaXN0b2dyYW0gYnkgc2FtcGxpbmcgZm91ciByb3dzIGZyb20gdGhlIGltYWdlLiBUaGlzIHByb3ZlZCB0byBiZVxuICAgICAgICAgICAgLy8gbW9yZSByb2J1c3Qgb24gdGhlIGJsYWNrYm94IHRlc3RzIHRoYW4gc2FtcGxpbmcgYSBkaWFnb25hbCBhcyB3ZSB1c2VkIHRvIGRvLlxuICAgICAgICAgICAgdGhpcy5pbml0QXJyYXlzKHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQnVja2V0cyA9IHRoaXMuYnVja2V0cztcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAxOyB5IDwgNTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcigoaGVpZ2h0ICogeSkgLyA1KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEx1bWluYW5jZXMgPSBzb3VyY2UuZ2V0Um93KHJvdywgdGhpcy5sdW1pbmFuY2VzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IE1hdGguZmxvb3IoKHdpZHRoICogNCkgLyA1KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gTWF0aC5mbG9vcih3aWR0aCAvIDUpOyB4IDwgcmlnaHQ7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IGxvY2FsTHVtaW5hbmNlc1t4XSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQnVja2V0c1twaXhlbCA+PiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJsYWNrUG9pbnQgPSBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuZXN0aW1hdGVCbGFja1BvaW50KGxvY2FsQnVja2V0cyk7XG4gICAgICAgICAgICAvLyBXZSBkZWxheSByZWFkaW5nIHRoZSBlbnRpcmUgaW1hZ2UgbHVtaW5hbmNlIHVudGlsIHRoZSBibGFjayBwb2ludCBlc3RpbWF0aW9uIHN1Y2NlZWRzLlxuICAgICAgICAgICAgLy8gQWx0aG91Z2ggd2UgZW5kIHVwIHJlYWRpbmcgZm91ciByb3dzIHR3aWNlLCBpdCBpcyBjb25zaXN0ZW50IHdpdGggb3VyIG1vdHRvIG9mXG4gICAgICAgICAgICAvLyBcImZhaWwgcXVpY2tseVwiIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgY29udGludW91cyBzY2FubmluZy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsIDwgYmxhY2tQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcmVhdGVCaW5hcml6ZXIoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcihzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRBcnJheXMobHVtaW5hbmNlU2l6ZSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sdW1pbmFuY2VzLmxlbmd0aCA8IGx1bWluYW5jZVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmx1bWluYW5jZXMgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkobHVtaW5hbmNlU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWNrZXRzID0gdGhpcy5idWNrZXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFM7IHgrKykge1xuICAgICAgICAgICAgICAgIGJ1Y2tldHNbeF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlc3RpbWF0ZUJsYWNrUG9pbnQoYnVja2V0cykge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGFsbGVzdCBwZWFrIGluIHRoZSBoaXN0b2dyYW0uXG4gICAgICAgICAgICBjb25zdCBudW1CdWNrZXRzID0gYnVja2V0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbWF4QnVja2V0Q291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGZpcnN0UGVhayA9IDA7XG4gICAgICAgICAgICBsZXQgZmlyc3RQZWFrU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChidWNrZXRzW3hdID4gZmlyc3RQZWFrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFBlYWsgPSB4O1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFBlYWtTaXplID0gYnVja2V0c1t4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHNbeF0gPiBtYXhCdWNrZXRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhCdWNrZXRDb3VudCA9IGJ1Y2tldHNbeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCB0aGUgc2Vjb25kLXRhbGxlc3QgcGVhayB3aGljaCBpcyBzb21ld2hhdCBmYXIgZnJvbSB0aGUgdGFsbGVzdCBwZWFrLlxuICAgICAgICAgICAgbGV0IHNlY29uZFBlYWsgPSAwO1xuICAgICAgICAgICAgbGV0IHNlY29uZFBlYWtTY29yZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlVG9CaWdnZXN0ID0geCAtIGZpcnN0UGVhaztcbiAgICAgICAgICAgICAgICAvLyBFbmNvdXJhZ2UgbW9yZSBkaXN0YW50IHNlY29uZCBwZWFrcyBieSBtdWx0aXBseWluZyBieSBzcXVhcmUgb2YgZGlzdGFuY2UuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBidWNrZXRzW3hdICogZGlzdGFuY2VUb0JpZ2dlc3QgKiBkaXN0YW5jZVRvQmlnZ2VzdDtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBzZWNvbmRQZWFrU2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGVhayA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZFBlYWtTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBmaXJzdFBlYWsgY29ycmVzcG9uZHMgdG8gdGhlIGJsYWNrIHBlYWsuXG4gICAgICAgICAgICBpZiAoZmlyc3RQZWFrID4gc2Vjb25kUGVhaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBmaXJzdFBlYWs7XG4gICAgICAgICAgICAgICAgZmlyc3RQZWFrID0gc2Vjb25kUGVhaztcbiAgICAgICAgICAgICAgICBzZWNvbmRQZWFrID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHRvbyBsaXR0bGUgY29udHJhc3QgaW4gdGhlIGltYWdlIHRvIHBpY2sgYSBtZWFuaW5nZnVsIGJsYWNrIHBvaW50LCB0aHJvdyByYXRoZXJcbiAgICAgICAgICAgIC8vIHRoYW4gd2FzdGUgdGltZSB0cnlpbmcgdG8gZGVjb2RlIHRoZSBpbWFnZSwgYW5kIHJpc2sgZmFsc2UgcG9zaXRpdmVzLlxuICAgICAgICAgICAgaWYgKHNlY29uZFBlYWsgLSBmaXJzdFBlYWsgPD0gbnVtQnVja2V0cyAvIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIGEgdmFsbGV5IGJldHdlZW4gdGhlbSB0aGF0IGlzIGxvdyBhbmQgY2xvc2VyIHRvIHRoZSB3aGl0ZSBwZWFrLlxuICAgICAgICAgICAgbGV0IGJlc3RWYWxsZXkgPSBzZWNvbmRQZWFrIC0gMTtcbiAgICAgICAgICAgIGxldCBiZXN0VmFsbGV5U2NvcmUgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBzZWNvbmRQZWFrIC0gMTsgeCA+IGZpcnN0UGVhazsgeC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbUZpcnN0ID0geCAtIGZpcnN0UGVhaztcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IGZyb21GaXJzdCAqIGZyb21GaXJzdCAqIChzZWNvbmRQZWFrIC0geCkgKiAobWF4QnVja2V0Q291bnQgLSBidWNrZXRzW3hdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBiZXN0VmFsbGV5U2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhbGxleSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYWxsZXlTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZXN0VmFsbGV5IDw8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTID0gNTtcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUID0gOCAtIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUztcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFMgPSAxIDw8IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUztcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuRU1QVFkgPSBVaW50OENsYW1wZWRBcnJheS5mcm9tKFswXSk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIGxvY2FsIHRocmVzaG9sZGluZyBhbGdvcml0aG0sIHdoaWNoIHdoaWxlIHNsb3dlciB0aGFuIHRoZVxuICAgICAqIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgaXMgZmFpcmx5IGVmZmljaWVudCBmb3Igd2hhdCBpdCBkb2VzLiBJdCBpcyBkZXNpZ25lZCBmb3JcbiAgICAgKiBoaWdoIGZyZXF1ZW5jeSBpbWFnZXMgb2YgYmFyY29kZXMgd2l0aCBibGFjayBkYXRhIG9uIHdoaXRlIGJhY2tncm91bmRzLiBGb3IgdGhpcyBhcHBsaWNhdGlvbixcbiAgICAgKiBpdCBkb2VzIGEgbXVjaCBiZXR0ZXIgam9iIHRoYW4gYSBnbG9iYWwgYmxhY2twb2ludCB3aXRoIHNldmVyZSBzaGFkb3dzIGFuZCBncmFkaWVudHMuXG4gICAgICogSG93ZXZlciBpdCB0ZW5kcyB0byBwcm9kdWNlIGFydGlmYWN0cyBvbiBsb3dlciBmcmVxdWVuY3kgaW1hZ2VzIGFuZCBpcyB0aGVyZWZvcmUgbm90XG4gICAgICogYSBnb29kIGdlbmVyYWwgcHVycG9zZSBiaW5hcml6ZXIgZm9yIHVzZXMgb3V0c2lkZSBaWGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3MgZXh0ZW5kcyBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIsIHVzaW5nIHRoZSBvbGRlciBoaXN0b2dyYW0gYXBwcm9hY2ggZm9yIDFEIHJlYWRlcnMsXG4gICAgICogYW5kIHRoZSBuZXdlciBsb2NhbCBhcHByb2FjaCBmb3IgMkQgcmVhZGVycy4gMUQgZGVjb2RpbmcgdXNpbmcgYSBwZXItcm93IGhpc3RvZ3JhbSBpcyBhbHJlYWR5XG4gICAgICogaW5oZXJlbnRseSBsb2NhbCwgYW5kIG9ubHkgZmFpbHMgZm9yIGhvcml6b250YWwgZ3JhZGllbnRzLiBXZSBjYW4gcmV2aXNpdCB0aGF0IHByb2JsZW0gbGF0ZXIsXG4gICAgICogYnV0IGZvciBub3cgaXQgd2FzIG5vdCBhIHdpbiB0byB1c2UgbG9jYWwgYmxvY2tzIGZvciAxRC5cbiAgICAgKlxuICAgICAqIFRoaXMgQmluYXJpemVyIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdW5pdCB0ZXN0cyBhbmQgdGhlIHJlY29tbWVuZGVkIGNsYXNzIGZvciBsaWJyYXJ5IHVzZXJzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBIeWJyaWRCaW5hcml6ZXIgZXh0ZW5kcyBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGZpbmFsIEJpdE1hdHJpeCBvbmNlIGZvciBhbGwgcmVxdWVzdHMuIFRoaXMgY291bGQgYmUgY2FsbGVkIG9uY2UgZnJvbSB0aGVcbiAgICAgICAgICogY29uc3RydWN0b3IgaW5zdGVhZCwgYnV0IHRoZXJlIGFyZSBzb21lIGFkdmFudGFnZXMgdG8gZG9pbmcgaXQgbGF6aWx5LCBzdWNoIGFzIG1ha2luZ1xuICAgICAgICAgKiBwcm9maWxpbmcgZWFzaWVyLCBhbmQgbm90IGRvaW5nIGhlYXZ5IGxpZnRpbmcgd2hlbiBjYWxsZXJzIGRvbid0IGV4cGVjdCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0QmxhY2tNYXRyaXgoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRyaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA+PSBIeWJyaWRCaW5hcml6ZXIuTUlOSU1VTV9ESU1FTlNJT04gJiYgaGVpZ2h0ID49IEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZXMgPSBzb3VyY2UuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgbGV0IHN1YldpZHRoID0gd2lkdGggPj4gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKCh3aWR0aCAmIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0spICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YldpZHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzdWJIZWlnaHQgPSBoZWlnaHQgPj4gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKChoZWlnaHQgJiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9NQVNLKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJIZWlnaHQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludHMgPSBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlQmxhY2tQb2ludHMobHVtaW5hbmNlcywgc3ViV2lkdGgsIHN1YkhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IEJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlVGhyZXNob2xkRm9yQmxvY2sobHVtaW5hbmNlcywgc3ViV2lkdGgsIHN1YkhlaWdodCwgd2lkdGgsIGhlaWdodCwgYmxhY2tQb2ludHMsIG5ld01hdHJpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBuZXdNYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW1hZ2UgaXMgdG9vIHNtYWxsLCBmYWxsIGJhY2sgdG8gdGhlIGdsb2JhbCBoaXN0b2dyYW0gYXBwcm9hY2guXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBzdXBlci5nZXRCbGFja01hdHJpeCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY3JlYXRlQmluYXJpemVyKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIeWJyaWRCaW5hcml6ZXIoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGVhY2ggYmxvY2sgaW4gdGhlIGltYWdlLCBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgYmxhY2sgcG9pbnQgdXNpbmcgYSA1eDUgZ3JpZFxuICAgICAgICAgKiBvZiB0aGUgYmxvY2tzIGFyb3VuZCBpdC4gQWxzbyBoYW5kbGVzIHRoZSBjb3JuZXIgY2FzZXMgKGZyYWN0aW9uYWwgYmxvY2tzIGFyZSBjb21wdXRlZCBiYXNlZFxuICAgICAgICAgKiBvbiB0aGUgbGFzdCBwaXhlbHMgaW4gdGhlIHJvdy9jb2x1bW4gd2hpY2ggYXJlIGFsc28gdXNlZCBpbiB0aGUgcHJldmlvdXMgYmxvY2spLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNhbGN1bGF0ZVRocmVzaG9sZEZvckJsb2NrKGx1bWluYW5jZXMsIHN1YldpZHRoIC8qaW50Ki8sIHN1YkhlaWdodCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgYmxhY2tQb2ludHMsIG1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgbWF4WU9mZnNldCA9IGhlaWdodCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xuICAgICAgICAgICAgY29uc3QgbWF4WE9mZnNldCA9IHdpZHRoIC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHN1YkhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHlvZmZzZXQgPSB5IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICAgICAgICAgIGlmICh5b2Zmc2V0ID4gbWF4WU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB5b2Zmc2V0ID0gbWF4WU9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdG9wID0gSHlicmlkQmluYXJpemVyLmNhcCh5LCAyLCBzdWJIZWlnaHQgLSAzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhvZmZzZXQgPSB4IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG9mZnNldCA+IG1heFhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgPSBtYXhYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHgsIDIsIHN1YldpZHRoIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB6ID0gLTI7IHogPD0gMjsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibGFja1JvdyA9IGJsYWNrUG9pbnRzW3RvcCArIHpdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGJsYWNrUm93W2xlZnQgLSAyXSArIGJsYWNrUm93W2xlZnQgLSAxXSArIGJsYWNrUm93W2xlZnRdICsgYmxhY2tSb3dbbGVmdCArIDFdICsgYmxhY2tSb3dbbGVmdCArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSBzdW0gLyAyNTtcbiAgICAgICAgICAgICAgICAgICAgSHlicmlkQmluYXJpemVyLnRocmVzaG9sZEJsb2NrKGx1bWluYW5jZXMsIHhvZmZzZXQsIHlvZmZzZXQsIGF2ZXJhZ2UsIHdpZHRoLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2FwKHZhbHVlIC8qaW50Ki8sIG1pbiAvKmludCovLCBtYXggLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhIHNpbmdsZSB0aHJlc2hvbGQgdG8gYSBibG9jayBvZiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgdGhyZXNob2xkQmxvY2sobHVtaW5hbmNlcywgeG9mZnNldCAvKmludCovLCB5b2Zmc2V0IC8qaW50Ki8sIHRocmVzaG9sZCAvKmludCovLCBzdHJpZGUgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHN0cmlkZSArIHhvZmZzZXQ7IHkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeSsrLCBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmlzb24gbmVlZHMgdG8gYmUgPD0gc28gdGhhdCBibGFjayA9PSAwIHBpeGVscyBhcmUgYmxhY2sgZXZlbiBpZiB0aGUgdGhyZXNob2xkIGlzIDAuXG4gICAgICAgICAgICAgICAgICAgIGlmICgobHVtaW5hbmNlc1tvZmZzZXQgKyB4XSAmIDB4RkYpIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldCh4b2Zmc2V0ICsgeCwgeW9mZnNldCArIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIGEgc2luZ2xlIGJsYWNrIHBvaW50IGZvciBlYWNoIGJsb2NrIG9mIHBpeGVscyBhbmQgc2F2ZXMgaXQgYXdheS5cbiAgICAgICAgICogU2VlIHRoZSBmb2xsb3dpbmcgdGhyZWFkIGZvciBhIGRpc2N1c3Npb24gb2YgdGhpcyBhbGdvcml0aG06XG4gICAgICAgICAqICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZ3JvdXAvenhpbmcvYnJvd3NlX3RocmVhZC90aHJlYWQvZDA2ZWZhMmMzNWE3ZGRjMFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNhbGN1bGF0ZUJsYWNrUG9pbnRzKGx1bWluYW5jZXMsIHN1YldpZHRoIC8qaW50Ki8sIHN1YkhlaWdodCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgbWF4WU9mZnNldCA9IGhlaWdodCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xuICAgICAgICAgICAgY29uc3QgbWF4WE9mZnNldCA9IHdpZHRoIC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6d2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3QgYmxhY2tQb2ludHMgPSBuZXcgQXJyYXkoc3ViSGVpZ2h0KTsgLy8gc3ViV2lkdGhcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc3ViSGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBibGFja1BvaW50c1t5XSA9IG5ldyBJbnQzMkFycmF5KHN1YldpZHRoKTtcbiAgICAgICAgICAgICAgICBsZXQgeW9mZnNldCA9IHkgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XG4gICAgICAgICAgICAgICAgaWYgKHlvZmZzZXQgPiBtYXhZT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHlvZmZzZXQgPSBtYXhZT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhvZmZzZXQgPSB4IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeG9mZnNldCA+IG1heFhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgPSBtYXhYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluID0gMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHl5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHdpZHRoICsgeG9mZnNldDsgeXkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeXkrKywgb2Zmc2V0ICs9IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4eCA9IDA7IHh4IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHh4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IGx1bWluYW5jZXNbb2Zmc2V0ICsgeHhdICYgMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgbG9va2luZyBmb3IgZ29vZCBjb250cmFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3J0LWNpcmN1aXQgbWluL21heCB0ZXN0cyBvbmNlIGR5bmFtaWMgcmFuZ2UgaXMgbWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4IC0gbWluID4gSHlicmlkQmluYXJpemVyLk1JTl9EWU5BTUlDX1JBTkdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluaXNoIHRoZSByZXN0IG9mIHRoZSByb3dzIHF1aWNrbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHl5KyssIG9mZnNldCArPSB3aWR0aDsgeXkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeXkrKywgb2Zmc2V0ICs9IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGx1bWluYW5jZXNbb2Zmc2V0ICsgeHhdICYgMHhGRjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBlc3RpbWF0ZSBpcyB0aGUgYXZlcmFnZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBibG9jay5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGF2ZXJhZ2UgPSBzdW0gPj4gKEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSICogMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPD0gSHlicmlkQmluYXJpemVyLk1JTl9EWU5BTUlDX1JBTkdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YXJpYXRpb24gd2l0aGluIHRoZSBibG9jayBpcyBsb3csIGFzc3VtZSB0aGlzIGlzIGEgYmxvY2sgd2l0aCBvbmx5IGxpZ2h0IG9yIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhcmsgcGl4ZWxzLiBJbiB0aGF0IGNhc2Ugd2UgZG8gbm90IHdhbnQgdG8gdXNlIHRoZSBhdmVyYWdlLCBhcyBpdCB3b3VsZCBkaXZpZGUgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG93IGNvbnRyYXN0IGFyZWEgaW50byBibGFjayBhbmQgd2hpdGUgcGl4ZWxzLCBlc3NlbnRpYWxseSBjcmVhdGluZyBkYXRhIG91dCBvZiBub2lzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGJsb2NrIGlzIGxpZ2h0L2JhY2tncm91bmQuIFNpbmNlIG5vIGVzdGltYXRlIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxldmVsIG9mIGRhcmsgcGl4ZWxzIGV4aXN0cyBsb2NhbGx5LCB1c2UgaGFsZiB0aGUgbWluIGZvciB0aGUgYmxvY2suXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmVyYWdlID0gbWluIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ID4gMCAmJiB4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY3QgdGhlIFwid2hpdGUgYmFja2dyb3VuZFwiIGFzc3VtcHRpb24gZm9yIGJsb2NrcyB0aGF0IGhhdmUgbmVpZ2hib3JzIGJ5IGNvbXBhcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwaXhlbHMgaW4gdGhpcyBibG9jayB0byB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIGJsYWNrIHBvaW50cy4gVGhpcyBpcyBiYXNlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgZGFyayBiYXJjb2RlIHN5bWJvbG9neSBpcyBhbHdheXMgc3Vycm91bmRlZCBieSBzb21lIGFtb3VudCBvZiBsaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2tncm91bmQgZm9yIHdoaWNoIHJlYXNvbmFibGUgYmxhY2sgcG9pbnQgZXN0aW1hdGVzIHdlcmUgbWFkZS4gVGhlIGJwIGVzdGltYXRlZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBib3VuZGFyaWVzIGlzIHVzZWQgZm9yIHRoZSBpbnRlcmlvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgKG1pbiA8IGJwKSBpcyBhcmJpdHJhcnkgYnV0IHdvcmtzIGJldHRlciB0aGFuIG90aGVyIGhldXJpc3RpY3MgdGhhdCB3ZXJlIHRyaWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQgPSAoYmxhY2tQb2ludHNbeSAtIDFdW3hdICsgKDIgKiBibGFja1BvaW50c1t5XVt4IC0gMV0pICsgYmxhY2tQb2ludHNbeSAtIDFdW3ggLSAxXSkgLyA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPCBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlTmVpZ2hib3JCbGFja1BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBibGFja1BvaW50c1t5XVt4XSA9IGF2ZXJhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsYWNrUG9pbnRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgY2xhc3MgdXNlcyA1eDUgYmxvY2tzIHRvIGNvbXB1dGUgbG9jYWwgbHVtaW5hbmNlLCB3aGVyZSBlYWNoIGJsb2NrIGlzIDh4OCBwaXhlbHMuXG4gICAgLy8gU28gdGhpcyBpcyB0aGUgc21hbGxlc3QgZGltZW5zaW9uIGluIGVhY2ggYXhpcyB3ZSBjYW4gYWNjZXB0LlxuICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSID0gMztcbiAgICBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSA9IDEgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7IC8vIC4uLjAxMDAuLi4wMFxuICAgIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0sgPSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSAtIDE7IC8vIC4uLjAwMTEuLi4xMVxuICAgIEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTiA9IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFICogNTtcbiAgICBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UgPSAyNDtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNsYXNzIGhpZXJhcmNoeSBpcyB0byBhYnN0cmFjdCBkaWZmZXJlbnQgYml0bWFwIGltcGxlbWVudGF0aW9ucyBhY3Jvc3NcbiAgICAgKiBwbGF0Zm9ybXMgaW50byBhIHN0YW5kYXJkIGludGVyZmFjZSBmb3IgcmVxdWVzdGluZyBncmV5c2NhbGUgbHVtaW5hbmNlIHZhbHVlcy4gVGhlIGludGVyZmFjZVxuICAgICAqIG9ubHkgcHJvdmlkZXMgaW1tdXRhYmxlIG1ldGhvZHM7IHRoZXJlZm9yZSBjcm9wIGFuZCByb3RhdGlvbiBjcmVhdGUgY29waWVzLiBUaGlzIGlzIHRvIGVuc3VyZVxuICAgICAqIHRoYXQgb25lIFJlYWRlciBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGx1bWluYW5jZSBzb3VyY2UgYW5kIGxlYXZlIGl0IGluIGFuIHVua25vd24gc3RhdGVcbiAgICAgKiBmb3Igb3RoZXIgUmVhZGVycyBpbiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqL1xuICAgIGNsYXNzIEx1bWluYW5jZVNvdXJjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBUaGUgd2lkdGggb2YgdGhlIGJpdG1hcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgYml0bWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBzdWJjbGFzcyBzdXBwb3J0cyBjcm9wcGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGlzQ3JvcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBjcm9wcGVkIGltYWdlIGRhdGEuIEltcGxlbWVudGF0aW9ucyBtYXkga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICogb3JpZ2luYWwgZGF0YSByYXRoZXIgdGhhbiBhIGNvcHkuIE9ubHkgY2FsbGFibGUgaWYgaXNDcm9wU3VwcG9ydGVkKCkgaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRXaWR0aCgpKVxuICAgICAgICAgKiBAcGFyYW0gdG9wIFRoZSB0b3AgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRIZWlnaHQoKSlcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXG4gICAgICAgICAqIEByZXR1cm4gQSBjcm9wcGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oJ1RoaXMgbHVtaW5hbmNlIHNvdXJjZSBkb2VzIG5vdCBzdXBwb3J0IGNyb3BwaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBzdWJjbGFzcyBzdXBwb3J0cyBjb3VudGVyLWNsb2Nrd2lzZSByb3RhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlzUm90YXRlU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA5MCBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXG4gICAgICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlQ291bnRlckNsb2Nrd2lzZSgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbignVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24gYnkgOTAgZGVncmVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCByb3RhdGVkIGltYWdlIGRhdGEgYnkgNDUgZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlLlxuICAgICAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBBIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbignVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24gYnkgNDUgZGVncmVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VSb3cgPSB0aGlzLmdldFJvdyh5LCByb3cpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZSA9IHNvdXJjZVJvd1t4XSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAobHVtaW5hbmNlIDwgMHg0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICcjJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsdW1pbmFuY2UgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJysnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGx1bWluYW5jZSA8IDB4QzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnLic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgTHVtaW5hbmNlU291cmNlfSB3aGljaCBpbnZlcnRzIHRoZSBsdW1pbmFuY2VzIGl0IHJldHVybnMgLS0gYmxhY2sgYmVjb21lc1xuICAgICAqIHdoaXRlIGFuZCB2aWNlIHZlcnNhLCBhbmQgZWFjaCB2YWx1ZSBiZWNvbWVzICgyNTUtdmFsdWUpLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSBleHRlbmRzIEx1bWluYW5jZVNvdXJjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBzdXBlcihkZWxlZ2F0ZS5nZXRXaWR0aCgpLCBkZWxlZ2F0ZS5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBnZXRSb3coeSAvKmludCovLCByb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVJvdyA9IHRoaXMuZGVsZWdhdGUuZ2V0Um93KHksIHJvdyk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNvdXJjZVJvd1tpXSA9IC8qKGJ5dGUpKi8gKDI1NSAtIChzb3VyY2VSb3dbaV0gJiAweEZGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlUm93O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0TWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5kZWxlZ2F0ZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBpbnZlcnRlZE1hdHJpeCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGludmVydGVkTWF0cml4W2ldID0gLyooYnl0ZSkqLyAoMjU1IC0gKG1hdHJpeFtpXSAmIDB4RkYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnZlcnRlZE1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGlzQ3JvcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmlzQ3JvcFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY3JvcChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBpc1JvdGF0ZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmlzUm90YXRlU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gb3JpZ2luYWwgZGVsZWdhdGUge0BsaW5rIEx1bWluYW5jZVNvdXJjZX0gc2luY2UgaW52ZXJ0IHVuZG9lcyBpdHNlbGZcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaW52ZXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICovXG4gICAgY2xhc3MgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UgZXh0ZW5kcyBMdW1pbmFuY2VTb3VyY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICAgICAgICAgIHN1cGVyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgIHRoaXMudGVtcENhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5tYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YShjYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YShjYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLnRvR3JheXNjYWxlQnVmZmVyKGltYWdlRGF0YS5kYXRhLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b0dyYXlzY2FsZUJ1ZmZlcihpbWFnZUJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgZ3JheXNjYWxlQnVmZmVyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMCwgbGVuZ3RoID0gaW1hZ2VCdWZmZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDQsIGorKykge1xuICAgICAgICAgICAgICAgIGxldCBncmF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gaW1hZ2VCdWZmZXJbaSArIDNdO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb2xvciBvZiBmdWxseS10cmFuc3BhcmVudCBwaXhlbHMgaXMgaXJyZWxldmFudC4gVGhleSBhcmUgb2Z0ZW4sIHRlY2huaWNhbGx5LCBmdWxseS10cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgIC8vIGJsYWNrICgwIGFscGhhLCBhbmQgdGhlbiAwIFJHQikuIFRoZXkgYXJlIG9mdGVuIHVzZWQsIG9mIGNvdXJzZSBhcyB0aGUgXCJ3aGl0ZVwiIGFyZWEgaW4gYVxuICAgICAgICAgICAgICAgIC8vIGJhcmNvZGUgaW1hZ2UuIEZvcmNlIGFueSBzdWNoIHBpeGVsIHRvIGJlIHdoaXRlOlxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBncmF5ID0gMHhGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsUiA9IGltYWdlQnVmZmVyW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhlbEcgPSBpbWFnZUJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsQiA9IGltYWdlQnVmZmVyW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gLjI5OVIgKyAwLjU4N0cgKyAwLjExNEIgKFlVVi9ZSVEgZm9yIFBBTCBhbmQgTlRTQyksXG4gICAgICAgICAgICAgICAgICAgIC8vICgzMDYqUikgPj4gMTAgaXMgYXBwcm94aW1hdGVseSBlcXVhbCB0byBSKjAuMjk5LCBhbmQgc28gb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIDB4MjAwID4+IDEwIGlzIDAuNSwgaXQgaW1wbGVtZW50cyByb3VuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgZ3JheSA9ICgzMDYgKiBwaXhlbFIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNjAxICogcGl4ZWxHICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDExNyAqIHBpeGVsQiArXG4gICAgICAgICAgICAgICAgICAgICAgICAweDIwMCkgPj4gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyYXlzY2FsZUJ1ZmZlcltqXSA9IGdyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JheXNjYWxlQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1JlcXVlc3RlZCByb3cgaXMgb3V0c2lkZSB0aGUgaW1hZ2U6ICcgKyB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICBpZiAocm93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgd2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgdW5kZXJseWluZyByYXN0ZXIgb2YgaW1hZ2UgY29uc2lzdHMgb2YgYnl0ZXMgd2l0aCB0aGUgbHVtaW5hbmNlIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNhbiBhdm9pZCBzZXQvc2xpY2U/XG4gICAgICAgICAgICAgICAgcm93LnNldCh0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgc3RhcnQgKyB3aWR0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY3JvcChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgc3VwZXIuY3JvcChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgYWx3YXlzIHRydWUsIHNpbmNlIHRoZSBpbWFnZSBpcyBhIGdyYXktc2NhbGUgaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNSb3RhdGVTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKCkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUoLTkwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSgpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRlKC00NSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBnZXRUZW1wQ2FudmFzRWxlbWVudCgpIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSB0aGlzLnRlbXBDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcENhbnZhc0VsZW1lbnQgPSB0aGlzLmNhbnZhcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIHRlbXBDYW52YXNFbGVtZW50LndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMudGVtcENhbnZhc0VsZW1lbnQgPSB0ZW1wQ2FudmFzRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBDYW52YXNFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0ZShhbmdsZSkge1xuICAgICAgICAgICAgY29uc3QgdGVtcENhbnZhc0VsZW1lbnQgPSB0aGlzLmdldFRlbXBDYW52YXNFbGVtZW50KCk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQ29udGV4dCA9IHRlbXBDYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBhbmdsZSAqIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLkRFR1JFRV9UT19SQURJQU5TO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBzZXQgbmV3IGRpbWVuc2lvbnMgZm9yIHRlbXAgY2FudmFzXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLmNlaWwoTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSkgKiB3aWR0aCArIE1hdGguYWJzKE1hdGguc2luKGFuZ2xlUmFkaWFucykpICogaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGguY2VpbChNYXRoLmFicyhNYXRoLnNpbihhbmdsZVJhZGlhbnMpKSAqIHdpZHRoICsgTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSkgKiBoZWlnaHQpO1xuICAgICAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIHRlbXBDYW52YXNFbGVtZW50LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIC8vIERyYXcgYXQgY2VudGVyIG9mIHRlbXAgY2FudmFzIHRvIHByZXZlbnQgY2xpcHBpbmcgb2YgaW1hZ2UgZGF0YVxuICAgICAgICAgICAgdGVtcENvbnRleHQudHJhbnNsYXRlKG5ld1dpZHRoIC8gMiwgbmV3SGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB0ZW1wQ29udGV4dC5yb3RhdGUoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgICAgIHRlbXBDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgd2lkdGggLyAtMiwgaGVpZ2h0IC8gLTIpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5tYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YSh0ZW1wQ2FudmFzRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpbnZlcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLkRFR1JFRV9UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqXG4gICAgICogVmlkZW8gaW5wdXQgZGV2aWNlIG1ldGFkYXRhIGNvbnRhaW5pbmcgdGhlIGlkIGFuZCBsYWJlbCBvZiB0aGUgZGV2aWNlIGlmIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBjbGFzcyBWaWRlb0lucHV0RGV2aWNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVmlkZW9JbnB1dERldmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIHRoZSB2aWRlbyBpbnB1dCBkZXZpY2UgaWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIHRoZSBsYWJlbCBvZiB0aGUgZGV2aWNlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZGV2aWNlSWQsIGxhYmVsLCBncm91cElkKSB7XG4gICAgICAgICAgICB0aGlzLmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICAgICAgICAgIHRoaXMua2luZCA9ICd2aWRlb2lucHV0JztcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICAgICAgICBncm91cElkOiB0aGlzLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9fYXdhaXRlciA9ICgoZ2xvYmFsVGhpcyB8fCBnbG9iYWwgfHwgc2VsZiB8fCB3aW5kb3cgfHwgdW5kZWZpbmVkKSAmJiAoZ2xvYmFsVGhpcyB8fCBnbG9iYWwgfHwgc2VsZiB8fCB3aW5kb3cgfHwgdW5kZWZpbmVkKS5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgYnJvd3NlciBjb2RlIHJlYWRlci5cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJDb2RlUmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge1JlYWRlcn0gcmVhZGVyIFRoZSByZWFkZXIgaW5zdGFuY2UgdG8gZGVjb2RlIHRoZSBiYXJjb2RlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBzdWNjZXNzZnVsIGRlY29kZSB0cmllc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCwgX2hpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgICAgIHRoaXMudGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXM7XG4gICAgICAgICAgICB0aGlzLl9oaW50cyA9IF9oaW50cztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGJyZWFrIHRoZSBsb29wLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3N0b3BBc3luY0RlY29kZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWxheSB0aW1lIGJldHdlZW4gZGVjb2RlIGF0dGVtcHRzIG1hZGUgYnkgdGhlIHNjYW5uZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5hdmlnYXRvciBpcyBwcmVzZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGhhc05hdmlnYXRvcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbWVkaWFEZXZpY2VzIHVuZGVyIG5hdmlnYXRvciBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaXNNZWRpYURldmljZXNTdXBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc05hdmlnYXRvciAmJiAhIW5hdmlnYXRvci5tZWRpYURldmljZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVudW1lcmF0ZURldmljZXMgdW5kZXIgbmF2aWdhdG9yIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjYW5FbnVtZXJhdGVEZXZpY2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuaXNNZWRpYURldmljZXNTdXBvcnRlZCAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaW1lIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzIGluIG1pbGxpIHNlY29uZHMuICovXG4gICAgICAgIGdldCB0aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgdGhlIHRpbWUgc3BhbiB0aGUgZGVjb2RlciB3YWl0cyBiZXR3ZWVuIHR3byBkZWNvZGluZyB0cmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyBUaW1lIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzIGluIG1pbGxpIHNlY29uZHMuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQgdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzKG1pbGxpcykge1xuICAgICAgICAgICAgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzID0gbWlsbGlzIDwgMCA/IDAgOiBtaWxsaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0IGhpbnRzKGhpbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9oaW50cyA9IGhpbnRzIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGhpbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hpbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBhbGwgdGhlIGF2YWlsYWJsZSB2aWRlbyBpbnB1dCBkZXZpY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFZpZGVvSW5wdXREZXZpY2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzTmF2aWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBlbnVtZXJhdGUgZGV2aWNlcywgbmF2aWdhdG9yIGlzIG5vdCBwcmVzZW50LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2FuRW51bWVyYXRlRGV2aWNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgZW51bWVyYXRlIGRldmljZXMsIG1ldGhvZCBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW9EZXZpY2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXZpY2Ugb2YgZGV2aWNlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gZGV2aWNlLmtpbmQgPT09ICd2aWRlbycgPyAndmlkZW9pbnB1dCcgOiBkZXZpY2Uua2luZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBkZXZpY2UuZGV2aWNlSWQgfHwgZGV2aWNlLmlkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRldmljZS5sYWJlbCB8fCBgVmlkZW8gZGV2aWNlICR7dmlkZW9EZXZpY2VzLmxlbmd0aCArIDF9YDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJZCA9IGRldmljZS5ncm91cElkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWRlb0RldmljZSA9IHsgZGV2aWNlSWQsIGxhYmVsLCBraW5kLCBncm91cElkIH07XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvRGV2aWNlcy5wdXNoKHZpZGVvRGV2aWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvRGV2aWNlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnRhaW4gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGRldmljZXMgd2l0aCB0eXBlICd2aWRlb2lucHV0Jy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8VmlkZW9JbnB1dERldmljZVtdPn0gYW4gYXJyYXkgb2YgYXZhaWxhYmxlIHZpZGVvIGlucHV0IGRldmljZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgbGlzdFZpZGVvSW5wdXREZXZpY2VzYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmlkZW9JbnB1dERldmljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZXMgPSB5aWVsZCB0aGlzLmxpc3RWaWRlb0lucHV0RGV2aWNlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXZpY2VzLm1hcChkID0+IG5ldyBWaWRlb0lucHV0RGV2aWNlKGQuZGV2aWNlSWQsIGQubGFiZWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZXQncyB5b3UgZmluZCBhIGRldmljZSB1c2luZyBpdCdzIElkLlxuICAgICAgICAgKi9cbiAgICAgICAgZmluZERldmljZUJ5SWQoZGV2aWNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMubGlzdFZpZGVvSW5wdXREZXZpY2VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlcy5maW5kKHggPT4geC5kZXZpY2VJZCA9PT0gZGV2aWNlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2VJZCB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHZpZGVvIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZU9uY2VGcm9tVmlkZW9EZXZpY2VgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2VJZCB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHZpZGVvIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlT25jZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGxldCB2aWRlb0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkIH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7IHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZUZyb21Db25zdHJhaW50cyhjb25zdHJhaW50cywgdmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSBhIHN0cmVhbSBvYnRhaW5lZCBmcm9tIHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25zdHJhaW50cyB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0gdmlkZW8gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gW2NvbnN0cmFpbnRzXSB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlT25jZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW8gPSB5aWVsZCB0aGlzLmF0dGFjaFN0cmVhbVRvVmlkZW8oc3RyZWFtLCB2aWRlb1NvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5kZWNvZGVPbmNlKHZpZGVvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRpbnVvdXNseSBkZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW2RldmljZUlkXSB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxudWxsfSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGBkZWNvZGVGcm9tVmlkZW9EZXZpY2VgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZUNvbnRpbnVvdXNseShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlRnJvbVZpZGVvRGV2aWNlKGRldmljZUlkLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGludW91c2x5IHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIHRoZSBkZXZpY2Ugc3BlY2lmaWVkIGJ5IGRldmljZSB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtkZXZpY2VJZF0gdGhlIGlkIG9mIG9uZSBvZiB0aGUgZGV2aWNlcyBvYnRhaW5lZCBhZnRlciBjYWxsaW5nIGdldFZpZGVvSW5wdXREZXZpY2VzLiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB0aGlzIGNhc2UgaXQgd2lsbCBkZWNvZGUgZnJvbSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLCBwcmVmZmVyaW5nIHRoZSBtYWluIGNhbWVyYSAoZW52aXJvbm1lbnQgZmFjaW5nKSBpZiBhdmFpbGFibGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR8bnVsbH0gW3ZpZGVvXSB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW9EZXZpY2UoZGV2aWNlSWQsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCB2aWRlb0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHsgZGV2aWNlSWQ6IHsgZXhhY3Q6IGRldmljZUlkIH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7IHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGludW91c2x5IHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gW2NvbnN0cmFpbnRzXSB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBvbmUgYXR0ZW1wdCwgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tU3RyZWFtKHN0cmVhbSwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvID0geWllbGQgdGhpcy5hdHRhY2hTdHJlYW1Ub1ZpZGVvKHN0cmVhbSwgdmlkZW9Tb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmRlY29kZUNvbnRpbnVvdXNseSh2aWRlbywgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQnJlYWtzIHRoZSBkZWNvZGluZyBsb29wLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEFzeW5jRGVjb2RlKCkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQnJlYWtzIHRoZSBkZWNvZGluZyBsb29wLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcENvbnRpbnVvdXNEZWNvZGUoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG5ldyBzdHJlYW0gYW5kIHJlcXVlc3QgYSBuZXcgZGVjb2Rpbmctd2l0aC1kZWxheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0cmVhbSBUaGUgc3RyZWFtIHRvIGJlIHNob3duIGluIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gZGVjb2RlRm4gQSBjYWxsYmFjayBmb3IgdGhlIGRlY29kZSBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICBhdHRhY2hTdHJlYW1Ub1ZpZGVvKHN0cmVhbSwgdmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KHZpZGVvU291cmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFZpZGVvU291cmNlKHZpZGVvRWxlbWVudCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHZpZGVvRWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvRWxlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBwbGF5VmlkZW9PbkxvYWRBc3luYyh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB0aGlzLnBsYXlWaWRlb09uTG9hZCh2aWRlb0VsZW1lbnQsICgpID0+IHJlc29sdmUoKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBsaXN0ZW5lcnMgYW5kIGNhbGxiYWNrcyB0byB0aGUgdmlkZW9FbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tGblxuICAgICAgICAgKi9cbiAgICAgICAgcGxheVZpZGVvT25Mb2FkKGVsZW1lbnQsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyID0gKCkgPT4gdGhpcy5zdG9wU3RyZWFtcygpO1xuICAgICAgICAgICAgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lciA9ICgpID0+IHRoaXMudHJ5UGxheVZpZGVvKGVsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIHRoaXMudmlkZW9DYW5QbGF5TGlzdGVuZXIpO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICAvLyBpZiBjYW5wbGF5IHdhcyBhbHJlYWR5IGZpcmVkLCB3ZSB3b24ndCBrbm93IHdoZW4gdG8gcGxheSwgc28ganVzdCBnaXZlIGl0IGEgdHJ5XG4gICAgICAgICAgICB0aGlzLnRyeVBsYXlWaWRlbyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2aWRlbyBlbGVtZW50IGlzIGN1cnJlbnRseSBwbGF5aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNWaWRlb1BsYXlpbmcodmlkZW8pIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlby5jdXJyZW50VGltZSA+IDAgJiYgIXZpZGVvLnBhdXNlZCAmJiAhdmlkZW8uZW5kZWQgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEp1c3QgdHJpZXMgdG8gcGxheSB0aGUgdmlkZW8gYW5kIGxvZ3MgYW55IGVycm9ycy5cbiAgICAgICAgICogVGhlIHBsYXkgY2FsbCBpcyBvbmx5IG1hZGUgaXMgdGhlIHZpZGVvIGlzIG5vdCBhbHJlYWR5IHBsYXlpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0cnlQbGF5VmlkZW8odmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5aW5nKHZpZGVvRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUcnlpbmcgdG8gcGxheSB2aWRlbyB0aGF0IGlzIGFscmVhZHkgcGxheWluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB2aWRlb0VsZW1lbnQucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJdCB3YXMgbm90IHBvc3NpYmxlIHRvIHBsYXkgdGhlIHZpZGVvLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWFyY2hlcyBhbmQgdmFsaWRhdGVzIGEgbWVkaWEgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldE1lZGlhRWxlbWVudChtZWRpYUVsZW1lbnRJZCwgdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVkaWFFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWVkaWFFbGVtZW50SWQpO1xuICAgICAgICAgICAgaWYgKCFtZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oYGVsZW1lbnQgd2l0aCBpZCAnJHttZWRpYUVsZW1lbnRJZH0nIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSB0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oYGVsZW1lbnQgd2l0aCBpZCAnJHttZWRpYUVsZW1lbnRJZH0nIG11c3QgYmUgYW4gJHt0eXBlfSBlbGVtZW50YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVkaWFFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsXVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21JbWFnZShzb3VyY2UsIHVybCkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UgJiYgIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignZWl0aGVyIGltYWdlRWxlbWVudCB3aXRoIGEgc3JjIHNldCBvciBhbiB1cmwgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVybCAmJiAhc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbUltYWdlVXJsKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tSW1hZ2VFbGVtZW50KHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSBhIHZpZGVvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8SFRNTEltYWdlRWxlbWVudCl9IFtzb3VyY2VdIFRoZSBpbWFnZSBlbGVtZW50IHRoYXQgY2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIHRoZSBlbGVtZW50IGl0c2VsZi4gQ2FuIGJlIHVuZGVmaW5lZCBpbiB3aGljaCBjYXNlIHRoZSBkZWNvZGluZyB3aWxsIGJlIGRvbmUgZnJvbSB0aGUgaW1hZ2VVcmwgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW8oc291cmNlLCB1cmwpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlICYmICF1cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oJ0VpdGhlciBhbiBlbGVtZW50IHdpdGggYSBzcmMgc2V0IG9yIGFuIFVSTCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tVmlkZW9VcmwodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnQoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBjb250aW51b3VzbHkgdGhlIGJhcmNvZGUgZnJvbSBhIHZpZGVvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyhzdHJpbmd8SFRNTEltYWdlRWxlbWVudCl9IFtzb3VyY2VdIFRoZSBpbWFnZSBlbGVtZW50IHRoYXQgY2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIHRoZSBlbGVtZW50IGl0c2VsZi4gQ2FuIGJlIHVuZGVmaW5lZCBpbiB3aGljaCBjYXNlIHRoZSBkZWNvZGluZyB3aWxsIGJlIGRvbmUgZnJvbSB0aGUgaW1hZ2VVcmwgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF1cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb0NvbnRpbnVvdXNseShzb3VyY2UsIHVybCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gc291cmNlICYmIHVuZGVmaW5lZCA9PT0gdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdFaXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3JjIHNldCBvciBhbiBVUkwgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVybCAmJiAhc291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvVXJsQ29udGludW91c2x5KHVybCwgY2FsbGJhY2tGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tVmlkZW9FbGVtZW50Q29udGludW91c2x5KHNvdXJjZSwgY2FsbGJhY2tGbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbUltYWdlRWxlbWVudChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBpbWFnZSBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlSW1hZ2VFbGVtZW50KHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW1hZ2VMb2FkZWQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrID0gdGhpcy5kZWNvZGVPbmNlKGVsZW1lbnQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhc2sgPSB0aGlzLl9kZWNvZGVPbkxvYWRJbWFnZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIHNvbWV0aGluZyBmcm9tIGFuIGltYWdlIEhUTUwgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb0VsZW1lbnQoc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZGVjb2RlRnJvbVZpZGVvRWxlbWVudFNldHVwKHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlT25Mb2FkVmlkZW8oZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseShzb3VyY2UsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAoc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVPbkxvYWRWaWRlb0NvbnRpbnVvdXNseShlbGVtZW50LCBjYWxsYmFja0ZuKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB1cCB0aGUgdmlkZW8gc291cmNlIHNvIGl0IGNhbiBiZSBkZWNvZGVkIHdoZW4gbG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc291cmNlIFRoZSB2aWRlbyBzb3VyY2UgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIF9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignQSB2aWRlbyBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KHNvdXJjZSk7XG4gICAgICAgICAgICAvLyBkZWZpbmVzIHRoZSB2aWRlbyBlbGVtZW50IGJlZm9yZSBzdGFydHMgZGVjb2RpbmdcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIGltYWdlIGZyb20gYSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tSW1hZ2VVcmwodXJsKSB7XG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignQW4gVVJMIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlSW1hZ2VFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVUYXNrID0gdGhpcy5fZGVjb2RlT25Mb2FkSW1hZ2UoZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIGltYWdlIGZyb20gYSBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVGcm9tVmlkZW9VcmwodXJsKSB7XG4gICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbignQW4gVVJMIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAvLyBjcmVhdGVzIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByZXBhcmVWaWRlb0VsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVRhc2sgPSB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIGltYWdlIGZyb20gYSBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUZyb21WaWRlb1VybENvbnRpbnVvdXNseSh1cmwsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlVGFzayA9IHRoaXMuZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseShlbGVtZW50LCBjYWxsYmFja0ZuKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3JjID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgX2RlY29kZU9uTG9hZEltYWdlKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyID0gKCkgPT4gdGhpcy5kZWNvZGVPbmNlKGVsZW1lbnQsIGZhbHNlLCB0cnVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9kZWNvZGVPbkxvYWRWaWRlbyh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcGxheXMgdGhlIHZpZGVvXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wbGF5VmlkZW9PbkxvYWRBc3luYyh2aWRlb0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0cyBkZWNvZGluZyBhZnRlciBwbGF5ZWQgdGhlIHZpZGVvXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZGVjb2RlT25jZSh2aWRlb0VsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2RlY29kZU9uTG9hZFZpZGVvQ29udGludW91c2x5KHZpZGVvRWxlbWVudCwgY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBwbGF5cyB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnRzIGRlY29kaW5nIGFmdGVyIHBsYXllZCB0aGUgdmlkZW9cbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUNvbnRpbnVvdXNseSh2aWRlb0VsZW1lbnQsIGNhbGxiYWNrRm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNJbWFnZUxvYWRlZChpbWcpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyB0aGUgb25sb2FkIGV2ZW50LCBJRSBjb3JyZWN0bHkgaWRlbnRpZmllcyBhbnkgaW1hZ2VzIHRoYXRcbiAgICAgICAgICAgIC8vIHdlcmVu4oCZdCBkb3dubG9hZGVkIGFzIG5vdCBjb21wbGV0ZS4gT3RoZXJzIHNob3VsZCB0b28uIEdlY2tvLWJhc2VkXG4gICAgICAgICAgICAvLyBicm93c2VycyBhY3QgbGlrZSBOUzQgaW4gdGhhdCB0aGV5IHJlcG9ydCB0aGlzIGluY29ycmVjdGx5LlxuICAgICAgICAgICAgaWYgKCFpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGV5IGRvIGhhdmUgdHdvIHZlcnkgdXNlZnVsIHByb3BlcnRpZXM6IG5hdHVyYWxXaWR0aCBhbmRcbiAgICAgICAgICAgIC8vIG5hdHVyYWxIZWlnaHQuIFRoZXNlIGdpdmUgdGhlIHRydWUgc2l6ZSBvZiB0aGUgaW1hZ2UuIElmIGl0IGZhaWxlZFxuICAgICAgICAgICAgLy8gdG8gbG9hZCwgZWl0aGVyIG9mIHRoZXNlIHNob3VsZCBiZSB6ZXJvLlxuICAgICAgICAgICAgaWYgKGltZy5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBvdGhlciB3YXkgb2YgY2hlY2tpbmc6IGFzc3VtZSBpdOKAmXMgb2suXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KGltYWdlU291cmNlKSB7XG4gICAgICAgICAgICBsZXQgaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVNvdXJjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQud2lkdGggPSAyMDA7XG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50LmhlaWdodCA9IDIwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW1hZ2VTb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VFbGVtZW50ID0gdGhpcy5nZXRNZWRpYUVsZW1lbnQoaW1hZ2VTb3VyY2UsICdpbWcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbWFnZVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSBpbWFnZVNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYSBIVE1MVmlkZW9FbGVtZW50IGZvciBzY2FubmluZyBvciBjcmVhdGVzIGEgbmV3IG9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvU291cmNlIFRoZSBIVE1MVmlkZW9FbGVtZW50IHRvIGJlIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVWaWRlb0VsZW1lbnQodmlkZW9Tb3VyY2UpIHtcbiAgICAgICAgICAgIGxldCB2aWRlb0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXZpZGVvU291cmNlICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC53aWR0aCA9IDIwMDtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuaGVpZ2h0ID0gMjAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2aWRlb1NvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSB0aGlzLmdldE1lZGlhRWxlbWVudCh2aWRlb1NvdXJjZSwgJ3ZpZGVvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlkZW9Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50ID0gdmlkZW9Tb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZWVkZWQgZm9yIGlPUyAxMVxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZXMgdG8gZGVjb2RlIGZyb20gdGhlIHZpZGVvIGlucHV0IHVudGlsIGl0IGZpbmRzIHNvbWUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVPbmNlKGVsZW1lbnQsIHJldHJ5SWZOb3RGb3VuZCA9IHRydWUsIHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQXN5bmNEZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BBc3luY0RlY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdWaWRlbyBzdHJlYW0gaGFzIGVuZGVkIGJlZm9yZSBhbnkgY29kZSBjb3VsZCBiZSBkZXRlY3RlZC4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BBc3luY0RlY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZk5vdEZvdW5kID0gcmV0cnlJZk5vdEZvdW5kICYmIGUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSBlIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb24gfHwgZSBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWZDaGVja3N1bU9yRm9ybWF0ID0gaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgJiYgcmV0cnlJZkNoZWNrc3VtT3JGb3JtYXRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlmTm90Rm91bmQgfHwgaWZDaGVja3N1bU9yRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGxvb3AsIHRoaXMuX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBsb29wKHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250aW51b3VzbHkgZGVjb2RlcyBmcm9tIHZpZGVvIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQ29udGludW91c2x5KGVsZW1lbnQsIGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBsb29wID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQ29udGludW91c0RlY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRlY29kZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tGbihyZXN1bHQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AsIHRoaXMudGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrRm4obnVsbCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hlY2tzdW1PckZvcm1hdEVycm9yID0gZSBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uIHx8IGUgaW5zdGFuY2VvZiBGb3JtYXRFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTm90Rm91bmQgPSBlIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciB8fCBpc05vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcCwgdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb29wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIEJpbmFyeUJpdG1hcCBmb3IgeWEhIChhbmQgZGVjb2RlcyBpdClcbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBnZXQgYmluYXJ5IGJpdG1hcCBmb3IgZGVjb2RlIGZ1bmN0aW9uXG4gICAgICAgICAgICBjb25zdCBiaW5hcnlCaXRtYXAgPSB0aGlzLmNyZWF0ZUJpbmFyeUJpdG1hcChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJpdG1hcChiaW5hcnlCaXRtYXApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgbWVkaWEgZWxlbWVudCBpcyBpbmRlZWQgYSB7QGxpbmsgSHRtbFZpZGVvRWxlbWVudH0uXG4gICAgICAgICAqL1xuICAgICAgICBfaXNIVE1MVmlkZW9FbGVtZW50KG1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsVmlkZW8gPSBtZWRpYUVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsVmlkZW8udmlkZW9XaWR0aCAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXRpbmcgdGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIG5leHQgZnJhbWUgaW4gYW55d2F5XG4gICAgICAgICAqIHlvdSB3YW50IGJlZm9yZSBkZWNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3RnJhbWVPbkNhbnZhcyhcbiAgICAgICAgICAgIHNyY0VsZW1lbnQsIGRpbWVuc2lvbnMsIGNhbnZhc0VsZW1lbnRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBzeDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNXaWR0aDogc3JjRWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgICAgICAgICAgICAgICBzSGVpZ2h0OiBzcmNFbGVtZW50LnZpZGVvSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgZHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRXaWR0aDogc3JjRWxlbWVudC52aWRlb1dpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkSGVpZ2h0OiBzcmNFbGVtZW50LnZpZGVvSGVpZ2h0fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FudmFzRWxlbWVudENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dCA9IHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnN4LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc3ksXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zV2lkdGgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZHgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5keSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmRXaWR0aCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmV3cml0aW5nIHRoaXMgYWxsb3dzIHlvdSB0byBtYW5pcHVsYXRlIHRoZSBzbmFwc2hvdCBpbWFnZSBpbiBhbnl3YXlcbiAgICAgICAgICogIHlvdSB3YW50IGJlZm9yZSBkZWNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3SW1hZ2VPbkNhbnZhcyhcbiAgICAgICAgICAgIHNyY0VsZW1lbnQsXG4gICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgY2FudmFzRWxlbWVudENvbnRleHQgPSB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBzeDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3k6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNXaWR0aDogc3JjRWxlbWVudC5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHNIZWlnaHQ6IHNyY0VsZW1lbnQubmF0dXJhbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIGR5OiAwLFxuICAgICAgICAgICAgICAgICAgICBkV2lkdGg6IHNyY0VsZW1lbnQubmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkSGVpZ2h0OiBzcmNFbGVtZW50Lm5hdHVyYWxIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW52YXNFbGVtZW50Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0ID0gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnRDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICBzcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc3gsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5zeSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNXaWR0aCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5keCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmR5LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZFdpZHRoLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBiaW5hcnlCaXRtYXAgYmFzZWQgaW4gc29tZSBpbWFnZSBzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtZWRpYUVsZW1lbnQgSFRNTCBlbGVtZW50IGNvbnRhaW5pbmcgZHJhd2FibGUgaW1hZ2Ugc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQmluYXJ5Qml0bWFwKG1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5nZXRDYXB0dXJlQ2FudmFzQ29udGV4dChtZWRpYUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSFRNTFZpZGVvRWxlbWVudChtZWRpYUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3RnJhbWVPbkNhbnZhcyhtZWRpYUVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbWFnZU9uQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGx1bWluYW5jZVNvdXJjZSA9IG5ldyBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZShjYW52YXMpO1xuICAgICAgICAgICAgY29uc3QgaHlicmlkQmluYXJpemVyID0gbmV3IEh5YnJpZEJpbmFyaXplcihsdW1pbmFuY2VTb3VyY2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcChoeWJyaWRCaW5hcml6ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0Q2FwdHVyZUNhbnZhc0NvbnRleHQobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5nZXRDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gZWxlbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQgPSBjdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZXRDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5jcmVhdGVDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzID0gZWxlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcHR1cmVDYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgdGhlIGVuY2Fwc3VsYXRlZCByZWFkZXJzIGRlY29kZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQml0bWFwKGJpbmFyeUJpdG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmRlY29kZShiaW5hcnlCaXRtYXAsIHRoaXMuX2hpbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICog8J+WjCBQcmVwYXJlcyB0aGUgY2FudmFzIGZvciBjYXB0dXJlIGFuZCBzY2FuIGZyYW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYXB0dXJlQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZWRpYUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBtZWRpYUVsZW1lbnQudmlkZW9XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWVkaWFFbGVtZW50LnZpZGVvSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZWRpYUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gbWVkaWFFbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBtZWRpYUVsZW1lbnQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IG1lZGlhRWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IG1lZGlhRWxlbWVudC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHRoZSBjb250aW51b3VzIHNjYW4gYW5kIGNsZWFucyB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcFN0cmVhbXMoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcEFzeW5jRGVjb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFzeW5jRGVjb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQ29udGludW91c0RlY29kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGNvZGUgcmVhZGVyIHRvIHRoZSBpbml0aWFsIHN0YXRlLiBDYW5jZWxzIGFueSBvbmdvaW5nIGJhcmNvZGUgc2Nhbm5pbmcgZnJvbSB2aWRlbyBvciBjYW1lcmEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAvLyBzdG9wcyB0aGUgY2FtZXJhLCBwcmV2aWV3IGFuZCBzY2FuIPCflLRcbiAgICAgICAgICAgIHRoaXMuc3RvcFN0cmVhbXMoKTtcbiAgICAgICAgICAgIC8vIGNsZWFuIGFuZCBmb3JnZXQgYWJvdXQgSFRNTCBlbGVtZW50c1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVZpZGVvRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUltYWdlRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUNhcHR1cmVDYW52YXMoKTtcbiAgICAgICAgfVxuICAgICAgICBfZGVzdHJveVZpZGVvRWxlbWVudCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy52aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaXJzdCBnaXZlcyBmcmVlZG9uIHRvIHRoZSBlbGVtZW50IPCflYpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLnZpZGVvRW5kZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudmlkZW9QbGF5aW5nRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy52aWRlb1BsYXlpbmdFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIHRoaXMudmlkZW9DYW5QbGF5TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBmb3JnZXRzIGFib3V0IHRoYXQgZWxlbWVudCDwn5iiXG4gICAgICAgICAgICB0aGlzLmNsZWFuVmlkZW9Tb3VyY2UodGhpcy52aWRlb0VsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgX2Rlc3Ryb3lJbWFnZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmlyc3QgZ2l2ZXMgZnJlZWRvbiB0byB0aGUgZWxlbWVudCDwn5WKXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSB0aGlzLmltYWdlTG9hZGVkTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZW4gZm9yZ2V0IGFib3V0IHRoYXQgZWxlbWVudCDwn5iiXG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zcmMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFucyBjYW52YXMgcmVmZXJlbmNlcyDwn5aMXG4gICAgICAgICAqL1xuICAgICAgICBfZGVzdHJveUNhcHR1cmVDYW52YXMoKSB7XG4gICAgICAgICAgICAvLyB0aGVuIGZvcmdldCBhYm91dCB0aGF0IGVsZW1lbnQg8J+YolxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUNhbnZhcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGF0IHRoZSB2aWRlb0VsZW1lbnQgc3JjIHdpbGwgYmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHN0cmVhbVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkVmlkZW9Tb3VyY2UodmlkZW9FbGVtZW50LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG1heSBub3QgaGF2ZSBgc3JjT2JqZWN0YFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBAbm90ZSBUaHJvd3MgRXhjZXB0aW9uIGlmIGludGVycnVwdGVkIGJ5IGEgbmV3IGxvYWRlZCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBAbm90ZSBBdm9pZCB1c2luZyB0aGlzIGluIG5ldyBicm93c2VycywgYXMgaXQgaXMgZ29pbmcgYXdheS5cbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmJpbmRzIGEgSFRNTCB2aWRlbyBzcmMgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFuVmlkZW9Tb3VyY2UodmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmMgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGRlY29kaW5nIGEgYmFyY29kZSB3aXRoaW4gYW4gaW1hZ2UuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBSZXN1bHQge1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSB0ZXh0OiBzdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgVWludDhBcnJheSByYXdCeXRlcyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBSZXN1bHRQb2NvbnN0IHJlc3VsdFBvaW50czogSW50MzJBcnJheSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICBCYXJjb2RlRm9ybWF0IGZvcm1hdCkge1xuICAgICAgICAvLyAgIHRoaXModGV4dCwgcmF3Qnl0ZXMsIHJlc3VsdFBvaW50cywgZm9ybWF0LCBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKSlcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IodGV4dDogc3RyaW5nLFxuICAgICAgICAvLyAgICAgICAgICAgICAgIFVpbnQ4QXJyYXkgcmF3Qnl0ZXMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgUmVzdWx0UG9jb25zdCByZXN1bHRQb2ludHM6IEludDMyQXJyYXksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgQmFyY29kZUZvcm1hdCBmb3JtYXQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgbG9uZyB0aW1lc3RhbXApIHtcbiAgICAgICAgLy8gICB0aGlzKHRleHQsIHJhd0J5dGVzLCByYXdCeXRlcyA9PSBudWxsID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGgsXG4gICAgICAgIC8vICAgICAgICByZXN1bHRQb2ludHMsIGZvcm1hdCwgdGltZXN0YW1wKVxuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKHRleHQsIHJhd0J5dGVzLCBudW1CaXRzID0gcmF3Qnl0ZXMgPT0gbnVsbCA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoLCByZXN1bHRQb2ludHMsIGZvcm1hdCwgdGltZXN0YW1wID0gU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aGlzLnJhd0J5dGVzID0gcmF3Qnl0ZXM7XG4gICAgICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSByZXN1bHRQb2ludHM7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMucmF3Qnl0ZXMgPSByYXdCeXRlcztcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IG51bUJpdHMgfHwgbnVsbCA9PT0gbnVtQml0cykge1xuICAgICAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IChyYXdCeXRlcyA9PT0gbnVsbCB8fCByYXdCeXRlcyA9PT0gdW5kZWZpbmVkKSA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1CaXRzID0gbnVtQml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gcmVzdWx0UG9pbnRzO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRpbWVzdGFtcCB8fCBudWxsID09PSB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcmF3IHRleHQgZW5jb2RlZCBieSB0aGUgYmFyY29kZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gcmF3IGJ5dGVzIGVuY29kZWQgYnkgdGhlIGJhcmNvZGUsIGlmIGFwcGxpY2FibGUsIG90aGVyd2lzZSB7QGNvZGUgbnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3Qnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gaG93IG1hbnkgYml0cyBvZiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9IGFyZSB2YWxpZDsgdHlwaWNhbGx5IDggdGltZXMgaXRzIGxlbmd0aFxuICAgICAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgICAgICovXG4gICAgICAgIGdldE51bUJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHBvaW50cyByZWxhdGVkIHRvIHRoZSBiYXJjb2RlIGluIHRoZSBpbWFnZS4gVGhlc2UgYXJlIHR5cGljYWxseSBwb2ludHNcbiAgICAgICAgICogICAgICAgICBpZGVudGlmeWluZyBmaW5kZXIgcGF0dGVybnMgb3IgdGhlIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUuIFRoZSBleGFjdCBtZWFuaW5nIGlzXG4gICAgICAgICAqICAgICAgICAgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgYmFyY29kZSB0aGF0IHdhcyBkZWNvZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVzdWx0UG9pbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0UG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBCYXJjb2RlRm9ybWF0fSByZXByZXNlbnRpbmcgdGhlIGZvcm1hdCBvZiB0aGUgYmFyY29kZSB0aGF0IHdhcyBkZWNvZGVkXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYXJjb2RlRm9ybWF0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBNYXB9IG1hcHBpbmcge0BsaW5rIFJlc3VsdE1ldGFkYXRhVHlwZX0ga2V5cyB0byB2YWx1ZXMuIE1heSBiZVxuICAgICAgICAgKiAgIHtAY29kZSBudWxsfS4gVGhpcyBjb250YWlucyBvcHRpb25hbCBtZXRhZGF0YSBhYm91dCB3aGF0IHdhcyBkZXRlY3RlZCBhYm91dCB0aGUgYmFyY29kZSxcbiAgICAgICAgICogICBsaWtlIG9yaWVudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVzdWx0TWV0YWRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBwdXRNZXRhZGF0YSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0TWV0YWRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHRNZXRhZGF0YS5zZXQodHlwZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHB1dEFsbE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRNZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbmV3IE1hcChtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZFJlc3VsdFBvaW50cyhuZXdQb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFBvaW50cyA9IHRoaXMucmVzdWx0UG9pbnRzO1xuICAgICAgICAgICAgaWYgKG9sZFBvaW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gbmV3UG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3UG9pbnRzICE9PSBudWxsICYmIG5ld1BvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsUG9pbnRzID0gbmV3IEFycmF5KG9sZFBvaW50cy5sZW5ndGggKyBuZXdQb2ludHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KG9sZFBvaW50cywgMCwgYWxsUG9pbnRzLCAwLCBvbGRQb2ludHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KG5ld1BvaW50cywgMCwgYWxsUG9pbnRzLCBvbGRQb2ludHMubGVuZ3RoLCBuZXdQb2ludHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IGFsbFBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRUaW1lc3RhbXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIERpcmVjdCBwb3J0IHRvIFR5cGVTY3JpcHQgb2YgWlhpbmcgYnkgQWRyaWFuIFRvyJljxINcbiAgICAgKi9cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogRW51bWVyYXRlcyBiYXJjb2RlIGZvcm1hdHMga25vd24gdG8gdGhpcyBwYWNrYWdlLiBQbGVhc2Uga2VlcCBhbHBoYWJldGl6ZWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIHZhciBCYXJjb2RlRm9ybWF0O1xuICAgIChmdW5jdGlvbiAoQmFyY29kZUZvcm1hdCkge1xuICAgICAgICAvKiogQXp0ZWMgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkFaVEVDXCJdID0gMF0gPSBcIkFaVEVDXCI7XG4gICAgICAgIC8qKiBDT0RBQkFSIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09EQUJBUlwiXSA9IDFdID0gXCJDT0RBQkFSXCI7XG4gICAgICAgIC8qKiBDb2RlIDM5IDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09ERV8zOVwiXSA9IDJdID0gXCJDT0RFXzM5XCI7XG4gICAgICAgIC8qKiBDb2RlIDkzIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09ERV85M1wiXSA9IDNdID0gXCJDT0RFXzkzXCI7XG4gICAgICAgIC8qKiBDb2RlIDEyOCAxRCBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkNPREVfMTI4XCJdID0gNF0gPSBcIkNPREVfMTI4XCI7XG4gICAgICAgIC8qKiBEYXRhIE1hdHJpeCAyRCBiYXJjb2RlIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiREFUQV9NQVRSSVhcIl0gPSA1XSA9IFwiREFUQV9NQVRSSVhcIjtcbiAgICAgICAgLyoqIEVBTi04IDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiRUFOXzhcIl0gPSA2XSA9IFwiRUFOXzhcIjtcbiAgICAgICAgLyoqIEVBTi0xMyAxRCBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkVBTl8xM1wiXSA9IDddID0gXCJFQU5fMTNcIjtcbiAgICAgICAgLyoqIElURiAoSW50ZXJsZWF2ZWQgVHdvIG9mIEZpdmUpIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiSVRGXCJdID0gOF0gPSBcIklURlwiO1xuICAgICAgICAvKiogTWF4aUNvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovXG4gICAgICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIk1BWElDT0RFXCJdID0gOV0gPSBcIk1BWElDT0RFXCI7XG4gICAgICAgIC8qKiBQREY0MTcgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJQREZfNDE3XCJdID0gMTBdID0gXCJQREZfNDE3XCI7XG4gICAgICAgIC8qKiBRUiBDb2RlIDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJRUl9DT0RFXCJdID0gMTFdID0gXCJRUl9DT0RFXCI7XG4gICAgICAgIC8qKiBSU1MgMTQgKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiUlNTXzE0XCJdID0gMTJdID0gXCJSU1NfMTRcIjtcbiAgICAgICAgLyoqIFJTUyBFWFBBTkRFRCAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJSU1NfRVhQQU5ERURcIl0gPSAxM10gPSBcIlJTU19FWFBBTkRFRFwiO1xuICAgICAgICAvKiogVVBDLUEgMUQgZm9ybWF0LiAqL1xuICAgICAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfQVwiXSA9IDE0XSA9IFwiVVBDX0FcIjtcbiAgICAgICAgLyoqIFVQQy1FIDFEIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiVVBDX0VcIl0gPSAxNV0gPSBcIlVQQ19FXCI7XG4gICAgICAgIC8qKiBVUEMvRUFOIGV4dGVuc2lvbiBmb3JtYXQuIE5vdCBhIHN0YW5kLWFsb25lIGZvcm1hdC4gKi9cbiAgICAgICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiVVBDX0VBTl9FWFRFTlNJT05cIl0gPSAxNl0gPSBcIlVQQ19FQU5fRVhURU5TSU9OXCI7XG4gICAgfSkoQmFyY29kZUZvcm1hdCB8fCAoQmFyY29kZUZvcm1hdCA9IHt9KSk7XG4gICAgdmFyIEJhcmNvZGVGb3JtYXQkMSA9IEJhcmNvZGVGb3JtYXQ7XG5cbiAgICAvKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgc29tZSB0eXBlIG9mIG1ldGFkYXRhIGFib3V0IHRoZSByZXN1bHQgb2YgdGhlIGRlY29kaW5nIHRoYXQgdGhlIGRlY29kZXJcbiAgICAgKiB3aXNoZXMgdG8gY29tbXVuaWNhdGUgYmFjayB0byB0aGUgY2FsbGVyLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICB2YXIgUmVzdWx0TWV0YWRhdGFUeXBlO1xuICAgIChmdW5jdGlvbiAoUmVzdWx0TWV0YWRhdGFUeXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnNwZWNpZmllZCwgYXBwbGljYXRpb24tc3BlY2lmaWMgbWV0YWRhdGEuIE1hcHMgdG8gYW4gdW5zcGVjaWZpZWQge0BsaW5rIE9iamVjdH0uXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiT1RIRVJcIl0gPSAwXSA9IFwiT1RIRVJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbm90ZXMgdGhlIGxpa2VseSBhcHByb3hpbWF0ZSBvcmllbnRhdGlvbiBvZiB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuIFRoaXMgdmFsdWVcbiAgICAgICAgICogaXMgZ2l2ZW4gYXMgZGVncmVlcyByb3RhdGVkIGNsb2Nrd2lzZSBmcm9tIHRoZSBub3JtYWwsIHVwcmlnaHQgb3JpZW50YXRpb24uXG4gICAgICAgICAqIEZvciBleGFtcGxlIGEgMUQgYmFyY29kZSB3aGljaCB3YXMgZm91bmQgYnkgcmVhZGluZyB0b3AtdG8tYm90dG9tIHdvdWxkIGJlXG4gICAgICAgICAqIHNhaWQgdG8gaGF2ZSBvcmllbnRhdGlvbiBcIjkwXCIuIFRoaXMga2V5IG1hcHMgdG8gYW4ge0BsaW5rIEludGVnZXJ9IHdob3NlXG4gICAgICAgICAqIHZhbHVlIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIk9SSUVOVEFUSU9OXCJdID0gMV0gPSBcIk9SSUVOVEFUSU9OXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD4yRCBiYXJjb2RlIGZvcm1hdHMgdHlwaWNhbGx5IGVuY29kZSB0ZXh0LCBidXQgYWxsb3cgZm9yIGEgc29ydCBvZiAnYnl0ZSBtb2RlJ1xuICAgICAgICAgKiB3aGljaCBpcyBzb21ldGltZXMgdXNlZCB0byBlbmNvZGUgYmluYXJ5IGRhdGEuIFdoaWxlIHtAbGluayBSZXN1bHR9IG1ha2VzIGF2YWlsYWJsZVxuICAgICAgICAgKiB0aGUgY29tcGxldGUgcmF3IGJ5dGVzIGluIHRoZSBiYXJjb2RlIGZvciB0aGVzZSBmb3JtYXRzLCBpdCBkb2VzIG5vdCBvZmZlciB0aGUgYnl0ZXNcbiAgICAgICAgICogZnJvbSB0aGUgYnl0ZSBzZWdtZW50cyBhbG9uZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlRoaXMgbWFwcyB0byBhIHtAbGluayBqYXZhLnV0aWwuTGlzdH0gb2YgYnl0ZSBhcnJheXMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgICAgICogcmF3IGJ5dGVzIGluIHRoZSBieXRlIHNlZ21lbnRzIGluIHRoZSBiYXJjb2RlLCBpbiBvcmRlci48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiQllURV9TRUdNRU5UU1wiXSA9IDJdID0gXCJCWVRFX1NFR01FTlRTXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFcnJvciBjb3JyZWN0aW9uIGxldmVsIHVzZWQsIGlmIGFwcGxpY2FibGUuIFRoZSB2YWx1ZSB0eXBlIGRlcGVuZHMgb24gdGhlXG4gICAgICAgICAqIGZvcm1hdCwgYnV0IGlzIHR5cGljYWxseSBhIFN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJFUlJPUl9DT1JSRUNUSU9OX0xFVkVMXCJdID0gM10gPSBcIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUxcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBzb21lIHBlcmlvZGljYWxzLCBpbmRpY2F0ZXMgdGhlIGlzc3VlIG51bWJlciBhcyBhbiB7QGxpbmsgSW50ZWdlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiSVNTVUVfTlVNQkVSXCJdID0gNF0gPSBcIklTU1VFX05VTUJFUlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHNvbWUgcHJvZHVjdHMsIGluZGljYXRlcyB0aGUgc3VnZ2VzdGVkIHJldGFpbCBwcmljZSBpbiB0aGUgYmFyY29kZSBhcyBhXG4gICAgICAgICAqIGZvcm1hdHRlZCB7QGxpbmsgU3RyaW5nfS5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJTVUdHRVNURURfUFJJQ0VcIl0gPSA1XSA9IFwiU1VHR0VTVEVEX1BSSUNFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3Igc29tZSBwcm9kdWN0cywgdGhlIHBvc3NpYmxlIGNvdW50cnkgb2YgbWFudWZhY3R1cmUgYXMgYSB7QGxpbmsgU3RyaW5nfSBkZW5vdGluZyB0aGVcbiAgICAgICAgICogSVNPIGNvdW50cnkgY29kZS4gU29tZSBtYXAgdG8gbXVsdGlwbGUgcG9zc2libGUgY291bnRyaWVzLCBsaWtlIFwiVVMvQ0FcIi5cbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJQT1NTSUJMRV9DT1VOVFJZXCJdID0gNl0gPSBcIlBPU1NJQkxFX0NPVU5UUllcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCB0aGUgZXh0ZW5zaW9uIHRleHRcbiAgICAgICAgICovXG4gICAgICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJVUENfRUFOX0VYVEVOU0lPTlwiXSA9IDddID0gXCJVUENfRUFOX0VYVEVOU0lPTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogUERGNDE3LXNwZWNpZmljIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiUERGNDE3X0VYVFJBX01FVEFEQVRBXCJdID0gOF0gPSBcIlBERjQxN19FWFRSQV9NRVRBREFUQVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGNvZGUgZm9ybWF0IHN1cHBvcnRzIHN0cnVjdHVyZWQgYXBwZW5kIGFuZCB0aGUgY3VycmVudCBzY2FubmVkIGNvZGUgaXMgcGFydCBvZiBvbmUgdGhlbiB0aGVcbiAgICAgICAgICogc2VxdWVuY2UgbnVtYmVyIGlzIGdpdmVuIHdpdGggaXQuXG4gICAgICAgICAqL1xuICAgICAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0VcIl0gPSA5XSA9IFwiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0VcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBjb2RlIGZvcm1hdCBzdXBwb3J0cyBzdHJ1Y3R1cmVkIGFwcGVuZCBhbmQgdGhlIGN1cnJlbnQgc2Nhbm5lZCBjb2RlIGlzIHBhcnQgb2Ygb25lIHRoZW4gdGhlXG4gICAgICAgICAqIHBhcml0eSBpcyBnaXZlbiB3aXRoIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlNUUlVDVFVSRURfQVBQRU5EX1BBUklUWVwiXSA9IDEwXSA9IFwiU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZXCI7XG4gICAgfSkoUmVzdWx0TWV0YWRhdGFUeXBlIHx8IChSZXN1bHRNZXRhZGF0YVR5cGUgPSB7fSkpO1xuICAgIHZhciBSZXN1bHRNZXRhZGF0YVR5cGUkMSA9IFJlc3VsdE1ldGFkYXRhVHlwZTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHJlc3VsdCBvZiBkZWNvZGluZyBhIG1hdHJpeCBvZiBiaXRzLiBUaGlzIHR5cGljYWxseVxuICAgICAqIGFwcGxpZXMgdG8gMkQgYmFyY29kZSBmb3JtYXRzLiBGb3Igbm93IGl0IGNvbnRhaW5zIHRoZSByYXcgYnl0ZXMgb2J0YWluZWQsXG4gICAgICogYXMgd2VsbCBhcyBhIFN0cmluZyBpbnRlcnByZXRhdGlvbiBvZiB0aG9zZSBieXRlcywgaWYgYXBwbGljYWJsZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZXJSZXN1bHQge1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocmF3Qnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0cmluZyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgTGlzdDxVaW50OEFycmF5PiBieXRlU2VnbWVudHMsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFN0cmluZyBlY0xldmVsKSB7XG4gICAgICAgIC8vICAgdGhpcyhyYXdCeXRlcywgdGV4dCwgYnl0ZVNlZ21lbnRzLCBlY0xldmVsLCAtMSwgLTEpXG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3RydWN0b3IocmF3Qnl0ZXMsIHRleHQsIGJ5dGVTZWdtZW50cywgZWNMZXZlbCwgc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID0gLTEsIHN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVNlZ21lbnRzID0gYnl0ZVNlZ21lbnRzO1xuICAgICAgICAgICAgdGhpcy5lY0xldmVsID0gZWNMZXZlbDtcbiAgICAgICAgICAgIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID0gc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5ID0gc3RydWN0dXJlZEFwcGVuZFBhcml0eTtcbiAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IChyYXdCeXRlcyA9PT0gdW5kZWZpbmVkIHx8IHJhd0J5dGVzID09PSBudWxsKSA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHJhdyBieXRlcyByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhd0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGhvdyBtYW55IGJpdHMgb2Yge0BsaW5rICNnZXRSYXdCeXRlcygpfSBhcmUgdmFsaWQ7IHR5cGljYWxseSA4IHRpbWVzIGl0cyBsZW5ndGhcbiAgICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgICAqL1xuICAgICAgICBnZXROdW1CaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtQml0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG51bUJpdHMgb3ZlcnJpZGVzIHRoZSBudW1iZXIgb2YgYml0cyB0aGF0IGFyZSB2YWxpZCBpbiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9XG4gICAgICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TnVtQml0cyhudW1CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVzdWx0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBsaXN0IG9mIGJ5dGUgc2VnbWVudHMgaW4gdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCeXRlU2VnbWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlU2VnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbmFtZSBvZiBlcnJvciBjb3JyZWN0aW9uIGxldmVsIHVzZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RUNMZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGVycm9ycyBjb3JyZWN0ZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXJyb3JzQ29ycmVjdGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzQ29ycmVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHNldEVycm9yc0NvcnJlY3RlZChlcnJvcnNDb3JyZWN0ZWQgLypJbnRlZ2VyKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzQ29ycmVjdGVkID0gZXJyb3JzQ29ycmVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBlcmFzdXJlcyBjb3JyZWN0ZWQsIG9yIHtAY29kZSBudWxsfSBpZiBub3QgYXBwbGljYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXJhc3VyZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcmFzdXJlcztcbiAgICAgICAgfVxuICAgICAgICBzZXRFcmFzdXJlcyhlcmFzdXJlcyAvKkludGVnZXIqLykge1xuICAgICAgICAgICAgdGhpcy5lcmFzdXJlcyA9IGVyYXN1cmVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGFyYml0cmFyeSBhZGRpdGlvbmFsIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBnZXRPdGhlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm90aGVyO1xuICAgICAgICB9XG4gICAgICAgIHNldE90aGVyKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgaGFzU3RydWN0dXJlZEFwcGVuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPj0gMCAmJiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciA+PSAwO1xuICAgICAgICB9XG4gICAgICAgIGdldFN0cnVjdHVyZWRBcHBlbmRQYXJpdHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGdldFN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIHBlcmZvcm1pbmcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMgb3ZlclxuICAgICAqIHRoZSBHYWxvaXMgRmllbGRzLiBPcGVyYXRpb25zIHVzZSBhIGdpdmVuIHByaW1pdGl2ZSBwb2x5bm9taWFsIGluIGNhbGN1bGF0aW9ucy48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaHJvdWdob3V0IHRoaXMgcGFja2FnZSwgZWxlbWVudHMgb2YgdGhlIEdGIGFyZSByZXByZXNlbnRlZCBhcyBhbiB7QGNvZGUgaW50fVxuICAgICAqIGZvciBjb252ZW5pZW5jZSBhbmQgc3BlZWQgKGJ1dCBhdCB0aGUgY29zdCBvZiBtZW1vcnkpLlxuICAgICAqIDwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgQWJzdHJhY3RHZW5lcmljR0Yge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiAyIHRvIHRoZSBwb3dlciBvZiBhIGluIEdGKHNpemUpXG4gICAgICAgICAqL1xuICAgICAgICBleHAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gYmFzZSAyIGxvZyBvZiBhIGluIEdGKHNpemUpXG4gICAgICAgICAqL1xuICAgICAgICBsb2coYSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ1RhYmxlW2FdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGJvdGggYWRkaXRpb24gYW5kIHN1YnRyYWN0aW9uIC0tIHRoZXkgYXJlIHRoZSBzYW1lIGluIEdGKHNpemUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHN1bS9kaWZmZXJlbmNlIG9mIGEgYW5kIGJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhZGRPclN1YnRyYWN0KGEgLyppbnQqLywgYiAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gYSBeIGI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlJlcHJlc2VudHMgYSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgZWxlbWVudHMgb2YgYSBHRi5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgaW1tdXRhYmxlLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGFuIGluZGlyZWN0XG4gICAgICogcG9ydCBvZiBoaXMgQysrIFJlZWQtU29sb21vbiBpbXBsZW1lbnRhdGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEdlbmVyaWNHRlBvbHkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGZpZWxkIHRoZSB7QGxpbmsgR2VuZXJpY0dGfSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGZpZWxkIHRvIHVzZVxuICAgICAgICAgKiB0byBwZXJmb3JtIGNvbXB1dGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gY29lZmZpY2llbnRzIGNvZWZmaWNpZW50cyBhcyBpbnRzIHJlcHJlc2VudGluZyBlbGVtZW50cyBvZiBHRihzaXplKSwgYXJyYW5nZWRcbiAgICAgICAgICogZnJvbSBtb3N0IHNpZ25pZmljYW50IChoaWdoZXN0LXBvd2VyIHRlcm0pIGNvZWZmaWNpZW50IHRvIGxlYXN0IHNpZ25pZmljYW50XG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGFyZ3VtZW50IGlzIG51bGwgb3IgZW1wdHksXG4gICAgICAgICAqIG9yIGlmIGxlYWRpbmcgY29lZmZpY2llbnQgaXMgMCBhbmQgdGhpcyBpcyBub3QgYVxuICAgICAgICAgKiBjb25zdGFudCBwb2x5bm9taWFsICh0aGF0IGlzLCBpdCBpcyBub3QgdGhlIG1vbm9taWFsIFwiMFwiKVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZmllbGQsIGNvZWZmaWNpZW50cykge1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudHNMZW5ndGggPSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50c0xlbmd0aCA+IDEgJiYgY29lZmZpY2llbnRzWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyB0ZXJtIG11c3QgYmUgbm9uLXplcm8gZm9yIGFueXRoaW5nIGV4Y2VwdCB0aGUgY29uc3RhbnQgcG9seW5vbWlhbCBcIjBcIlxuICAgICAgICAgICAgICAgIGxldCBmaXJzdE5vblplcm8gPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChmaXJzdE5vblplcm8gPCBjb2VmZmljaWVudHNMZW5ndGggJiYgY29lZmZpY2llbnRzW2ZpcnN0Tm9uWmVyb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vblplcm8gPT09IGNvZWZmaWNpZW50c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IEludDMyQXJyYXkuZnJvbShbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShjb2VmZmljaWVudHNMZW5ndGggLSBmaXJzdE5vblplcm8pO1xuICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvZWZmaWNpZW50cywgZmlyc3ROb25aZXJvLCB0aGlzLmNvZWZmaWNpZW50cywgMCwgdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRDb2VmZmljaWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gZGVncmVlIG9mIHRoaXMgcG9seW5vbWlhbFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGVncmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhpcyBwb2x5bm9taWFsIGlzIHRoZSBtb25vbWlhbCBcIjBcIlxuICAgICAgICAgKi9cbiAgICAgICAgaXNaZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzWzBdID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGNvZWZmaWNpZW50IG9mIHheZGVncmVlIHRlcm0gaW4gdGhpcyBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb2VmZmljaWVudChkZWdyZWUgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzW3RoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBkZWdyZWVdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGV2YWx1YXRpb24gb2YgdGhpcyBwb2x5bm9taWFsIGF0IGEgZ2l2ZW4gcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIGV2YWx1YXRlQXQoYSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSB4XjAgY29lZmZpY2llbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChhID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCB0aGUgc3VtIG9mIHRoZSBjb2VmZmljaWVudHNcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjb2VmZmljaWVudHMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudCA9IGNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQWJzdHJhY3RHZW5lcmljR0YuYWRkT3JTdWJ0cmFjdChyZXN1bHQsIGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IGNvZWZmaWNpZW50c1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KGZpZWxkLm11bHRpcGx5KGEsIHJlc3VsdCksIGNvZWZmaWNpZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGFkZE9yU3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc21hbGxlckNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IGxhcmdlckNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gc21hbGxlckNvZWZmaWNpZW50cztcbiAgICAgICAgICAgICAgICBzbWFsbGVyQ29lZmZpY2llbnRzID0gbGFyZ2VyQ29lZmZpY2llbnRzO1xuICAgICAgICAgICAgICAgIGxhcmdlckNvZWZmaWNpZW50cyA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3VtRGlmZiA9IG5ldyBJbnQzMkFycmF5KGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoRGlmZiA9IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGggLSBzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShsYXJnZXJDb2VmZmljaWVudHMsIDAsIHN1bURpZmYsIDAsIGxlbmd0aERpZmYpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW1EaWZmW2ldID0gQWJzdHJhY3RHZW5lcmljR0YuYWRkT3JTdWJ0cmFjdChzbWFsbGVyQ29lZmZpY2llbnRzW2kgLSBsZW5ndGhEaWZmXSwgbGFyZ2VyQ29lZmZpY2llbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seSh0aGlzLmZpZWxkLCBzdW1EaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkgfHwgb3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBjb25zdCBhTGVuZ3RoID0gYUNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgY29uc3QgYkxlbmd0aCA9IGJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KGFMZW5ndGggKyBiTGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFDb2VmZiA9IGFDb2VmZmljaWVudHNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFtpICsgal0gPSBBYnN0cmFjdEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KHByb2R1Y3RbaSArIGpdLCBmaWVsZC5tdWx0aXBseShhQ29lZmYsIGJDb2VmZmljaWVudHNbal0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5U2NhbGFyKHNjYWxhciAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjYWxhciA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0W2ldID0gZmllbGQubXVsdGlwbHkoY29lZmZpY2llbnRzW2ldLCBzY2FsYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlIC8qaW50Ki8sIGNvZWZmaWNpZW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplICsgZGVncmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdFtpXSA9IGZpZWxkLm11bHRpcGx5KGNvZWZmaWNpZW50c1tpXSwgY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBwcm9kdWN0KTtcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0RpdmlkZSBieSAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBsZXQgcXVvdGllbnQgPSBmaWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSBvdGhlci5nZXRDb2VmZmljaWVudChvdGhlci5nZXREZWdyZWUoKSk7XG4gICAgICAgICAgICBjb25zdCBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSA9IGZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgICAgICB3aGlsZSAocmVtYWluZGVyLmdldERlZ3JlZSgpID49IG90aGVyLmdldERlZ3JlZSgpICYmICFyZW1haW5kZXIuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWdyZWVEaWZmZXJlbmNlID0gcmVtYWluZGVyLmdldERlZ3JlZSgpIC0gb3RoZXIuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBmaWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLmdldERlZ3JlZSgpKSwgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBvdGhlci5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGlvblF1b3RpZW50ID0gZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBxdW90aWVudC5hZGRPclN1YnRyYWN0KGl0ZXJhdGlvblF1b3RpZW50KTtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuYWRkT3JTdWJ0cmFjdCh0ZXJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcXVvdGllbnQsIHJlbWFpbmRlcl07XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGRlZ3JlZSA9IHRoaXMuZ2V0RGVncmVlKCk7IGRlZ3JlZSA+PSAwOyBkZWdyZWUtLSkge1xuICAgICAgICAgICAgICAgIGxldCBjb2VmZmljaWVudCA9IHRoaXMuZ2V0Q29lZmZpY2llbnQoZGVncmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgLSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZpY2llbnQgPSAtY29lZmZpY2llbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyArICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMCB8fCBjb2VmZmljaWVudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxwaGFQb3dlciA9IHRoaXMuZmllbGQubG9nKGNvZWZmaWNpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYVBvd2VyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcxJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFscGhhUG93ZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdhXic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGFscGhhUG93ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3heJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZGVncmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBBcml0aG1ldGljRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgQXJpdGhtZXRpY0V4Y2VwdGlvbi5raW5kID0gJ0FyaXRobWV0aWNFeGNlcHRpb24nO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcGVyZm9ybWluZyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyBvdmVyXG4gICAgICogdGhlIEdhbG9pcyBGaWVsZHMuIE9wZXJhdGlvbnMgdXNlIGEgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwgaW4gY2FsY3VsYXRpb25zLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRocm91Z2hvdXQgdGhpcyBwYWNrYWdlLCBlbGVtZW50cyBvZiB0aGUgR0YgYXJlIHJlcHJlc2VudGVkIGFzIGFuIHtAY29kZSBpbnR9XG4gICAgICogZm9yIGNvbnZlbmllbmNlIGFuZCBzcGVlZCAoYnV0IGF0IHRoZSBjb3N0IG9mIG1lbW9yeSkuXG4gICAgICogPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKi9cbiAgICBjbGFzcyBHZW5lcmljR0YgZXh0ZW5kcyBBYnN0cmFjdEdlbmVyaWNHRiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSByZXByZXNlbnRhdGlvbiBvZiBHRihzaXplKSB1c2luZyB0aGUgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwcmltaXRpdmUgaXJyZWR1Y2libGUgcG9seW5vbWlhbCB3aG9zZSBjb2VmZmljaWVudHMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gICAgICAgICAqICB0aGUgYml0cyBvZiBhbiBpbnQsIHdoZXJlIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXQgcmVwcmVzZW50cyB0aGUgY29uc3RhbnRcbiAgICAgICAgICogIGNvZWZmaWNpZW50XG4gICAgICAgICAqIEBwYXJhbSBzaXplIHRoZSBzaXplIG9mIHRoZSBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0gYiB0aGUgZmFjdG9yIGIgaW4gdGhlIGdlbmVyYXRvciBwb2x5bm9taWFsIGNhbiBiZSAwLSBvciAxLWJhc2VkXG4gICAgICAgICAqICAoZyh4KSA9ICh4K2FeYikoeCthXihiKzEpKS4uLih4K2FeKGIrMnQtMSkpKS5cbiAgICAgICAgICogIEluIG1vc3QgY2FzZXMgaXQgc2hvdWxkIGJlIDEsIGJ1dCBmb3IgUVIgY29kZSBpdCBpcyAwLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IocHJpbWl0aXZlIC8qaW50Ki8sIHNpemUgLyppbnQqLywgZ2VuZXJhdG9yQmFzZSAvKmludCovKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3JCYXNlID0gZ2VuZXJhdG9yQmFzZTtcbiAgICAgICAgICAgIGNvbnN0IGV4cFRhYmxlID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBsZXQgeCA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4cFRhYmxlW2ldID0geDtcbiAgICAgICAgICAgICAgICB4ICo9IDI7IC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSBnZW5lcmF0b3IgYWxwaGEgaXMgMlxuICAgICAgICAgICAgICAgIGlmICh4ID49IHNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgeCBePSBwcmltaXRpdmU7XG4gICAgICAgICAgICAgICAgICAgIHggJj0gc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leHBUYWJsZSA9IGV4cFRhYmxlO1xuICAgICAgICAgICAgY29uc3QgbG9nVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvZ1RhYmxlW2V4cFRhYmxlW2ldXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ1RhYmxlID0gbG9nVGFibGU7XG4gICAgICAgICAgICAvLyBsb2dUYWJsZVswXSA9PSAwIGJ1dCB0aGlzIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgICAgICB0aGlzLnplcm8gPSBuZXcgR2VuZXJpY0dGUG9seSh0aGlzLCBJbnQzMkFycmF5LmZyb20oWzBdKSk7XG4gICAgICAgICAgICB0aGlzLm9uZSA9IG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMsIEludDMyQXJyYXkuZnJvbShbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRaZXJvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgICAgICBnZXRPbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIG1vbm9taWFsIHJlcHJlc2VudGluZyBjb2VmZmljaWVudCAqIHheZGVncmVlXG4gICAgICAgICAqL1xuICAgICAgICBidWlsZE1vbm9taWFsKGRlZ3JlZSAvKmludCovLCBjb2VmZmljaWVudCAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoZGVncmVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkZWdyZWUgKyAxKTtcbiAgICAgICAgICAgIGNvZWZmaWNpZW50c1swXSA9IGNvZWZmaWNpZW50O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMsIGNvZWZmaWNpZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBhXG4gICAgICAgICAqL1xuICAgICAgICBpbnZlcnNlKGEgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbdGhpcy5zaXplIC0gdGhpcy5sb2dUYWJsZVthXSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHByb2R1Y3Qgb2YgYSBhbmQgYiBpbiBHRihzaXplKVxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwIHx8IGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cFRhYmxlWyh0aGlzLmxvZ1RhYmxlW2FdICsgdGhpcy5sb2dUYWJsZVtiXSkgJSAodGhpcy5zaXplIC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGdldEdlbmVyYXRvckJhc2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3JCYXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCdHRigweCcgKyBJbnRlZ2VyLnRvSGV4U3RyaW5nKHRoaXMucHJpbWl0aXZlKSArICcsJyArIHRoaXMuc2l6ZSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBvID09PSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEyID0gbmV3IEdlbmVyaWNHRigweDEwNjksIDQwOTYsIDEpOyAvLyB4XjEyICsgeF42ICsgeF41ICsgeF4zICsgMVxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEwID0gbmV3IEdlbmVyaWNHRigweDQwOSwgMTAyNCwgMSk7IC8vIHheMTAgKyB4XjMgKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfNiA9IG5ldyBHZW5lcmljR0YoMHg0MywgNjQsIDEpOyAvLyB4XjYgKyB4ICsgMVxuICAgIEdlbmVyaWNHRi5BWlRFQ19QQVJBTSA9IG5ldyBHZW5lcmljR0YoMHgxMywgMTYsIDEpOyAvLyB4XjQgKyB4ICsgMVxuICAgIEdlbmVyaWNHRi5RUl9DT0RFX0ZJRUxEXzI1NiA9IG5ldyBHZW5lcmljR0YoMHgwMTFkLCAyNTYsIDApOyAvLyB4XjggKyB4XjQgKyB4XjMgKyB4XjIgKyAxXG4gICAgR2VuZXJpY0dGLkRBVEFfTUFUUklYX0ZJRUxEXzI1NiA9IG5ldyBHZW5lcmljR0YoMHgwMTJkLCAyNTYsIDEpOyAvLyB4XjggKyB4XjUgKyB4XjMgKyB4XjIgKyAxXG4gICAgR2VuZXJpY0dGLkFaVEVDX0RBVEFfOCA9IEdlbmVyaWNHRi5EQVRBX01BVFJJWF9GSUVMRF8yNTY7XG4gICAgR2VuZXJpY0dGLk1BWElDT0RFX0ZJRUxEXzY0ID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBSZWVkU29sb21vbkV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIFJlZWRTb2xvbW9uRXhjZXB0aW9uLmtpbmQgPSAnUmVlZFNvbG9tb25FeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgfVxuICAgIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbi5raW5kID0gJ0lsbGVnYWxTdGF0ZUV4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkltcGxlbWVudHMgUmVlZC1Tb2xvbW9uIGRlY29kaW5nLCBhcyB0aGUgbmFtZSBpbXBsaWVzLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoZSBhbGdvcml0aG0gd2lsbCBub3QgYmUgZXhwbGFpbmVkIGhlcmUsIGJ1dCB0aGUgZm9sbG93aW5nIHJlZmVyZW5jZXMgd2VyZSBoZWxwZnVsXG4gICAgICogaW4gY3JlYXRpbmcgdGhpcyBpbXBsZW1lbnRhdGlvbjo8L3A+XG4gICAgICpcbiAgICAgKiA8dWw+XG4gICAgICogPGxpPkJydWNlIE1hZ2dzLlxuICAgICAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LmNzLmNtdS5lZHUvYWZzL2NzLmNtdS5lZHUvcHJvamVjdC9wc2NpY28tZ3V5Yi9yZWFsd29ybGQvd3d3L3JzX2RlY29kZS5wc1wiPlxuICAgICAqIFwiRGVjb2RpbmcgUmVlZC1Tb2xvbW9uIENvZGVzXCI8L2E+IChzZWUgZGlzY3Vzc2lvbiBvZiBGb3JuZXkncyBGb3JtdWxhKTwvbGk+XG4gICAgICogPGxpPkouSS4gSGFsbC4gPGEgaHJlZj1cInd3dy5tdGgubXN1LmVkdS9+amhhbGwvY2xhc3Nlcy9jb2Rlbm90ZXMvR1JTLnBkZlwiPlxuICAgICAqIFwiQ2hhcHRlciA1LiBHZW5lcmFsaXplZCBSZWVkLVNvbG9tb24gQ29kZXNcIjwvYT5cbiAgICAgKiAoc2VlIGRpc2N1c3Npb24gb2YgRXVjbGlkZWFuIGFsZ29yaXRobSk8L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICpcbiAgICAgKiA8cD5NdWNoIGNyZWRpdCBpcyBkdWUgdG8gV2lsbGlhbSBSdWNrbGlkZ2Ugc2luY2UgcG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBhbiBpbmRpcmVjdFxuICAgICAqIHBvcnQgb2YgaGlzIEMrKyBSZWVkLVNvbG9tb24gaW1wbGVtZW50YXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIFdpbGxpYW0gUnVja2xpZGdlXG4gICAgICogQGF1dGhvciBzYW5mb3Jkc3F1aXJlc1xuICAgICAqL1xuICAgIGNsYXNzIFJlZWRTb2xvbW9uRGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZpZWxkKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRlY29kZXMgZ2l2ZW4gc2V0IG9mIHJlY2VpdmVkIGNvZGV3b3Jkcywgd2hpY2ggaW5jbHVkZSBib3RoIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb25cbiAgICAgICAgICogY29kZXdvcmRzLiBSZWFsbHksIHRoaXMgbWVhbnMgaXQgdXNlcyBSZWVkLVNvbG9tb24gdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycywgaW4tcGxhY2UsXG4gICAgICAgICAqIGluIHRoZSBpbnB1dC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZWNlaXZlZCBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gdHdvUyBudW1iZXIgb2YgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgYXZhaWxhYmxlXG4gICAgICAgICAqIEB0aHJvd3MgUmVlZFNvbG9tb25FeGNlcHRpb24gaWYgZGVjb2RpbmcgZmFpbHMgZm9yIGFueSByZWFzb25cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZShyZWNlaXZlZCwgdHdvUyAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgICAgICAgICBjb25zdCBwb2x5ID0gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHJlY2VpdmVkKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bmRyb21lQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkodHdvUyk7XG4gICAgICAgICAgICBsZXQgbm9FcnJvciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR3b1M7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2YWxSZXN1bHQgPSBwb2x5LmV2YWx1YXRlQXQoZmllbGQuZXhwKGkgKyBmaWVsZC5nZXRHZW5lcmF0b3JCYXNlKCkpKTtcbiAgICAgICAgICAgICAgICBzeW5kcm9tZUNvZWZmaWNpZW50c1tzeW5kcm9tZUNvZWZmaWNpZW50cy5sZW5ndGggLSAxIC0gaV0gPSBldmFsUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChldmFsUmVzdWx0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9FcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN5bmRyb21lID0gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHN5bmRyb21lQ29lZmZpY2llbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hT21lZ2EgPSB0aGlzLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobShmaWVsZC5idWlsZE1vbm9taWFsKHR3b1MsIDEpLCBzeW5kcm9tZSwgdHdvUyk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYSA9IHNpZ21hT21lZ2FbMF07XG4gICAgICAgICAgICBjb25zdCBvbWVnYSA9IHNpZ21hT21lZ2FbMV07XG4gICAgICAgICAgICBjb25zdCBlcnJvckxvY2F0aW9ucyA9IHRoaXMuZmluZEVycm9yTG9jYXRpb25zKHNpZ21hKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWFnbml0dWRlcyA9IHRoaXMuZmluZEVycm9yTWFnbml0dWRlcyhvbWVnYSwgZXJyb3JMb2NhdGlvbnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcmVjZWl2ZWQubGVuZ3RoIC0gMSAtIGZpZWxkLmxvZyhlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb24oJ0JhZCBlcnJvciBsb2NhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFtwb3NpdGlvbl0gPSBHZW5lcmljR0YuYWRkT3JTdWJ0cmFjdChyZWNlaXZlZFtwb3NpdGlvbl0sIGVycm9yTWFnbml0dWRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVuRXVjbGlkZWFuQWxnb3JpdGhtKGEsIGIsIFIgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gQXNzdW1lIGEncyBkZWdyZWUgaXMgPj0gYidzXG4gICAgICAgICAgICBpZiAoYS5nZXREZWdyZWUoKSA8IGIuZ2V0RGVncmVlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICAgICAgICBiID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGxldCByTGFzdCA9IGE7XG4gICAgICAgICAgICBsZXQgciA9IGI7XG4gICAgICAgICAgICBsZXQgdExhc3QgPSBmaWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICBsZXQgdCA9IGZpZWxkLmdldE9uZSgpO1xuICAgICAgICAgICAgLy8gUnVuIEV1Y2xpZGVhbiBhbGdvcml0aG0gdW50aWwgcidzIGRlZ3JlZSBpcyBsZXNzIHRoYW4gUi8yXG4gICAgICAgICAgICB3aGlsZSAoci5nZXREZWdyZWUoKSA+PSAoUiAvIDIgfCAwKSkge1xuICAgICAgICAgICAgICAgIGxldCByTGFzdExhc3QgPSByTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgdExhc3RMYXN0ID0gdExhc3Q7XG4gICAgICAgICAgICAgICAgckxhc3QgPSByO1xuICAgICAgICAgICAgICAgIHRMYXN0ID0gdDtcbiAgICAgICAgICAgICAgICAvLyBEaXZpZGUgckxhc3RMYXN0IGJ5IHJMYXN0LCB3aXRoIHF1b3RpZW50IGluIHEgYW5kIHJlbWFpbmRlciBpbiByXG4gICAgICAgICAgICAgICAgaWYgKHJMYXN0LmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9vcHMsIEV1Y2xpZGVhbiBhbGdvcml0aG0gYWxyZWFkeSB0ZXJtaW5hdGVkP1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb24oJ3Jfe2ktMX0gd2FzIHplcm8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgciA9IHJMYXN0TGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgcSA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gckxhc3QuZ2V0Q29lZmZpY2llbnQockxhc3QuZ2V0RGVncmVlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRsdEludmVyc2UgPSBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpICYmICFyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZURpZmYgPSByLmdldERlZ3JlZSgpIC0gckxhc3QuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLmFkZE9yU3VidHJhY3QoZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICByID0gci5hZGRPclN1YnRyYWN0KHJMYXN0Lm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gcS5tdWx0aXBseSh0TGFzdCkuYWRkT3JTdWJ0cmFjdCh0TGFzdExhc3QpO1xuICAgICAgICAgICAgICAgIGlmIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ0RpdmlzaW9uIGFsZ29yaXRobSBmYWlsZWQgdG8gcmVkdWNlIHBvbHlub21pYWw/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbWFUaWxkZUF0WmVybyA9IHQuZ2V0Q29lZmZpY2llbnQoMCk7XG4gICAgICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbignc2lnbWFUaWxkZSgwKSB3YXMgemVybycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW52ZXJzZSA9IGZpZWxkLmludmVyc2Uoc2lnbWFUaWxkZUF0WmVybyk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYSA9IHQubXVsdGlwbHlTY2FsYXIoaW52ZXJzZSk7XG4gICAgICAgICAgICBjb25zdCBvbWVnYSA9IHIubXVsdGlwbHlTY2FsYXIoaW52ZXJzZSk7XG4gICAgICAgICAgICByZXR1cm4gW3NpZ21hLCBvbWVnYV07XG4gICAgICAgIH1cbiAgICAgICAgZmluZEVycm9yTG9jYXRpb25zKGVycm9yTG9jYXRvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGRpcmVjdCBhcHBsaWNhdGlvbiBvZiBDaGllbidzIHNlYXJjaFxuICAgICAgICAgICAgY29uc3QgbnVtRXJyb3JzID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgaWYgKG51bUVycm9ycyA9PT0gMSkgeyAvLyBzaG9ydGN1dFxuICAgICAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW2Vycm9yTG9jYXRvci5nZXRDb2VmZmljaWVudCgxKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkobnVtRXJyb3JzKTtcbiAgICAgICAgICAgIGxldCBlID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmllbGQuZ2V0U2l6ZSgpICYmIGUgPCBudW1FcnJvcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckxvY2F0b3IuZXZhbHVhdGVBdChpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZV0gPSBmaWVsZC5pbnZlcnNlKGkpO1xuICAgICAgICAgICAgICAgICAgICBlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgIT09IG51bUVycm9ycykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbignRXJyb3IgbG9jYXRvciBkZWdyZWUgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mIHJvb3RzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZpbmRFcnJvck1hZ25pdHVkZXMoZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRpb25zKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRpcmVjdGx5IGFwcGx5aW5nIEZvcm5leSdzIEZvcm11bGFcbiAgICAgICAgICAgIGNvbnN0IHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShzKTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeGlJbnZlcnNlID0gZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVub21pbmF0b3IgPSBmaWVsZC5tdWx0aXBseShkZW5vbWluYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KDEsIGZpZWxkLm11bHRpcGx5KGVycm9yTG9jYXRpb25zW2pdLCB4aUludmVyc2UpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFib3ZlIHNob3VsZCB3b3JrIGJ1dCBmYWlscyBvbiBzb21lIEFwcGxlIGFuZCBMaW51eCBKREtzIGR1ZSB0byBhIEhvdHNwb3QgYnVnLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVsb3cgaXMgYSBmdW5ueS1sb29raW5nIHdvcmthcm91bmQgZnJvbSBTdGV2ZW4gUGFya2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtID0gZmllbGQubXVsdGlwbHkoZXJyb3JMb2NhdGlvbnNbal0sIHhpSW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtUGx1czEgPSAodGVybSAmIDB4MSkgPT09IDAgPyB0ZXJtIHwgMSA6IHRlcm0gJiB+MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yID0gZmllbGQubXVsdGlwbHkoZGVub21pbmF0b3IsIHRlcm1QbHVzMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZmllbGQubXVsdGlwbHkoZXJyb3JFdmFsdWF0b3IuZXZhbHVhdGVBdCh4aUludmVyc2UpLCBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmdldEdlbmVyYXRvckJhc2UoKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmaWVsZC5tdWx0aXBseShyZXN1bHRbaV0sIHhpSW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XG4gICAgdmFyIFRhYmxlO1xuICAgIChmdW5jdGlvbiAoVGFibGUpIHtcbiAgICAgICAgVGFibGVbVGFibGVbXCJVUFBFUlwiXSA9IDBdID0gXCJVUFBFUlwiO1xuICAgICAgICBUYWJsZVtUYWJsZVtcIkxPV0VSXCJdID0gMV0gPSBcIkxPV0VSXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiTUlYRURcIl0gPSAyXSA9IFwiTUlYRURcIjtcbiAgICAgICAgVGFibGVbVGFibGVbXCJESUdJVFwiXSA9IDNdID0gXCJESUdJVFwiO1xuICAgICAgICBUYWJsZVtUYWJsZVtcIlBVTkNUXCJdID0gNF0gPSBcIlBVTkNUXCI7XG4gICAgICAgIFRhYmxlW1RhYmxlW1wiQklOQVJZXCJdID0gNV0gPSBcIkJJTkFSWVwiO1xuICAgIH0pKFRhYmxlIHx8IChUYWJsZSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+VGhlIG1haW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBBenRlYyBDb2RlIGRlY29kaW5nIC0tIGFzIG9wcG9zZWQgdG8gbG9jYXRpbmcgYW5kIGV4dHJhY3RpbmdcbiAgICAgKiB0aGUgQXp0ZWMgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZXIge1xuICAgICAgICBkZWNvZGUoZGV0ZWN0b3JSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGRhdGEgPSBkZXRlY3RvclJlc3VsdDtcbiAgICAgICAgICAgIGxldCBtYXRyaXggPSBkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCk7XG4gICAgICAgICAgICBsZXQgcmF3Yml0cyA9IHRoaXMuZXh0cmFjdEJpdHMobWF0cml4KTtcbiAgICAgICAgICAgIGxldCBjb3JyZWN0ZWRCaXRzID0gdGhpcy5jb3JyZWN0Qml0cyhyYXdiaXRzKTtcbiAgICAgICAgICAgIGxldCByYXdCeXRlcyA9IERlY29kZXIuY29udmVydEJvb2xBcnJheVRvQnl0ZUFycmF5KGNvcnJlY3RlZEJpdHMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IERlY29kZXIuZ2V0RW5jb2RlZERhdGEoY29ycmVjdGVkQml0cyk7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyUmVzdWx0KHJhd0J5dGVzLCByZXN1bHQsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5zZXROdW1CaXRzKGNvcnJlY3RlZEJpdHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHRlc3RpbmcgdGhlIGhpZ2gtbGV2ZWwgZW5jb2RlclxuICAgICAgICBzdGF0aWMgaGlnaExldmVsRGVjb2RlKGNvcnJlY3RlZEJpdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZWREYXRhKGNvcnJlY3RlZEJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBzdHJpbmcgZW5jb2RlZCBpbiB0aGUgYXp0ZWMgY29kZSBiaXRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGRlY29kZWQgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0RW5jb2RlZERhdGEoY29ycmVjdGVkQml0cykge1xuICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gY29ycmVjdGVkQml0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGF0Y2hUYWJsZSA9IFRhYmxlLlVQUEVSOyAvLyB0YWJsZSBtb3N0IHJlY2VudGx5IGxhdGNoZWQgdG9cbiAgICAgICAgICAgIGxldCBzaGlmdFRhYmxlID0gVGFibGUuVVBQRVI7IC8vIHRhYmxlIHRvIHVzZSBmb3IgdGhlIG5leHQgcmVhZFxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNoaWZ0VGFibGUgPT09IFRhYmxlLkJJTkFSWSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCA1KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4IC0gaW5kZXggPCAxMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gRGVjb2Rlci5yZWFkQ29kZShjb3JyZWN0ZWRCaXRzLCBpbmRleCwgMTEpICsgMzE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFyQ291bnQgPSAwOyBjaGFyQ291bnQgPCBsZW5ndGg7IGNoYXJDb3VudCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGVuZEluZGV4OyAvLyBGb3JjZSBvdXRlciBsb29wIHRvIGV4aXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAvKihjaGFyKSovIFN0cmluZ1V0aWxzLmNhc3RBc05vblV0ZjhDaGFyKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gODtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBHbyBiYWNrIHRvIHdoYXRldmVyIG1vZGUgd2UgaGFkIGJlZW4gaW5cbiAgICAgICAgICAgICAgICAgICAgc2hpZnRUYWJsZSA9IGxhdGNoVGFibGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHNoaWZ0VGFibGUgPT09IFRhYmxlLkRJR0lUID8gNCA6IDU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ciA9IERlY29kZXIuZ2V0Q2hhcmFjdGVyKHNoaWZ0VGFibGUsIGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJ0NUUkxfJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElTTy9JRUMgMjQ3Nzg6MjAwOCBwcmVzY3JpYmVzIGVuZGluZyBhIHNoaWZ0IHNlcXVlbmNlIGluIHRoZSBtb2RlIGZyb20gd2hpY2ggaXQgd2FzIGludm9rZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgaW5jbHVkaW5nIHdoZW4gdGhhdCBtb2RlIGlzIGEgc2hpZnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXIgdGVzdCBjYXNlIGRsdXNicy5wbmcgZm9yIGlzc3VlICM2NDIgZXhlcmNpc2VzIHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRjaFRhYmxlID0gc2hpZnRUYWJsZTsgLy8gTGF0Y2ggdGhlIGN1cnJlbnQgbW9kZSwgc28gYXMgdG8gcmV0dXJuIHRvIFVwcGVyIGFmdGVyIFUvUyBCL1NcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VGFibGUgPSBEZWNvZGVyLmdldFRhYmxlKHN0ci5jaGFyQXQoNSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQXQoNikgPT09ICdMJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGNoVGFibGUgPSBzaGlmdFRhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIGJhY2sgdG8gd2hhdGV2ZXIgbW9kZSB3ZSBoYWQgYmVlbiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRUYWJsZSA9IGxhdGNoVGFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRzIHRoZSB0YWJsZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBjaGFyIHBhc3NlZFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldFRhYmxlKHQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuTE9XRVI7XG4gICAgICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5QVU5DVDtcbiAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLk1JWEVEO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuRElHSVQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5CSU5BUlk7XG4gICAgICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLlVQUEVSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjaGFyYWN0ZXIgKG9yIHN0cmluZykgY29ycmVzcG9uZGluZyB0byB0aGUgcGFzc2VkIGNvZGUgaW4gdGhlIGdpdmVuIHRhYmxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0YWJsZSB0aGUgdGFibGUgdXNlZFxuICAgICAgICAgKiBAcGFyYW0gY29kZSB0aGUgY29kZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0Q2hhcmFjdGVyKHRhYmxlLCBjb2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5VUFBFUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuVVBQRVJfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5MT1dFUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuTE9XRVJfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5NSVhFRDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuTUlYRURfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5QVU5DVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuUFVOQ1RfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgY2FzZSBUYWJsZS5ESUdJVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuRElHSVRfVEFCTEVbY29kZV07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZWFjaCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdCYWQgdGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UGVyZm9ybXMgUlMgZXJyb3IgY29ycmVjdGlvbiBvbiBhbiBhcnJheSBvZiBiaXRzLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgY29ycmVjdGVkIGFycmF5XG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBjb250YWlucyB0b28gbWFueSBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIGNvcnJlY3RCaXRzKHJhd2JpdHMpIHtcbiAgICAgICAgICAgIGxldCBnZjtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZFNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDIpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSA2O1xuICAgICAgICAgICAgICAgIGdmID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGRhdGEuZ2V0TmJMYXllcnMoKSA8PSA4KSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRTaXplID0gODtcbiAgICAgICAgICAgICAgICBnZiA9IEdlbmVyaWNHRi5BWlRFQ19EQVRBXzg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmRkYXRhLmdldE5iTGF5ZXJzKCkgPD0gMjIpIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZFNpemUgPSAxMDtcbiAgICAgICAgICAgICAgICBnZiA9IEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRTaXplID0gMTI7XG4gICAgICAgICAgICAgICAgZ2YgPSBHZW5lcmljR0YuQVpURUNfREFUQV8xMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1EYXRhQ29kZXdvcmRzID0gdGhpcy5kZGF0YS5nZXROYkRhdGFibG9ja3MoKTtcbiAgICAgICAgICAgIGxldCBudW1Db2Rld29yZHMgPSByYXdiaXRzLmxlbmd0aCAvIGNvZGV3b3JkU2l6ZTtcbiAgICAgICAgICAgIGlmIChudW1Db2Rld29yZHMgPCBudW1EYXRhQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJhd2JpdHMubGVuZ3RoICUgY29kZXdvcmRTaXplO1xuICAgICAgICAgICAgbGV0IGRhdGFXb3JkcyA9IG5ldyBJbnQzMkFycmF5KG51bUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvZGV3b3JkczsgaSsrLCBvZmZzZXQgKz0gY29kZXdvcmRTaXplKSB7XG4gICAgICAgICAgICAgICAgZGF0YVdvcmRzW2ldID0gRGVjb2Rlci5yZWFkQ29kZShyYXdiaXRzLCBvZmZzZXQsIGNvZGV3b3JkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyKGdmKTtcbiAgICAgICAgICAgICAgICByc0RlY29kZXIuZGVjb2RlKGRhdGFXb3JkcywgbnVtQ29kZXdvcmRzIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBwZXJmb3JtIHRoZSB1bnN0dWZmaW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICAgIC8vIEZpcnN0LCBjb3VudCBob3cgbWFueSBiaXRzIGFyZSBnb2luZyB0byBiZSB0aHJvd24gb3V0IGFzIHN0dWZmaW5nXG4gICAgICAgICAgICBsZXQgbWFzayA9ICgxIDw8IGNvZGV3b3JkU2l6ZSkgLSAxO1xuICAgICAgICAgICAgbGV0IHN0dWZmZWRCaXRzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFXb3JkID0gZGF0YVdvcmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhV29yZCA9PT0gMCB8fCBkYXRhV29yZCA9PT0gbWFzaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFXb3JkID09PSAxIHx8IGRhdGFXb3JkID09PSBtYXNrIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHVmZmVkQml0cysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdywgYWN0dWFsbHkgdW5wYWNrIHRoZSBiaXRzIGFuZCByZW1vdmUgdGhlIHN0dWZmaW5nXG4gICAgICAgICAgICBsZXQgY29ycmVjdGVkQml0cyA9IG5ldyBBcnJheShudW1EYXRhQ29kZXdvcmRzICogY29kZXdvcmRTaXplIC0gc3R1ZmZlZEJpdHMpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFXb3JkID0gZGF0YVdvcmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhV29yZCA9PT0gMSB8fCBkYXRhV29yZCA9PT0gbWFzayAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBjb2Rld29yZFNpemUtMSBiaXRzIGFyZSBhbGwgemVyb3Mgb3IgYWxsIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkQml0cy5maWxsKGRhdGFXb3JkID4gMSwgaW5kZXgsIGluZGV4ICsgY29kZXdvcmRTaXplIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFycmF5cy5maWxsKGNvcnJlY3RlZEJpdHMsIGluZGV4LCBpbmRleCArIGNvZGV3b3JkU2l6ZSAtIDEsIGRhdGFXb3JkID4gMSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IGNvZGV3b3JkU2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBiaXQgPSBjb2Rld29yZFNpemUgLSAxOyBiaXQgPj0gMDsgLS1iaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZEJpdHNbaW5kZXgrK10gPSAoZGF0YVdvcmQgJiAoMSA8PCBiaXQpKSAhPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3JyZWN0ZWRCaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBhcnJheSBvZiBiaXRzIGZyb20gYW4gQXp0ZWMgQ29kZSBtYXRyaXhcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgYXJyYXkgb2YgYml0c1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdEJpdHMobWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgY29tcGFjdCA9IHRoaXMuZGRhdGEuaXNDb21wYWN0KCk7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzID0gdGhpcy5kZGF0YS5nZXROYkxheWVycygpO1xuICAgICAgICAgICAgbGV0IGJhc2VNYXRyaXhTaXplID0gKGNvbXBhY3QgPyAxMSA6IDE0KSArIGxheWVycyAqIDQ7IC8vIG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzXG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50TWFwID0gbmV3IEludDMyQXJyYXkoYmFzZU1hdHJpeFNpemUpO1xuICAgICAgICAgICAgbGV0IHJhd2JpdHMgPSBuZXcgQXJyYXkodGhpcy50b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCkpO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsaWdubWVudE1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbaV0gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXRyaXhTaXplID0gYmFzZU1hdHJpeFNpemUgKyAxICsgMiAqIEludGVnZXIudHJ1bmNEaXZpc2lvbigoSW50ZWdlci50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKSAtIDEpLCAxNSk7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdDZW50ZXIgPSBiYXNlTWF0cml4U2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IGNlbnRlciA9IEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdDZW50ZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3T2Zmc2V0ID0gaSArIEludGVnZXIudHJ1bmNEaXZpc2lvbihpLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtvcmlnQ2VudGVyIC0gaSAtIDFdID0gY2VudGVyIC0gbmV3T2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50TWFwW29yaWdDZW50ZXIgKyBpXSA9IGNlbnRlciArIG5ld09mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHJvd09mZnNldCA9IDA7IGkgPCBsYXllcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByb3dTaXplID0gKGxheWVycyAtIGkpICogNCArIChjb21wYWN0ID8gOSA6IDEyKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdG9wLWxlZnQgbW9zdCBwb2ludCBvZiB0aGlzIGxheWVyIGlzIDxsb3csIGxvdz4gKG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzKVxuICAgICAgICAgICAgICAgIGxldCBsb3cgPSBpICogMjtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYm90dG9tLXJpZ2h0IG1vc3QgcG9pbnQgb2YgdGhpcyBsYXllciBpcyA8aGlnaCwgaGlnaD4gKG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzKVxuICAgICAgICAgICAgICAgIGxldCBoaWdoID0gYmFzZU1hdHJpeFNpemUgLSAxIC0gbG93O1xuICAgICAgICAgICAgICAgIC8vIFdlIHB1bGwgYml0cyBmcm9tIHRoZSB0d28gMiB4IHJvd1NpemUgY29sdW1ucyBhbmQgdHdvIHJvd1NpemUgeCAyIHJvd3NcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd1NpemU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29sdW1uT2Zmc2V0ID0gaiAqIDI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgMjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Yml0c1tyb3dPZmZzZXQgKyBjb2x1bW5PZmZzZXQgKyBrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LmdldChhbGlnbm1lbnRNYXBbbG93ICsga10sIGFsaWdubWVudE1hcFtsb3cgKyBqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gcm93XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdiaXRzW3Jvd09mZnNldCArIDIgKiByb3dTaXplICsgY29sdW1uT2Zmc2V0ICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2xvdyArIGpdLCBhbGlnbm1lbnRNYXBbaGlnaCAtIGtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Yml0c1tyb3dPZmZzZXQgKyA0ICogcm93U2l6ZSArIGNvbHVtbk9mZnNldCArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtoaWdoIC0ga10sIGFsaWdubWVudE1hcFtoaWdoIC0gal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9wIHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3Yml0c1tyb3dPZmZzZXQgKyA2ICogcm93U2l6ZSArIGNvbHVtbk9mZnNldCArIGtdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtoaWdoIC0gal0sIGFsaWdubWVudE1hcFtsb3cgKyBrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IHJvd1NpemUgKiA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhd2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWRzIGEgY29kZSBvZiBnaXZlbiBsZW5ndGggYW5kIGF0IGdpdmVuIGluZGV4IGluIGFuIGFycmF5IG9mIGJpdHNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyByZWFkQ29kZShyYXdiaXRzLCBzdGFydEluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBzdGFydEluZGV4ICsgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMgPDw9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHJhd2JpdHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzIHw9IDB4MDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZHMgYSBjb2RlIG9mIGxlbmd0aCA4IGluIGFuIGFycmF5IG9mIGJpdHMsIHBhZGRpbmcgd2l0aCB6ZXJvc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJlYWRCeXRlKHJhd2JpdHMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBuID0gcmF3Yml0cy5sZW5ndGggLSBzdGFydEluZGV4O1xuICAgICAgICAgICAgaWYgKG4gPj0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERlY29kZXIucmVhZENvZGUocmF3Yml0cywgc3RhcnRJbmRleCwgbikgPDwgKDggLSBuKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGFja3MgYSBiaXQgYXJyYXkgaW50byBieXRlcywgbW9zdCBzaWduaWZpY2FudCBiaXQgZmlyc3RcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb252ZXJ0Qm9vbEFycmF5VG9CeXRlQXJyYXkoYm9vbEFycikge1xuICAgICAgICAgICAgbGV0IGJ5dGVBcnIgPSBuZXcgVWludDhBcnJheSgoYm9vbEFyci5sZW5ndGggKyA3KSAvIDgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycltpXSA9IERlY29kZXIucmVhZEJ5dGUoYm9vbEFyciwgOCAqIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVBcnI7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWxCaXRzSW5MYXllcihsYXllcnMsIGNvbXBhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGNvbXBhY3QgPyA4OCA6IDExMikgKyAxNiAqIGxheWVycykgKiBsYXllcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVjb2Rlci5VUFBFUl9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJyxcbiAgICAgICAgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnQ1RSTF9MTCcsICdDVFJMX01MJywgJ0NUUkxfREwnLCAnQ1RSTF9CUydcbiAgICBdO1xuICAgIERlY29kZXIuTE9XRVJfVEFCTEUgPSBbXG4gICAgICAgICdDVFJMX1BTJywgJyAnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsXG4gICAgICAgICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ0NUUkxfVVMnLCAnQ1RSTF9NTCcsICdDVFJMX0RMJywgJ0NUUkxfQlMnXG4gICAgXTtcbiAgICBEZWNvZGVyLk1JWEVEX1RBQkxFID0gW1xuICAgICAgICAvLyBNb2R1bGUgcGFyc2UgZmFpbGVkOiBPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlICg1MDoyOSlcbiAgICAgICAgLy8gc28gbnVtYmVyIHN0cmluZyB3ZXJlIHNjYXBlZFxuICAgICAgICAnQ1RSTF9QUycsICcgJywgJ1xcXFwxJywgJ1xcXFwyJywgJ1xcXFwzJywgJ1xcXFw0JywgJ1xcXFw1JywgJ1xcXFw2JywgJ1xcXFw3JywgJ1xcYicsICdcXHQnLCAnXFxuJyxcbiAgICAgICAgJ1xcXFwxMycsICdcXGYnLCAnXFxyJywgJ1xcXFwzMycsICdcXFxcMzQnLCAnXFxcXDM1JywgJ1xcXFwzNicsICdcXFxcMzcnLCAnQCcsICdcXFxcJywgJ14nLCAnXycsXG4gICAgICAgICdgJywgJ3wnLCAnficsICdcXFxcMTc3JywgJ0NUUkxfTEwnLCAnQ1RSTF9VTCcsICdDVFJMX1BMJywgJ0NUUkxfQlMnXG4gICAgXTtcbiAgICBEZWNvZGVyLlBVTkNUX1RBQkxFID0gW1xuICAgICAgICAnJywgJ1xccicsICdcXHJcXG4nLCAnLiAnLCAnLCAnLCAnOiAnLCAnIScsICdcIicsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsICcoJywgJyknLFxuICAgICAgICAnKicsICcrJywgJywnLCAnLScsICcuJywgJy8nLCAnOicsICc7JywgJzwnLCAnPScsICc+JywgJz8nLCAnWycsICddJywgJ3snLCAnfScsICdDVFJMX1VMJ1xuICAgIF07XG4gICAgRGVjb2Rlci5ESUdJVF9UQUJMRSA9IFtcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJywnLCAnLicsICdDVFJMX1VMJywgJ0NUUkxfVVMnXG4gICAgXTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTIgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24uZGV0ZWN0b3IgeyovXG4gICAgLyoqXG4gICAgICogR2VuZXJhbCBtYXRoLXJlbGF0ZWQgYW5kIG51bWVyaWMgdXRpbGl0eSBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgTWF0aFV0aWxzIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuZHMgdXAgYmVpbmcgYSBiaXQgZmFzdGVyIHRoYW4ge0BsaW5rIE1hdGgjcm91bmQoZmxvYXQpfS4gVGhpcyBtZXJlbHkgcm91bmRzIGl0c1xuICAgICAgICAgKiBhcmd1bWVudCB0byB0aGUgbmVhcmVzdCBpbnQsIHdoZXJlIHguNSByb3VuZHMgdXAgdG8geCsxLiBTZW1hbnRpY3Mgb2YgdGhpcyBzaG9ydGN1dFxuICAgICAgICAgKiBkaWZmZXIgc2xpZ2h0bHkgZnJvbSB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9IGluIHRoYXQgaGFsZiByb3VuZHMgZG93biBmb3IgbmVnYXRpdmVcbiAgICAgICAgICogdmFsdWVzLiAtMi41IHJvdW5kcyB0byAtMywgbm90IC0yLiBGb3IgcHVycG9zZXMgaGVyZSBpdCBtYWtlcyBubyBkaWZmZXJlbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZCByZWFsIHZhbHVlIHRvIHJvdW5kXG4gICAgICAgICAqIEByZXR1cm4gbmVhcmVzdCB7QGNvZGUgaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJvdW5kKGQgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBpZiAoTmFOID09PSBkKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGQgPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgaWYgKGQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgcmV0dXJuIC8qKGludCkgKi8gKGQgKyAoZCA8IDAuMCA/IC0wLjUgOiAwLjUpKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IG1heWJlIHJlbW92ZSByb3VuZCBtZXRob2QgYW5kIGNhbGwgZGlyZWN0bHkgTWF0aC5yb3VuZCwgaXQgbG9va3MgbGlrZSBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIGpzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYVggcG9pbnQgQSB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYlkgcG9pbnQgQiB5IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRpc3RhbmNlKGFYIC8qZmxvYXR8aW50Ki8sIGFZIC8qZmxvYXR8aW50Ki8sIGJYIC8qZmxvYXR8aW50Ki8sIGJZIC8qZmxvYXR8aW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHhEaWZmID0gYVggLSBiWDtcbiAgICAgICAgICAgIGNvbnN0IHlEaWZmID0gYVkgLSBiWTtcbiAgICAgICAgICAgIHJldHVybiAvKihmbG9hdCkgKi8gTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFYIHBvaW50IEEgeCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBhWSBwb2ludCBBIHkgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gYlggcG9pbnQgQiB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGJZIHBvaW50IEIgeSBjb29yZGluYXRlXG4gICAgICAgICAqIEByZXR1cm4gRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIEEgYW5kIEJcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBzdGF0aWMgZGlzdGFuY2UoYVg6IG51bWJlciAvKmludCovLCBhWTogbnVtYmVyIC8qaW50Ki8sIGJYOiBudW1iZXIgLyppbnQqLywgYlk6IG51bWJlciAvKmludCovKTogZmxvYXQge1xuICAgICAgICAvLyAgIGNvbnN0IHhEaWZmID0gYVggLSBiWFxuICAgICAgICAvLyAgIGNvbnN0IHlEaWZmID0gYVkgLSBiWVxuICAgICAgICAvLyAgIHJldHVybiAoZmxvYXQpIE1hdGguc3FydCh4RGlmZiAqIHhEaWZmICsgeURpZmYgKiB5RGlmZik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBhcnJheSB2YWx1ZXMgdG8gc3VtXG4gICAgICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlcyBpbiBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHN1bShhcnJheSkge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgIT09IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb255ZmlsbCBmb3IgSmF2YSdzIEZsb2F0IGNsYXNzLlxuICAgICAqL1xuICAgIGNsYXNzIEZsb2F0IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmNUUyBoYXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGludCBhbmQgZmxvYXQsIHRoZXJlJ3MgYWxsIG51bWJlcnMsXG4gICAgICAgICAqIHRoaXMgaXMgdXNlZCBvbmx5IHRvIHBvbHlmaWxsIEphdmEgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmbG9hdFRvSW50Qml0cyhmKSB7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmxvYXQgbWF4IHZhbHVlIGluIEpTIGlzIHRoZSBudW1iZXIgbWF4IHZhbHVlLlxuICAgICAqL1xuICAgIEZsb2F0Lk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgYSBwb2ludCBvZiBpbnRlcmVzdCBpbiBhbiBpbWFnZSBjb250YWluaW5nIGEgYmFyY29kZS4gVHlwaWNhbGx5LCB0aGlzXG4gICAgICogd291bGQgYmUgdGhlIGxvY2F0aW9uIG9mIGEgZmluZGVyIHBhdHRlcm4gb3IgdGhlIGNvcm5lciBvZiB0aGUgYmFyY29kZSwgZm9yIGV4YW1wbGUuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBSZXN1bHRQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGdldFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICB9XG4gICAgICAgIGdldFkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZXN1bHRQb2ludCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyUG9pbnQgPSBvdGhlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlclBvaW50LnggJiYgdGhpcy55ID09PSBvdGhlclBvaW50Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAzMSAqIEZsb2F0LmZsb2F0VG9JbnRCaXRzKHRoaXMueCkgKyBGbG9hdC5mbG9hdFRvSW50Qml0cyh0aGlzLnkpO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgdGhpcy54ICsgJywnICsgdGhpcy55ICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcmRlcnMgYW4gYXJyYXkgb2YgdGhyZWUgUmVzdWx0UG9pbnRzIGluIGFuIG9yZGVyIFtBLEIsQ10gc3VjaCB0aGF0IEFCIGlzIGxlc3MgdGhhbiBBQ1xuICAgICAgICAgKiBhbmQgQkMgaXMgbGVzcyB0aGFuIEFDLCBhbmQgdGhlIGFuZ2xlIGJldHdlZW4gQkMgYW5kIEJBIGlzIGxlc3MgdGhhbiAxODAgZGVncmVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm5zIGFycmF5IG9mIHRocmVlIHtAY29kZSBSZXN1bHRQb2ludH0gdG8gb3JkZXJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBvcmRlckJlc3RQYXR0ZXJucyhwYXR0ZXJucykge1xuICAgICAgICAgICAgLy8gRmluZCBkaXN0YW5jZXMgYmV0d2VlbiBwYXR0ZXJuIGNlbnRlcnNcbiAgICAgICAgICAgIGNvbnN0IHplcm9PbmVEaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UocGF0dGVybnNbMF0sIHBhdHRlcm5zWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IG9uZVR3b0Rpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1sxXSwgcGF0dGVybnNbMl0pO1xuICAgICAgICAgICAgY29uc3QgemVyb1R3b0Rpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1swXSwgcGF0dGVybnNbMl0pO1xuICAgICAgICAgICAgbGV0IHBvaW50QTtcbiAgICAgICAgICAgIGxldCBwb2ludEI7XG4gICAgICAgICAgICBsZXQgcG9pbnRDO1xuICAgICAgICAgICAgLy8gQXNzdW1lIG9uZSBjbG9zZXN0IHRvIG90aGVyIHR3byBpcyBCOyBBIGFuZCBDIHdpbGwganVzdCBiZSBndWVzc2VzIGF0IGZpcnN0XG4gICAgICAgICAgICBpZiAob25lVHdvRGlzdGFuY2UgPj0gemVyb09uZURpc3RhbmNlICYmIG9uZVR3b0Rpc3RhbmNlID49IHplcm9Ud29EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoemVyb1R3b0Rpc3RhbmNlID49IG9uZVR3b0Rpc3RhbmNlICYmIHplcm9Ud29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSBwYXR0ZXJuc1sxXTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBwYXR0ZXJuc1swXTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSBwYXR0ZXJuc1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzJdO1xuICAgICAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIGNyb3NzIHByb2R1Y3QgdG8gZmlndXJlIG91dCB3aGV0aGVyIEEgYW5kIEMgYXJlIGNvcnJlY3Qgb3IgZmxpcHBlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgYXNrcyB3aGV0aGVyIEJDIHggQkEgaGFzIGEgcG9zaXRpdmUgeiBjb21wb25lbnQsIHdoaWNoIGlzIHRoZSBhcnJhbmdlbWVudFxuICAgICAgICAgICAgLy8gd2Ugd2FudCBmb3IgQSwgQiwgQy4gSWYgaXQncyBuZWdhdGl2ZSwgdGhlbiB3ZSd2ZSBnb3QgaXQgZmxpcHBlZCBhcm91bmQgYW5kXG4gICAgICAgICAgICAvLyBzaG91bGQgc3dhcCBBIGFuZCBDLlxuICAgICAgICAgICAgaWYgKHRoaXMuY3Jvc3NQcm9kdWN0Wihwb2ludEEsIHBvaW50QiwgcG9pbnRDKSA8IDAuMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBwb2ludEE7XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gcG9pbnRDO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXR0ZXJuc1swXSA9IHBvaW50QTtcbiAgICAgICAgICAgIHBhdHRlcm5zWzFdID0gcG9pbnRCO1xuICAgICAgICAgICAgcGF0dGVybnNbMl0gPSBwb2ludEM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuMSBmaXJzdCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBwYXR0ZXJuMiBzZWNvbmQgcGF0dGVyblxuICAgICAgICAgKiBAcmV0dXJuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRpc3RhbmNlKHBhdHRlcm4xLCBwYXR0ZXJuMikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZShwYXR0ZXJuMS54LCBwYXR0ZXJuMS55LCBwYXR0ZXJuMi54LCBwYXR0ZXJuMi55KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgeiBjb21wb25lbnQgb2YgdGhlIGNyb3NzIHByb2R1Y3QgYmV0d2VlbiB2ZWN0b3JzIEJDIGFuZCBCQS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJYID0gcG9pbnRCLng7XG4gICAgICAgICAgICBjb25zdCBiWSA9IHBvaW50Qi55O1xuICAgICAgICAgICAgcmV0dXJuICgocG9pbnRDLnggLSBiWCkgKiAocG9pbnRBLnkgLSBiWSkpIC0gKChwb2ludEMueSAtIGJZKSAqIChwb2ludEEueCAtIGJYKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGRldGVjdGluZyBhIGJhcmNvZGUgaW4gYW4gaW1hZ2UuIFRoaXMgaW5jbHVkZXMgdGhlIHJhd1xuICAgICAqIG1hdHJpeCBvZiBibGFjay93aGl0ZSBwaXhlbHMgY29ycmVzcG9uZGluZyB0byB0aGUgYmFyY29kZSwgYW5kIHBvc3NpYmx5IHBvaW50cyBvZiBpbnRlcmVzdFxuICAgICAqIGluIHRoZSBpbWFnZSwgbGlrZSB0aGUgbG9jYXRpb24gb2YgZmluZGVyIHBhdHRlcm5zIG9yIGNvcm5lcnMgb2YgdGhlIGJhcmNvZGUgaW4gdGhlIGltYWdlLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGV0ZWN0b3JSZXN1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihiaXRzLCBwb2ludHMpIHtcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfVxuICAgICAgICBnZXRCaXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcbiAgICAgICAgfVxuICAgICAgICBnZXRQb2ludHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkV4dGVuZHMge0BsaW5rIERldGVjdG9yUmVzdWx0fSB3aXRoIG1vcmUgaW5mb3JtYXRpb24gc3BlY2lmaWMgdG8gdGhlIEF6dGVjIGZvcm1hdCxcbiAgICAgKiBsaWtlIHRoZSBudW1iZXIgb2YgbGF5ZXJzIGFuZCB3aGV0aGVyIGl0J3MgY29tcGFjdC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEF6dGVjRGV0ZWN0b3JSZXN1bHQgZXh0ZW5kcyBEZXRlY3RvclJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJpdHMsIHBvaW50cywgY29tcGFjdCwgbmJEYXRhYmxvY2tzLCBuYkxheWVycykge1xuICAgICAgICAgICAgc3VwZXIoYml0cywgcG9pbnRzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgICAgICAgICB0aGlzLm5iRGF0YWJsb2NrcyA9IG5iRGF0YWJsb2NrcztcbiAgICAgICAgICAgIHRoaXMubmJMYXllcnMgPSBuYkxheWVycztcbiAgICAgICAgfVxuICAgICAgICBnZXROYkxheWVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5iTGF5ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldE5iRGF0YWJsb2NrcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5iRGF0YWJsb2NrcztcbiAgICAgICAgfVxuICAgICAgICBpc0NvbXBhY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYWN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5cbiAgICAgKiBEZXRlY3RzIGEgY2FuZGlkYXRlIGJhcmNvZGUtbGlrZSByZWN0YW5ndWxhciByZWdpb24gd2l0aGluIGFuIGltYWdlLiBJdFxuICAgICAqIHN0YXJ0cyBhcm91bmQgdGhlIGNlbnRlciBvZiB0aGUgaW1hZ2UsIGluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGUgY2FuZGlkYXRlXG4gICAgICogcmVnaW9uIHVudGlsIGl0IGZpbmRzIGEgd2hpdGUgcmVjdGFuZ3VsYXIgcmVnaW9uLiBCeSBrZWVwaW5nIHRyYWNrIG9mIHRoZVxuICAgICAqIGxhc3QgYmxhY2sgcG9pbnRzIGl0IGVuY291bnRlcmVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjb3JuZXJzIG9mIHRoZSBiYXJjb2RlLlxuICAgICAqIDwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgRGF2aWQgT2xpdmllclxuICAgICAqL1xuICAgIGNsYXNzIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3Ige1xuICAgICAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBpbWFnZTogQml0TWF0cml4KSAvKnRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiovIHtcbiAgICAgICAgLy8gICB0aGlzKGltYWdlLCBJTklUX1NJWkUsIGltYWdlLmdldFdpZHRoKCkgLyAyLCBpbWFnZS5nZXRIZWlnaHQoKSAvIDIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBiYXJjb2RlIGltYWdlIHRvIGZpbmQgYSByZWN0YW5nbGUgaW5cbiAgICAgICAgICogQHBhcmFtIGluaXRTaXplIGluaXRpYWwgc2l6ZSBvZiBzZWFyY2ggYXJlYSBhcm91bmQgY2VudGVyXG4gICAgICAgICAqIEBwYXJhbSB4IHggcG9zaXRpb24gb2Ygc2VhcmNoIGNlbnRlclxuICAgICAgICAgKiBAcGFyYW0geSB5IHBvc2l0aW9uIG9mIHNlYXJjaCBjZW50ZXJcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBpcyB0b28gc21hbGwgdG8gYWNjb21tb2RhdGUge0Bjb2RlIGluaXRTaXplfVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UsIGluaXRTaXplIC8qaW50Ki8sIHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBpbml0U2l6ZSB8fCBudWxsID09PSBpbml0U2l6ZSkge1xuICAgICAgICAgICAgICAgIGluaXRTaXplID0gV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5JTklUX1NJWkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSB4IHx8IG51bGwgPT09IHgpIHtcbiAgICAgICAgICAgICAgICB4ID0gaW1hZ2UuZ2V0V2lkdGgoKSAvIDIgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0geSB8fCBudWxsID09PSB5KSB7XG4gICAgICAgICAgICAgICAgeSA9IGltYWdlLmdldEhlaWdodCgpIC8gMiB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYWxmc2l6ZSA9IGluaXRTaXplIC8gMiB8IDA7XG4gICAgICAgICAgICB0aGlzLmxlZnRJbml0ID0geCAtIGhhbGZzaXplO1xuICAgICAgICAgICAgdGhpcy5yaWdodEluaXQgPSB4ICsgaGFsZnNpemU7XG4gICAgICAgICAgICB0aGlzLnVwSW5pdCA9IHkgLSBoYWxmc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZG93bkluaXQgPSB5ICsgaGFsZnNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy51cEluaXQgPCAwIHx8IHRoaXMubGVmdEluaXQgPCAwIHx8IHRoaXMuZG93bkluaXQgPj0gdGhpcy5oZWlnaHQgfHwgdGhpcy5yaWdodEluaXQgPj0gdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogRGV0ZWN0cyBhIGNhbmRpZGF0ZSBiYXJjb2RlLWxpa2UgcmVjdGFuZ3VsYXIgcmVnaW9uIHdpdGhpbiBhbiBpbWFnZS4gSXRcbiAgICAgICAgICogc3RhcnRzIGFyb3VuZCB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZSwgaW5jcmVhc2VzIHRoZSBzaXplIG9mIHRoZSBjYW5kaWRhdGVcbiAgICAgICAgICogcmVnaW9uIHVudGlsIGl0IGZpbmRzIGEgd2hpdGUgcmVjdGFuZ3VsYXIgcmVnaW9uLlxuICAgICAgICAgKiA8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFJlc3VsdFBvaW50fVtdIGRlc2NyaWJpbmcgdGhlIGNvcm5lcnMgb2YgdGhlIHJlY3Rhbmd1bGFyXG4gICAgICAgICAqICAgICAgICAgcmVnaW9uLiBUaGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvcHBvc2VkIG9uIHRoZSBkaWFnb25hbCwgYXNcbiAgICAgICAgICogICAgICAgICBhcmUgdGhlIHNlY29uZCBhbmQgdGhpcmQuIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIHRoZSB0b3Btb3N0XG4gICAgICAgICAqICAgICAgICAgcG9pbnQgYW5kIHRoZSBsYXN0LCB0aGUgYm90dG9tbW9zdC4gVGhlIHNlY29uZCBwb2ludCB3aWxsIGJlXG4gICAgICAgICAqICAgICAgICAgbGVmdG1vc3QgYW5kIHRoZSB0aGlyZCwgdGhlIHJpZ2h0bW9zdFxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIERhdGEgTWF0cml4IENvZGUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3QoKSB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdEluaXQ7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLnJpZ2h0SW5pdDtcbiAgICAgICAgICAgIGxldCB1cCA9IHRoaXMudXBJbml0O1xuICAgICAgICAgICAgbGV0IGRvd24gPSB0aGlzLmRvd25Jbml0O1xuICAgICAgICAgICAgbGV0IHNpemVFeGNlZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICBsZXQgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIHdoaWxlIChhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIC8vIC4gICB8XG4gICAgICAgICAgICAgICAgLy8gLi4uLi5cbiAgICAgICAgICAgICAgICBsZXQgcmlnaHRCb3JkZXJOb3RXaGl0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChyaWdodEJvcmRlck5vdFdoaXRlIHx8ICFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCkgJiYgcmlnaHQgPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodEJvcmRlck5vdFdoaXRlID0gdGhpcy5jb250YWluc0JsYWNrUG9pbnQodXAsIGRvd24sIHJpZ2h0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodEJvcmRlck5vdFdoaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIC8vIC4gICAuXG4gICAgICAgICAgICAgICAgLy8gLl9fXy5cbiAgICAgICAgICAgICAgICBsZXQgYm90dG9tQm9yZGVyTm90V2hpdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYm90dG9tQm9yZGVyTm90V2hpdGUgfHwgIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvdHRvbSkgJiYgZG93biA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBib3R0b21Cb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KGxlZnQsIHJpZ2h0LCBkb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbUJvcmRlck5vdFdoaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvd24gPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAuLi4uLlxuICAgICAgICAgICAgICAgIC8vIHwgICAuXG4gICAgICAgICAgICAgICAgLy8gLi4uLi5cbiAgICAgICAgICAgICAgICBsZXQgbGVmdEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGxlZnRCb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCkgJiYgbGVmdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRCb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KHVwLCBkb3duLCBsZWZ0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0Qm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25MZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLl9fXy5cbiAgICAgICAgICAgICAgICAvLyAuICAgLlxuICAgICAgICAgICAgICAgIC8vIC4uLi4uXG4gICAgICAgICAgICAgICAgbGV0IHRvcEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRvcEJvcmRlck5vdFdoaXRlIHx8ICFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3ApICYmIHVwID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQm9yZGVyTm90V2hpdGUgPSB0aGlzLmNvbnRhaW5zQmxhY2tQb2ludChsZWZ0LCByaWdodCwgdXAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wQm9yZGVyTm90V2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNpemVFeGNlZWRlZCAmJiBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgICAgIGxldCB6ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgeiA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHogPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQobGVmdCwgZG93biAtIGksIGxlZnQgKyBpLCBkb3duKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGdvIGRvd24gcmlnaHRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgdCA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQobGVmdCwgdXAgKyBpLCBsZWZ0ICsgaSwgdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZ28gZG93biBsZWZ0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IHggPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRCbGFja1BvaW50T25TZWdtZW50KHJpZ2h0LCB1cCArIGksIHJpZ2h0IC0gaSwgdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZ28gdXAgbGVmdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyB5ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0QmxhY2tQb2ludE9uU2VnbWVudChyaWdodCwgZG93biAtIGksIHJpZ2h0IC0gaSwgZG93bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbnRlckVkZ2VzKHksIHosIHgsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmxhY2tQb2ludE9uU2VnbWVudChhWCAvKmZsb2F0Ki8sIGFZIC8qZmxvYXQqLywgYlggLypmbG9hdCovLCBiWSAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoVXRpbHMucm91bmQoTWF0aFV0aWxzLmRpc3RhbmNlKGFYLCBhWSwgYlgsIGJZKSk7XG4gICAgICAgICAgICBjb25zdCB4U3RlcCA9IChiWCAtIGFYKSAvIGRpc3Q7XG4gICAgICAgICAgICBjb25zdCB5U3RlcCA9IChiWSAtIGFZKSAvIGRpc3Q7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoVXRpbHMucm91bmQoYVggKyBpICogeFN0ZXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoVXRpbHMucm91bmQoYVkgKyBpICogeVN0ZXApO1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogcmVjZW50ZXJzIHRoZSBwb2ludHMgb2YgYSBjb25zdGFudCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBjZW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHkgYm90dG9tIG1vc3QgcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHogbGVmdCBtb3N0IHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB4IHJpZ2h0IG1vc3QgcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHQgdG9wIG1vc3QgcG9pbnRcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgUmVzdWx0UG9pbnR9W10gZGVzY3JpYmluZyB0aGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ3VsYXJcbiAgICAgICAgICogICAgICAgICByZWdpb24uIFRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9wcG9zZWQgb24gdGhlIGRpYWdvbmFsLCBhc1xuICAgICAgICAgKiAgICAgICAgIGFyZSB0aGUgc2Vjb25kIGFuZCB0aGlyZC4gVGhlIGZpcnN0IHBvaW50IHdpbGwgYmUgdGhlIHRvcG1vc3RcbiAgICAgICAgICogICAgICAgICBwb2ludCBhbmQgdGhlIGxhc3QsIHRoZSBib3R0b21tb3N0LiBUaGUgc2Vjb25kIHBvaW50IHdpbGwgYmVcbiAgICAgICAgICogICAgICAgICBsZWZ0bW9zdCBhbmQgdGhlIHRoaXJkLCB0aGUgcmlnaHRtb3N0XG4gICAgICAgICAqL1xuICAgICAgICBjZW50ZXJFZGdlcyh5LCB6LCB4LCB0KSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgICAgdCAgICAgICAgICAgIHRcbiAgICAgICAgICAgIC8vICB6ICAgICAgICAgICAgICAgICAgICAgIHhcbiAgICAgICAgICAgIC8vICAgICAgICB4ICAgIE9SICAgIHpcbiAgICAgICAgICAgIC8vICAgeSAgICAgICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IHlpID0geS5nZXRYKCk7XG4gICAgICAgICAgICBjb25zdCB5aiA9IHkuZ2V0WSgpO1xuICAgICAgICAgICAgY29uc3QgemkgPSB6LmdldFgoKTtcbiAgICAgICAgICAgIGNvbnN0IHpqID0gei5nZXRZKCk7XG4gICAgICAgICAgICBjb25zdCB4aSA9IHguZ2V0WCgpO1xuICAgICAgICAgICAgY29uc3QgeGogPSB4LmdldFkoKTtcbiAgICAgICAgICAgIGNvbnN0IHRpID0gdC5nZXRYKCk7XG4gICAgICAgICAgICBjb25zdCB0aiA9IHQuZ2V0WSgpO1xuICAgICAgICAgICAgY29uc3QgQ09SUiA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IuQ09SUjtcbiAgICAgICAgICAgIGlmICh5aSA8IHRoaXMud2lkdGggLyAyLjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQodGkgLSBDT1JSLCB0aiArIENPUlIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoemkgKyBDT1JSLCB6aiArIENPUlIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoeGkgLSBDT1JSLCB4aiAtIENPUlIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoeWkgKyBDT1JSLCB5aiAtIENPUlIpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh0aSArIENPUlIsIHRqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh6aSArIENPUlIsIHpqIC0gQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh4aSAtIENPUlIsIHhqICsgQ09SUiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCh5aSAtIENPUlIsIHlqIC0gQ09SUilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzZWdtZW50IGNvbnRhaW5zIGEgYmxhY2sgcG9pbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGEgICAgICAgICAgbWluIHZhbHVlIG9mIHRoZSBzY2FubmVkIGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGIgICAgICAgICAgbWF4IHZhbHVlIG9mIHRoZSBzY2FubmVkIGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGZpeGVkICAgICAgdmFsdWUgb2YgZml4ZWQgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gaG9yaXpvbnRhbCBzZXQgdG8gdHJ1ZSBpZiBzY2FuIG11c3QgYmUgaG9yaXpvbnRhbCwgZmFsc2UgaWYgdmVydGljYWxcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGEgYmxhY2sgcG9pbnQgaGFzIGJlZW4gZm91bmQsIGVsc2UgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluc0JsYWNrUG9pbnQoYSAvKmludCovLCBiIC8qaW50Ki8sIGZpeGVkIC8qaW50Ki8sIGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IGE7IHggPD0gYjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoeCwgZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSBhOyB5IDw9IGI7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGZpeGVkLCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5JTklUX1NJWkUgPSAxMDtcbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLkNPUlIgPSAxO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjbGFzcyBjYW4sIGdpdmVuIGxvY2F0aW9ucyBvZiBmaW5kZXIgcGF0dGVybnMgZm9yIGEgUVIgY29kZSBpbiBhblxuICAgICAqIGltYWdlLCBzYW1wbGUgdGhlIHJpZ2h0IHBvaW50cyBpbiB0aGUgaW1hZ2UgdG8gcmVjb25zdHJ1Y3QgdGhlIFFSIGNvZGUsIGFjY291bnRpbmcgZm9yXG4gICAgICogcGVyc3BlY3RpdmUgZGlzdG9ydGlvbi4gSXQgaXMgYWJzdHJhY3RlZCBzaW5jZSBpdCBpcyByZWxhdGl2ZWx5IGV4cGVuc2l2ZSBhbmQgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgKiB0byB0YWtlIGFkdmFudGFnZSBvZiBwbGF0Zm9ybS1zcGVjaWZpYyBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb25zLCBsaWtlIFN1bidzIEphdmEgQWR2YW5jZWRcbiAgICAgKiBJbWFnaW5nIGxpYnJhcnksIGJ1dCB3aGljaCBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBvdGhlciBlbnZpcm9ubWVudHMgc3VjaCBhcyBKMk1FLCBhbmQgdmljZVxuICAgICAqIHZlcnNhLlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIHVzZWQgY2FuIGJlIGNvbnRyb2xsZWQgYnkgY2FsbGluZyB7QGxpbmsgI3NldEdyaWRTYW1wbGVyKEdyaWRTYW1wbGVyKX1cbiAgICAgKiB3aXRoIGFuIGluc3RhbmNlIG9mIGEgY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyB0aGlzIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgR3JpZFNhbXBsZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q2hlY2tzIGEgc2V0IG9mIHBvaW50cyB0aGF0IGhhdmUgYmVlbiB0cmFuc2Zvcm1lZCB0byBzYW1wbGUgcG9pbnRzIG9uIGFuIGltYWdlIGFnYWluc3RcbiAgICAgICAgICogdGhlIGltYWdlJ3MgZGltZW5zaW9ucyB0byBzZWUgaWYgdGhlIHBvaW50IGFyZSBldmVuIHdpdGhpbiB0aGUgaW1hZ2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5UaGlzIG1ldGhvZCB3aWxsIGFjdHVhbGx5IFwibnVkZ2VcIiB0aGUgZW5kcG9pbnRzIGJhY2sgb250byB0aGUgaW1hZ2UgaWYgdGhleSBhcmUgZm91bmQgdG8gYmVcbiAgICAgICAgICogYmFyZWx5IChsZXNzIHRoYW4gMSBwaXhlbCkgb2ZmIHRoZSBpbWFnZS4gVGhpcyBhY2NvdW50cyBmb3IgaW1wZXJmZWN0IGRldGVjdGlvbiBvZiBmaW5kZXJcbiAgICAgICAgICogcGF0dGVybnMgaW4gYW4gaW1hZ2Ugd2hlcmUgdGhlIFFSIENvZGUgcnVucyBhbGwgdGhlIHdheSB0byB0aGUgaW1hZ2UgYm9yZGVyLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+Rm9yIGVmZmljaWVuY3ksIHRoZSBtZXRob2Qgd2lsbCBjaGVjayBwb2ludHMgZnJvbSBlaXRoZXIgZW5kIG9mIHRoZSBsaW5lIHVudGlsIG9uZSBpcyBmb3VuZFxuICAgICAgICAgKiB0byBiZSB3aXRoaW4gdGhlIGltYWdlLiBCZWNhdXNlIHRoZSBzZXQgb2YgcG9pbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGxpbmVhciwgdGhpcyBpcyB2YWxpZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSBpbnRvIHdoaWNoIHRoZSBwb2ludHMgc2hvdWxkIG1hcFxuICAgICAgICAgKiBAcGFyYW0gcG9pbnRzIGFjdHVhbCBwb2ludHMgaW4geDEseTEsLi4uLHhuLHluIGZvcm1cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhbiBlbmRwb2ludCBpcyBsaWVzIG91dHNpZGUgdGhlIGltYWdlIGJvdW5kYXJpZXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjaGVja0FuZE51ZGdlUG9pbnRzKGltYWdlLCBwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIHN0YXJ0IHVudGlsIHdlIHNlZSBzb21lIHRoYXQgYXJlIE9LOlxuICAgICAgICAgICAgbGV0IG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBwb2ludHMubGVuZ3RoICYmIG51ZGdlZDsgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IocG9pbnRzW29mZnNldCArIDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoeCA8IC0xIHx8IHggPiB3aWR0aCB8fCB5IDwgLTEgfHwgeSA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVkZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4ID09PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IHdpZHRoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IGhlaWdodCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIGVuZDpcbiAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBwb2ludHMubGVuZ3RoIC0gMjsgb2Zmc2V0ID49IDAgJiYgbnVkZ2VkOyBvZmZzZXQgLT0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudWRnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gd2lkdGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gaGVpZ2h0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIHBlcnNwZWN0aXZlIHRyYW5zZm9ybSBpbiB0d28gZGltZW5zaW9ucy4gR2l2ZW4gZm91ciBzb3VyY2UgYW5kIGZvdXJcbiAgICAgKiBkZXN0aW5hdGlvbiBwb2ludHMsIGl0IHdpbGwgY29tcHV0ZSB0aGUgdHJhbnNmb3JtYXRpb24gaW1wbGllZCBiZXR3ZWVuIHRoZW0uIFRoZSBjb2RlIGlzIGJhc2VkXG4gICAgICogZGlyZWN0bHkgdXBvbiBzZWN0aW9uIDMuNC4yIG9mIEdlb3JnZSBXb2xiZXJnJ3MgXCJEaWdpdGFsIEltYWdlIFdhcnBpbmdcIjsgc2VlIHBhZ2VzIDU0LTU2LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihhMTEgLypmbG9hdCovLCBhMjEgLypmbG9hdCovLCBhMzEgLypmbG9hdCovLCBhMTIgLypmbG9hdCovLCBhMjIgLypmbG9hdCovLCBhMzIgLypmbG9hdCovLCBhMTMgLypmbG9hdCovLCBhMjMgLypmbG9hdCovLCBhMzMgLypmbG9hdCovKSB7XG4gICAgICAgICAgICB0aGlzLmExMSA9IGExMTtcbiAgICAgICAgICAgIHRoaXMuYTIxID0gYTIxO1xuICAgICAgICAgICAgdGhpcy5hMzEgPSBhMzE7XG4gICAgICAgICAgICB0aGlzLmExMiA9IGExMjtcbiAgICAgICAgICAgIHRoaXMuYTIyID0gYTIyO1xuICAgICAgICAgICAgdGhpcy5hMzIgPSBhMzI7XG4gICAgICAgICAgICB0aGlzLmExMyA9IGExMztcbiAgICAgICAgICAgIHRoaXMuYTIzID0gYTIzO1xuICAgICAgICAgICAgdGhpcy5hMzMgPSBhMzM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHF1YWRyaWxhdGVyYWxUb1F1YWRyaWxhdGVyYWwoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8sIHgwcCAvKmZsb2F0Ki8sIHkwcCAvKmZsb2F0Ki8sIHgxcCAvKmZsb2F0Ki8sIHkxcCAvKmZsb2F0Ki8sIHgycCAvKmZsb2F0Ki8sIHkycCAvKmZsb2F0Ki8sIHgzcCAvKmZsb2F0Ki8sIHkzcCAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IHFUb1MgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9TcXVhcmUoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIGNvbnN0IHNUb1EgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5zcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDBwLCB5MHAsIHgxcCwgeTFwLCB4MnAsIHkycCwgeDNwLCB5M3ApO1xuICAgICAgICAgICAgcmV0dXJuIHNUb1EudGltZXMocVRvUyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtUG9pbnRzKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMuYTExO1xuICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5hMTI7XG4gICAgICAgICAgICBjb25zdCBhMTMgPSB0aGlzLmExMztcbiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuYTIxO1xuICAgICAgICAgICAgY29uc3QgYTIyID0gdGhpcy5hMjI7XG4gICAgICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmEyMztcbiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuYTMxO1xuICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5hMzI7XG4gICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLmEzMztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gYTEzICogeCArIGEyMyAqIHkgKyBhMzM7XG4gICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gKGExMSAqIHggKyBhMjEgKiB5ICsgYTMxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIHBvaW50c1tpICsgMV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtUG9pbnRzV2l0aFZhbHVlcyh4VmFsdWVzLCB5VmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmExMTtcbiAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMuYTEyO1xuICAgICAgICAgICAgY29uc3QgYTEzID0gdGhpcy5hMTM7XG4gICAgICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmEyMTtcbiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuYTIyO1xuICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5hMjM7XG4gICAgICAgICAgICBjb25zdCBhMzEgPSB0aGlzLmEzMTtcbiAgICAgICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuYTMyO1xuICAgICAgICAgICAgY29uc3QgYTMzID0gdGhpcy5hMzM7XG4gICAgICAgICAgICBjb25zdCBuID0geFZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB5VmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gYTEzICogeCArIGEyMyAqIHkgKyBhMzM7XG4gICAgICAgICAgICAgICAgeFZhbHVlc1tpXSA9IChhMTEgKiB4ICsgYTIxICogeSArIGEzMSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICB5VmFsdWVzW2ldID0gKGExMiAqIHggKyBhMjIgKiB5ICsgYTMyKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDAgLypmbG9hdCovLCB5MCAvKmZsb2F0Ki8sIHgxIC8qZmxvYXQqLywgeTEgLypmbG9hdCovLCB4MiAvKmZsb2F0Ki8sIHkyIC8qZmxvYXQqLywgeDMgLypmbG9hdCovLCB5MyAvKmZsb2F0Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGR4MyA9IHgwIC0geDEgKyB4MiAtIHgzO1xuICAgICAgICAgICAgY29uc3QgZHkzID0geTAgLSB5MSArIHkyIC0geTM7XG4gICAgICAgICAgICBpZiAoZHgzID09PSAwLjAgJiYgZHkzID09PSAwLjApIHtcbiAgICAgICAgICAgICAgICAvLyBBZmZpbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHgxIC0geDAsIHgyIC0geDEsIHgwLCB5MSAtIHkwLCB5MiAtIHkxLCB5MCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkeDEgPSB4MSAtIHgyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4MiA9IHgzIC0geDI7XG4gICAgICAgICAgICAgICAgY29uc3QgZHkxID0geTEgLSB5MjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeTIgPSB5MyAtIHkyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gZHgxICogZHkyIC0gZHgyICogZHkxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGExMyA9IChkeDMgKiBkeTIgLSBkeDIgKiBkeTMpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgYTIzID0gKGR4MSAqIGR5MyAtIGR4MyAqIGR5MSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHgxIC0geDAgKyBhMTMgKiB4MSwgeDMgLSB4MCArIGEyMyAqIHgzLCB4MCwgeTEgLSB5MCArIGExMyAqIHkxLCB5MyAtIHkwICsgYTIzICogeTMsIHkwLCBhMTMsIGEyMywgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcXVhZHJpbGF0ZXJhbFRvU3F1YXJlKHgwIC8qZmxvYXQqLywgeTAgLypmbG9hdCovLCB4MSAvKmZsb2F0Ki8sIHkxIC8qZmxvYXQqLywgeDIgLypmbG9hdCovLCB5MiAvKmZsb2F0Ki8sIHgzIC8qZmxvYXQqLywgeTMgLypmbG9hdCovKSB7XG4gICAgICAgICAgICAvLyBIZXJlLCB0aGUgYWRqb2ludCBzZXJ2ZXMgYXMgdGhlIGludmVyc2U6XG4gICAgICAgICAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykuYnVpbGRBZGpvaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRBZGpvaW50KCkge1xuICAgICAgICAgICAgLy8gQWRqb2ludCBpcyB0aGUgdHJhbnNwb3NlIG9mIHRoZSBjb2ZhY3RvciBtYXRyaXg6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHRoaXMuYTIyICogdGhpcy5hMzMgLSB0aGlzLmEyMyAqIHRoaXMuYTMyLCB0aGlzLmEyMyAqIHRoaXMuYTMxIC0gdGhpcy5hMjEgKiB0aGlzLmEzMywgdGhpcy5hMjEgKiB0aGlzLmEzMiAtIHRoaXMuYTIyICogdGhpcy5hMzEsIHRoaXMuYTEzICogdGhpcy5hMzIgLSB0aGlzLmExMiAqIHRoaXMuYTMzLCB0aGlzLmExMSAqIHRoaXMuYTMzIC0gdGhpcy5hMTMgKiB0aGlzLmEzMSwgdGhpcy5hMTIgKiB0aGlzLmEzMSAtIHRoaXMuYTExICogdGhpcy5hMzIsIHRoaXMuYTEyICogdGhpcy5hMjMgLSB0aGlzLmExMyAqIHRoaXMuYTIyLCB0aGlzLmExMyAqIHRoaXMuYTIxIC0gdGhpcy5hMTEgKiB0aGlzLmEyMywgdGhpcy5hMTEgKiB0aGlzLmEyMiAtIHRoaXMuYTEyICogdGhpcy5hMjEpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVzKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHRoaXMuYTExICogb3RoZXIuYTExICsgdGhpcy5hMjEgKiBvdGhlci5hMTIgKyB0aGlzLmEzMSAqIG90aGVyLmExMywgdGhpcy5hMTEgKiBvdGhlci5hMjEgKyB0aGlzLmEyMSAqIG90aGVyLmEyMiArIHRoaXMuYTMxICogb3RoZXIuYTIzLCB0aGlzLmExMSAqIG90aGVyLmEzMSArIHRoaXMuYTIxICogb3RoZXIuYTMyICsgdGhpcy5hMzEgKiBvdGhlci5hMzMsIHRoaXMuYTEyICogb3RoZXIuYTExICsgdGhpcy5hMjIgKiBvdGhlci5hMTIgKyB0aGlzLmEzMiAqIG90aGVyLmExMywgdGhpcy5hMTIgKiBvdGhlci5hMjEgKyB0aGlzLmEyMiAqIG90aGVyLmEyMiArIHRoaXMuYTMyICogb3RoZXIuYTIzLCB0aGlzLmExMiAqIG90aGVyLmEzMSArIHRoaXMuYTIyICogb3RoZXIuYTMyICsgdGhpcy5hMzIgKiBvdGhlci5hMzMsIHRoaXMuYTEzICogb3RoZXIuYTExICsgdGhpcy5hMjMgKiBvdGhlci5hMTIgKyB0aGlzLmEzMyAqIG90aGVyLmExMywgdGhpcy5hMTMgKiBvdGhlci5hMjEgKyB0aGlzLmEyMyAqIG90aGVyLmEyMiArIHRoaXMuYTMzICogb3RoZXIuYTIzLCB0aGlzLmExMyAqIG90aGVyLmEzMSArIHRoaXMuYTIzICogb3RoZXIuYTMyICsgdGhpcy5hMzMgKiBvdGhlci5hMzMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERlZmF1bHRHcmlkU2FtcGxlciBleHRlbmRzIEdyaWRTYW1wbGVyIHtcbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBzYW1wbGVHcmlkKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgcDFUb1ggLypmbG9hdCovLCBwMVRvWSAvKmZsb2F0Ki8sIHAyVG9YIC8qZmxvYXQqLywgcDJUb1kgLypmbG9hdCovLCBwM1RvWCAvKmZsb2F0Ki8sIHAzVG9ZIC8qZmxvYXQqLywgcDRUb1ggLypmbG9hdCovLCBwNFRvWSAvKmZsb2F0Ki8sIHAxRnJvbVggLypmbG9hdCovLCBwMUZyb21ZIC8qZmxvYXQqLywgcDJGcm9tWCAvKmZsb2F0Ki8sIHAyRnJvbVkgLypmbG9hdCovLCBwM0Zyb21YIC8qZmxvYXQqLywgcDNGcm9tWSAvKmZsb2F0Ki8sIHA0RnJvbVggLypmbG9hdCovLCBwNEZyb21ZIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbChwMVRvWCwgcDFUb1ksIHAyVG9YLCBwMlRvWSwgcDNUb1gsIHAzVG9ZLCBwNFRvWCwgcDRUb1ksIHAxRnJvbVgsIHAxRnJvbVksIHAyRnJvbVgsIHAyRnJvbVksIHAzRnJvbVgsIHAzRnJvbVksIHA0RnJvbVgsIHA0RnJvbVkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlR3JpZFdpdGhUcmFuc2Zvcm0oaW1hZ2UsIGRpbWVuc2lvblgsIGRpbWVuc2lvblksIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBzYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uWCAvKmludCovLCBkaW1lbnNpb25ZIC8qaW50Ki8sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvblggPD0gMCB8fCBkaW1lbnNpb25ZIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0TWF0cml4KGRpbWVuc2lvblgsIGRpbWVuc2lvblkpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgyICogZGltZW5zaW9uWCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGRpbWVuc2lvblk7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaVZhbHVlID0geSArIDAuNTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1heDsgeCArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1t4XSA9ICh4IC8gMikgKyAwLjU7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1t4ICsgMV0gPSBpVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS50cmFuc2Zvcm1Qb2ludHMocG9pbnRzKTtcbiAgICAgICAgICAgICAgICAvLyBRdWljayBjaGVjayB0byBzZWUgaWYgcG9pbnRzIHRyYW5zZm9ybWVkIHRvIHNvbWV0aGluZyBpbnNpZGUgdGhlIGltYWdlXG4gICAgICAgICAgICAgICAgLy8gc3VmZmljaWVudCB0byBjaGVjayB0aGUgZW5kcG9pbnRzXG4gICAgICAgICAgICAgICAgR3JpZFNhbXBsZXIuY2hlY2tBbmROdWRnZVBvaW50cyhpbWFnZSwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1heDsgeCArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KE1hdGguZmxvb3IocG9pbnRzW3hdKSwgTWF0aC5mbG9vcihwb2ludHNbeCArIDFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFjaygtaXNoKSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KHggLyAyLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoYWlvb2JlIC8qOiBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGZlZWxzIHdyb25nLCBidXQsIHNvbWV0aW1lcyBpZiB0aGUgZmluZGVyIHBhdHRlcm5zIGFyZSBtaXNpZGVudGlmaWVkLCB0aGUgcmVzdWx0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBnZXRzIFwidHdpc3RlZFwiIHN1Y2ggdGhhdCBpdCBtYXBzIGEgc3RyYWlnaHQgbGluZSBvZiBwb2ludHMgdG8gYSBzZXQgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdob3NlIGVuZHBvaW50cyBhcmUgaW4gYm91bmRzLCBidXQgb3RoZXJzIGFyZSBub3QuIFRoZXJlIGlzIHByb2JhYmx5IHNvbWUgbWF0aGVtYXRpY2FsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdheSB0byBkZXRlY3QgdGhpcyBhYm91dCB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCBJIGRvbid0IGtub3cgeWV0LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gYW4gdWdseSBydW50aW1lIGV4Y2VwdGlvbiBkZXNwaXRlIG91ciBjbGV2ZXIgY2hlY2tzIGFib3ZlIC0tIGNhbid0IGhhdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdC4gV2UgY291bGQgY2hlY2sgZWFjaCBwb2ludCdzIGNvb3JkaW5hdGVzIGJ1dCB0aGF0IGZlZWxzIGR1cGxpY2F0aXZlLiBXZSBzZXR0bGUgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoaW5nIGFuZCB3cmFwcGluZyBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgR3JpZFNhbXBsZXJJbnN0YW5jZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlciB1c2VkIGJ5IHRoZSBsaWJyYXJ5LiBPbmUgZ2xvYmFsXG4gICAgICAgICAqIGluc3RhbmNlIGlzIHN0b3JlZCwgd2hpY2ggbWF5IHNvdW5kIHByb2JsZW1hdGljLiBCdXQsIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm92aWRlZFxuICAgICAgICAgKiBvdWdodCB0byBiZSBhcHByb3ByaWF0ZSBmb3IgdGhlIGVudGlyZSBwbGF0Zm9ybSwgYW5kIGFsbCB1c2VzIG9mIHRoaXMgbGlicmFyeVxuICAgICAgICAgKiBpbiB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIEpWTS4gRm9yIGluc3RhbmNlLCBhbiBBbmRyb2lkIGFjdGl2aXR5IGNhbiBzd2FwIGluXG4gICAgICAgICAqIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgdGFrZXMgYWR2YW50YWdlIG9mIG5hdGl2ZSBwbGF0Zm9ybSBsaWJyYXJpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXdHcmlkU2FtcGxlciBUaGUgcGxhdGZvcm0tc3BlY2lmaWMgb2JqZWN0IHRvIGluc3RhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgc2V0R3JpZFNhbXBsZXIobmV3R3JpZFNhbXBsZXIpIHtcbiAgICAgICAgICAgIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXIgPSBuZXdHcmlkU2FtcGxlcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlclxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlciA9IG5ldyBEZWZhdWx0R3JpZFNhbXBsZXIoKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jlc3VsdFBvaW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludCh0aGlzLmdldFgoKSwgdGhpcy5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICB9XG4gICAgICAgIGdldFkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYW4gQXp0ZWMgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGUgQXp0ZWMgQ29kZVxuICAgICAqIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcbiAgICAgKiBAYXV0aG9yIEZyYW5rIFllbGxpblxuICAgICAqL1xuICAgIGNsYXNzIERldGVjdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuRVhQRUNURURfQ09STkVSX0JJVFMgPSBuZXcgSW50MzJBcnJheShbXG4gICAgICAgICAgICAgICAgMHhlZTAsXG4gICAgICAgICAgICAgICAgMHgxZGMsXG4gICAgICAgICAgICAgICAgMHg4M2IsXG4gICAgICAgICAgICAgICAgMHg3MDcsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBkZXRlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3RNaXJyb3IoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3RzIGFuIEF6dGVjIENvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpc01pcnJvciBpZiB0cnVlLCBpbWFnZSBpcyBhIG1pcnJvci1pbWFnZSBvZiBvcmlnaW5hbFxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBBenRlY0RldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGFuIEF6dGVjIENvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBBenRlYyBDb2RlIGNhbiBiZSBmb3VuZFxuICAgICAgICAgKi9cbiAgICAgICAgZGV0ZWN0TWlycm9yKGlzTWlycm9yKSB7XG4gICAgICAgICAgICAvLyAxLiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgYXp0ZWMgbWF0cml4XG4gICAgICAgICAgICBsZXQgcENlbnRlciA9IHRoaXMuZ2V0TWF0cml4Q2VudGVyKCk7XG4gICAgICAgICAgICAvLyAyLiBHZXQgdGhlIGNlbnRlciBwb2ludHMgb2YgdGhlIGZvdXIgZGlhZ29uYWwgcG9pbnRzIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZVxuICAgICAgICAgICAgLy8gIFt0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnQsIHRvcExlZnRdXG4gICAgICAgICAgICBsZXQgYnVsbHNFeWVDb3JuZXJzID0gdGhpcy5nZXRCdWxsc0V5ZUNvcm5lcnMocENlbnRlcik7XG4gICAgICAgICAgICBpZiAoaXNNaXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGJ1bGxzRXllQ29ybmVyc1swXTtcbiAgICAgICAgICAgICAgICBidWxsc0V5ZUNvcm5lcnNbMF0gPSBidWxsc0V5ZUNvcm5lcnNbMl07XG4gICAgICAgICAgICAgICAgYnVsbHNFeWVDb3JuZXJzWzJdID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMuIEdldCB0aGUgc2l6ZSBvZiB0aGUgbWF0cml4IGFuZCBvdGhlciBwYXJhbWV0ZXJzIGZyb20gdGhlIGJ1bGwncyBleWVcbiAgICAgICAgICAgIHRoaXMuZXh0cmFjdFBhcmFtZXRlcnMoYnVsbHNFeWVDb3JuZXJzKTtcbiAgICAgICAgICAgIC8vIDQuIFNhbXBsZSB0aGUgZ3JpZFxuICAgICAgICAgICAgbGV0IGJpdHMgPSB0aGlzLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgYnVsbHNFeWVDb3JuZXJzW3RoaXMuc2hpZnQgJSA0XSwgYnVsbHNFeWVDb3JuZXJzWyh0aGlzLnNoaWZ0ICsgMSkgJSA0XSwgYnVsbHNFeWVDb3JuZXJzWyh0aGlzLnNoaWZ0ICsgMikgJSA0XSwgYnVsbHNFeWVDb3JuZXJzWyh0aGlzLnNoaWZ0ICsgMykgJSA0XSk7XG4gICAgICAgICAgICAvLyA1LiBHZXQgdGhlIGNvcm5lcnMgb2YgdGhlIG1hdHJpeC5cbiAgICAgICAgICAgIGxldCBjb3JuZXJzID0gdGhpcy5nZXRNYXRyaXhDb3JuZXJQb2ludHMoYnVsbHNFeWVDb3JuZXJzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXp0ZWNEZXRlY3RvclJlc3VsdChiaXRzLCBjb3JuZXJzLCB0aGlzLmNvbXBhY3QsIHRoaXMubmJEYXRhQmxvY2tzLCB0aGlzLm5iTGF5ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdHMgdGhlIG51bWJlciBvZiBkYXRhIGxheWVycyBhbmQgZGF0YSBibG9ja3MgZnJvbSB0aGUgbGF5ZXIgYXJvdW5kIHRoZSBidWxsJ3MgZXllLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnVsbHNFeWVDb3JuZXJzIHRoZSBhcnJheSBvZiBidWxsJ3MgZXllIGNvcm5lcnNcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpbiBjYXNlIG9mIHRvbyBtYW55IGVycm9ycyBvciBpbnZhbGlkIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGV4dHJhY3RQYXJhbWV0ZXJzKGJ1bGxzRXllQ29ybmVycykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRQb2ludChidWxsc0V5ZUNvcm5lcnNbMF0pIHx8ICF0aGlzLmlzVmFsaWRQb2ludChidWxsc0V5ZUNvcm5lcnNbMV0pIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1syXSkgfHwgIXRoaXMuaXNWYWxpZFBvaW50KGJ1bGxzRXllQ29ybmVyc1szXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsZW5ndGggPSAyICogdGhpcy5uYkNlbnRlckxheWVycztcbiAgICAgICAgICAgIC8vIEdldCB0aGUgYml0cyBhcm91bmQgdGhlIGJ1bGwncyBleWVcbiAgICAgICAgICAgIGxldCBzaWRlcyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzBdLCBidWxsc0V5ZUNvcm5lcnNbMV0sIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1sxXSwgYnVsbHNFeWVDb3JuZXJzWzJdLCBsZW5ndGgpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlTGluZShidWxsc0V5ZUNvcm5lcnNbMl0sIGJ1bGxzRXllQ29ybmVyc1szXSwgbGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzNdLCBidWxsc0V5ZUNvcm5lcnNbMF0sIGxlbmd0aCkgLy8gVG9wXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIGJ1bGxzRXllQ29ybmVyc1tzaGlmdF0gaXMgdGhlIGNvcm5lciBvZiB0aGUgYnVsbHMnZXllIHRoYXQgaGFzIHRocmVlXG4gICAgICAgICAgICAvLyBvcmllbnRhdGlvbiBtYXJrcy5cbiAgICAgICAgICAgIC8vIHNpZGVzW3NoaWZ0XSBpcyB0aGUgcm93L2NvbHVtbiB0aGF0IGdvZXMgZnJvbSB0aGUgY29ybmVyIHdpdGggdGhyZWVcbiAgICAgICAgICAgIC8vIG9yaWVudGF0aW9uIG1hcmtzIHRvIHRoZSBjb3JuZXIgd2l0aCB0d28uXG4gICAgICAgICAgICB0aGlzLnNoaWZ0ID0gdGhpcy5nZXRSb3RhdGlvbihzaWRlcywgbGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gdGhlIHBhcmFtZXRlciBiaXRzIGludG8gYSBzaW5nbGUgMjgtIG9yIDQwLWJpdCBsb25nXG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVyRGF0YSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gc2lkZXNbKHRoaXMuc2hpZnQgKyBpKSAlIDRdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzaWRlIG9mIHRoZSBmb3JtIC4uWFhYWFhYWC4gd2hlcmUgWHMgYXJlIHBhcmFtZXRlciBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgPDw9IDc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgKz0gKHNpZGUgPj4gMSkgJiAweDdGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzaWRlIG9mIHRoZSBmb3JtIC4uWFhYWFguWFhYWFguIHdoZXJlIFhzIGFyZSBwYXJhbWV0ZXIgZGF0YVxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhIDw8PSAxMDtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSArPSAoKHNpZGUgPj4gMikgJiAoMHgxZiA8PCA1KSkgKyAoKHNpZGUgPj4gMSkgJiAweDFGKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3JyZWN0cyBwYXJhbWV0ZXIgZGF0YSB1c2luZyBSUy4gIFJldHVybnMganVzdCB0aGUgZGF0YSBwb3J0aW9uXG4gICAgICAgICAgICAvLyB3aXRob3V0IHRoZSBlcnJvciBjb3JyZWN0aW9uLlxuICAgICAgICAgICAgbGV0IGNvcnJlY3RlZERhdGEgPSB0aGlzLmdldENvcnJlY3RlZFBhcmFtZXRlckRhdGEocGFyYW1ldGVyRGF0YSwgdGhpcy5jb21wYWN0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyA4IGJpdHM6ICAyIGJpdHMgbGF5ZXJzIGFuZCA2IGJpdHMgZGF0YSBibG9ja3NcbiAgICAgICAgICAgICAgICB0aGlzLm5iTGF5ZXJzID0gKGNvcnJlY3RlZERhdGEgPj4gNikgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMubmJEYXRhQmxvY2tzID0gKGNvcnJlY3RlZERhdGEgJiAweDNGKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNiBiaXRzOiAgNSBiaXRzIGxheWVycyBhbmQgMTEgYml0cyBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgICAgIHRoaXMubmJMYXllcnMgPSAoY29ycmVjdGVkRGF0YSA+PiAxMSkgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMubmJEYXRhQmxvY2tzID0gKGNvcnJlY3RlZERhdGEgJiAweDdGRikgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldFJvdGF0aW9uKHNpZGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEluIGEgbm9ybWFsIHBhdHRlcm4sIHdlIGV4cGVjdCB0byBTZWVcbiAgICAgICAgICAgIC8vICAgKiogICAgLiogICAgICAgICAgICAgRCAgICAgICBBXG4gICAgICAgICAgICAvLyAgICogICAgICAqXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAuICAgICAgKlxuICAgICAgICAgICAgLy8gICAuLiAgICAuLiAgICAgICAgICAgICBDICAgICAgIEJcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSAzIGJpdHMgZnJvbSBlYWNoIG9mIHRoZSBzaWRlcyB0aGUgZm9ybSB0aGUgbG9jYXRvciBwYXR0ZXJuIGFuZCBjb25jYXRlbmF0ZVxuICAgICAgICAgICAgLy8gaW50byBhIDEyLWJpdCBpbnRlZ2VyLiAgU3RhcnQgd2l0aCB0aGUgYml0IGF0IEFcbiAgICAgICAgICAgIGxldCBjb3JuZXJCaXRzID0gMDtcbiAgICAgICAgICAgIHNpZGVzLmZvckVhY2goKHNpZGUsIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gWFguLi4uLi5YIHdoZXJlIFgncyBhcmUgb3JpZW50YXRpb24gbWFya3NcbiAgICAgICAgICAgICAgICBsZXQgdCA9ICgoc2lkZSA+PiAobGVuZ3RoIC0gMikpIDw8IDEpICsgKHNpZGUgJiAxKTtcbiAgICAgICAgICAgICAgICBjb3JuZXJCaXRzID0gKGNvcm5lckJpdHMgPDwgMykgKyB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBmb3IgKHZhciBzaWRlIGluIHNpZGVzKSB7XG4gICAgICAgICAgICAvLyAgICAgLy8gWFguLi4uLi5YIHdoZXJlIFgncyBhcmUgb3JpZW50YXRpb24gbWFya3NcbiAgICAgICAgICAgIC8vICAgICB2YXIgdCA9ICgoc2lkZSA+PiAobGVuZ3RoIC0gMikpIDw8IDEpICsgKHNpZGUgJiAxKTtcbiAgICAgICAgICAgIC8vICAgICBjb3JuZXJCaXRzID0gKGNvcm5lckJpdHMgPDwgMykgKyB0O1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gTW92IHRoZSBib3R0b20gYml0IHRvIHRoZSB0b3AsIHNvIHRoYXQgdGhlIHRocmVlIGJpdHMgb2YgdGhlIGxvY2F0b3IgcGF0dGVybiBhdCBBIGFyZVxuICAgICAgICAgICAgLy8gdG9nZXRoZXIuICBjb3JuZXJCaXRzIGlzIG5vdzpcbiAgICAgICAgICAgIC8vICAzIG9yaWVudGF0aW9uIGJpdHMgYXQgQSB8fCAzIG9yaWVudGF0aW9uIGJpdHMgYXQgQiB8fCAuLi4gfHwgMyBvcmllbnRhdGlvbiBiaXRzIGF0IERcbiAgICAgICAgICAgIGNvcm5lckJpdHMgPSAoKGNvcm5lckJpdHMgJiAxKSA8PCAxMSkgKyAoY29ybmVyQml0cyA+PiAxKTtcbiAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgc2hpZnQgaW5kaWNhdGVzIHdoaWNoIGVsZW1lbnQgb2YgQnVsbHNFeWVDb3JuZXJzW10gZ29lcyBpbnRvIHRoZSB0b3AtbGVmdFxuICAgICAgICAgICAgLy8gY29ybmVyLiBTaW5jZSB0aGUgZm91ciByb3RhdGlvbiB2YWx1ZXMgaGF2ZSBhIEhhbW1pbmcgZGlzdGFuY2Ugb2YgOCwgd2VcbiAgICAgICAgICAgIC8vIGNhbiBlYXNpbHkgdG9sZXJhdGUgdHdvIGVycm9ycy5cbiAgICAgICAgICAgIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCA0OyBzaGlmdCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEludGVnZXIuYml0Q291bnQoY29ybmVyQml0cyBeIHRoaXMuRVhQRUNURURfQ09STkVSX0JJVFNbc2hpZnRdKSA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29ycmVjdHMgdGhlIHBhcmFtZXRlciBiaXRzIHVzaW5nIFJlZWQtU29sb21vbiBhbGdvcml0aG0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJEYXRhIHBhcmFtZXRlciBiaXRzXG4gICAgICAgICAqIEBwYXJhbSBjb21wYWN0IHRydWUgaWYgdGhpcyBpcyBhIGNvbXBhY3QgQXp0ZWMgY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIHRoZSBhcnJheSBjb250YWlucyB0b28gbWFueSBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIGdldENvcnJlY3RlZFBhcmFtZXRlckRhdGEocGFyYW1ldGVyRGF0YSwgY29tcGFjdCkge1xuICAgICAgICAgICAgbGV0IG51bUNvZGV3b3JkcztcbiAgICAgICAgICAgIGxldCBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBudW1Db2Rld29yZHMgPSA3O1xuICAgICAgICAgICAgICAgIG51bURhdGFDb2Rld29yZHMgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtQ29kZXdvcmRzID0gMTA7XG4gICAgICAgICAgICAgICAgbnVtRGF0YUNvZGV3b3JkcyA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtRUNDb2Rld29yZHMgPSBudW1Db2Rld29yZHMgLSBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgbGV0IHBhcmFtZXRlcldvcmRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBudW1Db2Rld29yZHMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcldvcmRzW2ldID0gcGFyYW1ldGVyRGF0YSAmIDB4RjtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhID4+PSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcnNEZWNvZGVyID0gbmV3IFJlZWRTb2xvbW9uRGVjb2RlcihHZW5lcmljR0YuQVpURUNfUEFSQU0pO1xuICAgICAgICAgICAgICAgIHJzRGVjb2Rlci5kZWNvZGUocGFyYW1ldGVyV29yZHMsIG51bUVDQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb3NzIHRoZSBlcnJvciBjb3JyZWN0aW9uLiAgSnVzdCByZXR1cm4gdGhlIGRhdGEgYXMgYW4gaW50ZWdlclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgNCkgKyBwYXJhbWV0ZXJXb3Jkc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIHRoZSBjb3JuZXJzIG9mIGEgYnVsbC1leWUgY2VudGVyZWQgb24gdGhlIHBhc3NlZCBwb2ludC5cbiAgICAgICAgICogVGhpcyByZXR1cm5zIHRoZSBjZW50ZXJzIG9mIHRoZSBkaWFnb25hbCBwb2ludHMganVzdCBvdXRzaWRlIHRoZSBidWxsJ3MgZXllXG4gICAgICAgICAqIFJldHVybnMgW3RvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCwgdG9wTGVmdF1cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBDZW50ZXIgQ2VudGVyIHBvaW50XG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNvcm5lcnMgb2YgdGhlIGJ1bGwtZXllXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gSWYgbm8gdmFsaWQgYnVsbC1leWUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCdWxsc0V5ZUNvcm5lcnMocENlbnRlcikge1xuICAgICAgICAgICAgbGV0IHBpbmEgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IHBpbmIgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IHBpbmMgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IHBpbmQgPSBwQ2VudGVyO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodGhpcy5uYkNlbnRlckxheWVycyA9IDE7IHRoaXMubmJDZW50ZXJMYXllcnMgPCA5OyB0aGlzLm5iQ2VudGVyTGF5ZXJzKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcG91dGEgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmEsIGNvbG9yLCAxLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvdXRiID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5iLCBjb2xvciwgMSwgMSk7XG4gICAgICAgICAgICAgICAgbGV0IHBvdXRjID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5jLCBjb2xvciwgLTEsIDEpO1xuICAgICAgICAgICAgICAgIGxldCBwb3V0ZCA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQocGluZCwgY29sb3IsIC0xLCAtMSk7XG4gICAgICAgICAgICAgICAgLy8gZCAgICAgIGFcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGMgICAgICBiXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmJDZW50ZXJMYXllcnMgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBxID0gKHRoaXMuZGlzdGFuY2VQb2ludChwb3V0ZCwgcG91dGEpICogdGhpcy5uYkNlbnRlckxheWVycykgLyAodGhpcy5kaXN0YW5jZVBvaW50KHBpbmQsIHBpbmEpICogKHRoaXMubmJDZW50ZXJMYXllcnMgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxIDwgMC43NSB8fCBxID4gMS4yNSB8fCAhdGhpcy5pc1doaXRlT3JCbGFja1JlY3RhbmdsZShwb3V0YSwgcG91dGIsIHBvdXRjLCBwb3V0ZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBpbmEgPSBwb3V0YTtcbiAgICAgICAgICAgICAgICBwaW5iID0gcG91dGI7XG4gICAgICAgICAgICAgICAgcGluYyA9IHBvdXRjO1xuICAgICAgICAgICAgICAgIHBpbmQgPSBwb3V0ZDtcbiAgICAgICAgICAgICAgICBjb2xvciA9ICFjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5iQ2VudGVyTGF5ZXJzICE9PSA1ICYmIHRoaXMubmJDZW50ZXJMYXllcnMgIT09IDcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcGFjdCA9IHRoaXMubmJDZW50ZXJMYXllcnMgPT09IDU7XG4gICAgICAgICAgICAvLyBFeHBhbmQgdGhlIHNxdWFyZSBieSAuNSBwaXhlbCBpbiBlYWNoIGRpcmVjdGlvbiBzbyB0aGF0IHdlJ3JlIG9uIHRoZSBib3JkZXJcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHdoaXRlIHNxdWFyZSBhbmQgdGhlIGJsYWNrIHNxdWFyZVxuICAgICAgICAgICAgbGV0IHBpbmF4ID0gbmV3IFJlc3VsdFBvaW50KHBpbmEuZ2V0WCgpICsgMC41LCBwaW5hLmdldFkoKSAtIDAuNSk7XG4gICAgICAgICAgICBsZXQgcGluYnggPSBuZXcgUmVzdWx0UG9pbnQocGluYi5nZXRYKCkgKyAwLjUsIHBpbmIuZ2V0WSgpICsgMC41KTtcbiAgICAgICAgICAgIGxldCBwaW5jeCA9IG5ldyBSZXN1bHRQb2ludChwaW5jLmdldFgoKSAtIDAuNSwgcGluYy5nZXRZKCkgKyAwLjUpO1xuICAgICAgICAgICAgbGV0IHBpbmR4ID0gbmV3IFJlc3VsdFBvaW50KHBpbmQuZ2V0WCgpIC0gMC41LCBwaW5kLmdldFkoKSAtIDAuNSk7XG4gICAgICAgICAgICAvLyBFeHBhbmQgdGhlIHNxdWFyZSBzbyB0aGF0IGl0cyBjb3JuZXJzIGFyZSB0aGUgY2VudGVycyBvZiB0aGUgcG9pbnRzXG4gICAgICAgICAgICAvLyBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRTcXVhcmUoW3BpbmF4LCBwaW5ieCwgcGluY3gsIHBpbmR4XSwgMiAqIHRoaXMubmJDZW50ZXJMYXllcnMgLSAzLCAyICogdGhpcy5uYkNlbnRlckxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIGEgY2FuZGlkYXRlIGNlbnRlciBwb2ludCBvZiBhbiBBenRlYyBjb2RlIGZyb20gYW4gaW1hZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB0aGUgY2VudGVyIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXRyaXhDZW50ZXIoKSB7XG4gICAgICAgICAgICBsZXQgcG9pbnRBO1xuICAgICAgICAgICAgbGV0IHBvaW50QjtcbiAgICAgICAgICAgIGxldCBwb2ludEM7XG4gICAgICAgICAgICBsZXQgcG9pbnREO1xuICAgICAgICAgICAgLy8gR2V0IGEgd2hpdGUgcmVjdGFuZ2xlIHRoYXQgY2FuIGJlIHRoZSBib3JkZXIgb2YgdGhlIG1hdHJpeCBpbiBjZW50ZXIgYnVsbCdzIGV5ZSBvclxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgY29ybmVyUG9pbnRzID0gbmV3IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IodGhpcy5pbWFnZSkuZGV0ZWN0KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gY29ybmVyUG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgIHBvaW50QiA9IGNvcm5lclBvaW50c1sxXTtcbiAgICAgICAgICAgICAgICBwb2ludEMgPSBjb3JuZXJQb2ludHNbMl07XG4gICAgICAgICAgICAgICAgcG9pbnREID0gY29ybmVyUG9pbnRzWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGV4Y2VwdGlvbiBjYW4gYmUgaW4gY2FzZSB0aGUgaW5pdGlhbCByZWN0YW5nbGUgaXMgd2hpdGVcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHN1cmVseSBpbiB0aGUgYnVsbCdzIGV5ZSwgd2UgdHJ5IHRvIGV4cGFuZCB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgIGxldCBjeCA9IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAvIDI7XG4gICAgICAgICAgICAgICAgbGV0IGN5ID0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgICAgICAgICAgcG9pbnRBID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggKyA3LCBjeSAtIDcpLCBmYWxzZSwgMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5ICsgNyksIGZhbHNlLCAxLCAxKS50b1Jlc3VsdFBvaW50KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggLSA3LCBjeSArIDcpLCBmYWxzZSwgLTEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5IC0gNyksIGZhbHNlLCAtMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNlbnRlciBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAgICBsZXQgY3ggPSBNYXRoVXRpbHMucm91bmQoKHBvaW50QS5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkpIC8gNC4wKTtcbiAgICAgICAgICAgIGxldCBjeSA9IE1hdGhVdGlscy5yb3VuZCgocG9pbnRBLmdldFkoKSArIHBvaW50RC5nZXRZKCkgKyBwb2ludEIuZ2V0WSgpICsgcG9pbnRDLmdldFkoKSkgLyA0LjApO1xuICAgICAgICAgICAgLy8gUmVkZXRlcm1pbmUgdGhlIHdoaXRlIHJlY3RhbmdsZSBzdGFydGluZyBmcm9tIHByZXZpb3VzbHkgY29tcHV0ZWQgY2VudGVyLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHdlIGVuZCB1cCB3aXRoIGEgd2hpdGUgcmVjdGFuZ2xlIGluIGNlbnRlciBidWxsJ3MgZXllXG4gICAgICAgICAgICAvLyBpbiBvcmRlciB0byBjb21wdXRlIGEgbW9yZSBhY2N1cmF0ZSBjZW50ZXIuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JuZXJQb2ludHMgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcih0aGlzLmltYWdlLCAxNSwgY3gsIGN5KS5kZXRlY3QoKTtcbiAgICAgICAgICAgICAgICBwb2ludEEgPSBjb3JuZXJQb2ludHNbMF07XG4gICAgICAgICAgICAgICAgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgIHBvaW50QyA9IGNvcm5lclBvaW50c1syXTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSBjb3JuZXJQb2ludHNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhjZXB0aW9uIGNhbiBiZSBpbiBjYXNlIHRoZSBpbml0aWFsIHJlY3RhbmdsZSBpcyB3aGl0ZVxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSB0cnkgdG8gZXhwYW5kIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgcG9pbnRBID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggKyA3LCBjeSAtIDcpLCBmYWxzZSwgMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEIgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCArIDcsIGN5ICsgNyksIGZhbHNlLCAxLCAxKS50b1Jlc3VsdFBvaW50KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRDID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggLSA3LCBjeSArIDcpLCBmYWxzZSwgLTEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwb2ludEQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeCAtIDcsIGN5IC0gNyksIGZhbHNlLCAtMSwgLTEpLnRvUmVzdWx0UG9pbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlY29tcHV0ZSB0aGUgY2VudGVyIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgIGN4ID0gTWF0aFV0aWxzLnJvdW5kKChwb2ludEEuZ2V0WCgpICsgcG9pbnRELmdldFgoKSArIHBvaW50Qi5nZXRYKCkgKyBwb2ludEMuZ2V0WCgpKSAvIDQuMCk7XG4gICAgICAgICAgICBjeSA9IE1hdGhVdGlscy5yb3VuZCgocG9pbnRBLmdldFkoKSArIHBvaW50RC5nZXRZKCkgKyBwb2ludEIuZ2V0WSgpICsgcG9pbnRDLmdldFkoKSkgLyA0LjApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChjeCwgY3kpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBBenRlYyBjb2RlIGNvcm5lcnMgZnJvbSB0aGUgYnVsbCdzIGV5ZSBjb3JuZXJzIGFuZCB0aGUgcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGJ1bGxzRXllQ29ybmVycyB0aGUgYXJyYXkgb2YgYnVsbCdzIGV5ZSBjb3JuZXJzXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGF6dGVjIGNvZGUgY29ybmVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWF0cml4Q29ybmVyUG9pbnRzKGJ1bGxzRXllQ29ybmVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kU3F1YXJlKGJ1bGxzRXllQ29ybmVycywgMiAqIHRoaXMubmJDZW50ZXJMYXllcnMsIHRoaXMuZ2V0RGltZW5zaW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQml0TWF0cml4IGJ5IHNhbXBsaW5nIHRoZSBwcm92aWRlZCBpbWFnZS5cbiAgICAgICAgICogdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBhbmQgYm90dG9tTGVmdCBhcmUgdGhlIGNlbnRlcnMgb2YgdGhlIHNxdWFyZXMgb24gdGhlXG4gICAgICAgICAqIGRpYWdvbmFsIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZS5cbiAgICAgICAgICovXG4gICAgICAgIHNhbXBsZUdyaWQoaW1hZ2UsIHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCkge1xuICAgICAgICAgICAgbGV0IHNhbXBsZXIgPSBHcmlkU2FtcGxlckluc3RhbmNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICBsZXQgZGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oKTtcbiAgICAgICAgICAgIGxldCBsb3cgPSBkaW1lbnNpb24gLyAyIC0gdGhpcy5uYkNlbnRlckxheWVycztcbiAgICAgICAgICAgIGxldCBoaWdoID0gZGltZW5zaW9uIC8gMiArIHRoaXMubmJDZW50ZXJMYXllcnM7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlci5zYW1wbGVHcmlkKGltYWdlLCBkaW1lbnNpb24sIGRpbWVuc2lvbiwgbG93LCBsb3csIC8vIHRvcGxlZnRcbiAgICAgICAgICAgIGhpZ2gsIGxvdywgLy8gdG9wcmlnaHRcbiAgICAgICAgICAgIGhpZ2gsIGhpZ2gsIC8vIGJvdHRvbXJpZ2h0XG4gICAgICAgICAgICBsb3csIGhpZ2gsIC8vIGJvdHRvbWxlZnRcbiAgICAgICAgICAgIHRvcExlZnQuZ2V0WCgpLCB0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WCgpLCB0b3BSaWdodC5nZXRZKCksIGJvdHRvbVJpZ2h0LmdldFgoKSwgYm90dG9tUmlnaHQuZ2V0WSgpLCBib3R0b21MZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1wbGVzIGEgbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHAxICAgc3RhcnQgcG9pbnQgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHAyICAgZW5kIHBvaW50IChleGNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSBzaXplIG51bWJlciBvZiBiaXRzXG4gICAgICAgICAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGJpdHMgYXMgYW4gaW50IChmaXJzdCBiaXQgaXMgaGlnaC1vcmRlciBiaXQgb2YgcmVzdWx0KVxuICAgICAgICAgKi9cbiAgICAgICAgc2FtcGxlTGluZShwMSwgcDIsIHNpemUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzLmRpc3RhbmNlUmVzdWx0UG9pbnQocDEsIHAyKTtcbiAgICAgICAgICAgIGxldCBtb2R1bGVTaXplID0gZCAvIHNpemU7XG4gICAgICAgICAgICBsZXQgcHggPSBwMS5nZXRYKCk7XG4gICAgICAgICAgICBsZXQgcHkgPSBwMS5nZXRZKCk7XG4gICAgICAgICAgICBsZXQgZHggPSBtb2R1bGVTaXplICogKHAyLmdldFgoKSAtIHAxLmdldFgoKSkgLyBkO1xuICAgICAgICAgICAgbGV0IGR5ID0gbW9kdWxlU2l6ZSAqIChwMi5nZXRZKCkgLSBwMS5nZXRZKCkpIC8gZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2UuZ2V0KE1hdGhVdGlscy5yb3VuZChweCArIGkgKiBkeCksIE1hdGhVdGlscy5yb3VuZChweSArIGkgKiBkeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAxIDw8IChzaXplIC0gaSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYm9yZGVyIG9mIHRoZSByZWN0YW5nbGUgcGFzc2VkIGluIHBhcmFtZXRlciBpcyBjb21wb3VuZCBvZiB3aGl0ZSBwb2ludHMgb25seVxuICAgICAgICAgKiAgICAgICAgIG9yIGJsYWNrIHBvaW50cyBvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBpc1doaXRlT3JCbGFja1JlY3RhbmdsZShwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgbGV0IGNvcnIgPSAzO1xuICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQocDEuZ2V0WCgpIC0gY29yciwgcDEuZ2V0WSgpICsgY29ycik7XG4gICAgICAgICAgICBwMiA9IG5ldyBQb2ludChwMi5nZXRYKCkgLSBjb3JyLCBwMi5nZXRZKCkgLSBjb3JyKTtcbiAgICAgICAgICAgIHAzID0gbmV3IFBvaW50KHAzLmdldFgoKSArIGNvcnIsIHAzLmdldFkoKSAtIGNvcnIpO1xuICAgICAgICAgICAgcDQgPSBuZXcgUG9pbnQocDQuZ2V0WCgpICsgY29yciwgcDQuZ2V0WSgpICsgY29ycik7XG4gICAgICAgICAgICBsZXQgY0luaXQgPSB0aGlzLmdldENvbG9yKHA0LCBwMSk7XG4gICAgICAgICAgICBpZiAoY0luaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuZ2V0Q29sb3IocDEsIHAyKTtcbiAgICAgICAgICAgIGlmIChjICE9PSBjSW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSB0aGlzLmdldENvbG9yKHAyLCBwMyk7XG4gICAgICAgICAgICBpZiAoYyAhPT0gY0luaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gdGhpcy5nZXRDb2xvcihwMywgcDQpO1xuICAgICAgICAgICAgcmV0dXJuIGMgPT09IGNJbml0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb2xvciBvZiBhIHNlZ21lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiAxIGlmIHNlZ21lbnQgbW9yZSB0aGFuIDkwJSBibGFjaywgLTEgaWYgc2VnbWVudCBpcyBtb3JlIHRoYW4gOTAlIHdoaXRlLCAwIGVsc2VcbiAgICAgICAgICovXG4gICAgICAgIGdldENvbG9yKHAxLCBwMikge1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzLmRpc3RhbmNlUG9pbnQocDEsIHAyKTtcbiAgICAgICAgICAgIGxldCBkeCA9IChwMi5nZXRYKCkgLSBwMS5nZXRYKCkpIC8gZDtcbiAgICAgICAgICAgIGxldCBkeSA9IChwMi5nZXRZKCkgLSBwMS5nZXRZKCkpIC8gZDtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgICAgICBsZXQgcHggPSBwMS5nZXRYKCk7XG4gICAgICAgICAgICBsZXQgcHkgPSBwMS5nZXRZKCk7XG4gICAgICAgICAgICBsZXQgY29sb3JNb2RlbCA9IHRoaXMuaW1hZ2UuZ2V0KHAxLmdldFgoKSwgcDEuZ2V0WSgpKTtcbiAgICAgICAgICAgIGxldCBpTWF4ID0gTWF0aC5jZWlsKGQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBweCArPSBkeDtcbiAgICAgICAgICAgICAgICBweSArPSBkeTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbWFnZS5nZXQoTWF0aFV0aWxzLnJvdW5kKHB4KSwgTWF0aFV0aWxzLnJvdW5kKHB5KSkgIT09IGNvbG9yTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXJyUmF0aW8gPSBlcnJvciAvIGQ7XG4gICAgICAgICAgICBpZiAoZXJyUmF0aW8gPiAwLjEgJiYgZXJyUmF0aW8gPCAwLjkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoZXJyUmF0aW8gPD0gMC4xKSA9PT0gY29sb3JNb2RlbCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQgd2l0aCBhIGRpZmZlcmVudCBjb2xvciBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaXJzdERpZmZlcmVudChpbml0LCBjb2xvciwgZHgsIGR5KSB7XG4gICAgICAgICAgICBsZXQgeCA9IGluaXQuZ2V0WCgpICsgZHg7XG4gICAgICAgICAgICBsZXQgeSA9IGluaXQuZ2V0WSgpICsgZHk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1ZhbGlkKHgsIHkpICYmIHRoaXMuaW1hZ2UuZ2V0KHgsIHkpID09PSBjb2xvcikge1xuICAgICAgICAgICAgICAgIHggKz0gZHg7XG4gICAgICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggLT0gZHg7XG4gICAgICAgICAgICB5IC09IGR5O1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNWYWxpZCh4LCB5KSAmJiB0aGlzLmltYWdlLmdldCh4LCB5KSA9PT0gY29sb3IpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCAtPSBkeDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzVmFsaWQoeCwgeSkgJiYgdGhpcy5pbWFnZS5nZXQoeCwgeSkgPT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgLT0gZHk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmQgdGhlIHNxdWFyZSByZXByZXNlbnRlZCBieSB0aGUgY29ybmVyIHBvaW50cyBieSBwdXNoaW5nIG91dCBlcXVhbGx5IGluIGFsbCBkaXJlY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3JuZXJQb2ludHMgdGhlIGNvcm5lcnMgb2YgdGhlIHNxdWFyZSwgd2hpY2ggaGFzIHRoZSBidWxsJ3MgZXllIGF0IGl0cyBjZW50ZXJcbiAgICAgICAgICogQHBhcmFtIG9sZFNpZGUgdGhlIG9yaWdpbmFsIGxlbmd0aCBvZiB0aGUgc2lkZSBvZiB0aGUgc3F1YXJlIGluIHRoZSB0YXJnZXQgYml0IG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbmV3U2lkZSB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgc2l6ZSBvZiB0aGUgc3F1YXJlIGluIHRoZSB0YXJnZXQgYml0IG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjb3JuZXJzIG9mIHRoZSBleHBhbmRlZCBzcXVhcmVcbiAgICAgICAgICovXG4gICAgICAgIGV4cGFuZFNxdWFyZShjb3JuZXJQb2ludHMsIG9sZFNpZGUsIG5ld1NpZGUpIHtcbiAgICAgICAgICAgIGxldCByYXRpbyA9IG5ld1NpZGUgLyAoMi4wICogb2xkU2lkZSk7XG4gICAgICAgICAgICBsZXQgZHggPSBjb3JuZXJQb2ludHNbMF0uZ2V0WCgpIC0gY29ybmVyUG9pbnRzWzJdLmdldFgoKTtcbiAgICAgICAgICAgIGxldCBkeSA9IGNvcm5lclBvaW50c1swXS5nZXRZKCkgLSBjb3JuZXJQb2ludHNbMl0uZ2V0WSgpO1xuICAgICAgICAgICAgbGV0IGNlbnRlcnggPSAoY29ybmVyUG9pbnRzWzBdLmdldFgoKSArIGNvcm5lclBvaW50c1syXS5nZXRYKCkpIC8gMi4wO1xuICAgICAgICAgICAgbGV0IGNlbnRlcnkgPSAoY29ybmVyUG9pbnRzWzBdLmdldFkoKSArIGNvcm5lclBvaW50c1syXS5nZXRZKCkpIC8gMi4wO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDAgPSBuZXcgUmVzdWx0UG9pbnQoY2VudGVyeCArIHJhdGlvICogZHgsIGNlbnRlcnkgKyByYXRpbyAqIGR5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQyID0gbmV3IFJlc3VsdFBvaW50KGNlbnRlcnggLSByYXRpbyAqIGR4LCBjZW50ZXJ5IC0gcmF0aW8gKiBkeSk7XG4gICAgICAgICAgICBkeCA9IGNvcm5lclBvaW50c1sxXS5nZXRYKCkgLSBjb3JuZXJQb2ludHNbM10uZ2V0WCgpO1xuICAgICAgICAgICAgZHkgPSBjb3JuZXJQb2ludHNbMV0uZ2V0WSgpIC0gY29ybmVyUG9pbnRzWzNdLmdldFkoKTtcbiAgICAgICAgICAgIGNlbnRlcnggPSAoY29ybmVyUG9pbnRzWzFdLmdldFgoKSArIGNvcm5lclBvaW50c1szXS5nZXRYKCkpIC8gMi4wO1xuICAgICAgICAgICAgY2VudGVyeSA9IChjb3JuZXJQb2ludHNbMV0uZ2V0WSgpICsgY29ybmVyUG9pbnRzWzNdLmdldFkoKSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgcmVzdWx0MSA9IG5ldyBSZXN1bHRQb2ludChjZW50ZXJ4ICsgcmF0aW8gKiBkeCwgY2VudGVyeSArIHJhdGlvICogZHkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDMgPSBuZXcgUmVzdWx0UG9pbnQoY2VudGVyeCAtIHJhdGlvICogZHgsIGNlbnRlcnkgLSByYXRpbyAqIGR5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRzID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDNdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZCh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCA+PSAwICYmIHggPCB0aGlzLmltYWdlLmdldFdpZHRoKCkgJiYgeSA+IDAgJiYgeSA8IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZFBvaW50KHBvaW50KSB7XG4gICAgICAgICAgICBsZXQgeCA9IE1hdGhVdGlscy5yb3VuZChwb2ludC5nZXRYKCkpO1xuICAgICAgICAgICAgbGV0IHkgPSBNYXRoVXRpbHMucm91bmQocG9pbnQuZ2V0WSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2VQb2ludChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmRpc3RhbmNlKGEuZ2V0WCgpLCBhLmdldFkoKSwgYi5nZXRYKCksIGIuZ2V0WSgpKTtcbiAgICAgICAgfVxuICAgICAgICBkaXN0YW5jZVJlc3VsdFBvaW50KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UoYS5nZXRYKCksIGEuZ2V0WSgpLCBiLmdldFgoKSwgYi5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldERpbWVuc2lvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNCAqIHRoaXMubmJMYXllcnMgKyAxMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5iTGF5ZXJzIDw9IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNCAqIHRoaXMubmJMYXllcnMgKyAxNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiA0ICogdGhpcy5uYkxheWVycyArIDIgKiAoSW50ZWdlci50cnVuY0RpdmlzaW9uKCh0aGlzLm5iTGF5ZXJzIC0gNCksIDgpICsgMSkgKyAxNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIEF6dGVjIGNvZGVzIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXG4gICAgICovXG4gICAgY2xhc3MgQXp0ZWNSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIERhdGEgTWF0cml4IGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIERhdGEgTWF0cml4IGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhIERhdGEgTWF0cml4IGNvZGUgY2Fubm90IGJlIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlKGltYWdlLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBleGNlcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRldGVjdG9yID0gbmV3IERldGVjdG9yKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGVjb2RlclJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBkZXRlY3RvclJlc3VsdCA9IGRldGVjdG9yLmRldGVjdE1pcnJvcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRGb3VuZFJlc3VsdFBvaW50cyhoaW50cywgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXIoKS5kZWNvZGUoZGV0ZWN0b3JSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZXRlY3RvclJlc3VsdCA9IGRldGVjdG9yLmRldGVjdE1pcnJvcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0Rm91bmRSZXN1bHRQb2ludHMoaGludHMsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlcigpLmRlY29kZShkZXRlY3RvclJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBSZXN1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKSwgZGVjb2RlclJlc3VsdC5nZXROdW1CaXRzKCksIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLkFaVEVDLCBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKSk7XG4gICAgICAgICAgICBsZXQgYnl0ZVNlZ21lbnRzID0gZGVjb2RlclJlc3VsdC5nZXRCeXRlU2VnbWVudHMoKTtcbiAgICAgICAgICAgIGlmIChieXRlU2VnbWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTtcbiAgICAgICAgICAgIGlmIChlY0xldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzKGhpbnRzLCBwb2ludHMpIHtcbiAgICAgICAgICAgIGlmIChoaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJwY2IgPSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICAgICAgaWYgKHJwY2IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGlkeCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBycGNiLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBenRlYyBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqXG4gICAgICogQGNsYXNzIEJyb3dzZXJBenRlY0NvZGVSZWFkZXJcbiAgICAgKiBAZXh0ZW5kcyB7QnJvd3NlckNvZGVSZWFkZXJ9XG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlckF6dGVjQ29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCkge1xuICAgICAgICAgICAgc3VwZXIobmV3IEF6dGVjUmVhZGVyKCksIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIGFsbCBmYW1pbGllc1xuICAgICAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgLypcbiAgICAgICAgQE92ZXJyaWRlXG4gICAgICAgIHB1YmxpYyBSZXN1bHQgZGVjb2RlKEJpbmFyeUJpdG1hcCBpbWFnZSkgdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24ge1xuICAgICAgICAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCB0cnkgcm90YXRpb24gd2l0aG91dCB0aGUgdHJ5IGhhcmRlciBmbGFnLCBldmVuIGlmIHJvdGF0aW9uIHdhcyBzdXBwb3J0ZWQuXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRGVjb2RlKGltYWdlLCBoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAobmZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJ5SGFyZGVyID0gaGludHMgJiYgKGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlRSWV9IQVJERVIpID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyICYmIGltYWdlLmlzUm90YXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm90YXRlZEltYWdlID0gaW1hZ2Uucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRvRGVjb2RlKHJvdGF0ZWRJbWFnZSwgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhhdCB3ZSBmb3VuZCBpdCByb3RhdGVkIDkwIGRlZ3JlZXMgQ0NXIC8gMjcwIGRlZ3JlZXMgQ1dcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWVudGF0aW9uID0gMjcwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwgJiYgKG1ldGFkYXRhLmdldChSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTikgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaWYgd2UgZm91bmQgaXQgcmV2ZXJzZWQgaW4gZG9EZWNvZGUoKSwgYWRkIGluIHRoYXQgcmVzdWx0IGhlcmU6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IChvcmllbnRhdGlvbiArIG1ldGFkYXRhLmdldChSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTikgJSAzNjApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTiwgb3JpZW50YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcmVzdWx0IHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHJvdGF0ZWRJbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gbmV3IFJlc3VsdFBvaW50KGhlaWdodCAtIHBvaW50c1tpXS5nZXRZKCkgLSAxLCBwb2ludHNbaV0uZ2V0WCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2UncmUgZ29pbmcgdG8gZXhhbWluZSByb3dzIGZyb20gdGhlIG1pZGRsZSBvdXR3YXJkLCBzZWFyY2hpbmcgYWx0ZXJuYXRlbHkgYWJvdmUgYW5kIGJlbG93IHRoZVxuICAgICAgICAgKiBtaWRkbGUsIGFuZCBmYXJ0aGVyIG91dCBlYWNoIHRpbWUuIHJvd1N0ZXAgaXMgdGhlIG51bWJlciBvZiByb3dzIGJldHdlZW4gZWFjaCBzdWNjZXNzaXZlXG4gICAgICAgICAqIGF0dGVtcHQgYWJvdmUgYW5kIGJlbG93IHRoZSBtaWRkbGUuIFNvIHdlJ2Qgc2NhbiByb3cgbWlkZGxlLCB0aGVuIG1pZGRsZSAtIHJvd1N0ZXAsIHRoZW5cbiAgICAgICAgICogbWlkZGxlICsgcm93U3RlcCwgdGhlbiBtaWRkbGUgLSAoMiAqIHJvd1N0ZXApLCBldGMuXG4gICAgICAgICAqIHJvd1N0ZXAgaXMgYmlnZ2VyIGFzIHRoZSBpbWFnZSBpcyB0YWxsZXIsIGJ1dCBpcyBhbHdheXMgYXQgbGVhc3QgMS4gV2UndmUgc29tZXdoYXQgYXJiaXRyYXJpbHlcbiAgICAgICAgICogZGVjaWRlZCB0aGF0IG1vdmluZyB1cCBhbmQgZG93biBieSBhYm91dCAxLzE2IG9mIHRoZSBpbWFnZSBpcyBwcmV0dHkgZ29vZDsgd2UgdHJ5IG1vcmUgb2YgdGhlXG4gICAgICAgICAqIGltYWdlIGlmIFwidHJ5aW5nIGhhcmRlclwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIGltYWdlIHRvIGRlY29kZVxuICAgICAgICAgKiBAcGFyYW0gaGludHMgQW55IGhpbnRzIHRoYXQgd2VyZSByZXF1ZXN0ZWRcbiAgICAgICAgICogQHJldHVybiBUaGUgY29udGVudHMgb2YgdGhlIGRlY29kZWQgYmFyY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBzcG9udGFuZW91cyBlcnJvcnMgd2hpY2ggb2NjdXJcbiAgICAgICAgICovXG4gICAgICAgIGRvRGVjb2RlKGltYWdlLCBoaW50cykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgcm93ID0gbmV3IEJpdEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyeUhhcmRlciA9IGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5UUllfSEFSREVSKSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCByb3dTdGVwID0gTWF0aC5tYXgoMSwgaGVpZ2h0ID4+ICh0cnlIYXJkZXIgPyA4IDogNSkpO1xuICAgICAgICAgICAgbGV0IG1heExpbmVzO1xuICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgIG1heExpbmVzID0gaGVpZ2h0OyAvLyBMb29rIGF0IHRoZSB3aG9sZSBpbWFnZSwgbm90IGp1c3QgdGhlIGNlbnRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4TGluZXMgPSAxNTsgLy8gMTUgcm93cyBzcGFjZWQgMS8zMiBhcGFydCBpcyByb3VnaGx5IHRoZSBtaWRkbGUgaGFsZiBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGgudHJ1bmMoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1heExpbmVzOyB4KyspIHtcbiAgICAgICAgICAgICAgICAvLyBTY2FubmluZyBmcm9tIHRoZSBtaWRkbGUgb3V0LiBEZXRlcm1pbmUgd2hpY2ggcm93IHdlJ3JlIGxvb2tpbmcgYXQgbmV4dDpcbiAgICAgICAgICAgICAgICBjb25zdCByb3dTdGVwc0Fib3ZlT3JCZWxvdyA9IE1hdGgudHJ1bmMoKHggKyAxKSAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQWJvdmUgPSAoeCAmIDB4MDEpID09PSAwOyAvLyBpLmUuIGlzIHggZXZlbj9cbiAgICAgICAgICAgICAgICBjb25zdCByb3dOdW1iZXIgPSBtaWRkbGUgKyByb3dTdGVwICogKGlzQWJvdmUgPyByb3dTdGVwc0Fib3ZlT3JCZWxvdyA6IC1yb3dTdGVwc0Fib3ZlT3JCZWxvdyk7XG4gICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA8IDAgfHwgcm93TnVtYmVyID49IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPb3BzLCBpZiB3ZSBydW4gb2ZmIHRoZSB0b3Agb3IgYm90dG9tLCBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBibGFjayBwb2ludCBmb3IgdGhpcyByb3cgYW5kIGxvYWQgaXQ6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gaW1hZ2UuZ2V0QmxhY2tSb3cocm93TnVtYmVyLCByb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgaGF2ZSB0aGUgaW1hZ2UgZGF0YSBpbiBhIEJpdEFycmF5LCBpdCdzIGZhaXJseSBjaGVhcCB0byByZXZlcnNlIGl0IGluIHBsYWNlIHRvXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRlY29kaW5nIHVwc2lkZSBkb3duIGJhcmNvZGVzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgMjsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSAxKSB7IC8vIHRyeWluZyBhZ2Fpbj9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7IC8vIHJldmVyc2UgdGhlIHJvdyBhbmQgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgd2Ugd2lsbCBvbmx5IGV2ZXIgZHJhdyByZXN1bHQgcG9pbnRzICpvbmNlKiBpbiB0aGUgbGlmZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2Ugd2FudCB0byBhdm9pZCBkcmF3aW5nIHRoZSB3cm9uZyBwb2ludHMgYWZ0ZXIgZmxpcHBpbmcgdGhlIHJvdywgYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBjbHV0dGVyIHdpdGggbm9pc2UgZnJvbSBldmVyeSBzaW5nbGUgcm93IHNjYW4gLS0ganVzdCB0aGUgc2NhbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgc3RhcnQgb24gdGhlIGNlbnRlciBsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSykgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGludHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGludHMuZm9yRWFjaCgoaGludCwga2V5KSA9PiBuZXdIaW50cy5zZXQoa2V5LCBoaW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SGludHMuZGVsZXRlKERlY29kZUhpbnRUeXBlJDEuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpbnRzID0gbmV3SGludHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGEgYmFyY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIG91ciBiYXJjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBpdCB3YXMgdXBzaWRlIGRvd24sIHNvIG5vdGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5PUklFTlRBVElPTiwgMTgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmQgcmVtZW1iZXIgdG8gZmxpcCB0aGUgcmVzdWx0IHBvaW50cyBob3Jpem9udGFsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gcmVzdWx0LmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gbmV3IFJlc3VsdFBvaW50KHdpZHRoIC0gcG9pbnRzWzBdLmdldFgoKSAtIDEsIHBvaW50c1swXS5nZXRZKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSBuZXcgUmVzdWx0UG9pbnQod2lkdGggLSBwb2ludHNbMV0uZ2V0WCgpIC0gMSwgcG9pbnRzWzFdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAocmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIC0tIGp1c3QgY291bGRuJ3QgZGVjb2RlIHRoaXMgcm93XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb3JkcyB0aGUgc2l6ZSBvZiBzdWNjZXNzaXZlIHJ1bnMgb2Ygd2hpdGUgYW5kIGJsYWNrIHBpeGVscyBpbiBhIHJvdywgc3RhcnRpbmcgYXQgYSBnaXZlbiBwb2ludC5cbiAgICAgICAgICogVGhlIHZhbHVlcyBhcmUgcmVjb3JkZWQgaW4gdGhlIGdpdmVuIGFycmF5LCBhbmQgdGhlIG51bWJlciBvZiBydW5zIHJlY29yZGVkIGlzIGVxdWFsIHRvIHRoZSBzaXplXG4gICAgICAgICAqIG9mIHRoZSBhcnJheS4gSWYgdGhlIHJvdyBzdGFydHMgb24gYSB3aGl0ZSBwaXhlbCBhdCB0aGUgZ2l2ZW4gc3RhcnQgcG9pbnQsIHRoZW4gdGhlIGZpcnN0IGNvdW50XG4gICAgICAgICAqIHJlY29yZGVkIGlzIHRoZSBydW4gb2Ygd2hpdGUgcGl4ZWxzIHN0YXJ0aW5nIGZyb20gdGhhdCBwb2ludDsgbGlrZXdpc2UgaXQgaXMgdGhlIGNvdW50IG9mIGEgcnVuXG4gICAgICAgICAqIG9mIGJsYWNrIHBpeGVscyBpZiB0aGUgcm93IGJlZ2luIG9uIGEgYmxhY2sgcGl4ZWxzIGF0IHRoYXQgcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgcm93IHRvIGNvdW50IGZyb21cbiAgICAgICAgICogQHBhcmFtIHN0YXJ0IG9mZnNldCBpbnRvIHJvdyB0byBzdGFydCBhdFxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgYXJyYXkgaW50byB3aGljaCB0byByZWNvcmQgY291bnRzXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgY291bnRlcnMgY2Fubm90IGJlIGZpbGxlZCBlbnRpcmVseSBmcm9tIHJvdyBiZWZvcmUgcnVubmluZyBvdXRcbiAgICAgICAgICogIG9mIHBpeGVsc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHJlY29yZFBhdHRlcm4ocm93LCBzdGFydCwgY291bnRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bUNvdW50ZXJzOyBpbmRleCsrKVxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2luZGV4XSA9IDA7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSAhcm93LmdldChzdGFydCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBpID0gc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KGkpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgcmVhZCBmdWxseSB0aGUgbGFzdCBzZWN0aW9uIG9mIHBpeGVscyBhbmQgZmlsbGVkIHVwIG91ciBjb3VudGVycyAtLSBvciBmaWxsZWRcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGNvdW50ZXIgYnV0IHJhbiBvZmYgdGhlIHNpZGUgb2YgdGhlIGltYWdlLCBPSy4gT3RoZXJ3aXNlLCBhIHByb2JsZW0uXG4gICAgICAgICAgICBpZiAoIShjb3VudGVyUG9zaXRpb24gPT09IG51bUNvdW50ZXJzIHx8IChjb3VudGVyUG9zaXRpb24gPT09IG51bUNvdW50ZXJzIC0gMSAmJiBpID09PSBlbmQpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyByZWNvcmRQYXR0ZXJuSW5SZXZlcnNlKHJvdywgc3RhcnQsIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG1vcmUgZWZmaWNpZW50IEkgZ3Vlc3NcbiAgICAgICAgICAgIGxldCBudW1UcmFuc2l0aW9uc0xlZnQgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHJvdy5nZXQoc3RhcnQpO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBudW1UcmFuc2l0aW9uc0xlZnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KC0tc3RhcnQpICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVRyYW5zaXRpb25zTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gIWxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bVRyYW5zaXRpb25zTGVmdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPbmVEUmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBzdGFydCArIDEsIGNvdW50ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBob3cgY2xvc2VseSBhIHNldCBvZiBvYnNlcnZlZCBjb3VudHMgb2YgcnVucyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgbWF0Y2hlcyBhIGdpdmVuXG4gICAgICAgICAqIHRhcmdldCBwYXR0ZXJuLiBUaGlzIGlzIHJlcG9ydGVkIGFzIHRoZSByYXRpbyBvZiB0aGUgdG90YWwgdmFyaWFuY2UgZnJvbSB0aGUgZXhwZWN0ZWQgcGF0dGVyblxuICAgICAgICAgKiBwcm9wb3J0aW9ucyBhY3Jvc3MgYWxsIHBhdHRlcm4gZWxlbWVudHMsIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBhdHRlcm4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb3VudGVycyBvYnNlcnZlZCBjb3VudGVyc1xuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiBleHBlY3RlZCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgVGhlIG1vc3QgYW55IGNvdW50ZXIgY2FuIGRpZmZlciBiZWZvcmUgd2UgZ2l2ZSB1cFxuICAgICAgICAgKiBAcmV0dXJuIHJhdGlvIG9mIHRvdGFsIHZhcmlhbmNlIGJldHdlZW4gY291bnRlcnMgYW5kIHBhdHRlcm4gY29tcGFyZWQgdG8gdG90YWwgcGF0dGVybiBzaXplXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgcGF0dGVybkxlbmd0aCArPSBwYXR0ZXJuW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvdGFsIDwgcGF0dGVybkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSBvbmUgcGl4ZWwgcGVyIHVuaXQgb2YgYmFyIHdpZHRoLCBhc3N1bWUgdGhpcyBpcyB0b28gc21hbGxcbiAgICAgICAgICAgICAgICAvLyB0byByZWxpYWJseSBtYXRjaCwgc28gZmFpbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pdEJhcldpZHRoID0gdG90YWwgLyBwYXR0ZXJuTGVuZ3RoO1xuICAgICAgICAgICAgbWF4SW5kaXZpZHVhbFZhcmlhbmNlICo9IHVuaXRCYXJXaWR0aDtcbiAgICAgICAgICAgIGxldCB0b3RhbFZhcmlhbmNlID0gMC4wO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBudW1Db3VudGVyczsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRlciA9IGNvdW50ZXJzW3hdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlZFBhdHRlcm4gPSBwYXR0ZXJuW3hdICogdW5pdEJhcldpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbmNlID0gY291bnRlciA+IHNjYWxlZFBhdHRlcm4gPyBjb3VudGVyIC0gc2NhbGVkUGF0dGVybiA6IHNjYWxlZFBhdHRlcm4gLSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA+IG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbFZhcmlhbmNlICs9IHZhcmlhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsVmFyaWFuY2UgLyB0b3RhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkRlY29kZXMgQ29kZSAxMjggYmFyY29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBDb2RlMTI4UmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIHN0YXRpYyBmaW5kU3RhcnRQYXR0ZXJuKHJvdykge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgY29uc3Qgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgICAgICBsZXQgY291bnRlclBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuTGVuZ3RoID0gNjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSByb3dPZmZzZXQ7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gKHBhdHRlcm5MZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IENvZGUxMjhSZWFkZXIuTUFYX0FWR19WQVJJQU5DRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0Q29kZSA9IENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOyBzdGFydENvZGUgPD0gQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0M7IHN0YXJ0Q29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlNbc3RhcnRDb2RlXSwgQ29kZTEyOFJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBzdGFydENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBiZWZvcmUgc3RhcnQgcGF0dGVybiwgPj0gNTAlIG9mIHdpZHRoIG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pc1JhbmdlKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtIChpIC0gcGF0dGVyblN0YXJ0KSAvIDIpLCBwYXR0ZXJuU3RhcnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3BhdHRlcm5TdGFydCwgaSwgYmVzdE1hdGNoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzID0gY291bnRlcnMuc2xpY2UoMiwgY291bnRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlQ29kZShyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQpIHtcbiAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHJvd09mZnNldCwgY291bnRlcnMpO1xuICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IENvZGUxMjhSZWFkZXIuTUFYX0FWR19WQVJJQU5DRTsgLy8gd29yc3QgdmFyaWFuY2Ugd2UnbGwgYWNjZXB0XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOUy5sZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBDb2RlMTI4UmVhZGVyLkNPREVfUEFUVEVSTlNbZF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBDb2RlMTI4UmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyBXZSdyZSBvdmVybG9va2luZyB0aGUgZmFjdCB0aGF0IHRoZSBTVE9QIHBhdHRlcm4gaGFzIDcgdmFsdWVzLCBub3QgNi5cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0Rk5DMSA9IGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5BU1NVTUVfR1MxKSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBhdHRlcm5JbmZvID0gQ29kZTEyOFJlYWRlci5maW5kU3RhcnRQYXR0ZXJuKHJvdyk7XG4gICAgICAgICAgICBjb25zdCBzdGFydENvZGUgPSBzdGFydFBhdHRlcm5JbmZvWzJdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRSYXdDb2Rlc0luZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJhd0NvZGVzID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuICAgICAgICAgICAgcmF3Q29kZXNbY3VycmVudFJhd0NvZGVzSW5kZXgrK10gPSBzdGFydENvZGU7XG4gICAgICAgICAgICBsZXQgY29kZVNldDtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RhcnRDb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQTpcbiAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0I6XG4gICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9DOlxuICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpc05leHRTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBsZXQgbGFzdFN0YXJ0ID0gc3RhcnRQYXR0ZXJuSW5mb1swXTtcbiAgICAgICAgICAgIGxldCBuZXh0U3RhcnQgPSBzdGFydFBhdHRlcm5JbmZvWzFdO1xuICAgICAgICAgICAgY29uc3QgY291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIGxldCBsYXN0Q29kZSA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZSA9IDA7XG4gICAgICAgICAgICBsZXQgY2hlY2tzdW1Ub3RhbCA9IHN0YXJ0Q29kZTtcbiAgICAgICAgICAgIGxldCBtdWx0aXBsaWVyID0gMDtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCB1cHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zaGlmdCA9IGlzTmV4dFNoaWZ0ZWQ7XG4gICAgICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgb2ZmIGxhc3QgY29kZVxuICAgICAgICAgICAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgYW5vdGhlciBjb2RlIGZyb20gaW1hZ2VcbiAgICAgICAgICAgICAgICBjb2RlID0gQ29kZTEyOFJlYWRlci5kZWNvZGVDb2RlKHJvdywgY291bnRlcnMsIG5leHRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmF3Q29kZXNbY3VycmVudFJhd0NvZGVzSW5kZXgrK10gPSBjb2RlO1xuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoZXRoZXIgdGhlIGxhc3QgY29kZSB3YXMgcHJpbnRhYmxlIG9yIG5vdCAoZXhjbHVkaW5nIENPREVfU1RPUClcbiAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gQ29kZTEyOFJlYWRlci5DT0RFX1NUT1ApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBjaGVja3N1bSBjb21wdXRhdGlvbiAoaWYgbm90IENPREVfU1RPUCBvZiBjb3Vyc2UpXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tzdW1Ub3RhbCArPSBtdWx0aXBsaWVyICogY29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB3aGVyZSB0aGUgbmV4dCBjb2RlIHdpbGwgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IGNvdW50ZXJzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgY3VycmVudCwgMCk7XG4gICAgICAgICAgICAgICAgLy8gVGFrZSBjYXJlIG9mIGlsbGVnYWwgc3RhcnQgY29kZXNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnRVcHBlck1vZGUgPT09IHVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJyAnLmNoYXJDb2RlQXQoMCkgKyBjb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJyAnLmNoYXJDb2RlQXQoMCkgKyBjb2RlICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hpZnRVcHBlck1vZGUgPT09IHVwcGVyTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSAtIDY0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSArIDY0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBsZXQgQ09ERV9TVE9QLCB3aGljaCBhbHdheXMgYXBwZWFycywgYWZmZWN0IHdoZXRoZXIgd2hldGhlciB3ZSB0aGluayB0aGUgbGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgd2FzIHByaW50YWJsZSBvciBub3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyYWN0ZXJXYXNQcmludGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR1MxIHNwZWNpZmljYXRpb24gNS40LjMuNy4gYW5kIDUuNC42LjQuIElmIHRoZSBmaXJzdCBjaGFyIGFmdGVyIHRoZSBzdGFydCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfNF9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0Rk5DMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC4zLjcuIGFuZCA1LjQuNi40LiBJZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc3RhcnQgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBGTkMxIHRoZW4gdGhpcyBpcyBHUzEtMTI4LiBXZSBhZGQgdGhlIHN5bWJvbG9neSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXBwZXJNb2RlICYmIHNoaWZ0VXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXBwZXJNb2RlICYmIHNoaWZ0VXBwZXJNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV4dFNoaWZ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0Rk5DMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC4zLjcuIGFuZCA1LjQuNi40LiBJZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc3RhcnQgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBGTkMxIHRoZW4gdGhpcyBpcyBHUzEtMTI4LiBXZSBhZGQgdGhlIHN5bWJvbG9neSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnNoaWZ0IGJhY2sgdG8gYW5vdGhlciBjb2RlIHNldCBpZiB3ZSB3ZXJlIHNoaWZ0ZWRcbiAgICAgICAgICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gY29kZVNldCA9PT0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQSA/IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0IgOiBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3RQYXR0ZXJuU2l6ZSA9IG5leHRTdGFydCAtIGxhc3RTdGFydDtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbXBsZSB3aGl0ZXNwYWNlIGZvbGxvd2luZyBwYXR0ZXJuLCBidXQsIHRvIGRvIHRoaXMgd2UgZmlyc3QgbmVlZCB0byByZW1lbWJlciB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBmdWRnZWQgZGVjb2RpbmcgQ09ERV9TVE9QIHNpbmNlIGl0IGFjdHVhbGx5IGhhcyA3IGJhcnMsIG5vdCA2LiBUaGVyZSBpcyBhIGJsYWNrIGJhciBsZWZ0XG4gICAgICAgICAgICAvLyB0byByZWFkIG9mZi4gV291bGQgYmUgc2xpZ2h0bHkgYmV0dGVyIHRvIHByb3Blcmx5IHJlYWQuIEhlcmUgd2UganVzdCBza2lwIGl0OlxuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcm93LmdldE5leHRVbnNldChuZXh0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKCFyb3cuaXNSYW5nZShuZXh0U3RhcnQsIE1hdGgubWluKHJvdy5nZXRTaXplKCksIG5leHRTdGFydCArIChuZXh0U3RhcnQgLSBsYXN0U3RhcnQpIC8gMiksIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHVsbCBvdXQgZnJvbSBzdW0gdGhlIHZhbHVlIG9mIHRoZSBwZW51bHRpbWF0ZSBjaGVjayBjb2RlXG4gICAgICAgICAgICBjaGVja3N1bVRvdGFsIC09IG11bHRpcGxpZXIgKiBsYXN0Q29kZTtcbiAgICAgICAgICAgIC8vIGxhc3RDb2RlIGlzIHRoZSBjaGVja3N1bSB0aGVuOlxuICAgICAgICAgICAgaWYgKGNoZWNrc3VtVG90YWwgJSAxMDMgIT09IGxhc3RDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHB1bGwgb3V0IHRoZSBjaGVjayBkaWdpdHMgZnJvbSBzdHJpbmdcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdExlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocmVzdWx0TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgYm90aGVyIGlmIHRoZSByZXN1bHQgaGFkIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIsIGFuZCBpZiB0aGUgY2hlY2tzdW0gZGlnaXQgaGFwcGVuZWQgdG9cbiAgICAgICAgICAgIC8vIGJlIGEgcHJpbnRhYmxlIGNoYXJhY3Rlci4gSWYgaXQgd2FzIGp1c3QgaW50ZXJwcmV0ZWQgYXMgYSBjb250cm9sIGNvZGUsIG5vdGhpbmcgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgaWYgKHJlc3VsdExlbmd0aCA+IDAgJiYgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlU2V0ID09PSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMCwgcmVzdWx0TGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDAsIHJlc3VsdExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSAoc3RhcnRQYXR0ZXJuSW5mb1sxXSArIHN0YXJ0UGF0dGVybkluZm9bMF0pIC8gMi4wO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBsYXN0U3RhcnQgKyBsYXN0UGF0dGVyblNpemUgLyAyLjA7XG4gICAgICAgICAgICBjb25zdCByYXdDb2Rlc1NpemUgPSByYXdDb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByYXdCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJhd0NvZGVzU2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NvZGVzU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmF3Qnl0ZXNbaV0gPSByYXdDb2Rlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtuZXcgUmVzdWx0UG9pbnQobGVmdCwgcm93TnVtYmVyKSwgbmV3IFJlc3VsdFBvaW50KHJpZ2h0LCByb3dOdW1iZXIpXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0KHJlc3VsdCwgcmF3Qnl0ZXMsIDAsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLkNPREVfMTI4LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMiwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAzLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMiwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDIsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDIsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAyLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAzLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMywgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDMsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMiwgMSwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAzLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMiwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDIsIDIsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDIsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAyLCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDIsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAyLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMiwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDMsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAxLCAyLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMSwgMywgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDMsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAyLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDMsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDEsIDMsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMiwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMywgMywgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDMsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgMSwgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDMsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAzLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMywgMSwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDEsIDIsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAxLCAzLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMywgMSwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDIsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAxLCAyLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMywgMiwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDQsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCA0LCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMywgMSwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDIsIDIsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCA0LCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgMiwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDQsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMSwgMiwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCA0LCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMiwgMSwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA0LCAyLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgNCwgMiwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDQsIDEsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAxLCAxLCAxLCA0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMywgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDQsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCA0LCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMiwgNCwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDEsIDQsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCAxLCAyLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDQsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAyLCA0LCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMiwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDIsIDEsIDEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAyLCAxLCAyLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDQsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAyLCAxLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgNCwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDMsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAxLCA0LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgNCwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDQsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCAxLCAxLCAxLCAxLCAzXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNCwgMSwgMSwgMywgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDMsIDEsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCA0LCAxLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDEsIDEsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCA0LCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMSwgNF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDEsIDEsIDIsIDMsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAzLCAzLCAxLCAxLCAxLCAyXSksXG4gICAgXTtcbiAgICBDb2RlMTI4UmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjI1O1xuICAgIENvZGUxMjhSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjc7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NISUZUID0gOTg7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQyA9IDk5O1xuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0IgPSAxMDA7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQSA9IDEwMTtcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzEgPSAxMDI7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18yID0gOTc7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zID0gOTY7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0EgPSAxMDE7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0IgPSAxMDA7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0EgPSAxMDM7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0IgPSAxMDQ7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0MgPSAxMDU7XG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1AgPSAxMDY7XG5cbiAgICAvKipcbiAgICAgKiA8cD5EZWNvZGVzIENvZGUgMzkgYmFyY29kZXMuIFN1cHBvcnRzIFwiRnVsbCBBU0NJSSBDb2RlIDM5XCIgaWYgVVNFX0NPREVfMzlfRVhURU5ERURfTU9ERSBpcyBzZXQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAc2VlIENvZGU5M1JlYWRlclxuICAgICAqL1xuICAgIGNsYXNzIENvZGUzOVJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHJlYWRlciB0aGF0IGFzc3VtZXMgYWxsIGVuY29kZWQgZGF0YSBpcyBkYXRhLCBhbmQgZG9lcyBub3QgdHJlYXQgdGhlIGZpbmFsXG4gICAgICAgICAqIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LiBJdCB3aWxsIG5vdCBkZWNvZGVkIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcy5cbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBDb2RlMzlSZWFkZXIoKSB7XG4gICAgICAgIC8vICAgdGhpcyhmYWxzZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSByZWFkZXIgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB0byBjaGVjayB0aGUgbGFzdCBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdC5cbiAgICAgICAgICogSXQgd2lsbCBub3QgZGVjb2RlZCBcImV4dGVuZGVkIENvZGUgMzlcIiBzZXF1ZW5jZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2luZ0NoZWNrRGlnaXQgaWYgdHJ1ZSwgdHJlYXQgdGhlIGxhc3QgZGF0YSBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdCwgbm90XG4gICAgICAgICAqIGRhdGEsIGFuZCB2ZXJpZnkgdGhhdCB0aGUgY2hlY2tzdW0gcGFzc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIENvZGUzOVJlYWRlcihib29sZWFuIHVzaW5nQ2hlY2tEaWdpdCkge1xuICAgICAgICAvLyAgIHRoaXModXNpbmdDaGVja0RpZ2l0LCBmYWxzZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSByZWFkZXIgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB0byBjaGVjayB0aGUgbGFzdCBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdCxcbiAgICAgICAgICogb3Igb3B0aW9uYWxseSBhdHRlbXB0IHRvIGRlY29kZSBcImV4dGVuZGVkIENvZGUgMzlcIiBzZXF1ZW5jZXMgdGhhdCBhcmUgdXNlZCB0byBlbmNvZGVcbiAgICAgICAgICogdGhlIGZ1bGwgQVNDSUkgY2hhcmFjdGVyIHNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzaW5nQ2hlY2tEaWdpdCBpZiB0cnVlLCB0cmVhdCB0aGUgbGFzdCBkYXRhIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LCBub3RcbiAgICAgICAgICogZGF0YSwgYW5kIHZlcmlmeSB0aGF0IHRoZSBjaGVja3N1bSBwYXNzZXMuXG4gICAgICAgICAqIEBwYXJhbSBleHRlbmRlZE1vZGUgaWYgdHJ1ZSwgd2lsbCBhdHRlbXB0IHRvIGRlY29kZSBleHRlbmRlZCBDb2RlIDM5IHNlcXVlbmNlcyBpbiB0aGVcbiAgICAgICAgICogdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHVzaW5nQ2hlY2tEaWdpdCA9IGZhbHNlLCBleHRlbmRlZE1vZGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMudXNpbmdDaGVja0RpZ2l0ID0gdXNpbmdDaGVja0RpZ2l0O1xuICAgICAgICAgICAgdGhpcy5leHRlbmRlZE1vZGUgPSBleHRlbmRlZE1vZGU7XG4gICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5jb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDkpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGxldCB0aGVDb3VudGVycyA9IHRoaXMuY291bnRlcnM7XG4gICAgICAgICAgICB0aGVDb3VudGVycy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IENvZGUzOVJlYWRlci5maW5kQXN0ZXJpc2tQYXR0ZXJuKHJvdywgdGhlQ291bnRlcnMpO1xuICAgICAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgIGxldCBuZXh0U3RhcnQgPSByb3cuZ2V0TmV4dFNldChzdGFydFsxXSk7XG4gICAgICAgICAgICBsZXQgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgIGxldCBsYXN0U3RhcnQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgQ29kZTM5UmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBuZXh0U3RhcnQsIHRoZUNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IENvZGUzOVJlYWRlci50b05hcnJvd1dpZGVQYXR0ZXJuKHRoZUNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gQ29kZTM5UmVhZGVyLnBhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgKz0gZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgdGhlQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYWQgb2ZmIHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcm93LmdldE5leHRTZXQobmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dSZXN1bHQgPSB0aGlzLmRlY29kZVJvd1Jlc3VsdC5zdWJzdHJpbmcoMCwgdGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIC0gMSk7IC8vIHJlbW92ZSBhc3Rlcmlza1xuICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBhZnRlciBwYXR0ZXJuOlxuICAgICAgICAgICAgbGV0IGxhc3RQYXR0ZXJuU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIHRoZUNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBhdHRlcm5TaXplICs9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd2hpdGVTcGFjZUFmdGVyRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gbGFzdFBhdHRlcm5TaXplO1xuICAgICAgICAgICAgLy8gSWYgNTAlIG9mIGxhc3QgcGF0dGVybiBzaXplLCBmb2xsb3dpbmcgbGFzdCBwYXR0ZXJuLCBpcyBub3Qgd2hpdGVzcGFjZSwgZmFpbFxuICAgICAgICAgICAgLy8gKGJ1dCBpZiBpdCdzIHdoaXRlc3BhY2UgdG8gdGhlIHZlcnkgZW5kIG9mIHRoZSBpbWFnZSwgdGhhdCdzIE9LKVxuICAgICAgICAgICAgaWYgKG5leHRTdGFydCAhPT0gZW5kICYmICh3aGl0ZVNwYWNlQWZ0ZXJFbmQgKiAyKSA8IGxhc3RQYXR0ZXJuU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudXNpbmdDaGVja0RpZ2l0KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1heCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IENvZGUzOVJlYWRlci5BTFBIQUJFVF9TVFJJTkcuaW5kZXhPZih0aGlzLmRlY29kZVJvd1Jlc3VsdC5jaGFyQXQoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVSb3dSZXN1bHQuY2hhckF0KG1heCkgIT09IENvZGUzOVJlYWRlci5BTFBIQUJFVF9TVFJJTkcuY2hhckF0KHRvdGFsICUgNDMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0LnN1YnN0cmluZygwLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlUm93UmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXh0ZW5kZWRNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gQ29kZTM5UmVhZGVyLmRlY29kZUV4dGVuZGVkKHRoaXMuZGVjb2RlUm93UmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IHRoaXMuZGVjb2RlUm93UmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxlZnQgPSAoc3RhcnRbMV0gKyBzdGFydFswXSkgLyAyLjA7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsYXN0U3RhcnQgKyBsYXN0UGF0dGVyblNpemUgLyAyLjA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIFtuZXcgUmVzdWx0UG9pbnQobGVmdCwgcm93TnVtYmVyKSwgbmV3IFJlc3VsdFBvaW50KHJpZ2h0LCByb3dOdW1iZXIpXSwgQmFyY29kZUZvcm1hdCQxLkNPREVfMzksIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZmluZEFzdGVyaXNrUGF0dGVybihyb3csIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KDApO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJvd09mZnNldDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldChpKSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBiZWZvcmUgc3RhcnQgcGF0dGVybiwgPj0gNTAlIG9mIHdpZHRoIG9mIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvTmFycm93V2lkZVBhdHRlcm4oY291bnRlcnMpID09PSBDb2RlMzlSZWFkZXIuQVNURVJJU0tfRU5DT0RJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuaXNSYW5nZShNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSBNYXRoLmZsb29yKChpIC0gcGF0dGVyblN0YXJ0KSAvIDIpKSwgcGF0dGVyblN0YXJ0LCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhdHRlcm5TdGFydCwgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzLmNvcHlXaXRoaW4oMCwgMiwgMiArIGNvdW50ZXJQb3NpdGlvbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGVmZmljaWVuY3ksIHJldHVybnMgLTEgb24gZmFpbHVyZS4gTm90IHRocm93aW5nIGhlcmUgc2F2ZWQgYXMgbWFueSBhcyA3MDAgZXhjZXB0aW9uc1xuICAgICAgICAvLyBwZXIgaW1hZ2Ugd2hlbiB1c2luZyBzb21lIG9mIG91ciBibGFja2JveCBpbWFnZXMuXG4gICAgICAgIHN0YXRpYyB0b05hcnJvd1dpZGVQYXR0ZXJuKGNvdW50ZXJzKSB7XG4gICAgICAgICAgICBsZXQgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbWF4TmFycm93Q291bnRlciA9IDA7XG4gICAgICAgICAgICBsZXQgd2lkZUNvdW50ZXJzO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBtaW5Db3VudGVyID0gMHg3ZmZmZmZmZjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluQ291bnRlciAmJiBjb3VudGVyID4gbWF4TmFycm93Q291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF4TmFycm93Q291bnRlciA9IG1pbkNvdW50ZXI7XG4gICAgICAgICAgICAgICAgd2lkZUNvdW50ZXJzID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWRlQ291bnRlcnNXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heE5hcnJvd0NvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gMSA8PCAobnVtQ291bnRlcnMgLSAxIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRlQ291bnRlcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkZUNvdW50ZXJzV2lkdGggKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2lkZUNvdW50ZXJzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIDMgd2lkZSBjb3VudGVycywgYnV0IGFyZSB0aGV5IGNsb3NlIGVub3VnaCBpbiB3aWR0aD9cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHBlcmZvcm0gYSBjaGVhcCwgY29uc2VydmF0aXZlIGNoZWNrIHRvIHNlZSBpZiBhbnkgaW5kaXZpZHVhbFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyIGlzIG1vcmUgdGhhbiAxLjUgdGltZXMgdGhlIGF2ZXJhZ2U6XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgd2lkZUNvdW50ZXJzID4gMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXhOYXJyb3dDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZUNvdW50ZXJzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG90YWxXaWRlQ291bnRlcnNXaWR0aCA9IDMgKiBhdmVyYWdlLCBzbyB0aGlzIGNoZWNrcyBpZiBjb3VudGVyID49IDMvMiAqIGF2ZXJhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXIgKiAyKSA+PSB0b3RhbFdpZGVDb3VudGVyc1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAod2lkZUNvdW50ZXJzID4gMyk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhdHRlcm5Ub0NoYXIocGF0dGVybikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDb2RlMzlSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChDb2RlMzlSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IENvZGUzOVJlYWRlci5BU1RFUklTS19FTkNPRElORykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnKic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlRXh0ZW5kZWQoZW5jb2RlZCkge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGRlY29kZWQgPSAnJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IGVuY29kZWQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnKycgfHwgYyA9PT0gJyQnIHx8IGMgPT09ICclJyB8fCBjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBlbmNvZGVkLmNoYXJBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhciA9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICtBIHRvICtaIG1hcCB0byBhIHRvIHpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkQSB0byAkWiBtYXAgdG8gY29udHJvbCBjb2RlcyBTSCB0byBTQlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICVBIHRvICVFIG1hcCB0byBjb250cm9sIGNvZGVzIEVTQyB0byBVU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdGJyAmJiBuZXh0IDw9ICdKJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApIC0gMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdLJyAmJiBuZXh0IDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID49ICdQJyAmJiBuZXh0IDw9ICdUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dC5jaGFyQ29kZUF0KDApICsgNDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnVScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJ0AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnVycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnYCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdYJyB8fCBuZXh0ID09PSAnWScgfHwgbmV4dCA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJ1xceDdmJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAvQSB0byAvTyBtYXAgdG8gISB0byAsIGFuZCAvWiBtYXBzIHRvIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSAtIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJzonO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkICs9IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgICAgICAgICAvLyBidW1wIHVwIGkgYWdhaW4gc2luY2Ugd2UgcmVhZCB0d28gY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslJztcbiAgICAvKipcbiAgICAgKiBUaGVzZSByZXByZXNlbnQgdGhlIGVuY29kaW5ncyBvZiBjaGFyYWN0ZXJzLCBhcyBwYXR0ZXJucyBvZiB3aWRlIGFuZCBuYXJyb3cgYmFycy5cbiAgICAgKiBUaGUgOSBsZWFzdC1zaWduaWZpY2FudCBiaXRzIG9mIGVhY2ggaW50IGNvcnJlc3BvbmQgdG8gdGhlIHBhdHRlcm4gb2Ygd2lkZSBhbmQgbmFycm93LFxuICAgICAqIHdpdGggMXMgcmVwcmVzZW50aW5nIFwid2lkZVwiIGFuZCAwcyByZXByZXNlbnRpbmcgbmFycm93LlxuICAgICAqL1xuICAgIENvZGUzOVJlYWRlci5DSEFSQUNURVJfRU5DT0RJTkdTID0gW1xuICAgICAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCxcbiAgICAgICAgMHgxMDksIDB4MDQ5LCAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsXG4gICAgICAgIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNiwgMHgwNDYsIDB4MDE2LFxuICAgICAgICAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDBBOCxcbiAgICAgICAgMHgwQTIsIDB4MDhBLCAweDAyQSAvLyAvLSVcbiAgICBdO1xuICAgIENvZGUzOVJlYWRlci5BU1RFUklTS19FTkNPRElORyA9IDB4MDk0O1xuXG4gICAgLyoqXG4gICAgICogPHA+RGVjb2RlcyBJVEYgYmFyY29kZXMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBUamllY29cbiAgICAgKi9cbiAgICBjbGFzcyBJVEZSZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBwcml2YXRlIHN0YXRpYyBXID0gMzsgLy8gUGl4ZWwgd2lkdGggb2YgYSAzeCB3aWRlIGxpbmVcbiAgICAgICAgICAgIC8vIHByaXZhdGUgc3RhdGljIHcgPSAyOyAvLyBQaXhlbCB3aWR0aCBvZiBhIDJ4IHdpZGUgbGluZVxuICAgICAgICAgICAgLy8gcHJpdmF0ZSBzdGF0aWMgTiA9IDE7IC8vIFBpeGVkIHdpZHRoIG9mIGEgbmFycm93IGxpbmVcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBTdG9yZXMgdGhlIGFjdHVhbCBuYXJyb3cgbGluZSB3aWR0aCBvZiB0aGUgaW1hZ2UgYmVpbmcgZGVjb2RlZC5cbiAgICAgICAgICAgIHRoaXMubmFycm93TGluZVdpZHRoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIElURldyaXRlci5QQVRURVJOU1xuICAgICAgICAvKlxuICAgICAgXG4gICAgICAgIC8hKipcbiAgICAgICAgICogUGF0dGVybnMgb2YgV2lkZSAvIE5hcnJvdyBsaW5lcyB0byBpbmRpY2F0ZSBlYWNoIGRpZ2l0XG4gICAgICAgICAqIS9cbiAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgLy8gRmluZCBvdXQgd2hlcmUgdGhlIE1pZGRsZSBzZWN0aW9uIChwYXlsb2FkKSBzdGFydHMgJiBlbmRzXG4gICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHRoaXMuZGVjb2RlU3RhcnQocm93KTtcbiAgICAgICAgICAgIGxldCBlbmRSYW5nZSA9IHRoaXMuZGVjb2RlRW5kKHJvdyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIElURlJlYWRlci5kZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlWzFdLCBlbmRSYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBhbGxvd2VkTGVuZ3RocyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFsbG93ZWRMZW5ndGhzID0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuQUxMT1dFRF9MRU5HVEhTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3RocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZExlbmd0aHMgPSBJVEZSZWFkZXIuREVGQVVMVF9BTExPV0VEX0xFTkdUSFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMgd2l0aCAyRCBiYXJjb2RlcyAoYW5kIG90aGVyIHBhdHRlcm5zKSwgbWFrZVxuICAgICAgICAgICAgLy8gYW4gYXNzdW1wdGlvbiB0aGF0IHRoZSBkZWNvZGVkIHN0cmluZyBtdXN0IGJlIGEgJ3N0YW5kYXJkJyBsZW5ndGggaWYgaXQncyBzaG9ydFxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHJlc3VsdFN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoT0sgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBtYXhBbGxvd2VkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGFsbG93ZWRMZW5ndGhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoT0sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4QWxsb3dlZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhBbGxvd2VkTGVuZ3RoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZW5ndGhPSyAmJiBsZW5ndGggPiBtYXhBbGxvd2VkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoT0sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZW5ndGhPSykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtuZXcgUmVzdWx0UG9pbnQoc3RhcnRSYW5nZVsxXSwgcm93TnVtYmVyKSwgbmV3IFJlc3VsdFBvaW50KGVuZFJhbmdlWzBdLCByb3dOdW1iZXIpXTtcbiAgICAgICAgICAgIGxldCByZXN1bHRSZXR1cm4gPSBuZXcgUmVzdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgLy8gbm8gbmF0dXJhbCBieXRlIHJlcHJlc2VudGF0aW9uIGZvciB0aGVzZSBiYXJjb2Rlc1xuICAgICAgICAgICAgMCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0JDEuSVRGLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0UmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIC8hKipcbiAgICAgICAgICogQHBhcmFtIHJvdyAgICAgICAgICByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcGF5bG9hZFN0YXJ0IG9mZnNldCBvZiBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHRTdHJpbmcge0BsaW5rIFN0cmluZ0J1aWxkZXJ9IHRvIGFwcGVuZCBkZWNvZGVkIGNoYXJzIHRvXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgZGVjb2RpbmcgY291bGQgbm90IGNvbXBsZXRlIHN1Y2Nlc3NmdWxseVxuICAgICAgICAgKiEvKi9cbiAgICAgICAgc3RhdGljIGRlY29kZU1pZGRsZShyb3csIHBheWxvYWRTdGFydCwgcGF5bG9hZEVuZCwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBEaWdpdHMgYXJlIGludGVybGVhdmVkIGluIHBhaXJzIC0gNSBibGFjayBsaW5lcyBmb3Igb25lIGRpZ2l0LCBhbmQgdGhlXG4gICAgICAgICAgICAvLyA1XG4gICAgICAgICAgICAvLyBpbnRlcmxlYXZlZCB3aGl0ZSBsaW5lcyBmb3IgdGhlIHNlY29uZCBkaWdpdC5cbiAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgbmVlZCB0byBzY2FuIDEwIGxpbmVzIGFuZCB0aGVuXG4gICAgICAgICAgICAvLyBzcGxpdCB0aGVzZSBpbnRvIHR3byBhcnJheXNcbiAgICAgICAgICAgIGxldCBjb3VudGVyRGlnaXRQYWlyID0gbmV3IEludDMyQXJyYXkoMTApOyAvLyAxMFxuICAgICAgICAgICAgbGV0IGNvdW50ZXJCbGFjayA9IG5ldyBJbnQzMkFycmF5KDUpOyAvLyA1XG4gICAgICAgICAgICBsZXQgY291bnRlcldoaXRlID0gbmV3IEludDMyQXJyYXkoNSk7IC8vIDVcbiAgICAgICAgICAgIGNvdW50ZXJEaWdpdFBhaXIuZmlsbCgwKTtcbiAgICAgICAgICAgIGNvdW50ZXJCbGFjay5maWxsKDApO1xuICAgICAgICAgICAgY291bnRlcldoaXRlLmZpbGwoMCk7XG4gICAgICAgICAgICB3aGlsZSAocGF5bG9hZFN0YXJ0IDwgcGF5bG9hZEVuZCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCAxMCBydW5zIG9mIGJsYWNrL3doaXRlLlxuICAgICAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHBheWxvYWRTdGFydCwgY291bnRlckRpZ2l0UGFpcik7XG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgdGhlbSBpbnRvIGVhY2ggYXJyYXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDU7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHdvSyA9IDIgKiBrO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyQmxhY2tba10gPSBjb3VudGVyRGlnaXRQYWlyW3R3b0tdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyV2hpdGVba10gPSBjb3VudGVyRGlnaXRQYWlyW3R3b0sgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IElURlJlYWRlci5kZWNvZGVEaWdpdChjb3VudGVyQmxhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZy5hcHBlbmQoYmVzdE1hdGNoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHRoaXMuZGVjb2RlRGlnaXQoY291bnRlcldoaXRlKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcuYXBwZW5kKGJlc3RNYXRjaC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjb3VudGVyRGlnaXRQYWlyLmZvckVhY2goZnVuY3Rpb24gKGNvdW50ZXJEaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkU3RhcnQgKz0gY291bnRlckRpZ2l0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qLyEqKlxuICAgICAgICAgKiBJZGVudGlmeSB3aGVyZSB0aGUgc3RhcnQgb2YgdGhlIG1pZGRsZSAvIHBheWxvYWQgc2VjdGlvbiBzdGFydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgICAgICogQHJldHVybiBBcnJheSwgY29udGFpbmluZyBpbmRleCBvZiBzdGFydCBvZiAnc3RhcnQgYmxvY2snIGFuZCBlbmQgb2ZcbiAgICAgICAgICogICAgICAgICAnc3RhcnQgYmxvY2snXG4gICAgICAgICAqIS8qL1xuICAgICAgICBkZWNvZGVTdGFydChyb3cpIHtcbiAgICAgICAgICAgIGxldCBlbmRTdGFydCA9IElURlJlYWRlci5za2lwV2hpdGVTcGFjZShyb3cpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0UGF0dGVybiA9IElURlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgZW5kU3RhcnQsIElURlJlYWRlci5TVEFSVF9QQVRURVJOKTtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgd2lkdGggb2YgYSBuYXJyb3cgbGluZSBpbiBwaXhlbHMuIFdlIGNhbiBkbyB0aGlzIGJ5XG4gICAgICAgICAgICAvLyBnZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgc3RhcnQgcGF0dGVybiBhbmQgZGl2aWRpbmcgYnkgNCBiZWNhdXNlIGl0c1xuICAgICAgICAgICAgLy8gbWFkZSB1cCBvZiA0IG5hcnJvdyBsaW5lcy5cbiAgICAgICAgICAgIHRoaXMubmFycm93TGluZVdpZHRoID0gKHN0YXJ0UGF0dGVyblsxXSAtIHN0YXJ0UGF0dGVyblswXSkgLyA0O1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVF1aWV0Wm9uZShyb3csIHN0YXJ0UGF0dGVyblswXSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRQYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qLyEqKlxuICAgICAgICAgKiBUaGUgc3RhcnQgJiBlbmQgcGF0dGVybnMgbXVzdCBiZSBwcmUvcG9zdCBmaXhlZCBieSBhIHF1aWV0IHpvbmUuIFRoaXNcbiAgICAgICAgICogem9uZSBtdXN0IGJlIGF0IGxlYXN0IDEwIHRpbWVzIHRoZSB3aWR0aCBvZiBhIG5hcnJvdyBsaW5lLiAgU2NhbiBiYWNrIHVudGlsXG4gICAgICAgICAqIHdlIGVpdGhlciBnZXQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBiYXJjb2RlIG9yIG1hdGNoIHRoZSBuZWNlc3NhcnkgbnVtYmVyIG9mXG4gICAgICAgICAqIHF1aWV0IHpvbmUgcGl4ZWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBJdHMgYXNzdW1lZCB0aGUgcm93IGlzIHJldmVyc2VkIHdoZW4gdXNpbmcgdGhpcyBtZXRob2QgdG8gZmluZFxuICAgICAgICAgKiBxdWlldCB6b25lIGFmdGVyIHRoZSBlbmQgcGF0dGVybi5cbiAgICAgICAgICpcbiAgICAgICAgICogcmVmOiBodHRwOi8vd3d3LmJhcmNvZGUtMS5uZXQvaTI1Y29kZS5odG1sXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgYml0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2Nhbm5lZCBiYXJjb2RlLlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRQYXR0ZXJuIGluZGV4IGludG8gcm93IG9mIHRoZSBzdGFydCBvciBlbmQgcGF0dGVybi5cbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiB0aGUgcXVpZXQgem9uZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICohLyovXG4gICAgICAgIHZhbGlkYXRlUXVpZXRab25lKHJvdywgc3RhcnRQYXR0ZXJuKSB7XG4gICAgICAgICAgICBsZXQgcXVpZXRDb3VudCA9IHRoaXMubmFycm93TGluZVdpZHRoICogMTA7IC8vIGV4cGVjdCB0byBmaW5kIHRoaXMgbWFueSBwaXhlbHMgb2YgcXVpZXQgem9uZVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vdCBzbyBtYW55IHBpeGVsIGF0IGFsbCBsZXQncyB0cnkgYXMgbWFueSBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgcXVpZXRDb3VudCA9IHF1aWV0Q291bnQgPCBzdGFydFBhdHRlcm4gPyBxdWlldENvdW50IDogc3RhcnRQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0UGF0dGVybiAtIDE7IHF1aWV0Q291bnQgPiAwICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1aWV0Q291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWlldENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5hYmxlIHRvIGZpbmQgdGhlIG5lY2Vzc2FyeSBudW1iZXIgb2YgcXVpZXQgem9uZSBwaXhlbHMuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLyEqKlxuICAgICAgICAgKiBTa2lwIGFsbCB3aGl0ZXNwYWNlIHVudGlsIHdlIGdldCB0byB0aGUgZmlyc3QgYmxhY2sgbGluZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcmV0dXJuIGluZGV4IG9mIHRoZSBmaXJzdCBibGFjayBsaW5lLlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIFRocm93cyBleGNlcHRpb24gaWYgbm8gYmxhY2sgbGluZXMgYXJlIGZvdW5kIGluIHRoZSByb3dcbiAgICAgICAgICohLyovXG4gICAgICAgIHN0YXRpYyBza2lwV2hpdGVTcGFjZShyb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFN0YXJ0ID0gcm93LmdldE5leHRTZXQoMCk7XG4gICAgICAgICAgICBpZiAoZW5kU3RhcnQgPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5kU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyovISoqXG4gICAgICAgICAqIElkZW50aWZ5IHdoZXJlIHRoZSBlbmQgb2YgdGhlIG1pZGRsZSAvIHBheWxvYWQgc2VjdGlvbiBlbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcm93IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXG4gICAgICAgICAqIEByZXR1cm4gQXJyYXksIGNvbnRhaW5pbmcgaW5kZXggb2Ygc3RhcnQgb2YgJ2VuZCBibG9jaycgYW5kIGVuZCBvZiAnZW5kXG4gICAgICAgICAqICAgICAgICAgYmxvY2snXG4gICAgICAgICAqIS8qL1xuICAgICAgICBkZWNvZGVFbmQocm93KSB7XG4gICAgICAgICAgICAvLyBGb3IgY29udmVuaWVuY2UsIHJldmVyc2UgdGhlIHJvdyBhbmQgdGhlblxuICAgICAgICAgICAgLy8gc2VhcmNoIGZyb20gJ3RoZSBzdGFydCcgZm9yIHRoZSBlbmQgYmxvY2tcbiAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRTdGFydCA9IElURlJlYWRlci5za2lwV2hpdGVTcGFjZShyb3cpO1xuICAgICAgICAgICAgICAgIGxldCBlbmRQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZFBhdHRlcm4gPSBJVEZSZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRURbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBhdHRlcm4gPSBJVEZSZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRURbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBzdGFydCAmIGVuZCBwYXR0ZXJucyBtdXN0IGJlIHByZS9wb3N0IGZpeGVkIGJ5IGEgcXVpZXQgem9uZS4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIHpvbmUgbXVzdCBiZSBhdCBsZWFzdCAxMCB0aW1lcyB0aGUgd2lkdGggb2YgYSBuYXJyb3cgbGluZS5cbiAgICAgICAgICAgICAgICAvLyByZWY6IGh0dHA6Ly93d3cuYmFyY29kZS0xLm5ldC9pMjVjb2RlLmh0bWxcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVpZXRab25lKHJvdywgZW5kUGF0dGVyblswXSk7XG4gICAgICAgICAgICAgICAgLy8gTm93IHJlY2FsY3VsYXRlIHRoZSBpbmRpY2VzIG9mIHdoZXJlIHRoZSAnZW5kYmxvY2snIHN0YXJ0cyAmIHN0b3BzIHRvXG4gICAgICAgICAgICAgICAgLy8gYWNjb21tb2RhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmV2ZXJzZWQgbmF0dXJlIG9mIHRoZSBzZWFyY2hcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGVuZFBhdHRlcm5bMF07XG4gICAgICAgICAgICAgICAgZW5kUGF0dGVyblswXSA9IHJvdy5nZXRTaXplKCkgLSBlbmRQYXR0ZXJuWzFdO1xuICAgICAgICAgICAgICAgIGVuZFBhdHRlcm5bMV0gPSByb3cuZ2V0U2l6ZSgpIC0gdGVtcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kUGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIFB1dCB0aGUgcm93IGJhY2sgdGhlIHJpZ2h0IHdheS5cbiAgICAgICAgICAgICAgICByb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIC8hKipcbiAgICAgICAgICogQHBhcmFtIHJvdyAgICAgICByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcm93T2Zmc2V0IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiAgIHBhdHRlcm4gb2YgY291bnRzIG9mIG51bWJlciBvZiBibGFjayBhbmQgd2hpdGUgcGl4ZWxzIHRoYXQgYXJlXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgYmVpbmcgc2VhcmNoZWQgZm9yIGFzIGEgcGF0dGVyblxuICAgICAgICAgKiBAcmV0dXJuIHN0YXJ0L2VuZCBob3Jpem9udGFsIG9mZnNldCBvZiBndWFyZCBwYXR0ZXJuLCBhcyBhbiBhcnJheSBvZiB0d29cbiAgICAgICAgICogICAgICAgICBpbnRzXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgcGF0dGVybiBpcyBub3QgZm91bmRcbiAgICAgICAgICohLyovXG4gICAgICAgIHN0YXRpYyBmaW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkocGF0dGVybkxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgICAgIGNvdW50ZXJzLmZpbGwoMCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gcm93T2Zmc2V0OyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9PSBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT25lRFJlYWRlci5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgSVRGUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IElURlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvdW50ZXJzLCAyLCBjb3VudGVycywgMCwgY291bnRlclBvc2l0aW9uIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKi8hKipcbiAgICAgICAgICogQXR0ZW1wdHMgdG8gZGVjb2RlIGEgc2VxdWVuY2Ugb2YgSVRGIGJsYWNrL3doaXRlIGxpbmVzIGludG8gc2luZ2xlXG4gICAgICAgICAqIGRpZ2l0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgdGhlIGNvdW50cyBvZiBydW5zIG9mIG9ic2VydmVkIGJsYWNrL3doaXRlL2JsYWNrLy4uLiB2YWx1ZXNcbiAgICAgICAgICogQHJldHVybiBUaGUgZGVjb2RlZCBkaWdpdFxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGRpZ2l0IGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIS8qL1xuICAgICAgICBzdGF0aWMgZGVjb2RlRGlnaXQoY291bnRlcnMpIHtcbiAgICAgICAgICAgIGxldCBiZXN0VmFyaWFuY2UgPSBJVEZSZWFkZXIuTUFYX0FWR19WQVJJQU5DRTsgLy8gd29yc3QgdmFyaWFuY2Ugd2UnbGwgYWNjZXB0XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICBsZXQgbWF4ID0gSVRGUmVhZGVyLlBBVFRFUk5TLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IElURlJlYWRlci5QQVRURVJOU1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyaWFuY2UgPSBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBJVEZSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0VmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFyaWFuY2UgPT09IGJlc3RWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIGEgc2Vjb25kICdiZXN0IG1hdGNoJyB3aXRoIHRoZSBzYW1lIHZhcmlhbmNlLCB3ZSBjYW4gbm90IHJlbGlhYmx5IHJlcG9ydCB0byBoYXZlIGEgc3VpdGFibGUgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaCAlIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSVRGUmVhZGVyLlBBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDIsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAxLCAxLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgMSwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDIsIDEsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAyLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAyLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMSwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDIsIDEsIDIsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAzLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgMSwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDMsIDEsIDEsIDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCAxLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMywgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDMsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAzLCAxLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMywgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDMsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAzLCAxXSkgLy8gOVxuICAgIF07XG4gICAgSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjM4O1xuICAgIElURlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNTtcbiAgICAvKiAvISoqIFZhbGlkIElURiBsZW5ndGhzLiBBbnl0aGluZyBsb25nZXIgdGhhbiB0aGUgbGFyZ2VzdCB2YWx1ZSBpcyBhbHNvIGFsbG93ZWQuICohLyovXG4gICAgSVRGUmVhZGVyLkRFRkFVTFRfQUxMT1dFRF9MRU5HVEhTID0gWzYsIDgsIDEwLCAxMiwgMTRdO1xuICAgIC8qLyEqKlxuICAgICAqIFN0YXJ0L2VuZCBndWFyZCBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogTm90ZTogVGhlIGVuZCBwYXR0ZXJuIGlzIHJldmVyc2VkIGJlY2F1c2UgdGhlIHJvdyBpcyByZXZlcnNlZCBiZWZvcmVcbiAgICAgKiBzZWFyY2hpbmcgZm9yIHRoZSBFTkRfUEFUVEVSTlxuICAgICAqIS8qL1xuICAgIElURlJlYWRlci5TVEFSVF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxXSk7XG4gICAgSVRGUmVhZGVyLkVORF9QQVRURVJOX1JFVkVSU0VEID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzXSkgLy8gM3hcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIFVQQyBhbmQgRUFOIGZhbWlsaWVzXG4gICAgICogb2Ygb25lLWRpbWVuc2lvbmFsIGJhcmNvZGVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAYXV0aG9yIGFsYXNkYWlyQGdvb2dsZS5jb20gKEFsYXNkYWlyIE1hY2tpbnRvc2gpXG4gICAgICovXG4gICAgY2xhc3MgQWJzdHJhY3RVUENFQU5SZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyBmaW5kU3RhcnRHdWFyZFBhdHRlcm4ocm93KSB7XG4gICAgICAgICAgICBsZXQgZm91bmRTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0UmFuZ2U7XG4gICAgICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pO1xuICAgICAgICAgICAgd2hpbGUgKCFmb3VuZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKTtcbiAgICAgICAgICAgICAgICBzdGFydFJhbmdlID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIG5leHRTdGFydCwgZmFsc2UsIHRoaXMuU1RBUlRfRU5EX1BBVFRFUk4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBzdGFydFJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgbGV0IHF1aWV0U3RhcnQgPSBzdGFydCAtIChuZXh0U3RhcnQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1aWV0U3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJ0ID0gcm93LmlzUmFuZ2UocXVpZXRTdGFydCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tDaGVja3N1bShzKSB7XG4gICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuY2hlY2tTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2hlY2sgPSBwYXJzZUludChzLmNoYXJBdChsZW5ndGggLSAxKSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIEFic3RyYWN0VVBDRUFOUmVhZGVyLmdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocy5zdWJzdHJpbmcoMCwgbGVuZ3RoIC0gMSkpID09PSBjaGVjaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlnaXQgPCAwIHx8IGRpZ2l0ID4gOSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bSAqPSAzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgxMDAwIC0gc3VtKSAlIDEwO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVFbmQocm93LCBlbmRTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgZmFsc2UsIEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLCBuZXcgSW50MzJBcnJheShBYnN0cmFjdFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZmluZEd1YXJkUGF0dGVybldpdGhvdXRDb3VudGVycyhyb3csIHJvd09mZnNldCwgd2hpdGVGaXJzdCwgcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEd1YXJkUGF0dGVybihyb3csIHJvd09mZnNldCwgd2hpdGVGaXJzdCwgcGF0dGVybiwgbmV3IEludDMyQXJyYXkocGF0dGVybi5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHJvdyByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzIHRvIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcm93T2Zmc2V0IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gd2hpdGVGaXJzdCBpZiB0cnVlLCBpbmRpY2F0ZXMgdGhhdCB0aGUgcGF0dGVybiBzcGVjaWZpZXMgd2hpdGUvYmxhY2svd2hpdGUvLi4uXG4gICAgICAgICAqIHBpeGVsIGNvdW50cywgb3RoZXJ3aXNlLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBibGFjay93aGl0ZS9ibGFjay8uLi5cbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4gcGF0dGVybiBvZiBjb3VudHMgb2YgbnVtYmVyIG9mIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMgdGhhdCBhcmUgYmVpbmdcbiAgICAgICAgICogc2VhcmNoZWQgZm9yIGFzIGEgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgYXJyYXkgb2YgY291bnRlcnMsIGFzIGxvbmcgYXMgcGF0dGVybiwgdG8gcmUtdXNlXG4gICAgICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3byBpbnRzXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgcGF0dGVybiBpcyBub3QgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCB3aGl0ZUZpcnN0LCBwYXR0ZXJuLCBjb3VudGVycykge1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIHJvd09mZnNldCA9IHdoaXRlRmlyc3QgPyByb3cuZ2V0TmV4dFVuc2V0KHJvd09mZnNldCkgOiByb3cuZ2V0TmV4dFNldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5MZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpc1doaXRlID0gd2hpdGVGaXJzdDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gcGF0dGVybkxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbcGF0dGVyblN0YXJ0LCB4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzbGljZSA9IGNvdW50ZXJzLnNsaWNlKDIsIGNvdW50ZXJzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUG9zaXRpb24gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tpXSA9IHNsaWNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkUGF0dGVybihyb3csIHJvd09mZnNldCwgY291bnRlcnMpO1xuICAgICAgICAgICAgbGV0IGJlc3RWYXJpYW5jZSA9IHRoaXMuTUFYX0FWR19WQVJJQU5DRTtcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSAtMTtcbiAgICAgICAgICAgIGxldCBtYXggPSBwYXR0ZXJucy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSBwYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyaWFuY2UgPSBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVzZSB0d28gdmFsdWVzIGFyZSBjcml0aWNhbCBmb3IgZGV0ZXJtaW5pbmcgaG93IHBlcm1pc3NpdmUgdGhlIGRlY29kaW5nIHdpbGwgYmUuXG4gICAgLy8gV2UndmUgYXJyaXZlZCBhdCB0aGVzZSB2YWx1ZXMgdGhyb3VnaCBhIGxvdCBvZiB0cmlhbCBhbmQgZXJyb3IuIFNldHRpbmcgdGhlbSBhbnkgaGlnaGVyXG4gICAgLy8gbGV0cyBmYWxzZSBwb3NpdGl2ZXMgY3JlZXAgaW4gcXVpY2tseS5cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFID0gMC40ODtcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNztcbiAgICAvKipcbiAgICAgKiBTdGFydC9lbmQgZ3VhcmQgcGF0dGVybi5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMV0pO1xuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gbWFya2luZyB0aGUgbWlkZGxlIG9mIGEgVVBDL0VBTiBwYXR0ZXJuLCBzZXBhcmF0aW5nIHRoZSB0d28gaGFsdmVzLlxuICAgICAqL1xuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSk7XG4gICAgLyoqXG4gICAgICogZW5kIGd1YXJkIHBhdHRlcm4uXG4gICAgICovXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuRU5EX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDEsIDEsIDFdKTtcbiAgICAvKipcbiAgICAgKiBcIk9kZFwiLCBvciBcIkxcIiBwYXR0ZXJucyB1c2VkIHRvIGVuY29kZSBVUEMvRUFOIGRpZ2l0cy5cbiAgICAgKi9cbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TID0gW1xuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDIsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCAyLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMSwgMiwgMl0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDQsIDEsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAzLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMywgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCAxLCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMiwgMSwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDEsIDEsIDJdKSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQHNlZSBVUENFQU5FeHRlbnNpb24yU3VwcG9ydFxuICAgICAqL1xuICAgIGNsYXNzIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLkNIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsweDE4LCAweDE0LCAweDEyLCAweDExLCAweDBDLCAweDA2LCAweDAzLCAweDBBLCAweDA5LCAweDA1XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXI7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5kZWNvZGVNaWRkbGUocm93LCBleHRlbnNpb25TdGFydFJhbmdlLCByZXN1bHQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbkRhdGEgPSBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wYXJzZUV4dGVuc2lvblN0cmluZyhyZXN1bHRTdHJpbmcpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoKGV4dGVuc2lvblN0YXJ0UmFuZ2VbMF0gKyBleHRlbnNpb25TdGFydFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKSxcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnQoZW5kLCByb3dOdW1iZXIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvblJlc3VsdCA9IG5ldyBSZXN1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5VUENfRUFOX0VYVEVOU0lPTiwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbkRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25SZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzO1xuICAgICAgICAgICAgY291bnRlcnNbMF0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMV0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xuICAgICAgICAgICAgY291bnRlcnNbM10gPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJvdy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgcm93T2Zmc2V0ID0gc3RhcnRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBsZ1BhdHRlcm5Gb3VuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDUgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gQWJzdHJhY3RVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQoXG4gICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOUyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoICUgMTApKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxnUGF0dGVybkZvdW5kIHw9IDEgPDwgKDQgLSB4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBvZmYgc2VwYXJhdG9yIGlmIG5vdCBsYXN0XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0VW5zZXQocm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoZWNrRGlnaXQgPSB0aGlzLmRldGVybWluZUNoZWNrRGlnaXQobGdQYXR0ZXJuRm91bmQpO1xuICAgICAgICAgICAgaWYgKFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LmV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdFN0cmluZy50b1N0cmluZygpKSAhPT0gY2hlY2tEaWdpdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZXh0ZW5zaW9uQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VtICo9IDM7XG4gICAgICAgICAgICByZXR1cm4gc3VtICUgMTA7XG4gICAgICAgIH1cbiAgICAgICAgZGV0ZXJtaW5lQ2hlY2tEaWdpdChsZ1BhdHRlcm5Gb3VuZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCAxMDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxnUGF0dGVybkZvdW5kID09PSB0aGlzLkNIRUNLX0RJR0lUX0VOQ09ESU5HU1tkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VFeHRlbnNpb25TdHJpbmcocmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3Lmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQucGFyc2VFeHRlbnNpb241U3RyaW5nKHJhdyk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoW1tSZXN1bHRNZXRhZGF0YVR5cGUkMS5TVUdHRVNURURfUFJJQ0UsIHZhbHVlXV0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUV4dGVuc2lvbjVTdHJpbmcocmF3KSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHJhdy5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnwqMnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnJCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2U6IGh0dHA6Ly93d3cuam9sbHl0ZWNoLmNvbVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOTAwMDAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHN1Z2dlc3RlZCByZXRhaWwgcHJpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzk5OTkxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGVtZW50YXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcwLjAwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzk5OTkwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1VzZWQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZS4uLiB1bmtub3duIGN1cnJlbmN5P1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYXdBbW91bnQgPSBwYXJzZUludChyYXcuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIGxldCB1bml0c1N0cmluZyA9IChyYXdBbW91bnQgLyAxMDApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgaHVuZHJlZHRocyA9IHJhd0Ftb3VudCAlIDEwMDtcbiAgICAgICAgICAgIGxldCBodW5kcmVkdGhzU3RyaW5nID0gaHVuZHJlZHRocyA8IDEwID8gJzAnICsgaHVuZHJlZHRocyA6IGh1bmRyZWR0aHMudG9TdHJpbmcoKTsgLy8gZml4bWVcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW5jeSArIHVuaXRzU3RyaW5nICsgJy4nICsgaHVuZHJlZHRoc1N0cmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnRcbiAgICAgKi9cbiAgICBjbGFzcyBVUENFQU5FeHRlbnNpb24yU3VwcG9ydCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlcjtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLmRlY29kZU1pZGRsZShyb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UsIHJlc3VsdCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uRGF0YSA9IFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0LnBhcnNlRXh0ZW5zaW9uU3RyaW5nKHJlc3VsdFN0cmluZyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UG9pbnRzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludCgoZXh0ZW5zaW9uU3RhcnRSYW5nZVswXSArIGV4dGVuc2lvblN0YXJ0UmFuZ2VbMV0pIC8gMi4wLCByb3dOdW1iZXIpLFxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludChlbmQsIHJvd051bWJlcilcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uUmVzdWx0ID0gbmV3IFJlc3VsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIHJlc3VsdFBvaW50cywgQmFyY29kZUZvcm1hdCQxLlVQQ19FQU5fRVhURU5TSU9OLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uUmVzdWx0LnB1dEFsbE1ldGFkYXRhKGV4dGVuc2lvbkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnM7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICAgICAgbGV0IGNoZWNrUGFyaXR5ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMiAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBiZXN0TWF0Y2ggPSBBYnN0cmFjdFVQQ0VBTlJlYWRlci5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIEFic3RyYWN0VVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCAlIDEwKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1Bhcml0eSB8PSAxIDw8ICgxIC0geCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgb2ZmIHNlcGFyYXRvciBpZiBub3QgbGFzdFxuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFNldChyb3dPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFVuc2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZUludChyZXN1bHRTdHJpbmcudG9TdHJpbmcoKSkgJSA0ICE9PSBjaGVja1Bhcml0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcGFyc2VFeHRlbnNpb25TdHJpbmcocmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoW1tSZXN1bHRNZXRhZGF0YVR5cGUkMS5JU1NVRV9OVU1CRVIsIHBhcnNlSW50KHJhdyldXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBVUENFQU5FeHRlbnNpb25TdXBwb3J0IHtcbiAgICAgICAgc3RhdGljIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgcm93T2Zmc2V0KSB7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uU3RhcnRSYW5nZSA9IEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4oXG4gICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgIHJvd09mZnNldCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aGlzLkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLFxuICAgICAgICAgICAgICAgIG5ldyBJbnQzMkFycmF5KHRoaXMuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGZpdmVTdXBwb3J0ID0gbmV3IFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpdmVTdXBwb3J0LmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHR3b1N1cHBvcnQgPSBuZXcgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdvU3VwcG9ydC5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQuRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDJdKTtcblxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBmdW5jdGlvbmFsaXR5IGFuZCBpbXBsZW1lbnRhdGlvbiB0aGF0IGlzIGNvbW1vbiB0byBVUEMgYW5kIEVBTiBmYW1pbGllc1xuICAgICAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQGF1dGhvciBhbGFzZGFpckBnb29nbGUuY29tIChBbGFzZGFpciBNYWNraW50b3NoKVxuICAgICAqL1xuICAgIGNsYXNzIFVQQ0VBTlJlYWRlciBleHRlbmRzIEFic3RyYWN0VVBDRUFOUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcbiAgICAgICAgICAgIFVQQ0VBTlJlYWRlci5MX0FORF9HX1BBVFRFUk5TID0gVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMubWFwKGFyciA9PiBJbnQzMkFycmF5LmZyb20oYXJyKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdpZHRocyA9IFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TW2kgLSAxMF07XG4gICAgICAgICAgICAgICAgbGV0IHJldmVyc2VkV2lkdGhzID0gbmV3IEludDMyQXJyYXkod2lkdGhzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZWRXaWR0aHNbal0gPSB3aWR0aHNbd2lkdGhzLmxlbmd0aCAtIGogLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlNbaV0gPSByZXZlcnNlZFdpZHRocztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRHdWFyZFJhbmdlID0gVVBDRUFOUmVhZGVyLmZpbmRTdGFydEd1YXJkUGF0dGVybihyb3cpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdFBvaW50Q2FsbGJhY2sgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRQb2ludENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRQb2ludCA9IG5ldyBSZXN1bHRQb2ludCgoc3RhcnRHdWFyZFJhbmdlWzBdICsgc3RhcnRHdWFyZFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChyZXN1bHRQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnVkZWxsbyA9IHRoaXMuZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRHdWFyZFJhbmdlLCB0aGlzLmRlY29kZVJvd1N0cmluZ0J1ZmZlcik7XG4gICAgICAgICAgICBsZXQgZW5kU3RhcnQgPSBidWRlbGxvLnJvd09mZnNldDtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBidWRlbGxvLnJlc3VsdFN0cmluZztcbiAgICAgICAgICAgIGlmIChyZXN1bHRQb2ludENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRQb2ludCA9IG5ldyBSZXN1bHRQb2ludChlbmRTdGFydCwgcm93TnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChyZXN1bHRQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5kUmFuZ2UgPSB0aGlzLmRlY29kZUVuZChyb3csIGVuZFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRQb2ludENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRQb2ludCA9IG5ldyBSZXN1bHRQb2ludCgoZW5kUmFuZ2VbMF0gKyBlbmRSYW5nZVsxXSkgLyAyLjAsIHJvd051bWJlcik7XG4gICAgICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocmVzdWx0UG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgcXVpZXQgem9uZSBhdCBsZWFzdCBhcyBiaWcgYXMgdGhlIGVuZCBwYXR0ZXJuIGFmdGVyIHRoZSBiYXJjb2RlLiBUaGVcbiAgICAgICAgICAgIC8vIHNwZWMgbWlnaHQgd2FudCBtb3JlIHdoaXRlc3BhY2UsIGJ1dCBpbiBwcmFjdGljZSB0aGlzIGlzIHRoZSBtYXhpbXVtIHdlIGNhbiBjb3VudCBvbi5cbiAgICAgICAgICAgIGxldCBlbmQgPSBlbmRSYW5nZVsxXTtcbiAgICAgICAgICAgIGxldCBxdWlldEVuZCA9IGVuZCArIChlbmQgLSBlbmRSYW5nZVswXSk7XG4gICAgICAgICAgICBpZiAocXVpZXRFbmQgPj0gcm93LmdldFNpemUoKSB8fCAhcm93LmlzUmFuZ2UoZW5kLCBxdWlldEVuZCwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBVUEMvRUFOIHNob3VsZCBuZXZlciBiZSBsZXNzIHRoYW4gOCBjaGFycyBhbnl3YXlcbiAgICAgICAgICAgIGlmIChyZXN1bHRTdHJpbmcubGVuZ3RoIDwgOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVVBDRUFOUmVhZGVyLmNoZWNrQ2hlY2tzdW0ocmVzdWx0U3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxlZnQgPSAoc3RhcnRHdWFyZFJhbmdlWzFdICsgc3RhcnRHdWFyZFJhbmdlWzBdKSAvIDIuMDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IChlbmRSYW5nZVsxXSArIGVuZFJhbmdlWzBdKSAvIDIuMDtcbiAgICAgICAgICAgIGxldCBmb3JtYXQgPSB0aGlzLmdldEJhcmNvZGVGb3JtYXQoKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRQb2ludCA9IFtuZXcgUmVzdWx0UG9pbnQobGVmdCwgcm93TnVtYmVyKSwgbmV3IFJlc3VsdFBvaW50KHJpZ2h0LCByb3dOdW1iZXIpXTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVSZXN1bHQgPSBuZXcgUmVzdWx0KHJlc3VsdFN0cmluZywgbnVsbCwgMCwgcmVzdWx0UG9pbnQsIGZvcm1hdCwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbkxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnNpb25SZXN1bHQgPSBVUENFQU5FeHRlbnNpb25TdXBwb3J0LmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZW5kUmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIGRlY29kZVJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5VUENfRUFOX0VYVEVOU0lPTiwgZXh0ZW5zaW9uUmVzdWx0LmdldFRleHQoKSk7XG4gICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0LnB1dEFsbE1ldGFkYXRhKGV4dGVuc2lvblJlc3VsdC5nZXRSZXN1bHRNZXRhZGF0YSgpKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHQuYWRkUmVzdWx0UG9pbnRzKGV4dGVuc2lvblJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uTGVuZ3RoID0gZXh0ZW5zaW9uUmVzdWx0LmdldFRleHQoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlRXJyb3IpIHt9XG4gICAgICAgICAgICBsZXQgYWxsb3dlZEV4dGVuc2lvbnMgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLkFMTE9XRURfRUFOX0VYVEVOU0lPTlMpO1xuICAgICAgICAgICAgaWYgKGFsbG93ZWRFeHRlbnNpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsZW5ndGggaW4gYWxsb3dlZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbkxlbmd0aC50b1N0cmluZygpID09PSBsZW5ndGgpIHsgLy8gY2hlY2sgbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVFbmQocm93LCBlbmRTdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKFxuICAgICAgICAgICAgICAgIHJvdywgZW5kU3RhcnQsIGZhbHNlLCBVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4sXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoVVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOLmxlbmd0aCkuZmlsbCgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNoZWNrQ2hlY2tzdW0ocykge1xuICAgICAgICAgICAgcmV0dXJuIFVQQ0VBTlJlYWRlci5jaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjaGVjayA9IHBhcnNlSW50KHMuY2hhckF0KGxlbmd0aCAtIDEpLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocy5zdWJzdHJpbmcoMCwgbGVuZ3RoIC0gMSkpID09PSBjaGVjaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bShzKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlnaXQgPCAwIHx8IGRpZ2l0ID4gOSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bSAqPSAzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgxMDAwIC0gc3VtKSAlIDEwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogPHA+SW1wbGVtZW50cyBkZWNvZGluZyBvZiB0aGUgRUFOLTEzIGZvcm1hdC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQGF1dGhvciBhbGFzZGFpckBnb29nbGUuY29tIChBbGFzZGFpciBNYWNraW50b3NoKVxuICAgICAqL1xuICAgIGNsYXNzIEVBTjEzUmVhZGVyIGV4dGVuZHMgVVBDRUFOUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IEludDMyQXJyYXkuZnJvbShbMCwgMCwgMCwgMF0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZU1pZGRsZShyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcbiAgICAgICAgICAgIGNvdW50ZXJzWzBdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcbiAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICBsZXQgbGdQYXR0ZXJuRm91bmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA2ICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IFVQQ0VBTlJlYWRlci5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VBTlJlYWRlci5MX0FORF9HX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2ggJSAxMCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgbGdQYXR0ZXJuRm91bmQgfD0gMSA8PCAoNSAtIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IEVBTjEzUmVhZGVyLmRldGVybWluZUZpcnN0RGlnaXQocmVzdWx0U3RyaW5nLCBsZ1BhdHRlcm5Gb3VuZCk7XG4gICAgICAgICAgICBsZXQgbWlkZGxlUmFuZ2UgPSBVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihcbiAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgVVBDRUFOUmVhZGVyLk1JRERMRV9QQVRURVJOLFxuICAgICAgICAgICAgICAgIG5ldyBJbnQzMkFycmF5KFVQQ0VBTlJlYWRlci5NSURETEVfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgICAgICAgICAgcm93T2Zmc2V0ID0gbWlkZGxlUmFuZ2VbMV07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgcm93T2Zmc2V0LCByZXN1bHRTdHJpbmcgfTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlRm9ybWF0KCkge1xuICAgICAgICAgICAgcmV0dXJuIEJhcmNvZGVGb3JtYXQkMS5FQU5fMTM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRldGVybWluZUZpcnN0RGlnaXQocmVzdWx0U3RyaW5nLCBsZ1BhdHRlcm5Gb3VuZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCAxMDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxnUGF0dGVybkZvdW5kID09PSB0aGlzLkZJUlNUX0RJR0lUX0VOQ09ESU5HU1tkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGQpKSArIHJlc3VsdFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFN0cmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFQU4xM1JlYWRlci5GSVJTVF9ESUdJVF9FTkNPRElOR1MgPSBbMHgwMCwgMHgwQiwgMHgwRCwgMHhFLCAweDEzLCAweDE5LCAweDFDLCAweDE1LCAweDE2LCAweDFBXTtcblxuICAgIC8qKlxuICAgICAqIDxwPkltcGxlbWVudHMgZGVjb2Rpbmcgb2YgdGhlIEVBTi04IGZvcm1hdC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEVBTjhSZWFkZXIgZXh0ZW5kcyBVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gSW50MzJBcnJheS5mcm9tKFswLCAwLCAwLCAwXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnM7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gcm93LmdldFNpemUoKTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA0ICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IFVQQ0VBTlJlYWRlci5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VBTlJlYWRlci5MX1BBVFRFUk5TKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtaWRkbGVSYW5nZSA9IFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCB0cnVlLCBVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4sIG5ldyBJbnQzMkFycmF5KFVQQ0VBTlJlYWRlci5NSURETEVfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xuICAgICAgICAgICAgcm93T2Zmc2V0ID0gbWlkZGxlUmFuZ2VbMV07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDQgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyLmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvdW50ZXIgb2YgY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgcm93T2Zmc2V0LCByZXN1bHRTdHJpbmcgfTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlRm9ybWF0KCkge1xuICAgICAgICAgICAgcmV0dXJuIEJhcmNvZGVGb3JtYXQkMS5FQU5fODtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY2Fwc3VsYXRlcyBmdW5jdGlvbmFsaXR5IGFuZCBpbXBsZW1lbnRhdGlvbiB0aGF0IGlzIGNvbW1vbiB0byBhbGwgZmFtaWxpZXNcbiAgICAgKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQGF1dGhvciBzYW0yMzMyIChTYW0gUnVkbG9mZilcbiAgICAgKlxuICAgICAqIEBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL3p4aW5nL3p4aW5nL2Jsb2IvM2M5NjkyMzI3NmRkNTc4NWQ1OGViOTcwYjZiYTNmODBkMzZhOTUwNS9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9vbmVkL1VQQ0FSZWFkZXIuamF2YVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGNsYXNzIFVQQ0FSZWFkZXIgZXh0ZW5kcyBVUENFQU5SZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmVhbjEzUmVhZGVyID0gbmV3IEVBTjEzUmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGdldEJhcmNvZGVGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdCQxLlVQQ19BO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCB0cnkgcm90YXRpb24gd2l0aG91dCB0aGUgdHJ5IGhhcmRlciBmbGFnLCBldmVuIGlmIHJvdGF0aW9uIHdhcyBzdXBwb3J0ZWQuXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXliZVJldHVyblJlc3VsdCh0aGlzLmVhbjEzUmVhZGVyLmRlY29kZShpbWFnZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXliZVJldHVyblJlc3VsdCh0aGlzLmVhbjEzUmVhZGVyLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYW4xM1JlYWRlci5kZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlLCByZXN1bHRTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIG1heWJlUmV0dXJuUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSByZXN1bHQuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgdXBjYVJlc3VsdCA9IG5ldyBSZXN1bHQodGV4dC5zdWJzdHJpbmcoMSksIG51bGwsIG51bGwsIHJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKSwgQmFyY29kZUZvcm1hdCQxLlVQQ19BKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB1cGNhUmVzdWx0LnB1dEFsbE1ldGFkYXRhKHJlc3VsdC5nZXRSZXN1bHRNZXRhZGF0YSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwY2FSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFuMTNSZWFkZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkltcGxlbWVudHMgZGVjb2Rpbmcgb2YgdGhlIFVQQy1FIGZvcm1hdC48L3A+XG4gICAgICogPHA+PGEgaHJlZj1cImh0dHA6Ly93d3cuYmFyY29kZWlzbGFuZC5jb20vdXBjZS5waHRtbFwiPlRoaXM8L2E+IGlzIGEgZ3JlYXQgcmVmZXJlbmNlIGZvclxuICAgICAqIFVQQy1FIGluZm9ybWF0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICpcbiAgICAgKiBAc291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iLzNjOTY5MjMyNzZkZDU3ODVkNThlYjk3MGI2YmEzZjgwZDM2YTk1MDUvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvb25lZC9VUENFUmVhZGVyLmphdmFcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICAvKiBmaW5hbCAqLyBjbGFzcyBVUENFUmVhZGVyIGV4dGVuZHMgVVBDRUFOUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KDQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlTWlkZGxlKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMubWFwKHggPT4geCk7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XG4gICAgICAgICAgICBsZXQgbGdQYXR0ZXJuRm91bmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA2ICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmVzdE1hdGNoID0gVVBDRVJlYWRlci5kZWNvZGVEaWdpdChcbiAgICAgICAgICAgICAgICAgICAgcm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIChiZXN0TWF0Y2ggJSAxMCkpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb3VudGVyIG9mIGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxnUGF0dGVybkZvdW5kIHw9ICgxIDw8ICg1IC0geCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHRTdHJpbmcgPSBVUENFUmVhZGVyLmRldGVybWluZU51bVN5c0FuZENoZWNrRGlnaXQoXG4gICAgICAgICAgICAgICAgcmVzdWx0LCBsZ1BhdHRlcm5Gb3VuZCk7XG4gICAgICAgICAgICByZXR1cm4ge3Jvd09mZnNldCwgcmVzdWx0U3RyaW5nfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZUVuZChyb3csIGVuZFN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gVVBDRVJlYWRlci5maW5kR3VhcmRQYXR0ZXJuV2l0aG91dENvdW50ZXJzKFxuICAgICAgICAgICAgICAgIHJvdywgZW5kU3RhcnQsIHRydWUsIFVQQ0VSZWFkZXIuTUlERExFX0VORF9QQVRURVJOKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBjaGVja0NoZWNrc3VtKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuY2hlY2tDaGVja3N1bShVUENFUmVhZGVyLmNvbnZlcnRVUENFdG9VUENBKHMpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRldGVybWluZU51bVN5c0FuZENoZWNrRGlnaXQocmVzdWx0U3RyaW5nLCBsZ1BhdHRlcm5Gb3VuZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgbnVtU3lzID0gMDsgbnVtU3lzIDw9IDE7IG51bVN5cysrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCAxMDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZ1BhdHRlcm5Gb3VuZCA9PT0gdGhpcy5OVU1TWVNfQU5EX0NIRUNLX0RJR0lUX1BBVFRFUk5TW251bVN5c11bZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmVmaXggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCcwJy5jaGFyQ29kZUF0KDApICsgbnVtU3lzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCcwJy5jaGFyQ29kZUF0KDApICsgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgcmVzdWx0U3RyaW5nICsgc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb24uZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBnZXRCYXJjb2RlRm9ybWF0KCkge1xuICAgICAgICAgICAgcmV0dXJuIEJhcmNvZGVGb3JtYXQkMS5VUENfRTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwYW5kcyBhIFVQQy1FIHZhbHVlIGJhY2sgaW50byBpdHMgZnVsbCwgZXF1aXZhbGVudCBVUEMtQSBjb2RlIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXBjZSBVUEMtRSBjb2RlIGFzIHN0cmluZyBvZiBkaWdpdHNcbiAgICAgICAgICogQHJldHVybiBlcXVpdmFsZW50IFVQQy1BIGNvZGUgYXMgc3RyaW5nIG9mIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvbnZlcnRVUENFdG9VUENBKHVwY2UpIHtcbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgbGluZSBpcyBlcXVpdmFsZW50IHRvIHVwY2UuZ2V0Q2hhcnMoMSwgNywgdXBjZUNoYXJzLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHVwY2VDaGFycyA9IHVwY2Uuc2xpY2UoMSwgNykuc3BsaXQoJycpLm1hcCh4ID0+IHguY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlciggLyoxMiovKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodXBjZS5jaGFyQXQoMCkpO1xuICAgICAgICAgICAgbGV0IGxhc3RDaGFyID0gdXBjZUNoYXJzWzVdO1xuICAgICAgICAgICAgc3dpdGNoIChsYXN0Q2hhcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hhcnModXBjZUNoYXJzLCAwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChsYXN0Q2hhcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMiwgMyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoYXJzKHVwY2VDaGFycywgMCwgMyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJzAwMDAwJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDMsIDIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDAsIDQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcwMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHVwY2VDaGFyc1s0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRDaGFycyh1cGNlQ2hhcnMsIDAsIDUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcwMDAwJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQobGFzdENoYXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIGNoZWNrIGRpZ2l0IGluIGNvbnZlcnNpb24gaWYgc3VwcGxpZWRcbiAgICAgICAgICAgIGlmICh1cGNlLmxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh1cGNlLmNoYXJBdCg3KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHBhdHRlcm4gdGhhdCBtYXJrcyB0aGUgbWlkZGxlLCBhbmQgZW5kLCBvZiBhIFVQQy1FIHBhdHRlcm4uXG4gICAgICogVGhlcmUgaXMgbm8gXCJzZWNvbmQgaGFsZlwiIHRvIGEgVVBDLUUgYmFyY29kZS5cbiAgICAgKi9cbiAgICBVUENFUmVhZGVyLk1JRERMRV9FTkRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMSwgMV0pO1xuICAgIC8vIEZvciBhbiBVUEMtRSBiYXJjb2RlLCB0aGUgZmluYWwgZGlnaXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIHBhcml0aWVzIHVzZWRcbiAgICAvLyB0byBlbmNvZGUgdGhlIG1pZGRsZSBzaXggZGlnaXRzLCBhY2NvcmRpbmcgdG8gdGhlIHRhYmxlIGJlbG93LlxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgICAgUGFyaXR5IG9mIG5leHQgNiBkaWdpdHNcbiAgICAvLyAgICBEaWdpdCAgIDAgICAgIDEgICAgIDIgICAgIDMgICAgIDQgICAgIDVcbiAgICAvLyAgICAgICAwICAgIEV2ZW4gICBFdmVuICBFdmVuIE9kZCAgT2RkICAgT2RkXG4gICAgLy8gICAgICAgMSAgICBFdmVuICAgRXZlbiAgT2RkICBFdmVuIE9kZCAgIE9kZFxuICAgIC8vICAgICAgIDIgICAgRXZlbiAgIEV2ZW4gIE9kZCAgT2RkICBFdmVuICBPZGRcbiAgICAvLyAgICAgICAzICAgIEV2ZW4gICBFdmVuICBPZGQgIE9kZCAgT2RkICAgRXZlblxuICAgIC8vICAgICAgIDQgICAgRXZlbiAgIE9kZCAgIEV2ZW4gRXZlbiBPZGQgICBPZGRcbiAgICAvLyAgICAgICA1ICAgIEV2ZW4gICBPZGQgICBPZGQgIEV2ZW4gRXZlbiAgT2RkXG4gICAgLy8gICAgICAgNiAgICBFdmVuICAgT2RkICAgT2RkICBPZGQgIEV2ZW4gIEV2ZW5cbiAgICAvLyAgICAgICA3ICAgIEV2ZW4gICBPZGQgICBFdmVuIE9kZCAgRXZlbiAgT2RkXG4gICAgLy8gICAgICAgOCAgICBFdmVuICAgT2RkICAgRXZlbiBPZGQgIE9kZCAgIEV2ZW5cbiAgICAvLyAgICAgICA5ICAgIEV2ZW4gICBPZGQgICBPZGQgIEV2ZW4gT2RkICAgRXZlblxuICAgIC8vXG4gICAgLy8gVGhlIGVuY29kaW5nIGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBmb2xsb3dpbmcgYXJyYXksIHdoaWNoIGlzIGEgYml0IHBhdHRlcm5cbiAgICAvLyB1c2luZyBPZGQgPSAwIGFuZCBFdmVuID0gMS4gRm9yIGV4YW1wbGUsIDUgaXMgcmVwcmVzZW50ZWQgYnk6XG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgT2RkIEV2ZW4gRXZlbiBPZGQgT2RkIEV2ZW5cbiAgICAvLyBpbiBiaW5hcnk6XG4gICAgLy8gICAgICAgICAgICAgICAgMCAgICAxICAgIDEgICAwICAgMCAgICAxICAgPT0gMHgxOVxuICAgIC8vXG4gICAgLyoqXG4gICAgICogU2VlIHtAbGluayAjTF9BTkRfR19QQVRURVJOU307IHRoZXNlIHZhbHVlcyBzaW1pbGFybHkgcmVwcmVzZW50IHBhdHRlcm5zIG9mXG4gICAgICogZXZlbi1vZGQgcGFyaXR5IGVuY29kaW5ncyBvZiBkaWdpdHMgdGhhdCBpbXBseSBib3RoIHRoZSBudW1iZXIgc3lzdGVtICgwIG9yIDEpXG4gICAgICogdXNlZCwgYW5kIHRoZSBjaGVjayBkaWdpdC5cbiAgICAgKi9cbiAgICBVUENFUmVhZGVyLk5VTVNZU19BTkRfQ0hFQ0tfRElHSVRfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzOCwgMHgzNCwgMHgzMiwgMHgzMSwgMHgyQywgMHgyNiwgMHgyMywgMHgyQSwgMHgyOSwgMHgyNV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDcsIDB4MEIsIDB4MEQsIDB4MEUsIDB4MTMsIDB4MTksIDB4MUMsIDB4MTUsIDB4MTYsIDB4MUFdKSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogPHA+QSByZWFkZXIgdGhhdCBjYW4gcmVhZCBhbGwgYXZhaWxhYmxlIFVQQy9FQU4gZm9ybWF0cy4gSWYgYSBjYWxsZXIgd2FudHMgdG8gdHJ5IHRvXG4gICAgICogcmVhZCBhbGwgc3VjaCBmb3JtYXRzLCBpdCBpcyBtb3N0IGVmZmljaWVudCB0byB1c2UgdGhpcyBpbXBsZW1lbnRhdGlvbiByYXRoZXIgdGhhbiBpbnZva2VcbiAgICAgKiBpbmRpdmlkdWFsIHJlYWRlcnMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlciBleHRlbmRzIE9uZURSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihoaW50cykge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIGxldCBwb3NzaWJsZUZvcm1hdHMgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlBPU1NJQkxFX0ZPUk1BVFMpO1xuICAgICAgICAgICAgbGV0IHJlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQocG9zc2libGVGb3JtYXRzKSkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5kZXhPZihCYXJjb2RlRm9ybWF0JDEuRUFOXzEzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRUFOMTNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5kZXhPZihCYXJjb2RlRm9ybWF0JDEuVVBDX0EpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBVUENBUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluZGV4T2YoQmFyY29kZUZvcm1hdCQxLkVBTl84KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRUFOOFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXQkMS5VUENfRSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFVQQ0VSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBoaW50cyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEVBTjEzUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgVVBDQVJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEVBTjhSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBVUENFUmVhZGVyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXJzID0gcmVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByZWFkZXIgb2YgdGhpcy5yZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgcmVzdWx0OiBSZXN1bHQgPSByZWFkZXIuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBzdGFydEd1YXJkUGF0dGVybiwgaGludHMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkZXIuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogYSAxMi1kaWdpdCBjb2RlIGVuY29kZWQgaW4gVVBDLUEgaXMgaWRlbnRpY2FsIHRvIGEgXCIwXCJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhvc2UgMTIgZGlnaXRzIGVuY29kZWQgYXMgRUFOLTEzLiBFYWNoIHdpbGwgcmVjb2duaXplIHN1Y2ggYSBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAvLyBVUEMtQSBhcyBhIDEyLWRpZ2l0IHN0cmluZyBhbmQgRUFOLTEzIGFzIGEgMTMtZGlnaXQgc3RyaW5nIHN0YXJ0aW5nIHdpdGggXCIwXCIuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGl2aWR1YWxseSB0aGVzZSBhcmUgY29ycmVjdCBhbmQgdGhlaXIgcmVhZGVycyB3aWxsIGJvdGggcmVhZCBzdWNoIGEgY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY29ycmVjdGx5IGNhbGwgaXQgRUFOLTEzLCBvciBVUEMtQSwgcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGlmIHdlJ3ZlIGJlZW4gbG9va2luZyBmb3IgYm90aCB0eXBlcywgd2UnZCBsaWtlIHRvIGNhbGwgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBVUEMtQSBjb2RlLiBCdXQgZm9yIGVmZmljaWVuY3kgd2Ugb25seSBydW4gdGhlIEVBTi0xMyBkZWNvZGVyIHRvIGFsc28gcmVhZFxuICAgICAgICAgICAgICAgICAgICAvLyBVUEMtQS4gU28gd2Ugc3BlY2lhbCBjYXNlIGl0IGhlcmUsIGFuZCBjb252ZXJ0IGFuIEVBTi0xMyByZXN1bHQgdG8gYSBVUEMtQVxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCwgZG9uJ3QgcmV0dXJuIFVQQy1BIGlmIFVQQy1BIHdhcyBub3QgYSByZXF1ZXN0ZWQgZm9ybWF0IVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlYW4xM01heUJlVVBDQSA9IHJlc3VsdC5nZXRCYXJjb2RlRm9ybWF0KCkgPT09IEJhcmNvZGVGb3JtYXQkMS5FQU5fMTMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRUZXh0KCkuY2hhckF0KDApID09PSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBTdXBwcmVzc1dhcm5pbmdzKFwidW5jaGVja2VkXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlRm9ybWF0cyA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuUE9TU0lCTEVfRk9STUFUUyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhblJldHVyblVQQ0EgPSBwb3NzaWJsZUZvcm1hdHMgPT0gbnVsbCB8fCBwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdCQxLlVQQ19BKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVhbjEzTWF5QmVVUENBICYmIGNhblJldHVyblVQQ0EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0J5dGVzID0gcmVzdWx0LmdldFJhd0J5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2ZlciB0aGUgbWV0YWRhdGEgYWNyb3NzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRVUENBID0gbmV3IFJlc3VsdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ2V0VGV4dCgpLnN1YnN0cmluZygxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdCeXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmF3Qnl0ZXMgPyByYXdCeXRlcy5sZW5ndGggOiBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ2V0UmVzdWx0UG9pbnRzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQmFyY29kZUZvcm1hdCQxLlVQQ19BKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFVQQ0EucHV0QWxsTWV0YWRhdGEocmVzdWx0LmdldFJlc3VsdE1ldGFkYXRhKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFVQQ0E7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlYWRlciBvZiB0aGlzLnJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGltcG9ydCBJbnRlZ2VyIGZyb20gJy4uLy4uL3V0aWwvSW50ZWdlcic7XG4gICAgLy8gaW1wb3J0IEZsb2F0IGZyb20gJy4uLy4uL3V0aWwvRmxvYXQnO1xuICAgIGNsYXNzIEFic3RyYWN0UlNTUmVhZGVyIGV4dGVuZHMgT25lRFJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlRmluZGVyQ291bnRlcnMgPSBuZXcgSW50MzJBcnJheSg0KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzID0gbmV3IEludDMyQXJyYXkoOCk7XG4gICAgICAgICAgICB0aGlzLm9kZFJvdW5kaW5nRXJyb3JzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAgICAgdGhpcy5ldmVuUm91bmRpbmdFcnJvcnMgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICB0aGlzLm9kZENvdW50cyA9IG5ldyBBcnJheSh0aGlzLmRhdGFDaGFyYWN0ZXJDb3VudGVycy5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbkNvdW50cyA9IG5ldyBBcnJheSh0aGlzLmRhdGFDaGFyYWN0ZXJDb3VudGVycy5sZW5ndGggLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBnZXREZWNvZGVGaW5kZXJDb3VudGVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZpbmRlckNvdW50ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGdldERhdGFDaGFyYWN0ZXJDb3VudGVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDaGFyYWN0ZXJDb3VudGVycztcbiAgICAgICAgfVxuICAgICAgICBnZXRPZGRSb3VuZGluZ0Vycm9ycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9kZFJvdW5kaW5nRXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIGdldEV2ZW5Sb3VuZGluZ0Vycm9ycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW5Sb3VuZGluZ0Vycm9ycztcbiAgICAgICAgfVxuICAgICAgICBnZXRPZGRDb3VudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZGRDb3VudHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXZlbkNvdW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW5Db3VudHM7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VGaW5kZXJWYWx1ZShjb3VudGVycywgZmluZGVyUGF0dGVybnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlID0gMDsgdmFsdWUgPCBmaW5kZXJQYXR0ZXJucy5sZW5ndGg7IHZhbHVlKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoT25lRFJlYWRlci5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgZmluZGVyUGF0dGVybnNbdmFsdWVdLCBBYnN0cmFjdFJTU1JlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBBYnN0cmFjdFJTU1JlYWRlci5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFycmF5IHZhbHVlcyB0byBzdW1cbiAgICAgICAgICogQHJldHVybiBzdW0gb2YgdmFsdWVzXG4gICAgICAgICAqIEBkZXByZWNhdGVkIGNhbGwge0BsaW5rIE1hdGhVdGlscyNzdW0oaW50W10pfVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGNvdW50KGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheShhcnJheSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpbmNyZW1lbnQoYXJyYXksIGVycm9ycykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yc1tpXSA+IGJpZ2dlc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnJheVtpbmRleF0rKztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjcmVtZW50KGFycmF5LCBlcnJvcnMpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgYmlnZ2VzdEVycm9yID0gZXJyb3JzWzBdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnNbaV0gPCBiaWdnZXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYmlnZ2VzdEVycm9yID0gZXJyb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlbaW5kZXhdLS07XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzRmluZGVyUGF0dGVybihjb3VudGVycykge1xuICAgICAgICAgICAgbGV0IGZpcnN0VHdvU3VtID0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcbiAgICAgICAgICAgIGxldCBzdW0gPSBmaXJzdFR3b1N1bSArIGNvdW50ZXJzWzJdICsgY291bnRlcnNbM107XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSBmaXJzdFR3b1N1bSAvIHN1bTtcbiAgICAgICAgICAgIGlmIChyYXRpbyA+PSBBYnN0cmFjdFJTU1JlYWRlci5NSU5fRklOREVSX1BBVFRFUk5fUkFUSU8gJiYgcmF0aW8gPD0gQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0ZJTkRFUl9QQVRURVJOX1JBVElPKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFzc2VzIHJhdGlvIHRlc3QgaW4gc3BlYywgYnV0IHNlZSBpZiB0aGUgY291bnRzIGFyZSB1bnJlYXNvbmFibGVcbiAgICAgICAgICAgICAgICBsZXQgbWluQ291bnRlciA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIGxldCBtYXhDb3VudGVyID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnRlciBvZiBjb3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heENvdW50ZXIgPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluQ291bnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ291bnRlciA9IGNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heENvdW50ZXIgPCAxMCAqIG1pbkNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSA9IDAuMjtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNDU7XG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuTUlOX0ZJTkRFUl9QQVRURVJOX1JBVElPID0gOS41IC8gMTIuMDtcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NQVhfRklOREVSX1BBVFRFUk5fUkFUSU8gPSAxMi41IC8gMTQuMDtcblxuICAgIGNsYXNzIERhdGFDaGFyYWN0ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hlY2tzdW1Qb3J0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNoZWNrc3VtUG9ydGlvbiA9IGNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldENoZWNrc3VtUG9ydGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlICsgJygnICsgdGhpcy5jaGVja3N1bVBvcnRpb24gKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBEYXRhQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoYXQudmFsdWUgJiYgdGhpcy5jaGVja3N1bVBvcnRpb24gPT09IHRoYXQuY2hlY2tzdW1Qb3J0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGhhc2hDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgXiB0aGlzLmNoZWNrc3VtUG9ydGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEZpbmRlclBhdHRlcm4ge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc3RhcnRFbmQsIHN0YXJ0LCBlbmQsIHJvd051bWJlcikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdGFydEVuZCA9IHN0YXJ0RW5kO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdGFydEVuZCA9IHN0YXJ0RW5kO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzLnB1c2gobmV3IFJlc3VsdFBvaW50KHN0YXJ0LCByb3dOdW1iZXIpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzLnB1c2gobmV3IFJlc3VsdFBvaW50KGVuZCwgcm93TnVtYmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRTdGFydEVuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0RW5kO1xuICAgICAgICB9XG4gICAgICAgIGdldFJlc3VsdFBvaW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFBvaW50cztcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEZpbmRlclBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhhdCA9IG87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdGhhdC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUlNTIHV0aWwgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFJTU1V0aWxzIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgc3RhdGljIGdldFJTU3ZhbHVlKHdpZHRocywgbWF4V2lkdGgsIG5vTmFycm93KSB7XG4gICAgICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aWR0aCBvZiB3aWR0aHMpIHtcbiAgICAgICAgICAgICAgICBuICs9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbCA9IDA7XG4gICAgICAgICAgICBsZXQgbmFycm93TWFzayA9IDA7XG4gICAgICAgICAgICBsZXQgZWxlbWVudHMgPSB3aWR0aHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgYmFyID0gMDsgYmFyIDwgZWxlbWVudHMgLSAxOyBiYXIrKykge1xuICAgICAgICAgICAgICAgIGxldCBlbG1XaWR0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGVsbVdpZHRoID0gMSwgbmFycm93TWFzayB8PSAxIDw8IGJhcjsgZWxtV2lkdGggPCB3aWR0aHNbYmFyXTsgZWxtV2lkdGgrKywgbmFycm93TWFzayAmPSB+KDEgPDwgYmFyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3ViVmFsID0gUlNTVXRpbHMuY29tYmlucyhuIC0gZWxtV2lkdGggLSAxLCBlbGVtZW50cyAtIGJhciAtIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9OYXJyb3cgJiYgKG5hcnJvd01hc2sgPT09IDApICYmIChuIC0gZWxtV2lkdGggLSAoZWxlbWVudHMgLSBiYXIgLSAxKSA+PSBlbGVtZW50cyAtIGJhciAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJWYWwgLT0gUlNTVXRpbHMuY29tYmlucyhuIC0gZWxtV2lkdGggLSAoZWxlbWVudHMgLSBiYXIpLCBlbGVtZW50cyAtIGJhciAtIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cyAtIGJhciAtIDEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGVzc1ZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBteHdFbGVtZW50ID0gbiAtIGVsbVdpZHRoIC0gKGVsZW1lbnRzIC0gYmFyIC0gMik7IG14d0VsZW1lbnQgPiBtYXhXaWR0aDsgbXh3RWxlbWVudC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVzc1ZhbCArPSBSU1NVdGlscy5jb21iaW5zKG4gLSBlbG1XaWR0aCAtIG14d0VsZW1lbnQgLSAxLCBlbGVtZW50cyAtIGJhciAtIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViVmFsIC09IGxlc3NWYWwgKiAoZWxlbWVudHMgLSAxIC0gYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuIC0gZWxtV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViVmFsLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IHN1YlZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbiAtPSBlbG1XaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNvbWJpbnMobiwgcikge1xuICAgICAgICAgICAgbGV0IG1heERlbm9tO1xuICAgICAgICAgICAgbGV0IG1pbkRlbm9tO1xuICAgICAgICAgICAgaWYgKG4gLSByID4gcikge1xuICAgICAgICAgICAgICAgIG1pbkRlbm9tID0gcjtcbiAgICAgICAgICAgICAgICBtYXhEZW5vbSA9IG4gLSByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluRGVub20gPSBuIC0gcjtcbiAgICAgICAgICAgICAgICBtYXhEZW5vbSA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsID0gMTtcbiAgICAgICAgICAgIGxldCBqID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBuOyBpID4gbWF4RGVub207IGktLSkge1xuICAgICAgICAgICAgICAgIHZhbCAqPSBpO1xuICAgICAgICAgICAgICAgIGlmIChqIDw9IG1pbkRlbm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCAvPSBqO1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKChqIDw9IG1pbkRlbm9tKSkge1xuICAgICAgICAgICAgICAgIHZhbCAvPSBqO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBCaXRBcnJheUJ1aWxkZXIge1xuICAgICAgICBzdGF0aWMgYnVpbGRCaXRBcnJheShwYWlycykge1xuICAgICAgICAgICAgbGV0IGNoYXJOdW1iZXIgPSAocGFpcnMubGVuZ3RoICogMikgLSAxO1xuICAgICAgICAgICAgaWYgKHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdLmdldFJpZ2h0Q2hhcigpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFyTnVtYmVyIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IDEyICogY2hhck51bWJlcjtcbiAgICAgICAgICAgIGxldCBiaW5hcnkgPSBuZXcgQml0QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBsZXQgYWNjUG9zID0gMDtcbiAgICAgICAgICAgIGxldCBmaXJzdFBhaXIgPSBwYWlyc1swXTtcbiAgICAgICAgICAgIGxldCBmaXJzdFZhbHVlID0gZmlyc3RQYWlyLmdldFJpZ2h0Q2hhcigpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgaWYgKChmaXJzdFZhbHVlICYgKDEgPDwgaSkpICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5LnNldChhY2NQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2NQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFpcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdFZhbHVlID0gY3VycmVudFBhaXIuZ2V0TGVmdENoYXIoKS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAxMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChsZWZ0VmFsdWUgJiAoMSA8PCBqKSkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5LnNldChhY2NQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjY1BvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhaXIuZ2V0UmlnaHRDaGFyKCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRWYWx1ZSA9IGN1cnJlbnRQYWlyLmdldFJpZ2h0Q2hhcigpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAxMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmlnaHRWYWx1ZSAmICgxIDw8IGopKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5LnNldChhY2NQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjUG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmluYXJ5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQmxvY2tQYXJzZWRSZXN1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihmaW5pc2hlZCwgZGVjb2RlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVkSW5mb3JtYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlZEluZm9ybWF0aW9uID0gZGVjb2RlZEluZm9ybWF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldERlY29kZWRJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZWRJbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpc0ZpbmlzaGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBEZWNvZGVkT2JqZWN0IHtcbiAgICAgICAgY29uc3RydWN0b3IobmV3UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubmV3UG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBnZXROZXdQb3NpdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRGVjb2RlZENoYXIgZXh0ZW5kcyBEZWNvZGVkT2JqZWN0IHtcbiAgICAgICAgY29uc3RydWN0b3IobmV3UG9zaXRpb24sIHZhbHVlKSB7XG4gICAgICAgICAgICBzdXBlcihuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpc0ZOQzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gRGVjb2RlZENoYXIuRk5DMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWNvZGVkQ2hhci5GTkMxID0gJyQnO1xuXG4gICAgY2xhc3MgRGVjb2RlZEluZm9ybWF0aW9uIGV4dGVuZHMgRGVjb2RlZE9iamVjdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG5ld1Bvc2l0aW9uLCBuZXdTdHJpbmcsIHJlbWFpbmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICBzdXBlcihuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdWYWx1ZSA9IHRoaXMucmVtYWluaW5nVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtYWluaW5nVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXdTdHJpbmcgPSBuZXdTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmV3U3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3U3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlzUmVtYWluaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgICAgIGdldFJlbWFpbmluZ1ZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBEZWNvZGVkTnVtZXJpYyBleHRlbmRzIERlY29kZWRPYmplY3Qge1xuICAgICAgICBjb25zdHJ1Y3RvcihuZXdQb3NpdGlvbiwgZmlyc3REaWdpdCwgc2Vjb25kRGlnaXQpIHtcbiAgICAgICAgICAgIHN1cGVyKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChmaXJzdERpZ2l0IDwgMCB8fCBmaXJzdERpZ2l0ID4gMTAgfHwgc2Vjb25kRGlnaXQgPCAwIHx8IHNlY29uZERpZ2l0ID4gMTApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpcnN0RGlnaXQgPSBmaXJzdERpZ2l0O1xuICAgICAgICAgICAgdGhpcy5zZWNvbmREaWdpdCA9IHNlY29uZERpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIGdldEZpcnN0RGlnaXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIGdldFNlY29uZERpZ2l0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kRGlnaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0ICogMTAgKyB0aGlzLnNlY29uZERpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIGlzRmlyc3REaWdpdEZOQzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0ID09PSBEZWNvZGVkTnVtZXJpYy5GTkMxO1xuICAgICAgICB9XG4gICAgICAgIGlzU2Vjb25kRGlnaXRGTkMxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kRGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzE7XG4gICAgICAgIH1cbiAgICAgICAgaXNBbnlGTkMxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3REaWdpdCA9PT0gRGVjb2RlZE51bWVyaWMuRk5DMSB8fCB0aGlzLnNlY29uZERpZ2l0ID09PSBEZWNvZGVkTnVtZXJpYy5GTkMxO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlY29kZWROdW1lcmljLkZOQzEgPSAxMDtcblxuICAgIGNsYXNzIEZpZWxkUGFyc2VyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhcnNlRmllbGRzSW5HZW5lcmFsUHVycG9zZShyYXdJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgaWYgKCFyYXdJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvY2Vzc2luZyAyLWRpZ2l0IEFJc1xuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXJzdFR3b0RpZ2l0cyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZygwLCAyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFMZW5ndGggb2YgRmllbGRQYXJzZXIuVFdPX0RJR0lUX0RBVEFfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0VHdvRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzFdID09PSBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzVmFyaWFibGVBSSgyLCBkYXRhTGVuZ3RoWzJdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NGaXhlZEFJKDIsIGRhdGFMZW5ndGhbMV0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpcnN0VGhyZWVEaWdpdHMgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgMyk7XG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhTGVuZ3RoIG9mIEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX0RBVEFfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0VGhyZWVEaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDMsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoMywgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFMZW5ndGggb2YgRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfUExVU19ESUdJVF9EQVRBX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzBdID09PSBmaXJzdFRocmVlRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzFdID09PSBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzVmFyaWFibGVBSSg0LCBkYXRhTGVuZ3RoWzJdLCByYXdJbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NGaXhlZEFJKDQsIGRhdGFMZW5ndGhbMV0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpcnN0Rm91ckRpZ2l0cyA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZygwLCA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFMZW5ndGggb2YgRmllbGRQYXJzZXIuRk9VUl9ESUdJVF9EQVRBX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzBdID09PSBmaXJzdEZvdXJEaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDQsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoNCwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwcm9jZXNzRml4ZWRBSShhaVNpemUsIGZpZWxkU2l6ZSwgcmF3SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCBhaVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhaSA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZygwLCBhaVNpemUpO1xuICAgICAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSArIGZpZWxkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpZWxkID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKGFpU2l6ZSwgYWlTaXplICsgZmllbGRTaXplKTtcbiAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoYWlTaXplICsgZmllbGRTaXplKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAnKCcgKyBhaSArICcpJyArIGZpZWxkO1xuICAgICAgICAgICAgbGV0IHBhcnNlZEFJID0gRmllbGRQYXJzZXIucGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlKHJlbWFpbmluZyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkQUkgPT0gbnVsbCA/IHJlc3VsdCA6IHJlc3VsdCArIHBhcnNlZEFJO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwcm9jZXNzVmFyaWFibGVBSShhaVNpemUsIHZhcmlhYmxlRmllbGRTaXplLCByYXdJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgbGV0IGFpID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIGFpU2l6ZSk7XG4gICAgICAgICAgICBsZXQgbWF4U2l6ZTtcbiAgICAgICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCBhaVNpemUgKyB2YXJpYWJsZUZpZWxkU2l6ZSkge1xuICAgICAgICAgICAgICAgIG1heFNpemUgPSByYXdJbmZvcm1hdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhTaXplID0gYWlTaXplICsgdmFyaWFibGVGaWVsZFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmllbGQgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoYWlTaXplLCBtYXhTaXplKTtcbiAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcobWF4U2l6ZSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJygnICsgYWkgKyAnKScgKyBmaWVsZDtcbiAgICAgICAgICAgIGxldCBwYXJzZWRBSSA9IEZpZWxkUGFyc2VyLnBhcnNlRmllbGRzSW5HZW5lcmFsUHVycG9zZShyZW1haW5pbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEFJID09IG51bGwgPyByZXN1bHQgOiByZXN1bHQgKyBwYXJzZWRBSTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEggPSBbXTtcbiAgICBGaWVsZFBhcnNlci5UV09fRElHSVRfREFUQV9MRU5HVEggPSBbXG4gICAgICAgIFsnMDAnLCAxOF0sXG4gICAgICAgIFsnMDEnLCAxNF0sXG4gICAgICAgIFsnMDInLCAxNF0sXG4gICAgICAgIFsnMTAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcbiAgICAgICAgWycxMScsIDZdLFxuICAgICAgICBbJzEyJywgNl0sXG4gICAgICAgIFsnMTMnLCA2XSxcbiAgICAgICAgWycxNScsIDZdLFxuICAgICAgICBbJzE3JywgNl0sXG4gICAgICAgIFsnMjAnLCAyXSxcbiAgICAgICAgWycyMScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxuICAgICAgICBbJzIyJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyOV0sXG4gICAgICAgIFsnMzAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDhdLFxuICAgICAgICBbJzM3JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCA4XSxcbiAgICAgICAgLy8gaW50ZXJuYWwgY29tcGFueSBjb2Rlc1xuICAgICAgICBbJzkwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTEnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5MicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzkzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTQnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc5NScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzk2JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTcnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDNdLFxuICAgICAgICBbJzk4JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnOTknLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICBdO1xuICAgIEZpZWxkUGFyc2VyLlRIUkVFX0RJR0lUX0RBVEFfTEVOR1RIID0gW1xuICAgICAgICAvLyBTYW1lIGZvcm1hdCBhcyBhYm92ZVxuICAgICAgICBbJzI0MCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzI0MScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzI0MicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgNl0sXG4gICAgICAgIFsnMjUwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjUxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnMjUzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxN10sXG4gICAgICAgIFsnMjU0JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnNDAwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnNDAxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnNDAyJywgMTddLFxuICAgICAgICBbJzQwMycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzQxMCcsIDEzXSxcbiAgICAgICAgWyc0MTEnLCAxM10sXG4gICAgICAgIFsnNDEyJywgMTNdLFxuICAgICAgICBbJzQxMycsIDEzXSxcbiAgICAgICAgWyc0MTQnLCAxM10sXG4gICAgICAgIFsnNDIwJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAyMF0sXG4gICAgICAgIFsnNDIxJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnNDIyJywgM10sXG4gICAgICAgIFsnNDIzJywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXG4gICAgICAgIFsnNDI0JywgM10sXG4gICAgICAgIFsnNDI1JywgM10sXG4gICAgICAgIFsnNDI2JywgM10sXG4gICAgXTtcbiAgICBGaWVsZFBhcnNlci5USFJFRV9ESUdJVF9QTFVTX0RJR0lUX0RBVEFfTEVOR1RIID0gW1xuICAgICAgICAvLyBTYW1lIGZvcm1hdCBhcyBhYm92ZVxuICAgICAgICBbJzMxMCcsIDZdLFxuICAgICAgICBbJzMxMScsIDZdLFxuICAgICAgICBbJzMxMicsIDZdLFxuICAgICAgICBbJzMxMycsIDZdLFxuICAgICAgICBbJzMxNCcsIDZdLFxuICAgICAgICBbJzMxNScsIDZdLFxuICAgICAgICBbJzMxNicsIDZdLFxuICAgICAgICBbJzMyMCcsIDZdLFxuICAgICAgICBbJzMyMScsIDZdLFxuICAgICAgICBbJzMyMicsIDZdLFxuICAgICAgICBbJzMyMycsIDZdLFxuICAgICAgICBbJzMyNCcsIDZdLFxuICAgICAgICBbJzMyNScsIDZdLFxuICAgICAgICBbJzMyNicsIDZdLFxuICAgICAgICBbJzMyNycsIDZdLFxuICAgICAgICBbJzMyOCcsIDZdLFxuICAgICAgICBbJzMyOScsIDZdLFxuICAgICAgICBbJzMzMCcsIDZdLFxuICAgICAgICBbJzMzMScsIDZdLFxuICAgICAgICBbJzMzMicsIDZdLFxuICAgICAgICBbJzMzMycsIDZdLFxuICAgICAgICBbJzMzNCcsIDZdLFxuICAgICAgICBbJzMzNScsIDZdLFxuICAgICAgICBbJzMzNicsIDZdLFxuICAgICAgICBbJzM0MCcsIDZdLFxuICAgICAgICBbJzM0MScsIDZdLFxuICAgICAgICBbJzM0MicsIDZdLFxuICAgICAgICBbJzM0MycsIDZdLFxuICAgICAgICBbJzM0NCcsIDZdLFxuICAgICAgICBbJzM0NScsIDZdLFxuICAgICAgICBbJzM0NicsIDZdLFxuICAgICAgICBbJzM0NycsIDZdLFxuICAgICAgICBbJzM0OCcsIDZdLFxuICAgICAgICBbJzM0OScsIDZdLFxuICAgICAgICBbJzM1MCcsIDZdLFxuICAgICAgICBbJzM1MScsIDZdLFxuICAgICAgICBbJzM1MicsIDZdLFxuICAgICAgICBbJzM1MycsIDZdLFxuICAgICAgICBbJzM1NCcsIDZdLFxuICAgICAgICBbJzM1NScsIDZdLFxuICAgICAgICBbJzM1NicsIDZdLFxuICAgICAgICBbJzM1NycsIDZdLFxuICAgICAgICBbJzM2MCcsIDZdLFxuICAgICAgICBbJzM2MScsIDZdLFxuICAgICAgICBbJzM2MicsIDZdLFxuICAgICAgICBbJzM2MycsIDZdLFxuICAgICAgICBbJzM2NCcsIDZdLFxuICAgICAgICBbJzM2NScsIDZdLFxuICAgICAgICBbJzM2NicsIDZdLFxuICAgICAgICBbJzM2NycsIDZdLFxuICAgICAgICBbJzM2OCcsIDZdLFxuICAgICAgICBbJzM2OScsIDZdLFxuICAgICAgICBbJzM5MCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTVdLFxuICAgICAgICBbJzM5MScsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMThdLFxuICAgICAgICBbJzM5MicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTVdLFxuICAgICAgICBbJzM5MycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMThdLFxuICAgICAgICBbJzcwMycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgIF07XG4gICAgRmllbGRQYXJzZXIuRk9VUl9ESUdJVF9EQVRBX0xFTkdUSCA9IFtcbiAgICAgICAgLy8gU2FtZSBmb3JtYXQgYXMgYWJvdmVcbiAgICAgICAgWyc3MDAxJywgMTNdLFxuICAgICAgICBbJzcwMDInLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc3MDAzJywgMTBdLFxuICAgICAgICBbJzgwMDEnLCAxNF0sXG4gICAgICAgIFsnODAwMicsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxuICAgICAgICBbJzgwMDMnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcbiAgICAgICAgWyc4MDA0JywgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXG4gICAgICAgIFsnODAwNScsIDZdLFxuICAgICAgICBbJzgwMDYnLCAxOF0sXG4gICAgICAgIFsnODAwNycsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxuICAgICAgICBbJzgwMDgnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDEyXSxcbiAgICAgICAgWyc4MDE4JywgMThdLFxuICAgICAgICBbJzgwMjAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDI1XSxcbiAgICAgICAgWyc4MTAwJywgNl0sXG4gICAgICAgIFsnODEwMScsIDEwXSxcbiAgICAgICAgWyc4MTAyJywgMl0sXG4gICAgICAgIFsnODExMCcsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgNzBdLFxuICAgICAgICBbJzgyMDAnLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDcwXSxcbiAgICBdO1xuXG4gICAgY2xhc3MgR2VuZXJhbEFwcElkRGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmluZm9ybWF0aW9uID0gaW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlQWxsQ29kZXMoYnVmZiwgaW5pdGlhbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gaW5pdGlhbFBvc2l0aW9uO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IG51bGw7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQoY3VycmVudFBvc2l0aW9uLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRGaWVsZHMgPSBGaWVsZFBhcnNlci5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UoaW5mby5nZXROZXdTdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZEZpZWxkcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmYuYXBwZW5kKHBhcnNlZEZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmZvLmlzUmVtYWluaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gJycgKyBpbmZvLmdldFJlbWFpbmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09PSBpbmZvLmdldE5ld1Bvc2l0aW9uKCkpIHsgLy8gTm8gc3RlcCBmb3J3YXJkIVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gaW5mby5nZXROZXdQb3NpdGlvbigpO1xuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmZi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3RpbGxOdW1lcmljKHBvcykge1xuICAgICAgICAgICAgLy8gSXQncyBudW1lcmljIGlmIGl0IHN0aWxsIGhhcyA3IHBvc2l0aW9uc1xuICAgICAgICAgICAgLy8gYW5kIG9uZSBvZiB0aGUgZmlyc3QgNCBiaXRzIGlzIFwiMVwiLlxuICAgICAgICAgICAgaWYgKHBvcyArIDcgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3MgKyA0IDw9IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IHBvcyArIDM7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZvcm1hdGlvbi5nZXQocG9zICsgMyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlTnVtZXJpYyhwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MgKyA3ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtZXJpYyA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDQpO1xuICAgICAgICAgICAgICAgIGlmIChudW1lcmljID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZE51bWVyaWModGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCksIERlY29kZWROdW1lcmljLkZOQzEsIERlY29kZWROdW1lcmljLkZOQzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWROdW1lcmljKHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpLCBudW1lcmljIC0gMSwgRGVjb2RlZE51bWVyaWMuRk5DMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtZXJpYyA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDcpO1xuICAgICAgICAgICAgbGV0IGRpZ2l0MSA9IChudW1lcmljIC0gOCkgLyAxMTtcbiAgICAgICAgICAgIGxldCBkaWdpdDIgPSAobnVtZXJpYyAtIDgpICUgMTE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWROdW1lcmljKHBvcyArIDcsIGRpZ2l0MSwgZGlnaXQyKTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgYml0cykge1xuICAgICAgICAgICAgcmV0dXJuIEdlbmVyYWxBcHBJZERlY29kZXIuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheSh0aGlzLmluZm9ybWF0aW9uLCBwb3MsIGJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBleHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGluZm9ybWF0aW9uLCBwb3MsIGJpdHMpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdHM7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbi5nZXQocG9zICsgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgfD0gMSA8PCAoYml0cyAtIGkgLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlR2VuZXJhbFB1cnBvc2VGaWVsZChwb3MsIHJlbWFpbmluZykge1xuICAgICAgICAgICAgLy8gdGhpcy5idWZmZXIuc2V0TGVuZ3RoKDApO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuc2V0TGVuZ3RoVG9aZXJvKCk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQocmVtYWluaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgbGV0IGxhc3REZWNvZGVkID0gdGhpcy5wYXJzZUJsb2NrcygpO1xuICAgICAgICAgICAgaWYgKGxhc3REZWNvZGVkICE9IG51bGwgJiYgbGFzdERlY29kZWQuaXNSZW1haW5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpLCBsYXN0RGVjb2RlZC5nZXRSZW1haW5pbmdWYWx1ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUJsb2NrcygpIHtcbiAgICAgICAgICAgIGxldCBpc0ZpbmlzaGVkO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5pc0FscGhhKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFscGhhQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5pc2hlZCA9IHJlc3VsdC5pc0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VycmVudC5pc0lzb0llYzY0NigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VJc29JZWM2NDZCbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIGl0IG11c3QgYmUgbnVtZXJpY1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlTnVtZXJpY0Jsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzRmluaXNoZWQgPSByZXN1bHQuaXNGaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25DaGFuZ2VkID0gaW5pdGlhbFBvc2l0aW9uICE9PSB0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uQ2hhbmdlZCAmJiAhaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghaXNGaW5pc2hlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmdldERlY29kZWRJbmZvcm1hdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlTnVtZXJpY0Jsb2NrKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNTdGlsbE51bWVyaWModGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bWVyaWMgPSB0aGlzLmRlY29kZU51bWVyaWModGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbihudW1lcmljLmdldE5ld1Bvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmIChudW1lcmljLmlzRmlyc3REaWdpdEZOQzEoKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5mb3JtYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmljLmlzU2Vjb25kRGlnaXRGTkMxKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb24odGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCksIG51bWVyaWMuZ2V0U2Vjb25kRGlnaXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdCh0cnVlLCBpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChudW1lcmljLmdldEZpcnN0RGlnaXQoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bWVyaWMuaXNTZWNvbmREaWdpdEZOQzEoKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdCh0cnVlLCBpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChudW1lcmljLmdldFNlY29uZERpZ2l0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOdW1lcmljVG9BbHBoYU51bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0QWxwaGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUlzb0llYzY0NkJsb2NrKCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNTdGlsbElzb0llYzY0Nih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNvID0gdGhpcy5kZWNvZGVJc29JZWM2NDYodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbihpc28uZ2V0TmV3UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzby5pc0ZOQzEoKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdCh0cnVlLCBpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChpc28uZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FscGhhT3I2NDZUb051bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oMyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldE51bWVyaWMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBbHBoYVRvNjQ2VG9BbHBoYUxhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSArIDUgPCB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24odGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0QWxwaGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlQWxwaGFCbG9jaygpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzU3RpbGxBbHBoYSh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWxwaGEgPSB0aGlzLmRlY29kZUFscGhhbnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKGFscGhhLmdldE5ld1Bvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYS5pc0ZOQzEoKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdCh0cnVlLCBpbmZvcm1hdGlvbik7IC8vIGVuZCBvZiB0aGUgY2hhciBibG9ja1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQoYWxwaGEuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FscGhhT3I2NDZUb051bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oMyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldE51bWVyaWMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBbHBoYVRvNjQ2VG9BbHBoYUxhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSArIDUgPCB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24odGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0SXNvSWVjNjQ2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpc1N0aWxsSXNvSWVjNjQ2KHBvcykge1xuICAgICAgICAgICAgaWYgKHBvcyArIDUgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcbiAgICAgICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyArIDcgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZXZlbkJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNyk7XG4gICAgICAgICAgICBpZiAoc2V2ZW5CaXRWYWx1ZSA+PSA2NCAmJiBzZXZlbkJpdFZhbHVlIDwgMTE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zICsgOCA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVpZ2h0Qml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA4KTtcbiAgICAgICAgICAgIHJldHVybiBlaWdodEJpdFZhbHVlID49IDIzMiAmJiBlaWdodEJpdFZhbHVlIDwgMjUzO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZUlzb0llYzY0Nihwb3MpIHtcbiAgICAgICAgICAgIGxldCBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcbiAgICAgICAgICAgIGlmIChmaXZlQml0VmFsdWUgPT09IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA1LCBEZWNvZGVkQ2hhci5GTkMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNSwgKCcwJyArIChmaXZlQml0VmFsdWUgLSA1KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNldmVuQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA3KTtcbiAgICAgICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDY0ICYmIHNldmVuQml0VmFsdWUgPCA5MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNywgKCcnICsgKHNldmVuQml0VmFsdWUgKyAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldmVuQml0VmFsdWUgPj0gOTAgJiYgc2V2ZW5CaXRWYWx1ZSA8IDExNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNywgKCcnICsgKHNldmVuQml0VmFsdWUgKyA3KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVpZ2h0Qml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA4KTtcbiAgICAgICAgICAgIGxldCBjO1xuICAgICAgICAgICAgc3dpdGNoIChlaWdodEJpdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzI6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnISc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjMzOlxuICAgICAgICAgICAgICAgICAgICBjID0gJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzQ6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnJSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM1OlxuICAgICAgICAgICAgICAgICAgICBjID0gJyYnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzNjpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICdcXCcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzNzpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcoJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMzg6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnKSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM5OlxuICAgICAgICAgICAgICAgICAgICBjID0gJyonO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0MDpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcrJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDE6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQyOlxuICAgICAgICAgICAgICAgICAgICBjID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0MzpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDQ6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ1OlxuICAgICAgICAgICAgICAgICAgICBjID0gJzonO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0NjpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc7JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDc6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnPCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAgICAgICAgICAgICBjID0gJz0nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0OTpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICc+JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTA6XG4gICAgICAgICAgICAgICAgICAgIGMgPSAnPyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjUxOlxuICAgICAgICAgICAgICAgICAgICBjID0gJ18nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1MjpcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA4LCBjKTtcbiAgICAgICAgfVxuICAgICAgICBpc1N0aWxsQWxwaGEocG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgNSA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugbm93IGNoZWNrIGlmIGl0J3MgYSB2YWxpZCA1LWJpdCB2YWx1ZSAoMC4uOSBhbmQgRk5DMSlcbiAgICAgICAgICAgIGxldCBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcbiAgICAgICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyArIDYgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaXhCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDYpO1xuICAgICAgICAgICAgcmV0dXJuIHNpeEJpdFZhbHVlID49IDE2ICYmIHNpeEJpdFZhbHVlIDwgNjM7IC8vIDYzIG5vdCBpbmNsdWRlZFxuICAgICAgICB9XG4gICAgICAgIGRlY29kZUFscGhhbnVtZXJpYyhwb3MpIHtcbiAgICAgICAgICAgIGxldCBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcbiAgICAgICAgICAgIGlmIChmaXZlQml0VmFsdWUgPT09IDE1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcihwb3MgKyA1LCBEZWNvZGVkQ2hhci5GTkMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNSwgKCcwJyArIChmaXZlQml0VmFsdWUgLSA1KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpeEJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNik7XG4gICAgICAgICAgICBpZiAoc2l4Qml0VmFsdWUgPj0gMzIgJiYgc2l4Qml0VmFsdWUgPCA1OCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNiwgKCcnICsgKHNpeEJpdFZhbHVlICsgMzMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYztcbiAgICAgICAgICAgIHN3aXRjaCAoc2l4Qml0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAgICAgICBjID0gJyonO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgICAgICAgICBjID0gJywnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICAgICAgICBjID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgICAgICAgICBjID0gJy4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICAgICAgICBjID0gJy8nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdEZWNvZGluZyBpbnZhbGlkIGFscGhhbnVtZXJpYyB2YWx1ZTogJyArIHNpeEJpdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXIocG9zICsgNiwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNBbHBoYVRvNjQ2VG9BbHBoYUxhdGNoKHBvcykge1xuICAgICAgICAgICAgaWYgKHBvcyArIDEgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNSAmJiBpICsgcG9zIDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbmZvcm1hdGlvbi5nZXQocG9zICsgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZm9ybWF0aW9uLmdldChwb3MgKyBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNBbHBoYU9yNjQ2VG9OdW1lcmljTGF0Y2gocG9zKSB7XG4gICAgICAgICAgICAvLyBOZXh0IGlzIGFscGhhbnVtZXJpYyBpZiB0aGVyZSBhcmUgMyBwb3NpdGlvbnMgYW5kIHRoZXkgYXJlIGFsbCB6ZXJvc1xuICAgICAgICAgICAgaWYgKHBvcyArIDMgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBwb3MgKyAzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvcm1hdGlvbi5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlzTnVtZXJpY1RvQWxwaGFOdW1lcmljTGF0Y2gocG9zKSB7XG4gICAgICAgICAgICAvLyBOZXh0IGlzIGFscGhhbnVtZXJpYyBpZiB0aGVyZSBhcmUgNCBwb3NpdGlvbnMgYW5kIHRoZXkgYXJlIGFsbCB6ZXJvcywgb3JcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2V0IG9mIHRoaXMganVzdCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc3ltYm9sXG4gICAgICAgICAgICBpZiAocG9zICsgMSA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0ICYmIGkgKyBwb3MgPCB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEFic3RyYWN0RXhwYW5kZWREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhbERlY29kZXIgPSBuZXcgR2VuZXJhbEFwcElkRGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0SW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBnZXRHZW5lcmFsRGVjb2RlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYWxEZWNvZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQUkwMWRlY29kZXIgZXh0ZW5kcyBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBjdXJyZW50UG9zKSB7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcoMDEpJyk7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbFBvc2l0aW9uID0gYnVmLmxlbmd0aCgpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnOScpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbldpdGhvdXRBSShidWYsIGN1cnJlbnRQb3MsIGluaXRpYWxQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlQ29tcHJlc3NlZEd0aW5XaXRob3V0QUkoYnVmLCBjdXJyZW50UG9zLCBpbml0aWFsQnVmZmVyUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRCbG9jayA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGN1cnJlbnRQb3MgKyAxMCAqIGksIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrIC8gMTAwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9jayAvIDEwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZChjdXJyZW50QmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQUkwMWRlY29kZXIuYXBwZW5kQ2hlY2tEaWdpdChidWYsIGluaXRpYWxCdWZmZXJQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFwcGVuZENoZWNrRGlnaXQoYnVmLCBjdXJyZW50UG9zKSB7XG4gICAgICAgICAgICBsZXQgY2hlY2tEaWdpdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBsZXQgZGlnaXQgPSBidWYuY2hhckF0KGkgKyBjdXJyZW50UG9zKSAtICcwJztcbiAgICAgICAgICAgICAgICAvLyBUbyBiZSBjaGVja2VkXG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gYnVmLmNoYXJBdChpICsgY3VycmVudFBvcykuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGNoZWNrRGlnaXQgKz0gKGkgJiAweDAxKSA9PT0gMCA/IDMgKiBkaWdpdCA6IGRpZ2l0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tEaWdpdCA9IDEwIC0gKGNoZWNrRGlnaXQgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tEaWdpdCA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICBjaGVja0RpZ2l0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoY2hlY2tEaWdpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMWRlY29kZXIuR1RJTl9TSVpFID0gNDA7XG5cbiAgICBjbGFzcyBBSTAxQW5kT3RoZXJBSXMgZXh0ZW5kcyBBSTAxZGVjb2RlciB7XG4gICAgICAgIC8vIHRoZSBzZWNvbmQgb25lIGlzIHRoZSBlbmNvZGF0aW9uIG1ldGhvZCwgYW5kIHRoZSBvdGhlciB0d28gYXJlIGZvciB0aGUgdmFyaWFibGUgbGVuZ3RoXG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBidWZmID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1ZmYuYXBwZW5kKCcoMDEpJyk7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbEd0aW5Qb3NpdGlvbiA9IGJ1ZmYubGVuZ3RoKCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RHdGluRGlnaXQgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUsIDQpO1xuICAgICAgICAgICAgYnVmZi5hcHBlbmQoZmlyc3RHdGluRGlnaXQpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbldpdGhvdXRBSShidWZmLCBBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUgKyA0LCBpbml0aWFsR3RpblBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlQWxsQ29kZXMoYnVmZiwgQUkwMUFuZE90aGVyQUlzLkhFQURFUl9TSVpFICsgNDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSA9IDEgKyAxICsgMjsgLy8gZmlyc3QgYml0IGVuY29kZXMgdGhlIGxpbmthZ2UgZmxhZyxcblxuICAgIGNsYXNzIEFueUFJRGVjb2RlciBleHRlbmRzIEFic3RyYWN0RXhwYW5kZWREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUFsbENvZGVzKGJ1ZiwgQW55QUlEZWNvZGVyLkhFQURFUl9TSVpFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBbnlBSURlY29kZXIuSEVBREVSX1NJWkUgPSAyICsgMSArIDI7XG5cbiAgICBjbGFzcyBBSTAxd2VpZ2h0RGVjb2RlciBleHRlbmRzIEFJMDFkZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVDb21wcmVzc2VkV2VpZ2h0KGJ1ZiwgY3VycmVudFBvcywgd2VpZ2h0U2l6ZSkge1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsV2VpZ2h0TnVtZXJpYyA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGN1cnJlbnRQb3MsIHdlaWdodFNpemUpO1xuICAgICAgICAgICAgdGhpcy5hZGRXZWlnaHRDb2RlKGJ1Ziwgb3JpZ2luYWxXZWlnaHROdW1lcmljKTtcbiAgICAgICAgICAgIGxldCB3ZWlnaHROdW1lcmljID0gdGhpcy5jaGVja1dlaWdodChvcmlnaW5hbFdlaWdodE51bWVyaWMpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREaXZpc29yID0gMTAwMDAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0TnVtZXJpYyAvIGN1cnJlbnREaXZpc29yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudERpdmlzb3IgLz0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKHdlaWdodE51bWVyaWMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgQUkwMTN4MHhEZWNvZGVyIGV4dGVuZHMgQUkwMXdlaWdodERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSAhPSBBSTAxM3gweERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxd2VpZ2h0RGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxM3gweERlY29kZXIuV0VJR0hUX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRXZWlnaHQoYnVmLCBBSTAxM3gweERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxd2VpZ2h0RGVjb2Rlci5HVElOX1NJWkUsIEFJMDEzeDB4RGVjb2Rlci5XRUlHSFRfU0laRSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQUkwMTN4MHhEZWNvZGVyLkhFQURFUl9TSVpFID0gNCArIDE7XG4gICAgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFID0gMTU7XG5cbiAgICBjbGFzcyBBSTAxMzEwM2RlY29kZXIgZXh0ZW5kcyBBSTAxM3gweERlY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgc3VwZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGFkZFdlaWdodENvZGUoYnVmLCB3ZWlnaHQpIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygzMTAzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrV2VpZ2h0KHdlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEFJMDEzMjB4RGVjb2RlciBleHRlbmRzIEFJMDEzeDB4RGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgYWRkV2VpZ2h0Q29kZShidWYsIHdlaWdodCkge1xuICAgICAgICAgICAgaWYgKHdlaWdodCA8IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDMyMDIpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcoMzIwMyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1dlaWdodCh3ZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICh3ZWlnaHQgPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0IC0gMTAwMDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBBSTAxMzkyeERlY29kZXIgZXh0ZW5kcyBBSTAxZGVjb2RlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpIDwgQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUpO1xuICAgICAgICAgICAgbGV0IGxhc3RBSWRpZ2l0ID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXIuR1RJTl9TSVpFLCBBSTAxMzkyeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygzOTInKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQobGFzdEFJZGlnaXQpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xuICAgICAgICAgICAgbGV0IGRlY29kZWRJbmZvcm1hdGlvbiA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzOTJ4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUsIG51bGwpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZChkZWNvZGVkSW5mb3JtYXRpb24uZ2V0TmV3U3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSA9IDUgKyAxICsgMjtcbiAgICBBSTAxMzkyeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFID0gMjtcblxuICAgIGNsYXNzIEFJMDEzOTN4RGVjb2RlciBleHRlbmRzIEFJMDFkZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgIHN1cGVyKGluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm9ybWF0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SW5mb3JtYXRpb24oKS5nZXRTaXplKCkgPCBBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkR3RpbihidWYsIEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSk7XG4gICAgICAgICAgICBsZXQgbGFzdEFJZGlnaXQgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUsIEFJMDEzOTN4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKDM5MycpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZChsYXN0QUlkaWdpdCk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcpJyk7XG4gICAgICAgICAgICBsZXQgZmlyc3RUaHJlZURpZ2l0cyA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzOTN4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUsIEFJMDEzOTN4RGVjb2Rlci5GSVJTVF9USFJFRV9ESUdJVFNfU0laRSk7XG4gICAgICAgICAgICBpZiAoZmlyc3RUaHJlZURpZ2l0cyAvIDEwMCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VGhyZWVEaWdpdHMgLyAxMCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmLmFwcGVuZChmaXJzdFRocmVlRGlnaXRzKTtcbiAgICAgICAgICAgIGxldCBnZW5lcmFsSW5mb3JtYXRpb24gPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlR2VuZXJhbFB1cnBvc2VGaWVsZChBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFICsgQUkwMTM5M3hEZWNvZGVyLkZJUlNUX1RIUkVFX0RJR0lUU19TSVpFLCBudWxsKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoZ2VuZXJhbEluZm9ybWF0aW9uLmdldE5ld1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgPSA1ICsgMSArIDI7XG4gICAgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSA9IDI7XG4gICAgQUkwMTM5M3hEZWNvZGVyLkZJUlNUX1RIUkVFX0RJR0lUU19TSVpFID0gMTA7XG5cbiAgICBjbGFzcyBBSTAxM3gweDF4RGVjb2RlciBleHRlbmRzIEFJMDF3ZWlnaHREZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mb3JtYXRpb24sIGZpcnN0QUlkaWdpdHMsIGRhdGVDb2RlKSB7XG4gICAgICAgICAgICBzdXBlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB0aGlzLmRhdGVDb2RlID0gZGF0ZUNvZGU7XG4gICAgICAgICAgICB0aGlzLmZpcnN0QUlkaWdpdHMgPSBmaXJzdEFJZGlnaXRzO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlSW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSAhPSBBSTAxM3gweDF4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLldFSUdIVF9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuREFURV9TSVpFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxM3gweDF4RGVjb2Rlci5IRUFERVJfU0laRSk7XG4gICAgICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRXZWlnaHQoYnVmLCBBSTAxM3gweDF4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLkdUSU5fU0laRSwgQUkwMTN4MHgxeERlY29kZXIuV0VJR0hUX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkRGF0ZShidWYsIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuR1RJTl9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuV0VJR0hUX1NJWkUpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZUNvbXByZXNzZWREYXRlKGJ1ZiwgY3VycmVudFBvcykge1xuICAgICAgICAgICAgbGV0IG51bWVyaWNEYXRlID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcywgQUkwMTN4MHgxeERlY29kZXIuREFURV9TSVpFKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljRGF0ZSA9PSAzODQwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJygnKTtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQodGhpcy5kYXRlQ29kZSk7XG4gICAgICAgICAgICBidWYuYXBwZW5kKCcpJyk7XG4gICAgICAgICAgICBsZXQgZGF5ID0gbnVtZXJpY0RhdGUgJSAzMjtcbiAgICAgICAgICAgIG51bWVyaWNEYXRlIC89IDMyO1xuICAgICAgICAgICAgbGV0IG1vbnRoID0gbnVtZXJpY0RhdGUgJSAxMiArIDE7XG4gICAgICAgICAgICBudW1lcmljRGF0ZSAvPSAxMjtcbiAgICAgICAgICAgIGxldCB5ZWFyID0gbnVtZXJpY0RhdGU7XG4gICAgICAgICAgICBpZiAoeWVhciAvIDEwID09IDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKHllYXIpO1xuICAgICAgICAgICAgaWYgKG1vbnRoIC8gMTAgPT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQobW9udGgpO1xuICAgICAgICAgICAgaWYgKGRheSAvIDEwID09IDApIHtcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWYuYXBwZW5kKGRheSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkV2VpZ2h0Q29kZShidWYsIHdlaWdodCkge1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKCcpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCh0aGlzLmZpcnN0QUlkaWdpdHMpO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCh3ZWlnaHQgLyAxMDAwMDApO1xuICAgICAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrV2VpZ2h0KHdlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlaWdodCAlIDEwMDAwMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBSTAxM3gweDF4RGVjb2Rlci5IRUFERVJfU0laRSA9IDcgKyAxO1xuICAgIEFJMDEzeDB4MXhEZWNvZGVyLldFSUdIVF9TSVpFID0gMjA7XG4gICAgQUkwMTN4MHgxeERlY29kZXIuREFURV9TSVpFID0gMTY7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEZWNvZGVyKGluZm9ybWF0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaW5mb3JtYXRpb24uZ2V0KDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBSTAxQW5kT3RoZXJBSXMoaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbmZvcm1hdGlvbi5nZXQoMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFueUFJRGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91ckJpdEVuY29kYXRpb25NZXRob2QgPSBHZW5lcmFsQXBwSWREZWNvZGVyLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDQpO1xuICAgICAgICAgICAgc3dpdGNoIChmb3VyQml0RW5jb2RhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBBSTAxMzEwM2RlY29kZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBBSTAxMzIweERlY29kZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZpdmVCaXRFbmNvZGF0aW9uTWV0aG9kID0gR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KGluZm9ybWF0aW9uLCAxLCA1KTtcbiAgICAgICAgICAgIHN3aXRjaCAoZml2ZUJpdEVuY29kYXRpb25NZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gbmV3IEFJMDEzOTJ4RGVjb2RlcihpbmZvcm1hdGlvbik7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIG5ldyBBSTAxMzkzeERlY29kZXIoaW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNldmVuQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXIuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShpbmZvcm1hdGlvbiwgMSwgNyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHNldmVuQml0RW5jb2RhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNTY6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMTAnLCAnMTEnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU3OiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzIwJywgJzExJyk7XG4gICAgICAgICAgICAgICAgY2FzZSA1ODogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMxMCcsICcxMycpO1xuICAgICAgICAgICAgICAgIGNhc2UgNTk6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMjAnLCAnMTMnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDYwOiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzEwJywgJzE1Jyk7XG4gICAgICAgICAgICAgICAgY2FzZSA2MTogcmV0dXJuIG5ldyBBSTAxM3gweDF4RGVjb2RlcihpbmZvcm1hdGlvbiwgJzMyMCcsICcxNScpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjI6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sICczMTAnLCAnMTcnKTtcbiAgICAgICAgICAgICAgICBjYXNlIDYzOiByZXR1cm4gbmV3IEFJMDEzeDB4MXhEZWNvZGVyKGluZm9ybWF0aW9uLCAnMzIwJywgJzE3Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbigndW5rbm93biBkZWNvZGVyOiAnICsgaW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgRXhwYW5kZWRQYWlyIHtcbiAgICAgICAgY29uc3RydWN0b3IobGVmdENoYXIsIHJpZ2h0Q2hhciwgZmluZGVyUGF0dGVyLCBtYXlCZUxhc3QpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdGNoYXIgPSBsZWZ0Q2hhcjtcbiAgICAgICAgICAgIHRoaXMucmlnaHRjaGFyID0gcmlnaHRDaGFyO1xuICAgICAgICAgICAgdGhpcy5maW5kZXJwYXR0ZXJuID0gZmluZGVyUGF0dGVyO1xuICAgICAgICAgICAgdGhpcy5tYXliZUxhc3QgPSBtYXlCZUxhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbWF5QmVMYXN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF5YmVMYXN0O1xuICAgICAgICB9XG4gICAgICAgIGdldExlZnRDaGFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmlnaHRDaGFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGdldEZpbmRlclBhdHRlcm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kZXJwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIG11c3RCZUxhc3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodGNoYXIgPT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnWyAnICsgdGhpcy5sZWZ0Y2hhciArICcsICcgKyB0aGlzLnJpZ2h0Y2hhciArICcgOiAnICsgKHRoaXMuZmluZGVycGF0dGVybiA9PSBudWxsID8gJ251bGwnIDogdGhpcy5maW5kZXJwYXR0ZXJuLmdldFZhbHVlKCkpICsgJyBdJztcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZXF1YWxzKG8xLCBvMikge1xuICAgICAgICAgICAgaWYgKCEobzEgaW5zdGFuY2VvZiBFeHBhbmRlZFBhaXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEV4cGFuZGVkUGFpci5lcXVhbHNPck51bGwobzEubGVmdGNoYXIsIG8yLmxlZnRjaGFyKSAmJlxuICAgICAgICAgICAgICAgIEV4cGFuZGVkUGFpci5lcXVhbHNPck51bGwobzEucmlnaHRjaGFyLCBvMi5yaWdodGNoYXIpICYmXG4gICAgICAgICAgICAgICAgRXhwYW5kZWRQYWlyLmVxdWFsc09yTnVsbChvMS5maW5kZXJwYXR0ZXJuLCBvMi5maW5kZXJwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZXF1YWxzT3JOdWxsKG8xLCBvMikge1xuICAgICAgICAgICAgcmV0dXJuIG8xID09PSBudWxsID8gbzIgPT09IG51bGwgOiBFeHBhbmRlZFBhaXIuZXF1YWxzKG8xLCBvMik7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaENvZGUoKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gRXhwYW5kZWRQYWlyLmhhc2hOb3ROdWxsKGxlZnRDaGFyKSBeIGhhc2hOb3ROdWxsKHJpZ2h0Q2hhcikgXiBoYXNoTm90TnVsbChmaW5kZXJQYXR0ZXJuKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMubGVmdGNoYXIuZ2V0VmFsdWUoKSBeIHRoaXMucmlnaHRjaGFyLmdldFZhbHVlKCkgXiB0aGlzLmZpbmRlcnBhdHRlcm4uZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEV4cGFuZGVkUm93IHtcbiAgICAgICAgY29uc3RydWN0b3IocGFpcnMsIHJvd051bWJlciwgd2FzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGFpcnMgPSBwYWlycztcbiAgICAgICAgICAgIHRoaXMucm93TnVtYmVyID0gcm93TnVtYmVyO1xuICAgICAgICAgICAgdGhpcy53YXNSZXZlcnNlZCA9IHdhc1JldmVyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGdldFBhaXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93TnVtYmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlzUmV2ZXJzZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YXNSZXZlcnNlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpc0VxdWl2YWxlbnQob3RoZXJQYWlycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFcXVhbGl0aXR5KHRoaXMsIG90aGVyUGFpcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAneyAnICsgdGhpcy5wYWlycyArICcgfSc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR3byByb3dzIGFyZSBlcXVhbCBpZiB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgcGFpcnMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgLy8gY2hlY2sgaW1wbGVtZW50YXRpb25cbiAgICAgICAgZXF1YWxzKG8xLCBvMikge1xuICAgICAgICAgICAgaWYgKCEobzEgaW5zdGFuY2VvZiBFeHBhbmRlZFJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0VxdWFsaXRpdHkobzEsIG8yKSAmJiBvMS53YXNSZXZlcnNlZCA9PT0gbzIud2FzUmV2ZXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tFcXVhbGl0aXR5KHBhaXIxLCBwYWlyMikge1xuICAgICAgICAgICAgaWYgKCFwYWlyMSB8fCAhcGFpcjIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHBhaXIxLmZvckVhY2goKGUxLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcGFpcjIuZm9yRWFjaChlMiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlMS5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCkgPT09IGUyLmdldExlZnRDaGFyKCkuZ2V0VmFsdWUoKSAmJiBlMS5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpID09PSBlMi5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpICYmIGUxLmdldEZpbmRlclBhdHRlcigpLmdldFZhbHVlKCkgPT09IGUyLmdldEZpbmRlclBhdHRlcigpLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuSXRlcmF0b3I7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbnM7XG4gICAgY2xhc3MgUlNTRXhwYW5kZWRSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdFJTU1JlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnBhaXJzID0gbmV3IEFycmF5KFJTU0V4cGFuZGVkUmVhZGVyLk1BWF9QQUlSUyk7XG4gICAgICAgICAgICB0aGlzLnJvd3MgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRFbmQgPSBbMl07XG4gICAgICAgICAgICB0aGlzLnZlcmJvc2UgPSAodmVyYm9zZSA9PT0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cykge1xuICAgICAgICAgICAgLy8gUm93cyBjYW4gc3RhcnQgd2l0aCBldmVuIHBhdHRlcm4gaW4gY2FzZSBpbiBwcmV2IHJvd3MgdGhlcmUgd2hlcmUgb2RkIG51bWJlciBvZiBwYXR0ZXJzLlxuICAgICAgICAgICAgLy8gU28gbGV0cyB0cnkgdHdpY2VcbiAgICAgICAgICAgIC8vIHRoaXMucGFpcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcm9tRXZlbiA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUlNTRXhwYW5kZWRSZWFkZXIuY29uc3RydWN0UmVzdWx0KHRoaXMuZGVjb2RlUm93MnBhaXJzKHJvd051bWJlciwgcm93KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE9LXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RnJvbUV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFJTU0V4cGFuZGVkUmVhZGVyLmNvbnN0cnVjdFJlc3VsdCh0aGlzLmRlY29kZVJvdzJwYWlycyhyb3dOdW1iZXIsIHJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5yb3dzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHByaXZhdGUgZm9yIHRlc3RpbmdcbiAgICAgICAgZGVjb2RlUm93MnBhaXJzKHJvd051bWJlciwgcm93KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlycy5wdXNoKHRoaXMucmV0cmlldmVOZXh0UGFpcihyb3csIHRoaXMucGFpcnMsIHJvd051bWJlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTm90Rm91bmRFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYWlycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aXQgdGhpcyBsb29wIHdoZW4gcmV0cmlldmVOZXh0UGFpcigpIGZhaWxzIGFuZCB0aHJvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogdmVyaWZ5IHNlcXVlbmNlIG9mIGZpbmRlciBwYXR0ZXJucyBhcyBpbiBjaGVja1BhaXJTZXF1ZW5jZSgpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja0NoZWNrc3VtKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYWlycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cnlTdGFja2VkRGVjb2RlO1xuICAgICAgICAgICAgaWYgKHRoaXMucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0cnlTdGFja2VkRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeVN0YWNrZWREZWNvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxldCB0cnlTdGFja2VkRGVjb2RlID0gIXRoaXMucm93cy5pc0VtcHR5KCk7XG4gICAgICAgICAgICB0aGlzLnN0b3JlUm93KHJvd051bWJlciwgZmFsc2UpOyAvLyBUT0RPOiBkZWFsIHdpdGggcmV2ZXJzZWQgcm93c1xuICAgICAgICAgICAgaWYgKHRyeVN0YWNrZWREZWNvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBpbWFnZSBpcyAxODAtcm90YXRlZCwgdGhlbiByb3dzIGFyZSBzb3J0ZWQgaW4gd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFRyeSB0d2ljZSB3aXRoIGJvdGggdGhlIGRpcmVjdGlvbnMuXG4gICAgICAgICAgICAgICAgbGV0IHBzID0gdGhpcy5jaGVja1Jvd3NCb29sZWFuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAocHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBzID0gdGhpcy5jaGVja1Jvd3NCb29sZWFuKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChwcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWVkIHRvIFZlcmlmeVxuICAgICAgICBjaGVja1Jvd3NCb29sZWFuKHJldmVyc2UpIHtcbiAgICAgICAgICAgIC8vIExpbWl0IG51bWJlciBvZiByb3dzIHdlIGFyZSBjaGVja2luZ1xuICAgICAgICAgICAgLy8gV2UgdXNlIHJlY3Vyc2l2ZSBhbGdvcml0aG0gd2l0aCBwdXJlIGNvbXBsZXhpdHkgYW5kIGRvbid0IHdhbnQgaXQgdG8gdGFrZSBmb3JldmVyXG4gICAgICAgICAgICAvLyBTdGFja2VkIGJhcmNvZGUgY2FuIGhhdmUgdXAgdG8gMTEgcm93cywgc28gMjUgc2VlbXMgcmVhc29uYWJsZSBlbm91Z2hcbiAgICAgICAgICAgIGlmICh0aGlzLnJvd3MubGVuZ3RoID4gMjUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MubGVuZ3RoID0gMDsgLy8gV2Ugd2lsbCBuZXZlciBoYXZlIGEgY2hhbmNlIHRvIGdldCByZXN1bHQsIHNvIGNsZWFyIGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93cyA9IHRoaXMucm93cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgLy8gQ29sbGVjdGlvbnMucmV2ZXJzZSh0aGlzLnJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBzID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHMgPSB0aGlzLmNoZWNrUm93cyhuZXcgQXJyYXkoKSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE9LXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93cyA9IHRoaXMucm93cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgLy8gQ29sbGVjdGlvbnMucmV2ZXJzZSh0aGlzLnJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgYSB2YWxpZCByb3dzIHNlcXVlbmNlXG4gICAgICAgIC8vIFJlY3Vyc2lvbiBpcyB1c2VkIHRvIGltcGxlbWVudCBiYWNrdHJhY2tpbmdcbiAgICAgICAgY2hlY2tSb3dzKGNvbGxlY3RlZFJvd3MsIGN1cnJlbnRSb3cpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJyZW50Um93OyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IHRoaXMucm93c1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sbGVjdGVkUm93IG9mIGNvbGxlY3RlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlycy5wdXNoKGNvbGxlY3RlZFJvdy5nZXRQYWlycygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYWlycy5wdXNoKHJvdy5nZXRQYWlycygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIVJTU0V4cGFuZGVkUmVhZGVyLmlzVmFsaWRTZXF1ZW5jZSh0aGlzLnBhaXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tDaGVja3N1bSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcnMgPSBuZXcgQXJyYXkoY29sbGVjdGVkUm93cyk7XG4gICAgICAgICAgICAgICAgcnMucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2lvbjogdHJ5IHRvIGFkZCBtb3JlIHJvd3NcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tSb3dzKHJzLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGZhaWxlZCwgdHJ5IHRoZSBuZXh0IGNhbmRpZGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIHBhaXJzIGZvcm0gYSB2YWxpZCBmaW5kIHBhdHRlcm4gc2VxdWVuY2UsXG4gICAgICAgIC8vIGVpdGhlciBjb21wbGV0ZSBvciBhIHByZWZpeFxuICAgICAgICBzdGF0aWMgaXNWYWxpZFNlcXVlbmNlKHBhaXJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZXF1ZW5jZSBvZiBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTl9TRVFVRU5DRVMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFpcnMubGVuZ3RoID4gc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYWlycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFpcnNbal0uZ2V0RmluZGVyUGF0dGVybigpLmdldFZhbHVlKCkgIT0gc2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZVJvdyhyb3dOdW1iZXIsIHdhc1JldmVyc2VkKSB7XG4gICAgICAgICAgICAvLyBEaXNjYXJkIGlmIGR1cGxpY2F0ZSBhYm92ZSBvciBiZWxvdzsgb3RoZXJ3aXNlIGluc2VydCBpbiBvcmRlciBieSByb3cgbnVtYmVyLlxuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9IDA7XG4gICAgICAgICAgICBsZXQgcHJldklzU2FtZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5leHRJc1NhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChpbnNlcnRQb3MgPCB0aGlzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVyb3cgPSB0aGlzLnJvd3NbaW5zZXJ0UG9zXTtcbiAgICAgICAgICAgICAgICBpZiAoZXJvdy5nZXRSb3dOdW1iZXIoKSA+IHJvd051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBuZXh0SXNTYW1lID0gZXJvdy5pc0VxdWl2YWxlbnQodGhpcy5wYWlycyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2SXNTYW1lID0gZXJvdy5pc0VxdWl2YWxlbnQodGhpcy5wYWlycyk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dElzU2FtZSB8fCBwcmV2SXNTYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiB0aGUgcm93IHdhcyBwYXJ0aWFsbHkgZGVjb2RlZCAoZS5nLiAyIHBhaXJzIGZvdW5kIGluc3RlYWQgb2YgMyksXG4gICAgICAgICAgICAvLyBpdCB3aWxsIHByZXZlbnQgdXMgZnJvbSBkZXRlY3RpbmcgdGhlIGJhcmNvZGUuXG4gICAgICAgICAgICAvLyBUcnkgdG8gbWVyZ2UgcGFydGlhbCByb3dzXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByb3cgaXMgcGFydCBvZiBhbiBhbGxyZWFkeSBkZXRlY3RlZCByb3dcbiAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc1BhcnRpYWxSb3codGhpcy5wYWlycywgdGhpcy5yb3dzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKGluc2VydFBvcywgbmV3IEV4cGFuZGVkUm93KHRoaXMucGFpcnMsIHJvd051bWJlciwgd2FzUmV2ZXJzZWQpKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFydGlhbFJvd3ModGhpcy5wYWlycywgdGhpcy5yb3dzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYWxsIHRoZSByb3dzIHRoYXQgY29udGFpbnMgb25seSBzcGVjaWZpZWQgcGFpcnNcbiAgICAgICAgcmVtb3ZlUGFydGlhbFJvd3MocGFpcnMsIHJvd3MpIHtcbiAgICAgICAgICAgIC8vIGZvciAoSXRlcmF0b3I8RXhwYW5kZWRSb3c+IGl0ZXJhdG9yID0gcm93cy5pdGVyYXRvcigpOyBpdGVyYXRvci5oYXNOZXh0KCk7KSB7XG4gICAgICAgICAgICAvLyAgIEV4cGFuZGVkUm93IHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAvLyAgIGlmIChyLmdldFBhaXJzKCkuc2l6ZSgpID09IHBhaXJzLnNpemUoKSkge1xuICAgICAgICAgICAgLy8gICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyAgIGJvb2xlYW4gYWxsRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gICBmb3IgKEV4cGFuZGVkUGFpciBwIDogci5nZXRQYWlycygpKSB7XG4gICAgICAgICAgICAvLyAgICAgYm9vbGVhbiBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gICAgIGZvciAoRXhwYW5kZWRQYWlyIHBwIDogcGFpcnMpIHtcbiAgICAgICAgICAgIC8vICAgICAgIGlmIChwLmVxdWFscyhwcCkpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgLy8gICAgICAgYWxsRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gICBpZiAoYWxsRm91bmQpIHtcbiAgICAgICAgICAgIC8vICAgICAvLyAncGFpcnMnIGNvbnRhaW5zIGFsbCB0aGUgcGFpcnMgZnJvbSB0aGUgcm93ICdyJ1xuICAgICAgICAgICAgLy8gICAgIGl0ZXJhdG9yLnJlbW92ZSgpO1xuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgb2Ygcm93cykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cuZ2V0UGFpcnMoKS5sZW5ndGggPT09IHBhaXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCBvZiByb3cuZ2V0UGFpcnMoKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcCBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEV4cGFuZGVkUGFpci5lcXVhbHMocCwgcHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIHdoZW4gb25lIG9mIHRoZSByb3dzIGFscmVhZHkgY29udGFpbnMgYWxsIHRoZSBwYWlyc1xuICAgICAgICBzdGF0aWMgaXNQYXJ0aWFsUm93KHBhaXJzLCByb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIHJvd3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWxsRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBwIG9mIHIuZ2V0UGFpcnMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuZXF1YWxzKHBwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByb3cgJ3InIGNvbnRhaW4gYWxsIHRoZSBwYWlycyBmcm9tICdwYWlycydcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdXNlZCBmb3IgdW5pdCB0ZXN0aW5nXG4gICAgICAgIGdldFJvd3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBwcml2YXRlIGZvciB1bml0IHRlc3RpbmdcbiAgICAgICAgc3RhdGljIGNvbnN0cnVjdFJlc3VsdChwYWlycykge1xuICAgICAgICAgICAgbGV0IGJpbmFyeSA9IEJpdEFycmF5QnVpbGRlci5idWlsZEJpdEFycmF5KHBhaXJzKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVyID0gY3JlYXRlRGVjb2RlcihiaW5hcnkpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdGluZ1N0cmluZyA9IGRlY29kZXIucGFyc2VJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgbGV0IGZpcnN0UG9pbnRzID0gcGFpcnNbMF0uZ2V0RmluZGVyUGF0dGVybigpLmdldFJlc3VsdFBvaW50cygpO1xuICAgICAgICAgICAgbGV0IGxhc3RQb2ludHMgPSBwYWlyc1twYWlycy5sZW5ndGggLSAxXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gW2ZpcnN0UG9pbnRzWzBdLCBmaXJzdFBvaW50c1sxXSwgbGFzdFBvaW50c1swXSwgbGFzdFBvaW50c1sxXV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChyZXN1bHRpbmdTdHJpbmcsIG51bGwsIG51bGwsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLlJTU19FWFBBTkRFRCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaGVja3N1bSgpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdFBhaXIgPSB0aGlzLnBhaXJzLmdldCgwKTtcbiAgICAgICAgICAgIGxldCBjaGVja0NoYXJhY3RlciA9IGZpcnN0UGFpci5nZXRMZWZ0Q2hhcigpO1xuICAgICAgICAgICAgbGV0IGZpcnN0Q2hhcmFjdGVyID0gZmlyc3RQYWlyLmdldFJpZ2h0Q2hhcigpO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhcmFjdGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hlY2tzdW0gPSBmaXJzdENoYXJhY3Rlci5nZXRDaGVja3N1bVBvcnRpb24oKTtcbiAgICAgICAgICAgIGxldCBzID0gMjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5wYWlycy5zaXplKCk7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UGFpciA9IHRoaXMucGFpcnMuZ2V0KGkpO1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IGN1cnJlbnRQYWlyLmdldExlZnRDaGFyKCkuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCk7XG4gICAgICAgICAgICAgICAgcysrO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50UmlnaHRDaGFyID0gY3VycmVudFBhaXIuZ2V0UmlnaHRDaGFyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSaWdodENoYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGVja3N1bSArPSBjdXJyZW50UmlnaHRDaGFyLmdldENoZWNrc3VtUG9ydGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tzdW0gJT0gMjExO1xuICAgICAgICAgICAgbGV0IGNoZWNrQ2hhcmFjdGVyVmFsdWUgPSAyMTEgKiAocyAtIDQpICsgY2hlY2tzdW07XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tDaGFyYWN0ZXJWYWx1ZSA9PSBjaGVja0NoYXJhY3Rlci5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXROZXh0U2Vjb25kQmFyKHJvdywgaW5pdGlhbFBvcykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRQb3M7XG4gICAgICAgICAgICBpZiAocm93LmdldChpbml0aWFsUG9zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFVuc2V0KGluaXRpYWxQb3MpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFNldChjdXJyZW50UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFNldChpbml0aWFsUG9zKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gcm93LmdldE5leHRVbnNldChjdXJyZW50UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UG9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBwcml2YXRlIGZvciB0ZXN0aW5nXG4gICAgICAgIHJldHJpZXZlTmV4dFBhaXIocm93LCBwcmV2aW91c1BhaXJzLCByb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIGxldCBpc09kZFBhdHRlcm4gPSBwcmV2aW91c1BhaXJzLmxlbmd0aCAlIDIgPT0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RnJvbUV2ZW4pIHtcbiAgICAgICAgICAgICAgICBpc09kZFBhdHRlcm4gPSAhaXNPZGRQYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhdHRlcm47XG4gICAgICAgICAgICBsZXQga2VlcEZpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGZvcmNlZE9mZnNldCA9IC0xO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZE5leHRQYWlyKHJvdywgcHJldmlvdXNQYWlycywgZm9yY2VkT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZUZvdW5kRmluZGVyUGF0dGVybihyb3csIHJvd051bWJlciwgaXNPZGRQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZE9mZnNldCA9IFJTU0V4cGFuZGVkUmVhZGVyLmdldE5leHRTZWNvbmRCYXIocm93LCB0aGlzLnN0YXJ0RW5kWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtlZXBGaW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoa2VlcEZpbmRpbmcpO1xuICAgICAgICAgICAgLy8gV2hlbiBzdGFja2VkIHN5bWJvbCBpcyBzcGxpdCBvdmVyIG11bHRpcGxlIHJvd3MsIHRoZXJlJ3Mgbm8gd2F5IHRvIGd1ZXNzIGlmIHRoaXMgcGFpciBjYW4gYmUgbGFzdCBvciBub3QuXG4gICAgICAgICAgICAvLyBib29sZWFuIG1heUJlTGFzdCA9IGNoZWNrUGFpclNlcXVlbmNlKHByZXZpb3VzUGFpcnMsIHBhdHRlcm4pO1xuICAgICAgICAgICAgbGV0IGxlZnRDaGFyID0gdGhpcy5kZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgaXNPZGRQYXR0ZXJuLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0VtcHR5UGFpcihwcmV2aW91c1BhaXJzKSAmJiBwcmV2aW91c1BhaXJzW3ByZXZpb3VzUGFpcnMubGVuZ3RoIC0gMV0ubXVzdEJlTGFzdCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmlnaHRDaGFyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByaWdodENoYXIgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRDaGFyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhwYW5kZWRQYWlyKGxlZnRDaGFyLCByaWdodENoYXIsIHBhdHRlcm4sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlzRW1wdHlQYWlyKHBhaXJzKSB7XG4gICAgICAgICAgICBpZiAocGFpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluZE5leHRQYWlyKHJvdywgcHJldmlvdXNQYWlycywgZm9yY2VkT2Zmc2V0KSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmdldERlY29kZUZpbmRlckNvdW50ZXJzKCk7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldDtcbiAgICAgICAgICAgIGlmIChmb3JjZWRPZmZzZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IGZvcmNlZE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFbXB0eVBhaXIocHJldmlvdXNQYWlycykpIHtcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RQYWlyID0gcHJldmlvdXNQYWlyc1twcmV2aW91c1BhaXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IGxhc3RQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRTdGFydEVuZCgpWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNlYXJjaGluZ0V2ZW5QYWlyID0gcHJldmlvdXNQYWlycy5sZW5ndGggJSAyICE9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydEZyb21FdmVuKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoaW5nRXZlblBhaXIgPSAhc2VhcmNoaW5nRXZlblBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHJvd09mZnNldCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFyb3cuZ2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3dPZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb3VudGVyUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IHJvd09mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hpbmdFdmVuUGFpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJldmVyc2VDb3VudGVycyhjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUlNTRXhwYW5kZWRSZWFkZXIuaXNGaW5kZXJQYXR0ZXJuKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFbmRbMF0gPSBwYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEVuZFsxXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaGluZ0V2ZW5QYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIucmV2ZXJzZUNvdW50ZXJzKGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMF0gPSBjb3VudGVyc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gY291bnRlcnNbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHJldmVyc2VDb3VudGVycyhjb3VudGVycykge1xuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoIC8gMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gY291bnRlcnNbbGVuZ3RoIC0gaSAtIDFdO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2xlbmd0aCAtIGkgLSAxXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJzZUZvdW5kRmluZGVyUGF0dGVybihyb3csIHJvd051bWJlciwgb2RkUGF0dGVybikge1xuICAgICAgICAgICAgLy8gQWN0dWFsbHkgd2UgZm91bmQgZWxlbWVudHMgMi01LlxuICAgICAgICAgICAgbGV0IGZpcnN0Q291bnRlcjtcbiAgICAgICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICBpZiAob2RkUGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhdHRlcm4gbnVtYmVyIGlzIG9kZCwgd2UgbmVlZCB0byBsb2NhdGUgZWxlbWVudCAxICpiZWZvcmUqIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgICAgICAgICAgIGxldCBmaXJzdEVsZW1lbnRTdGFydCA9IHRoaXMuc3RhcnRFbmRbMF0gLSAxO1xuICAgICAgICAgICAgICAgIC8vIExvY2F0ZSBlbGVtZW50IDFcbiAgICAgICAgICAgICAgICB3aGlsZSAoZmlyc3RFbGVtZW50U3RhcnQgPj0gMCAmJiAhcm93LmdldChmaXJzdEVsZW1lbnRTdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50U3RhcnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50U3RhcnQrKztcbiAgICAgICAgICAgICAgICBmaXJzdENvdW50ZXIgPSB0aGlzLnN0YXJ0RW5kWzBdIC0gZmlyc3RFbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBmaXJzdEVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnN0YXJ0RW5kWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGF0dGVybiBudW1iZXIgaXMgZXZlbiwgdGhlIHBhdHRlcm4gaXMgcmV2ZXJzZWQsIHNvIHdlIG5lZWQgdG8gbG9jYXRlIGVsZW1lbnQgMSAqYWZ0ZXIqIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydEVuZFswXTtcbiAgICAgICAgICAgICAgICBlbmQgPSByb3cuZ2V0TmV4dFVuc2V0KHRoaXMuc3RhcnRFbmRbMV0gKyAxKTtcbiAgICAgICAgICAgICAgICBmaXJzdENvdW50ZXIgPSBlbmQgLSB0aGlzLnN0YXJ0RW5kWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSAnY291bnRlcnMnIGhvbGQgMS00XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmdldERlY29kZUZpbmRlckNvdW50ZXJzKCk7XG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGNvdW50ZXJzLCAwLCBjb3VudGVycywgMSwgY291bnRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IGZpcnN0Q291bnRlcjtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlRmluZGVyVmFsdWUoY291bnRlcnMsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRURVJOUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuKHZhbHVlLCBuZXcgaW50W10geyBzdGFydCwgZW5kIH0sIHN0YXJ0LCBlbmQsIHJvd051bWJlcn0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuKHZhbHVlLCBbc3RhcnQsIGVuZF0sIHN0YXJ0LCBlbmQsIHJvd051bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgbGVmdENoYXIpIHtcbiAgICAgICAgICAgIGxldCBjb3VudGVycyA9IHRoaXMuZ2V0RGF0YUNoYXJhY3RlckNvdW50ZXJzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNvdW50ZXJzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbeF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRDaGFyKSB7XG4gICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIucmVjb3JkUGF0dGVybkluUmV2ZXJzZShyb3csIHBhdHRlcm4uZ2V0U3RhcnRFbmQoKVswXSwgY291bnRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHBhdHRlcm4uZ2V0U3RhcnRFbmQoKVsxXSwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgIC8vIHJldmVyc2UgaXRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGNvdW50ZXJzLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyssIGotLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tpXSA9IGNvdW50ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tqXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBjb3VudGVyc1tdIGhhcyB0aGUgcGl4ZWxzIG9mIHRoZSBtb2R1bGVcbiAgICAgICAgICAgIGxldCBudW1Nb2R1bGVzID0gMTc7IC8vIGxlZnQgYW5kIHJpZ2h0IGRhdGEgY2hhcmFjdGVycyBoYXZlIGFsbCB0aGUgc2FtZSBsZW5ndGhcbiAgICAgICAgICAgIGxldCBlbGVtZW50V2lkdGggPSBNYXRoVXRpbHMuc3VtKG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzKSkgLyBudW1Nb2R1bGVzO1xuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrOiBlbGVtZW50IHdpZHRoIGZvciBwYXR0ZXJuIGFuZCB0aGUgY2hhcmFjdGVyIHNob3VsZCBtYXRjaFxuICAgICAgICAgICAgbGV0IGV4cGVjdGVkRWxlbWVudFdpZHRoID0gKHBhdHRlcm4uZ2V0U3RhcnRFbmQoKVsxXSAtIHBhdHRlcm4uZ2V0U3RhcnRFbmQoKVswXSkgLyAxNS4wO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVsZW1lbnRXaWR0aCAtIGV4cGVjdGVkRWxlbWVudFdpZHRoKSAvIGV4cGVjdGVkRWxlbWVudFdpZHRoID4gMC4zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2RkQ291bnRzID0gdGhpcy5nZXRPZGRDb3VudHMoKTtcbiAgICAgICAgICAgIGxldCBldmVuQ291bnRzID0gdGhpcy5nZXRFdmVuQ291bnRzKCk7XG4gICAgICAgICAgICBsZXQgb2RkUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCk7XG4gICAgICAgICAgICBsZXQgZXZlblJvdW5kaW5nRXJyb3JzID0gdGhpcy5nZXRFdmVuUm91bmRpbmdFcnJvcnMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAxLjAgKiBjb3VudGVyc1tpXSAvIGVsZW1lbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSB2YWx1ZSArIDAuNTsgLy8gUm91bmRcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAuMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb3VudCA+IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gOC43KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoKGkgJiAweDAxKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9kZENvdW50c1tvZmZzZXRdID0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIG9kZFJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbkNvdW50c1tvZmZzZXRdID0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW5Sb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWUgLSBjb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkanVzdE9kZEV2ZW5Db3VudHMobnVtTW9kdWxlcyk7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0Um93TnVtYmVyID0gNCAqIHBhdHRlcm4uZ2V0VmFsdWUoKSArIChpc09kZFBhdHRlcm4gPyAwIDogMikgKyAobGVmdENoYXIgPyAwIDogMSkgLSAxO1xuICAgICAgICAgICAgbGV0IG9kZFN1bSA9IDA7XG4gICAgICAgICAgICBsZXQgb2RkQ2hlY2tzdW1Qb3J0aW9uID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBvZGRDb3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoUlNTRXhwYW5kZWRSZWFkZXIuaXNOb3RBMWxlZnQocGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdlaWdodCA9IFJTU0V4cGFuZGVkUmVhZGVyLldFSUdIVFNbd2VpZ2h0Um93TnVtYmVyXVsyICogaV07XG4gICAgICAgICAgICAgICAgICAgIG9kZENoZWNrc3VtUG9ydGlvbiArPSBvZGRDb3VudHNbaV0gKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9kZFN1bSArPSBvZGRDb3VudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXZlbkNoZWNrc3VtUG9ydGlvbiA9IDA7XG4gICAgICAgICAgICAvLyBpbnQgZXZlblN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZXZlbkNvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc05vdEExbGVmdChwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2VpZ2h0ID0gUlNTRXhwYW5kZWRSZWFkZXIuV0VJR0hUU1t3ZWlnaHRSb3dOdW1iZXJdWzIgKiBpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGV2ZW5DaGVja3N1bVBvcnRpb24gKz0gZXZlbkNvdW50c1tpXSAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXZlblN1bSArPSBldmVuQ291bnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoZWNrc3VtUG9ydGlvbiA9IG9kZENoZWNrc3VtUG9ydGlvbiArIGV2ZW5DaGVja3N1bVBvcnRpb247XG4gICAgICAgICAgICBpZiAoKG9kZFN1bSAmIDB4MDEpICE9IDAgfHwgb2RkU3VtID4gMTMgfHwgb2RkU3VtIDwgNCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdyb3VwID0gKDEzIC0gb2RkU3VtKSAvIDI7XG4gICAgICAgICAgICBsZXQgb2RkV2lkZXN0ID0gUlNTRXhwYW5kZWRSZWFkZXIuU1lNQk9MX1dJREVTVFtncm91cF07XG4gICAgICAgICAgICBsZXQgZXZlbldpZGVzdCA9IDkgLSBvZGRXaWRlc3Q7XG4gICAgICAgICAgICBsZXQgdk9kZCA9IFJTU1V0aWxzLmdldFJTU3ZhbHVlKG9kZENvdW50cywgb2RkV2lkZXN0LCB0cnVlKTtcbiAgICAgICAgICAgIGxldCB2RXZlbiA9IFJTU1V0aWxzLmdldFJTU3ZhbHVlKGV2ZW5Db3VudHMsIGV2ZW5XaWRlc3QsIGZhbHNlKTtcbiAgICAgICAgICAgIGxldCB0RXZlbiA9IFJTU0V4cGFuZGVkUmVhZGVyLkVWRU5fVE9UQUxfU1VCU0VUW2dyb3VwXTtcbiAgICAgICAgICAgIGxldCBnU3VtID0gUlNTRXhwYW5kZWRSZWFkZXIuR1NVTVtncm91cF07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2T2RkICogdEV2ZW4gKyB2RXZlbiArIGdTdW07XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFDaGFyYWN0ZXIodmFsdWUsIGNoZWNrc3VtUG9ydGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzTm90QTFsZWZ0KHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgbGVmdENoYXIpIHtcbiAgICAgICAgICAgIC8vIEExOiBwYXR0ZXJuLmdldFZhbHVlIGlzIDAgKEEpLCBhbmQgaXQncyBhbiBvZGRQYXR0ZXJuLCBhbmQgaXQgaXMgYSBsZWZ0IGNoYXJcbiAgICAgICAgICAgIHJldHVybiAhKHBhdHRlcm4uZ2V0VmFsdWUoKSA9PSAwICYmIGlzT2RkUGF0dGVybiAmJiBsZWZ0Q2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0T2RkRXZlbkNvdW50cyhudW1Nb2R1bGVzKSB7XG4gICAgICAgICAgICBsZXQgb2RkU3VtID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldE9kZENvdW50cygpKSk7XG4gICAgICAgICAgICBsZXQgZXZlblN1bSA9IE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkodGhpcy5nZXRFdmVuQ291bnRzKCkpKTtcbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnRPZGQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRPZGQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvZGRTdW0gPiAxMykge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvZGRTdW0gPCA0KSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGVjcmVtZW50RXZlbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV2ZW5TdW0gPiAxMykge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlblN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtaXNtYXRjaCA9IG9kZFN1bSArIGV2ZW5TdW0gLSBudW1Nb2R1bGVzO1xuICAgICAgICAgICAgbGV0IG9kZFBhcml0eUJhZCA9IChvZGRTdW0gJiAweDAxKSA9PSAxO1xuICAgICAgICAgICAgbGV0IGV2ZW5QYXJpdHlCYWQgPSAoZXZlblN1bSAmIDB4MDEpID09IDA7XG4gICAgICAgICAgICBpZiAobWlzbWF0Y2ggPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWlzbWF0Y2ggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIGJhZFxuICAgICAgICAgICAgICAgICAgICBpZiAob2RkU3VtIDwgZXZlblN1bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjcmVtZW50T2RkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5pbmNyZW1lbnQodGhpcy5nZXRPZGRDb3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRPZGRDb3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLmluY3JlbWVudCh0aGlzLmdldEV2ZW5Db3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuZGVjcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldEV2ZW5Sb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSU1NFeHBhbmRlZFJlYWRlci5TWU1CT0xfV0lERVNUID0gWzcsIDUsIDQsIDMsIDFdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkVWRU5fVE9UQUxfU1VCU0VUID0gWzQsIDIwLCA1MiwgMTA0LCAyMDRdO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkdTVU0gPSBbMCwgMzQ4LCAxMzg4LCAyOTQ4LCAzOTg4XTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgOCwgNCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDYsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA0LCA2LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMiwgOCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDYsIDUsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCAyLCA5LCAxXSkgLy8gRlxuICAgIF07XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuV0VJR0hUUyA9IFtcbiAgICAgICAgWzEsIDMsIDksIDI3LCA4MSwgMzIsIDk2LCA3N10sXG4gICAgICAgIFsyMCwgNjAsIDE4MCwgMTE4LCAxNDMsIDcsIDIxLCA2M10sXG4gICAgICAgIFsxODksIDE0NSwgMTMsIDM5LCAxMTcsIDE0MCwgMjA5LCAyMDVdLFxuICAgICAgICBbMTkzLCAxNTcsIDQ5LCAxNDcsIDE5LCA1NywgMTcxLCA5MV0sXG4gICAgICAgIFs2MiwgMTg2LCAxMzYsIDE5NywgMTY5LCA4NSwgNDQsIDEzMl0sXG4gICAgICAgIFsxODUsIDEzMywgMTg4LCAxNDIsIDQsIDEyLCAzNiwgMTA4XSxcbiAgICAgICAgWzExMywgMTI4LCAxNzMsIDk3LCA4MCwgMjksIDg3LCA1MF0sXG4gICAgICAgIFsxNTAsIDI4LCA4NCwgNDEsIDEyMywgMTU4LCA1MiwgMTU2XSxcbiAgICAgICAgWzQ2LCAxMzgsIDIwMywgMTg3LCAxMzksIDIwNiwgMTk2LCAxNjZdLFxuICAgICAgICBbNzYsIDE3LCA1MSwgMTUzLCAzNywgMTExLCAxMjIsIDE1NV0sXG4gICAgICAgIFs0MywgMTI5LCAxNzYsIDEwNiwgMTA3LCAxMTAsIDExOSwgMTQ2XSxcbiAgICAgICAgWzE2LCA0OCwgMTQ0LCAxMCwgMzAsIDkwLCA1OSwgMTc3XSxcbiAgICAgICAgWzEwOSwgMTE2LCAxMzcsIDIwMCwgMTc4LCAxMTIsIDEyNSwgMTY0XSxcbiAgICAgICAgWzcwLCAyMTAsIDIwOCwgMjAyLCAxODQsIDEzMCwgMTc5LCAxMTVdLFxuICAgICAgICBbMTM0LCAxOTEsIDE1MSwgMzEsIDkzLCA2OCwgMjA0LCAxOTBdLFxuICAgICAgICBbMTQ4LCAyMiwgNjYsIDE5OCwgMTcyLCA5NCwgNzEsIDJdLFxuICAgICAgICBbNiwgMTgsIDU0LCAxNjIsIDY0LCAxOTIsIDE1NCwgNDBdLFxuICAgICAgICBbMTIwLCAxNDksIDI1LCA3NSwgMTQsIDQyLCAxMjYsIDE2N10sXG4gICAgICAgIFs3OSwgMjYsIDc4LCAyMywgNjksIDIwNywgMTk5LCAxNzVdLFxuICAgICAgICBbMTAzLCA5OCwgODMsIDM4LCAxMTQsIDEzMSwgMTgyLCAxMjRdLFxuICAgICAgICBbMTYxLCA2MSwgMTgzLCAxMjcsIDE3MCwgODgsIDUzLCAxNTldLFxuICAgICAgICBbNTUsIDE2NSwgNzMsIDgsIDI0LCA3MiwgNSwgMTVdLFxuICAgICAgICBbNDUsIDEzNSwgMTk0LCAxNjAsIDU4LCAxNzQsIDEwMCwgODldXG4gICAgXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EgPSAwO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiA9IDE7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DID0gMjtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QgPSAzO1xuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSA9IDQ7XG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GID0gNTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTl9TRVFVRU5DRVMgPSBbXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQV0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRF0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQ10sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRl0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRF0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FXSxcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRl0sXG4gICAgICAgIFtSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRl0sXG4gICAgXTtcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5NQVhfUEFJUlMgPSAxMTtcblxuICAgIGNsYXNzIFBhaXIgZXh0ZW5kcyBEYXRhQ2hhcmFjdGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIGNoZWNrc3VtUG9ydGlvbiwgZmluZGVyUGF0dGVybikge1xuICAgICAgICAgICAgc3VwZXIodmFsdWUsIGNoZWNrc3VtUG9ydGlvbik7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuZmluZGVyUGF0dGVybiA9IGZpbmRlclBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RmluZGVyUGF0dGVybigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRlclBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpbmNyZW1lbnRDb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIFJTUzE0UmVhZGVyIGV4dGVuZHMgQWJzdHJhY3RSU1NSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlTGVmdFBhaXJzID0gW107XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlUmlnaHRQYWlycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRQYWlyID0gdGhpcy5kZWNvZGVQYWlyKHJvdywgZmFsc2UsIHJvd051bWJlciwgaGludHMpO1xuICAgICAgICAgICAgUlNTMTRSZWFkZXIuYWRkT3JUYWxseSh0aGlzLnBvc3NpYmxlTGVmdFBhaXJzLCBsZWZ0UGFpcik7XG4gICAgICAgICAgICByb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGV0IHJpZ2h0UGFpciA9IHRoaXMuZGVjb2RlUGFpcihyb3csIHRydWUsIHJvd051bWJlciwgaGludHMpO1xuICAgICAgICAgICAgUlNTMTRSZWFkZXIuYWRkT3JUYWxseSh0aGlzLnBvc3NpYmxlUmlnaHRQYWlycywgcmlnaHRQYWlyKTtcbiAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBsZWZ0IG9mIHRoaXMucG9zc2libGVMZWZ0UGFpcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5nZXRDb3VudCgpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByaWdodCBvZiB0aGlzLnBvc3NpYmxlUmlnaHRQYWlycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmdldENvdW50KCkgPiAxICYmIFJTUzE0UmVhZGVyLmNoZWNrQ2hlY2tzdW0obGVmdCwgcmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJTUzE0UmVhZGVyLmNvbnN0cnVjdFJlc3VsdChsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYWRkT3JUYWxseShwb3NzaWJsZVBhaXJzLCBwYWlyKSB7XG4gICAgICAgICAgICBpZiAocGFpciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBvdGhlciBvZiBwb3NzaWJsZVBhaXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyLmdldFZhbHVlKCkgPT09IHBhaXIuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBvdGhlci5pbmNyZW1lbnRDb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhaXJzLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlTGVmdFBhaXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlUmlnaHRQYWlycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjb25zdHJ1Y3RSZXN1bHQobGVmdFBhaXIsIHJpZ2h0UGFpcikge1xuICAgICAgICAgICAgbGV0IHN5bWJvbFZhbHVlID0gNDUzNzA3NyAqIGxlZnRQYWlyLmdldFZhbHVlKCkgKyByaWdodFBhaXIuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gbmV3IFN0cmluZyhzeW1ib2xWYWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDEzIC0gdGV4dC5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuYXBwZW5kKHRleHQpO1xuICAgICAgICAgICAgbGV0IGNoZWNrRGlnaXQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0ID0gYnVmZmVyLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgY2hlY2tEaWdpdCArPSAoKGkgJiAweDAxKSA9PT0gMCkgPyAzICogZGlnaXQgOiBkaWdpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAxMCAtIChjaGVja0RpZ2l0ICUgMTApO1xuICAgICAgICAgICAgaWYgKGNoZWNrRGlnaXQgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEaWdpdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuYXBwZW5kKGNoZWNrRGlnaXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBsZXQgbGVmdFBvaW50cyA9IGxlZnRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRSZXN1bHRQb2ludHMoKTtcbiAgICAgICAgICAgIGxldCByaWdodFBvaW50cyA9IHJpZ2h0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChidWZmZXIudG9TdHJpbmcoKSwgbnVsbCwgMCwgW2xlZnRQb2ludHNbMF0sIGxlZnRQb2ludHNbMV0sIHJpZ2h0UG9pbnRzWzBdLCByaWdodFBvaW50c1sxXV0sIEJhcmNvZGVGb3JtYXQkMS5SU1NfMTQsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tDaGVja3N1bShsZWZ0UGFpciwgcmlnaHRQYWlyKSB7XG4gICAgICAgICAgICBsZXQgY2hlY2tWYWx1ZSA9IChsZWZ0UGFpci5nZXRDaGVja3N1bVBvcnRpb24oKSArIDE2ICogcmlnaHRQYWlyLmdldENoZWNrc3VtUG9ydGlvbigpKSAlIDc5O1xuICAgICAgICAgICAgbGV0IHRhcmdldENoZWNrVmFsdWUgPSA5ICogbGVmdFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFZhbHVlKCkgKyByaWdodFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2hlY2tWYWx1ZSA+IDcyKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2hlY2tWYWx1ZS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldENoZWNrVmFsdWUgPiA4KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2hlY2tWYWx1ZS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVmFsdWUgPT09IHRhcmdldENoZWNrVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUGFpcihyb3csIHJpZ2h0LCByb3dOdW1iZXIsIGhpbnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEVuZCA9IHRoaXMuZmluZEZpbmRlclBhdHRlcm4ocm93LCByaWdodCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSB0aGlzLnBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCByaWdodCwgc3RhcnRFbmQpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRQb2ludENhbGxiYWNrID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VudGVyID0gKHN0YXJ0RW5kWzBdICsgc3RhcnRFbmRbMV0pIC8gMi4wO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdyBpcyBhY3R1YWxseSByZXZlcnNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyID0gcm93LmdldFNpemUoKSAtIDEgLSBjZW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQobmV3IFJlc3VsdFBvaW50KGNlbnRlciwgcm93TnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvdXRzaWRlID0gdGhpcy5kZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IGluc2lkZSA9IHRoaXMuZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhaXIoMTU5NyAqIG91dHNpZGUuZ2V0VmFsdWUoKSArIGluc2lkZS5nZXRWYWx1ZSgpLCBvdXRzaWRlLmdldENoZWNrc3VtUG9ydGlvbigpICsgNCAqIGluc2lkZS5nZXRDaGVja3N1bVBvcnRpb24oKSwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIG91dHNpZGVDaGFyKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmdldERhdGFDaGFyYWN0ZXJDb3VudGVycygpO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjb3VudGVycy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW3hdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRzaWRlQ2hhcikge1xuICAgICAgICAgICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybkluUmV2ZXJzZShyb3csIHBhdHRlcm4uZ2V0U3RhcnRFbmQoKVswXSwgY291bnRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuKHJvdywgcGF0dGVybi5nZXRTdGFydEVuZCgpWzFdICsgMSwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgIC8vIHJldmVyc2UgaXRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGNvdW50ZXJzLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyssIGotLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tpXSA9IGNvdW50ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tqXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG51bU1vZHVsZXMgPSBvdXRzaWRlQ2hhciA/IDE2IDogMTU7XG4gICAgICAgICAgICBsZXQgZWxlbWVudFdpZHRoID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheShjb3VudGVycykpIC8gbnVtTW9kdWxlcztcbiAgICAgICAgICAgIGxldCBvZGRDb3VudHMgPSB0aGlzLmdldE9kZENvdW50cygpO1xuICAgICAgICAgICAgbGV0IGV2ZW5Db3VudHMgPSB0aGlzLmdldEV2ZW5Db3VudHMoKTtcbiAgICAgICAgICAgIGxldCBvZGRSb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKTtcbiAgICAgICAgICAgIGxldCBldmVuUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldEV2ZW5Sb3VuZGluZ0Vycm9ycygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvdW50ZXJzW2ldIC8gZWxlbWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IE1hdGguZmxvb3IodmFsdWUgKyAwLjUpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb3VudCA+IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gTWF0aC5mbG9vcihpIC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKChpICYgMHgwMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2RkQ291bnRzW29mZnNldF0gPSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgb2RkUm91bmRpbmdFcnJvcnNbb2Zmc2V0XSA9IHZhbHVlIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVuQ291bnRzW29mZnNldF0gPSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZXZlblJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0T2RkRXZlbkNvdW50cyhvdXRzaWRlQ2hhciwgbnVtTW9kdWxlcyk7XG4gICAgICAgICAgICBsZXQgb2RkU3VtID0gMDtcbiAgICAgICAgICAgIGxldCBvZGRDaGVja3N1bVBvcnRpb24gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG9kZENvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIG9kZENoZWNrc3VtUG9ydGlvbiAqPSA5O1xuICAgICAgICAgICAgICAgIG9kZENoZWNrc3VtUG9ydGlvbiArPSBvZGRDb3VudHNbaV07XG4gICAgICAgICAgICAgICAgb2RkU3VtICs9IG9kZENvdW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBldmVuQ2hlY2tzdW1Qb3J0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCBldmVuU3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBldmVuQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgZXZlbkNoZWNrc3VtUG9ydGlvbiAqPSA5O1xuICAgICAgICAgICAgICAgIGV2ZW5DaGVja3N1bVBvcnRpb24gKz0gZXZlbkNvdW50c1tpXTtcbiAgICAgICAgICAgICAgICBldmVuU3VtICs9IGV2ZW5Db3VudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hlY2tzdW1Qb3J0aW9uID0gb2RkQ2hlY2tzdW1Qb3J0aW9uICsgMyAqIGV2ZW5DaGVja3N1bVBvcnRpb247XG4gICAgICAgICAgICBpZiAob3V0c2lkZUNoYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG9kZFN1bSAmIDB4MDEpICE9PSAwIHx8IG9kZFN1bSA+IDEyIHx8IG9kZFN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBncm91cCA9ICgxMiAtIG9kZFN1bSkgLyAyO1xuICAgICAgICAgICAgICAgIGxldCBvZGRXaWRlc3QgPSBSU1MxNFJlYWRlci5PVVRTSURFX09ERF9XSURFU1RbZ3JvdXBdO1xuICAgICAgICAgICAgICAgIGxldCBldmVuV2lkZXN0ID0gOSAtIG9kZFdpZGVzdDtcbiAgICAgICAgICAgICAgICBsZXQgdk9kZCA9IFJTU1V0aWxzLmdldFJTU3ZhbHVlKG9kZENvdW50cywgb2RkV2lkZXN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGV0IHZFdmVuID0gUlNTVXRpbHMuZ2V0UlNTdmFsdWUoZXZlbkNvdW50cywgZXZlbldpZGVzdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHRFdmVuID0gUlNTMTRSZWFkZXIuT1VUU0lERV9FVkVOX1RPVEFMX1NVQlNFVFtncm91cF07XG4gICAgICAgICAgICAgICAgbGV0IGdTdW0gPSBSU1MxNFJlYWRlci5PVVRTSURFX0dTVU1bZ3JvdXBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUNoYXJhY3Rlcih2T2RkICogdEV2ZW4gKyB2RXZlbiArIGdTdW0sIGNoZWNrc3VtUG9ydGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKGV2ZW5TdW0gJiAweDAxKSAhPT0gMCB8fCBldmVuU3VtID4gMTAgfHwgZXZlblN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBncm91cCA9ICgxMCAtIGV2ZW5TdW0pIC8gMjtcbiAgICAgICAgICAgICAgICBsZXQgb2RkV2lkZXN0ID0gUlNTMTRSZWFkZXIuSU5TSURFX09ERF9XSURFU1RbZ3JvdXBdO1xuICAgICAgICAgICAgICAgIGxldCBldmVuV2lkZXN0ID0gOSAtIG9kZFdpZGVzdDtcbiAgICAgICAgICAgICAgICBsZXQgdk9kZCA9IFJTU1V0aWxzLmdldFJTU3ZhbHVlKG9kZENvdW50cywgb2RkV2lkZXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgdkV2ZW4gPSBSU1NVdGlscy5nZXRSU1N2YWx1ZShldmVuQ291bnRzLCBldmVuV2lkZXN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGV0IHRPZGQgPSBSU1MxNFJlYWRlci5JTlNJREVfT0REX1RPVEFMX1NVQlNFVFtncm91cF07XG4gICAgICAgICAgICAgICAgbGV0IGdTdW0gPSBSU1MxNFJlYWRlci5JTlNJREVfR1NVTVtncm91cF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhQ2hhcmFjdGVyKHZFdmVuICogdE9kZCArIHZPZGQgKyBnU3VtLCBjaGVja3N1bVBvcnRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmRGaW5kZXJQYXR0ZXJuKHJvdywgcmlnaHRGaW5kZXJQYXR0ZXJuKSB7XG4gICAgICAgICAgICBsZXQgY291bnRlcnMgPSB0aGlzLmdldERlY29kZUZpbmRlckNvdW50ZXJzKCk7XG4gICAgICAgICAgICBjb3VudGVyc1swXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1sxXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCByb3dPZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJvd09mZnNldCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFyb3cuZ2V0KHJvd09mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0RmluZGVyUGF0dGVybiA9PT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaWxsIGVuY291bnRlciB3aGl0ZSBmaXJzdCB3aGVuIHNlYXJjaGluZyBmb3IgcmlnaHQgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd09mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93LmdldCh4KSAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQWJzdHJhY3RSU1NSZWFkZXIuaXNGaW5kZXJQYXR0ZXJuKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGF0dGVyblN0YXJ0LCB4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMF0gPSBjb3VudGVyc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gY291bnRlcnNbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1syXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VGb3VuZEZpbmRlclBhdHRlcm4ocm93LCByb3dOdW1iZXIsIHJpZ2h0LCBzdGFydEVuZCkge1xuICAgICAgICAgICAgLy8gQWN0dWFsbHkgd2UgZm91bmQgZWxlbWVudHMgMi01XG4gICAgICAgICAgICBsZXQgZmlyc3RJc0JsYWNrID0gcm93LmdldChzdGFydEVuZFswXSk7XG4gICAgICAgICAgICBsZXQgZmlyc3RFbGVtZW50U3RhcnQgPSBzdGFydEVuZFswXSAtIDE7XG4gICAgICAgICAgICAvLyBMb2NhdGUgZWxlbWVudCAxXG4gICAgICAgICAgICB3aGlsZSAoZmlyc3RFbGVtZW50U3RhcnQgPj0gMCAmJiBmaXJzdElzQmxhY2sgIT09IHJvdy5nZXQoZmlyc3RFbGVtZW50U3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50U3RhcnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0RWxlbWVudFN0YXJ0Kys7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENvdW50ZXIgPSBzdGFydEVuZFswXSAtIGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgLy8gTWFrZSAnY291bnRlcnMnIGhvbGQgMS00XG4gICAgICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgSW50MzJBcnJheShjb3VudGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb3VudGVycywgMCwgY29weSwgMSwgY291bnRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb3B5WzBdID0gZmlyc3RDb3VudGVyO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnBhcnNlRmluZGVyVmFsdWUoY29weSwgUlNTMTRSZWFkZXIuRklOREVSX1BBVFRFUk5TKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGZpcnN0RWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0RW5kWzFdO1xuICAgICAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gcm93IGlzIGFjdHVhbGx5IHJldmVyc2VkXG4gICAgICAgICAgICAgICAgc3RhcnQgPSByb3cuZ2V0U2l6ZSgpIC0gMSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGVuZCA9IHJvdy5nZXRTaXplKCkgLSAxIC0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuKHZhbHVlLCBbZmlyc3RFbGVtZW50U3RhcnQsIHN0YXJ0RW5kWzFdXSwgc3RhcnQsIGVuZCwgcm93TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBhZGp1c3RPZGRFdmVuQ291bnRzKG91dHNpZGVDaGFyLCBudW1Nb2R1bGVzKSB7XG4gICAgICAgICAgICBsZXQgb2RkU3VtID0gTWF0aFV0aWxzLnN1bShuZXcgSW50MzJBcnJheSh0aGlzLmdldE9kZENvdW50cygpKSk7XG4gICAgICAgICAgICBsZXQgZXZlblN1bSA9IE1hdGhVdGlscy5zdW0obmV3IEludDMyQXJyYXkodGhpcy5nZXRFdmVuQ291bnRzKCkpKTtcbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnRPZGQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRPZGQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbmNyZW1lbnRFdmVuID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGVjcmVtZW50RXZlbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG91dHNpZGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFN1bSA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9kZFN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW5TdW0gPiAxMikge1xuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlblN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9kZFN1bSA+IDExKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9kZFN1bSA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW5TdW0gPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlblN1bSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pc21hdGNoID0gb2RkU3VtICsgZXZlblN1bSAtIG51bU1vZHVsZXM7XG4gICAgICAgICAgICBsZXQgb2RkUGFyaXR5QmFkID0gKG9kZFN1bSAmIDB4MDEpID09PSAob3V0c2lkZUNoYXIgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgZXZlblBhcml0eUJhZCA9IChldmVuU3VtICYgMHgwMSkgPT09IDE7XG4gICAgICAgICAgICBpZiAobWlzbWF0Y2ggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIGJhZFxuICAgICAgICAgICAgICAgICAgICBpZiAob2RkU3VtIDwgZXZlblN1bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjcmVtZW50T2RkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBYnN0cmFjdFJTU1JlYWRlci5pbmNyZW1lbnQodGhpcy5nZXRPZGRDb3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcbiAgICAgICAgICAgICAgICBBYnN0cmFjdFJTU1JlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRPZGRDb3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY3JlbWVudEV2ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyLmluY3JlbWVudCh0aGlzLmdldEV2ZW5Db3VudHMoKSwgdGhpcy5nZXRPZGRSb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XG4gICAgICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXIuZGVjcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldEV2ZW5Sb3VuZGluZ0Vycm9ycygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSU1MxNFJlYWRlci5PVVRTSURFX0VWRU5fVE9UQUxfU1VCU0VUID0gWzEsIDEwLCAzNCwgNzAsIDEyNl07XG4gICAgUlNTMTRSZWFkZXIuSU5TSURFX09ERF9UT1RBTF9TVUJTRVQgPSBbNCwgMjAsIDQ4LCA4MV07XG4gICAgUlNTMTRSZWFkZXIuT1VUU0lERV9HU1VNID0gWzAsIDE2MSwgOTYxLCAyMDE1LCAyNzE1XTtcbiAgICBSU1MxNFJlYWRlci5JTlNJREVfR1NVTSA9IFswLCAzMzYsIDEwMzYsIDE1MTZdO1xuICAgIFJTUzE0UmVhZGVyLk9VVFNJREVfT0REX1dJREVTVCA9IFs4LCA2LCA0LCAzLCAxXTtcbiAgICBSU1MxNFJlYWRlci5JTlNJREVfT0REX1dJREVTVCA9IFsyLCA0LCA2LCA4XTtcbiAgICBSU1MxNFJlYWRlci5GSU5ERVJfUEFUVEVSTlMgPSBbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgOCwgMiwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzMsIDUsIDUsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCAzLCA3LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMywgMSwgOSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzIsIDcsIDQsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA1LCA2LCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgMywgOCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDUsIDcsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAzLCA5LCAxXSksXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgRGFuaWVsIFN3aXRraW4gPGRzd2l0a2luQGdvb2dsZS5jb20+XG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBNdWx0aUZvcm1hdE9uZURSZWFkZXIgZXh0ZW5kcyBPbmVEUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaGludHMsIHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmVyYm9zZSA9ICh2ZXJib3NlID09PSB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlRm9ybWF0cyA9ICFoaW50cyA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5QT1NTSUJMRV9GT1JNQVRTKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZUNvZGUzOUNoZWNrRGlnaXQgPSBoaW50cyAmJiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5BU1NVTUVfQ09ERV8zOV9DSEVDS19ESUdJVCkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5FQU5fMTMpIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuVVBDX0EpIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuRUFOXzgpIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuVVBDX0UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcihoaW50cykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5DT0RFXzM5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTM5UmVhZGVyKHVzZUNvZGUzOUNoZWNrRGlnaXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0LkNPREVfOTMpKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGU5M1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuQ09ERV8xMjgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlMTI4UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5JVEYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBJVEZSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdC5DT0RBQkFSKSkge1xuICAgICAgICAgICAgICAgIC8vICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RhQmFyUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5SU1NfMTQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBSU1MxNFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuUlNTX0VYUEFOREVEKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTRXhwYW5kZWRSZWFkZXIodGhpcy52ZXJib3NlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDYXNlIHdoZW4gbm8gaGludHMgd2VyZSBwcm92aWRlZCAtPiBhZGQgYWxsLlxuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcihoaW50cykpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlMzlSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGFCYXJSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGU5M1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRVUENFQU5SZWFkZXIoaGludHMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTEyOFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgSVRGUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBSU1MxNFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTRXhwYW5kZWRSZWFkZXIodGhpcy52ZXJib3NlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIGRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyc1tpXS5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGhpbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQE92ZXJyaWRlXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXJzLmZvckVhY2gocmVhZGVyID0+IHJlYWRlci5yZXNldCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqXG4gICAgICogQmFyY29kZSByZWFkZXIgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXG4gICAgICovXG4gICAgY2xhc3MgQnJvd3NlckJhcmNvZGVSZWFkZXIgZXh0ZW5kcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJCYXJjb2RlUmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqIEBwYXJhbSB7TWFwPERlY29kZUhpbnRUeXBlLCBhbnk+fSBoaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCwgaGludHMpIHtcbiAgICAgICAgICAgIHN1cGVyKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzLCBoaW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIHNldCBvZiBlcnJvci1jb3JyZWN0aW9uIGJsb2NrcyBpbiBvbmUgc3ltYm9sIHZlcnNpb24uIE1vc3QgdmVyc2lvbnMgd2lsbFxuICAgICAqIHVzZSBibG9ja3Mgb2YgZGlmZmVyaW5nIHNpemVzIHdpdGhpbiBvbmUgdmVyc2lvbiwgc28sIHRoaXMgZW5jYXBzdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvclxuICAgICAqIGVhY2ggc2V0IG9mIGJsb2Nrcy4gSXQgYWxzbyBob2xkcyB0aGUgbnVtYmVyIG9mIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHBlciBibG9jayBzaW5jZSBpdFxuICAgICAqIHdpbGwgYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBibG9ja3Mgd2l0aGluIG9uZSB2ZXJzaW9uLjwvcD5cbiAgICAgKi9cbiAgICBjbGFzcyBFQ0Jsb2NrcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGVjQ29kZXdvcmRzLCBlY0Jsb2NrczEsIGVjQmxvY2tzMikge1xuICAgICAgICAgICAgdGhpcy5lY0NvZGV3b3JkcyA9IGVjQ29kZXdvcmRzO1xuICAgICAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IFtlY0Jsb2NrczFdO1xuICAgICAgICAgICAgZWNCbG9ja3MyICYmIHRoaXMuZWNCbG9ja3MucHVzaChlY0Jsb2NrczIpO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNCbG9ja3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2NrcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yIG9uZSBlcnJvci1jb3JyZWN0aW9uIGJsb2NrIGluIG9uZSBzeW1ib2wgdmVyc2lvbi5cbiAgICAgKiBUaGlzIGluY2x1ZGVzIHRoZSBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHMsIGFuZCB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgYmxvY2sgd2l0aCB0aGVzZVxuICAgICAqIHBhcmFtZXRlcnMgaXMgdXNlZCBjb25zZWN1dGl2ZWx5IGluIHRoZSBEYXRhIE1hdHJpeCBjb2RlIHZlcnNpb24ncyBmb3JtYXQuPC9wPlxuICAgICAqL1xuICAgIGNsYXNzIEVDQiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvdW50LCBkYXRhQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgICAgICB0aGlzLmRhdGFDb2Rld29yZHMgPSBkYXRhQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YUNvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIFZlcnNpb24gb2JqZWN0IGVuY2Fwc3VsYXRlcyBhdHRyaWJ1dGVzIGFib3V0IGEgcGFydGljdWxhclxuICAgICAqIHNpemUgRGF0YSBNYXRyaXggQ29kZS5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqL1xuICAgIGNsYXNzIFZlcnNpb24ge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uTnVtYmVyLCBzeW1ib2xTaXplUm93cywgc3ltYm9sU2l6ZUNvbHVtbnMsIGRhdGFSZWdpb25TaXplUm93cywgZGF0YVJlZ2lvblNpemVDb2x1bW5zLCBlY0Jsb2Nrcykge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uTnVtYmVyID0gdmVyc2lvbk51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sU2l6ZVJvd3MgPSBzeW1ib2xTaXplUm93cztcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sU2l6ZUNvbHVtbnMgPSBzeW1ib2xTaXplQ29sdW1ucztcbiAgICAgICAgICAgIHRoaXMuZGF0YVJlZ2lvblNpemVSb3dzID0gZGF0YVJlZ2lvblNpemVSb3dzO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVnaW9uU2l6ZUNvbHVtbnMgPSBkYXRhUmVnaW9uU2l6ZUNvbHVtbnM7XG4gICAgICAgICAgICB0aGlzLmVjQmxvY2tzID0gZWNCbG9ja3M7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBjb2Rld29yZHNcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBjb25zdCBlY0NvZGV3b3JkcyA9IGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICBjb25zdCBlY2JBcnJheSA9IGVjQmxvY2tzLmdldEVDQmxvY2tzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBlY0Jsb2NrIG9mIGVjYkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZWNCbG9jay5nZXRDb3VudCgpICogKGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpICsgZWNDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50b3RhbENvZGV3b3JkcyA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGdldFZlcnNpb25OdW1iZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGdldFN5bWJvbFNpemVSb3dzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sU2l6ZVJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3ltYm9sU2l6ZUNvbHVtbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xTaXplQ29sdW1ucztcbiAgICAgICAgfVxuICAgICAgICBnZXREYXRhUmVnaW9uU2l6ZVJvd3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhUmVnaW9uU2l6ZVJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YVJlZ2lvblNpemVDb2x1bW5zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIGdldFRvdGFsQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RUNCbG9ja3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2NrcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGVkdWNlcyB2ZXJzaW9uIGluZm9ybWF0aW9uIGZyb20gRGF0YSBNYXRyaXggZGltZW5zaW9ucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIG1vZHVsZXNcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gbW9kdWxlc1xuICAgICAgICAgKiBAcmV0dXJuIFZlcnNpb24gZm9yIGEgRGF0YSBNYXRyaXggQ29kZSBvZiB0aG9zZSBkaW1lbnNpb25zXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGRpbWVuc2lvbnMgZG8gY29ycmVzcG9uZCB0byBhIHZhbGlkIERhdGEgTWF0cml4IHNpemVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXRWZXJzaW9uRm9yRGltZW5zaW9ucyhudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBpZiAoKG51bVJvd3MgJiAweDAxKSAhPT0gMCB8fCAobnVtQ29sdW1ucyAmIDB4MDEpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgdmVyc2lvbiBvZiBWZXJzaW9uLlZFUlNJT05TKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb24uc3ltYm9sU2l6ZVJvd3MgPT09IG51bVJvd3MgJiYgdmVyc2lvbi5zeW1ib2xTaXplQ29sdW1ucyA9PT0gbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2IDUuNS4xIFRhYmxlIDdcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBidWlsZFZlcnNpb25zKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxLCAxMCwgMTAsIDgsIDgsIG5ldyBFQ0Jsb2Nrcyg1LCBuZXcgRUNCKDEsIDMpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMiwgMTIsIDEyLCAxMCwgMTAsIG5ldyBFQ0Jsb2Nrcyg3LCBuZXcgRUNCKDEsIDUpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMywgMTQsIDE0LCAxMiwgMTIsIG5ldyBFQ0Jsb2NrcygxMCwgbmV3IEVDQigxLCA4KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDQsIDE2LCAxNiwgMTQsIDE0LCBuZXcgRUNCbG9ja3MoMTIsIG5ldyBFQ0IoMSwgMTIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oNSwgMTgsIDE4LCAxNiwgMTYsIG5ldyBFQ0Jsb2NrcygxNCwgbmV3IEVDQigxLCAxOCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig2LCAyMCwgMjAsIDE4LCAxOCwgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDEsIDIyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDcsIDIyLCAyMiwgMjAsIDIwLCBuZXcgRUNCbG9ja3MoMjAsIG5ldyBFQ0IoMSwgMzApKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oOCwgMjQsIDI0LCAyMiwgMjIsIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQigxLCAzNikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbig5LCAyNiwgMjYsIDI0LCAyNCwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDQ0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDEwLCAzMiwgMzIsIDE0LCAxNCwgbmV3IEVDQmxvY2tzKDM2LCBuZXcgRUNCKDEsIDYyKSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDExLCAzNiwgMzYsIDE2LCAxNiwgbmV3IEVDQmxvY2tzKDQyLCBuZXcgRUNCKDEsIDg2KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDEyLCA0MCwgNDAsIDE4LCAxOCwgbmV3IEVDQmxvY2tzKDQ4LCBuZXcgRUNCKDEsIDExNCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxMywgNDQsIDQ0LCAyMCwgMjAsIG5ldyBFQ0Jsb2Nrcyg1NiwgbmV3IEVDQigxLCAxNDQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTQsIDQ4LCA0OCwgMjIsIDIyLCBuZXcgRUNCbG9ja3MoNjgsIG5ldyBFQ0IoMSwgMTc0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE1LCA1MiwgNTIsIDI0LCAyNCwgbmV3IEVDQmxvY2tzKDQyLCBuZXcgRUNCKDIsIDEwMikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigxNiwgNjQsIDY0LCAxNCwgMTQsIG5ldyBFQ0Jsb2Nrcyg1NiwgbmV3IEVDQigyLCAxNDApKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTcsIDcyLCA3MiwgMTYsIDE2LCBuZXcgRUNCbG9ja3MoMzYsIG5ldyBFQ0IoNCwgOTIpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMTgsIDgwLCA4MCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNDgsIG5ldyBFQ0IoNCwgMTE0KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE5LCA4OCwgODgsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDU2LCBuZXcgRUNCKDQsIDE0NCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyMCwgOTYsIDk2LCAyMiwgMjIsIG5ldyBFQ0Jsb2Nrcyg2OCwgbmV3IEVDQig0LCAxNzQpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjEsIDEwNCwgMTA0LCAyNCwgMjQsIG5ldyBFQ0Jsb2Nrcyg1NiwgbmV3IEVDQig2LCAxMzYpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjIsIDEyMCwgMTIwLCAxOCwgMTgsIG5ldyBFQ0Jsb2Nrcyg2OCwgbmV3IEVDQig2LCAxNzUpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjMsIDEzMiwgMTMyLCAyMCwgMjAsIG5ldyBFQ0Jsb2Nrcyg2MiwgbmV3IEVDQig4LCAxNjMpKSksXG4gICAgICAgICAgICAgICAgbmV3IFZlcnNpb24oMjQsIDE0NCwgMTQ0LCAyMiwgMjIsIG5ldyBFQ0Jsb2Nrcyg2MiwgbmV3IEVDQig4LCAxNTYpLCBuZXcgRUNCKDIsIDE1NSkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyNSwgOCwgMTgsIDYsIDE2LCBuZXcgRUNCbG9ja3MoNywgbmV3IEVDQigxLCA1KSkpLFxuICAgICAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI2LCA4LCAzMiwgNiwgMTQsIG5ldyBFQ0Jsb2NrcygxMSwgbmV3IEVDQigxLCAxMCkpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyNywgMTIsIDI2LCAxMCwgMjQsIG5ldyBFQ0Jsb2NrcygxNCwgbmV3IEVDQigxLCAxNikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyOCwgMTIsIDM2LCAxMCwgMTYsIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigxLCAyMikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigyOSwgMTYsIDM2LCAxNCwgMTYsIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQigxLCAzMikpKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVyc2lvbigzMCwgMTYsIDQ4LCAxNCwgMjIsIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxLCA0OSkpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWZXJzaW9uLlZFUlNJT05TID0gVmVyc2lvbi5idWlsZFZlcnNpb25zKCk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqL1xuICAgIGNsYXNzIEJpdE1hdHJpeFBhcnNlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYml0TWF0cml4IHtAbGluayBCaXRNYXRyaXh9IHRvIHBhcnNlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGRpbWVuc2lvbiBpcyA8IDggb3IgPiAxNDQgb3Igbm90IDAgbW9kIDJcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGJpdE1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbiA8IDggfHwgZGltZW5zaW9uID4gMTQ0IHx8IChkaW1lbnNpb24gJiAweDAxKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IEJpdE1hdHJpeFBhcnNlci5yZWFkVmVyc2lvbihiaXRNYXRyaXgpO1xuICAgICAgICAgICAgdGhpcy5tYXBwaW5nQml0TWF0cml4ID0gdGhpcy5leHRyYWN0RGF0YVJlZ2lvbihiaXRNYXRyaXgpO1xuICAgICAgICAgICAgdGhpcy5yZWFkTWFwcGluZ01hdHJpeCA9IG5ldyBCaXRNYXRyaXgodGhpcy5tYXBwaW5nQml0TWF0cml4LmdldFdpZHRoKCksIHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXRIZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkNyZWF0ZXMgdGhlIHZlcnNpb24gb2JqZWN0IGJhc2VkIG9uIHRoZSBkaW1lbnNpb24gb2YgdGhlIG9yaWdpbmFsIGJpdCBtYXRyaXggZnJvbVxuICAgICAgICAgKiB0aGUgZGF0YW1hdHJpeCBjb2RlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2IFRhYmxlIDcgLSBFQ0MgMjAwIHN5bWJvbCBhdHRyaWJ1dGVzPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYml0TWF0cml4IE9yaWdpbmFsIHtAbGluayBCaXRNYXRyaXh9IGluY2x1ZGluZyBhbGlnbm1lbnQgcGF0dGVybnNcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgVmVyc2lvbn0gZW5jYXBzdWxhdGluZyB0aGUgRGF0YSBNYXRyaXggQ29kZSdzIFwidmVyc2lvblwiXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBtYXBwaW5nIG1hdHJpeCBhcmUgbm90IHZhbGlkXG4gICAgICAgICAqIERhdGEgTWF0cml4IGRpbWVuc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmVhZFZlcnNpb24oYml0TWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBudW1Sb3dzID0gYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgbnVtQ29sdW1ucyA9IGJpdE1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24uZ2V0VmVyc2lvbkZvckRpbWVuc2lvbnMobnVtUm93cywgbnVtQ29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSBiaXRzIGluIHRoZSB7QGxpbmsgQml0TWF0cml4fSByZXByZXNlbnRpbmcgdGhlIG1hcHBpbmcgbWF0cml4IChObyBhbGlnbm1lbnQgcGF0dGVybnMpXG4gICAgICAgICAqIGluIHRoZSBjb3JyZWN0IG9yZGVyIGluIG9yZGVyIHRvIHJlY29uc3RpdHV0ZSB0aGUgY29kZXdvcmRzIGJ5dGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlXG4gICAgICAgICAqIERhdGEgTWF0cml4IENvZGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgaXMgbm90IHJlYWRcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50OEFycmF5KHRoaXMudmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IHJvdyA9IDQ7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG51bVJvd3MgPSB0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBudW1Db2x1bW5zID0gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBsZXQgY29ybmVyMVJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjb3JuZXIyUmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGNvcm5lcjNSZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY29ybmVyNFJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFJlYWQgYWxsIG9mIHRoZSBjb2Rld29yZHNcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgZm91ciBjb3JuZXIgY2FzZXNcbiAgICAgICAgICAgICAgICBpZiAoKHJvdyA9PT0gbnVtUm93cykgJiYgKGNvbHVtbiA9PT0gMCkgJiYgIWNvcm5lcjFSZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIxKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgcm93IC09IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb3JuZXIxUmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChyb3cgPT09IG51bVJvd3MgLSAyKSAmJiAoY29sdW1uID09PSAwKSAmJiAoKG51bUNvbHVtbnMgJiAweDAzKSAhPT0gMCkgJiYgIWNvcm5lcjJSZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIyKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgcm93IC09IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb3JuZXIyUmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChyb3cgPT09IG51bVJvd3MgKyA0KSAmJiAoY29sdW1uID09PSAyKSAmJiAoKG51bUNvbHVtbnMgJiAweDA3KSA9PT0gMCkgJiYgIWNvcm5lcjNSZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIzKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgcm93IC09IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb3JuZXIzUmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChyb3cgPT09IG51bVJvd3MgLSAyKSAmJiAoY29sdW1uID09PSAwKSAmJiAoKG51bUNvbHVtbnMgJiAweDA3KSA9PT0gNCkgJiYgIWNvcm5lcjRSZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXI0KG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgcm93IC09IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICBjb3JuZXI0UmVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTd2VlcCB1cHdhcmQgZGlhZ29uYWxseSB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPCBudW1Sb3dzKSAmJiAoY29sdW1uID49IDApICYmICF0aGlzLnJlYWRNYXBwaW5nTWF0cml4LmdldChjb2x1bW4sIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkVXRhaChyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93IC09IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKHJvdyA+PSAwKSAmJiAoY29sdW1uIDwgbnVtQ29sdW1ucykpO1xuICAgICAgICAgICAgICAgICAgICByb3cgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN3ZWVwIGRvd253YXJkIGRpYWdvbmFsbHkgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPj0gMCkgJiYgKGNvbHVtbiA8IG51bUNvbHVtbnMpICYmICF0aGlzLnJlYWRNYXBwaW5nTWF0cml4LmdldChjb2x1bW4sIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkVXRhaChyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoKHJvdyA8IG51bVJvd3MpICYmIChjb2x1bW4gPj0gMCkpO1xuICAgICAgICAgICAgICAgICAgICByb3cgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoKHJvdyA8IG51bVJvd3MpIHx8IChjb2x1bW4gPCBudW1Db2x1bW5zKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0T2Zmc2V0ICE9PSB0aGlzLnZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIGEgYml0IG9mIHRoZSBtYXBwaW5nIG1hdHJpeCBhY2NvdW50aW5nIGZvciBib3VuZGFyeSB3cmFwcGluZy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3cgUm93IHRvIHJlYWQgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBjb2x1bW4gQ29sdW1uIHRvIHJlYWQgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYml0IGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZE1vZHVsZShyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSByb3cgYW5kIGNvbHVtbiBpbmRpY2VzIGJhc2VkIG9uIGJvdW5kYXJ5IHdyYXBwaW5nXG4gICAgICAgICAgICBpZiAocm93IDwgMCkge1xuICAgICAgICAgICAgICAgIHJvdyArPSBudW1Sb3dzO1xuICAgICAgICAgICAgICAgIGNvbHVtbiArPSA0IC0gKChudW1Sb3dzICsgNCkgJiAweDA3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2x1bW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IG51bUNvbHVtbnM7XG4gICAgICAgICAgICAgICAgcm93ICs9IDQgLSAoKG51bUNvbHVtbnMgKyA0KSAmIDB4MDcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTWFwcGluZ01hdHJpeC5zZXQoY29sdW1uLCByb3cpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXQoY29sdW1uLCByb3cpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzdGFuZGFyZCBVdGFoLXNoYXBlZCBwYXR0ZXJuLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCA1LjguMSBGaWd1cmUgNjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJvdyBDdXJyZW50IHJvdyBpbiB0aGUgbWFwcGluZyBtYXRyaXgsIGFuY2hvcmVkIGF0IHRoZSA4dGggYml0IChMU0IpIG9mIHRoZSBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBjb2x1bW4gQ3VycmVudCBjb2x1bW4gaW4gdGhlIG1hcHBpbmcgbWF0cml4LCBhbmNob3JlZCBhdCB0aGUgOHRoIGJpdCAoTFNCKSBvZiB0aGUgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSB1dGFoIHNoYXBlXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVXRhaChyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMiwgY29sdW1uIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdyAtIDIsIGNvbHVtbiAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMSwgY29sdW1uIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdyAtIDEsIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdywgY29sdW1uIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdywgY29sdW1uIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdywgY29sdW1uLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiAxLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi4zPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDFcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb3JuZXIxKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDIsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMywgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDIuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIEZpZ3VyZSBGLjQ8L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcbiAgICAgICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gMlxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvcm5lcjIobnVtUm93cywgbnVtQ29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCeXRlID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDMsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMiwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDQsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMywgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzcGVjaWFsIGNvcm5lciBjb25kaXRpb24gMy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgRmlndXJlIEYuNTwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgQ29ybmVyIGNvbmRpdGlvbiAzXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29ybmVyMyhudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAzLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAzLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgxLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzcGVjaWFsIGNvcm5lciBjb25kaXRpb24gNC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgRmlndXJlIEYuNjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxuICAgICAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgQ29ybmVyIGNvbmRpdGlvbiA0XG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29ybmVyNChudW1Sb3dzLCBudW1Db2x1bW5zKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMywgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAyLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgwLCBudW1Db2x1bW5zIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZSgyLCBudW1Db2x1bW5zIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDMsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkV4dHJhY3RzIHRoZSBkYXRhIHJlZ2lvbiBmcm9tIGEge0BsaW5rIEJpdE1hdHJpeH0gdGhhdCBjb250YWluc1xuICAgICAgICAgKiBhbGlnbm1lbnQgcGF0dGVybnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYml0TWF0cml4IE9yaWdpbmFsIHtAbGluayBCaXRNYXRyaXh9IHdpdGggYWxpZ25tZW50IHBhdHRlcm5zXG4gICAgICAgICAqIEByZXR1cm4gQml0TWF0cml4IHRoYXQgaGFzIHRoZSBhbGlnbm1lbnQgcGF0dGVybnMgcmVtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdERhdGFSZWdpb24oYml0TWF0cml4KSB7XG4gICAgICAgICAgICBjb25zdCBzeW1ib2xTaXplUm93cyA9IHRoaXMudmVyc2lvbi5nZXRTeW1ib2xTaXplUm93cygpO1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9sU2l6ZUNvbHVtbnMgPSB0aGlzLnZlcnNpb24uZ2V0U3ltYm9sU2l6ZUNvbHVtbnMoKTtcbiAgICAgICAgICAgIGlmIChiaXRNYXRyaXguZ2V0SGVpZ2h0KCkgIT09IHN5bWJvbFNpemVSb3dzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGltZW5zaW9uIG9mIGJpdE1hdHJpeCBtdXN0IG1hdGNoIHRoZSB2ZXJzaW9uIHNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGFSZWdpb25TaXplUm93cyA9IHRoaXMudmVyc2lvbi5nZXREYXRhUmVnaW9uU2l6ZVJvd3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFSZWdpb25TaXplQ29sdW1ucyA9IHRoaXMudmVyc2lvbi5nZXREYXRhUmVnaW9uU2l6ZUNvbHVtbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFSZWdpb25zUm93ID0gc3ltYm9sU2l6ZVJvd3MgLyBkYXRhUmVnaW9uU2l6ZVJvd3MgfCAwO1xuICAgICAgICAgICAgY29uc3QgbnVtRGF0YVJlZ2lvbnNDb2x1bW4gPSBzeW1ib2xTaXplQ29sdW1ucyAvIGRhdGFSZWdpb25TaXplQ29sdW1ucyB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaXplRGF0YVJlZ2lvblJvdyA9IG51bURhdGFSZWdpb25zUm93ICogZGF0YVJlZ2lvblNpemVSb3dzO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZURhdGFSZWdpb25Db2x1bW4gPSBudW1EYXRhUmVnaW9uc0NvbHVtbiAqIGRhdGFSZWdpb25TaXplQ29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IGJpdE1hdHJpeFdpdGhvdXRBbGlnbm1lbnQgPSBuZXcgQml0TWF0cml4KHNpemVEYXRhUmVnaW9uQ29sdW1uLCBzaXplRGF0YVJlZ2lvblJvdyk7XG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhUmVnaW9uUm93ID0gMDsgZGF0YVJlZ2lvblJvdyA8IG51bURhdGFSZWdpb25zUm93OyArK2RhdGFSZWdpb25Sb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVnaW9uUm93T2Zmc2V0ID0gZGF0YVJlZ2lvblJvdyAqIGRhdGFSZWdpb25TaXplUm93cztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkYXRhUmVnaW9uQ29sdW1uID0gMDsgZGF0YVJlZ2lvbkNvbHVtbiA8IG51bURhdGFSZWdpb25zQ29sdW1uOyArK2RhdGFSZWdpb25Db2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YVJlZ2lvbkNvbHVtbk9mZnNldCA9IGRhdGFSZWdpb25Db2x1bW4gKiBkYXRhUmVnaW9uU2l6ZUNvbHVtbnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVJlZ2lvblNpemVSb3dzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRSb3dPZmZzZXQgPSBkYXRhUmVnaW9uUm93ICogKGRhdGFSZWdpb25TaXplUm93cyArIDIpICsgMSArIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cml0ZVJvd09mZnNldCA9IGRhdGFSZWdpb25Sb3dPZmZzZXQgKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXRhUmVnaW9uU2l6ZUNvbHVtbnM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRDb2x1bW5PZmZzZXQgPSBkYXRhUmVnaW9uQ29sdW1uICogKGRhdGFSZWdpb25TaXplQ29sdW1ucyArIDIpICsgMSArIGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdE1hdHJpeC5nZXQocmVhZENvbHVtbk9mZnNldCwgcmVhZFJvd09mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVDb2x1bW5PZmZzZXQgPSBkYXRhUmVnaW9uQ29sdW1uT2Zmc2V0ICsgajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0TWF0cml4V2l0aG91dEFsaWdubWVudC5zZXQod3JpdGVDb2x1bW5PZmZzZXQsIHdyaXRlUm93T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYml0TWF0cml4V2l0aG91dEFsaWdubWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhIGJsb2NrIG9mIGRhdGEgd2l0aGluIGEgRGF0YSBNYXRyaXggQ29kZS4gRGF0YSBNYXRyaXggQ29kZXMgbWF5IHNwbGl0IHRoZWlyIGRhdGEgaW50b1xuICAgICAqIG11bHRpcGxlIGJsb2NrcywgZWFjaCBvZiB3aGljaCBpcyBhIHVuaXQgb2YgZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMuIEVhY2hcbiAgICAgKiBpcyByZXByZXNlbnRlZCBieSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxuICAgICAqL1xuICAgIGNsYXNzIERhdGFCbG9jayB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG51bURhdGFDb2Rld29yZHMsIGNvZGV3b3Jkcykge1xuICAgICAgICAgICAgdGhpcy5udW1EYXRhQ29kZXdvcmRzID0gbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgICAgIHRoaXMuY29kZXdvcmRzID0gY29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5XaGVuIERhdGEgTWF0cml4IENvZGVzIHVzZSBtdWx0aXBsZSBkYXRhIGJsb2NrcywgdGhleSBhY3R1YWxseSBpbnRlcmxlYXZlIHRoZSBieXRlcyBvZiBlYWNoIG9mIHRoZW0uXG4gICAgICAgICAqIFRoYXQgaXMsIHRoZSBmaXJzdCBieXRlIG9mIGRhdGEgYmxvY2sgMSB0byBuIGlzIHdyaXR0ZW4sIHRoZW4gdGhlIHNlY29uZCBieXRlcywgYW5kIHNvIG9uLiBUaGlzXG4gICAgICAgICAqIG1ldGhvZCB3aWxsIHNlcGFyYXRlIHRoZSBkYXRhIGludG8gb3JpZ2luYWwgYmxvY2tzLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJhd0NvZGV3b3JkcyBieXRlcyBhcyByZWFkIGRpcmVjdGx5IGZyb20gdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgICAgICogQHBhcmFtIHZlcnNpb24gdmVyc2lvbiBvZiB0aGUgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKiBAcmV0dXJuIERhdGFCbG9ja3MgY29udGFpbmluZyBvcmlnaW5hbCBieXRlcywgXCJkZS1pbnRlcmxlYXZlZFwiIGZyb20gcmVwcmVzZW50YXRpb24gaW4gdGhlXG4gICAgICAgICAqICAgICAgICAgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldERhdGFCbG9ja3MocmF3Q29kZXdvcmRzLCB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBudW1iZXIgYW5kIHNpemUgb2YgZGF0YSBibG9ja3MgdXNlZCBieSB0aGlzIHZlcnNpb25cbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2NrcygpO1xuICAgICAgICAgICAgLy8gRmlyc3QgY291bnQgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgbGV0IHRvdGFsQmxvY2tzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tBcnJheSA9IGVjQmxvY2tzLmdldEVDQmxvY2tzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBlY0Jsb2NrIG9mIGVjQmxvY2tBcnJheSkge1xuICAgICAgICAgICAgICAgIHRvdGFsQmxvY2tzICs9IGVjQmxvY2suZ2V0Q291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBlc3RhYmxpc2ggRGF0YUJsb2NrcyBvZiB0aGUgYXBwcm9wcmlhdGUgc2l6ZSBhbmQgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkodG90YWxCbG9ja3MpO1xuICAgICAgICAgICAgbGV0IG51bVJlc3VsdEJsb2NrcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBlY0Jsb2NrIG9mIGVjQmxvY2tBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWNCbG9jay5nZXRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtRGF0YUNvZGV3b3JkcyA9IGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1CbG9ja0NvZGV3b3JkcyA9IGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzKCkgKyBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbnVtUmVzdWx0QmxvY2tzKytdID0gbmV3IERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzLCBuZXcgVWludDhBcnJheShudW1CbG9ja0NvZGV3b3JkcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsbCBibG9ja3MgaGF2ZSB0aGUgc2FtZSBhbW91bnQgb2YgZGF0YSwgZXhjZXB0IHRoYXQgdGhlIGxhc3QgblxuICAgICAgICAgICAgLy8gKHdoZXJlIG4gbWF5IGJlIDApIGhhdmUgMSBsZXNzIGJ5dGUuIEZpZ3VyZSBvdXQgd2hlcmUgdGhlc2Ugc3RhcnQuXG4gICAgICAgICAgICAvLyBUT0RPKGJicm93bik6IFRoZXJlIGlzIG9ubHkgb25lIGNhc2Ugd2hlcmUgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGZvciBEYXRhIE1hdHJpeCBmb3Igc2l6ZSAxNDRcbiAgICAgICAgICAgIGNvbnN0IGxvbmdlckJsb2Nrc1RvdGFsQ29kZXdvcmRzID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBpbnQgc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzID0gbG9uZ2VyQmxvY2tzVG90YWxDb2Rld29yZHMgLSAxO1xuICAgICAgICAgICAgY29uc3QgbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyA9IGxvbmdlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzID0gbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyAtIDE7XG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBlbGVtZW50cyBvZiByZXN1bHQgbWF5IGJlIDEgZWxlbWVudCBzaG9ydGVyIGZvciAxNDQgbWF0cml4XG4gICAgICAgICAgICAvLyBmaXJzdCBmaWxsIG91dCBhcyBtYW55IGVsZW1lbnRzIGFzIGFsbCBvZiB0aGVtIGhhdmUgbWludXMgMVxuICAgICAgICAgICAgbGV0IHJhd0NvZGV3b3Jkc09mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbaV0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbGwgb3V0IHRoZSBsYXN0IGRhdGEgYmxvY2sgaW4gdGhlIGxvbmdlciBvbmVzXG4gICAgICAgICAgICBjb25zdCBzcGVjaWFsVmVyc2lvbiA9IHZlcnNpb24uZ2V0VmVyc2lvbk51bWJlcigpID09PSAyNDtcbiAgICAgICAgICAgIGNvbnN0IG51bUxvbmdlckJsb2NrcyA9IHNwZWNpYWxWZXJzaW9uID8gOCA6IG51bVJlc3VsdEJsb2NrcztcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtTG9uZ2VyQmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2xvbmdlckJsb2Nrc051bURhdGFDb2Rld29yZHMgLSAxXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgYWRkIGluIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXG4gICAgICAgICAgICBjb25zdCBtYXggPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsb25nZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpPZmZzZXQgPSBzcGVjaWFsVmVyc2lvbiA/IChqICsgOCkgJSBudW1SZXN1bHRCbG9ja3MgOiBqO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpT2Zmc2V0ID0gc3BlY2lhbFZlcnNpb24gJiYgak9mZnNldCA+IDcgPyBpIC0gMSA6IGk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqT2Zmc2V0XS5jb2Rld29yZHNbaU9mZnNldF0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXdDb2Rld29yZHNPZmZzZXQgIT09IHJhd0NvZGV3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGdldE51bURhdGFDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldENvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3JkcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBwcm92aWRlcyBhbiBlYXN5IGFic3RyYWN0aW9uIHRvIHJlYWQgYml0cyBhdCBhIHRpbWUgZnJvbSBhIHNlcXVlbmNlIG9mIGJ5dGVzLCB3aGVyZSB0aGVcbiAgICAgKiBudW1iZXIgb2YgYml0cyByZWFkIGlzIG5vdCBvZnRlbiBhIG11bHRpcGxlIG9mIDguPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhpcyBjbGFzcyBpcyB0aHJlYWQtc2FmZSBidXQgbm90IHJlZW50cmFudCAtLSB1bmxlc3MgdGhlIGNhbGxlciBtb2RpZmllcyB0aGUgYnl0ZXMgYXJyYXlcbiAgICAgKiBpdCBwYXNzZWQgaW4sIGluIHdoaWNoIGNhc2UgYWxsIGJldHMgYXJlIG9mZi48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEJpdFNvdXJjZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYnl0ZXMgYnl0ZXMgZnJvbSB3aGljaCB0aGlzIHdpbGwgcmVhZCBiaXRzLiBCaXRzIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBmaXJzdCBieXRlIGZpcnN0LlxuICAgICAgICAgKiBCaXRzIGFyZSByZWFkIHdpdGhpbiBhIGJ5dGUgZnJvbSBtb3N0LXNpZ25pZmljYW50IHRvIGxlYXN0LXNpZ25pZmljYW50IGJpdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5iaXRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgYml0IGluIGN1cnJlbnQgYnl0ZSB3aGljaCB3b3VsZCBiZSByZWFkIGJ5IHRoZSBuZXh0IGNhbGwgdG8ge0BsaW5rICNyZWFkQml0cyhpbnQpfS5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJpdE9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBpbmRleCBvZiBuZXh0IGJ5dGUgaW4gaW5wdXQgYnl0ZSBhcnJheSB3aGljaCB3b3VsZCBiZSByZWFkIGJ5IHRoZSBuZXh0IGNhbGwgdG8ge0BsaW5rICNyZWFkQml0cyhpbnQpfS5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJ5dGVPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbnVtQml0cyBudW1iZXIgb2YgYml0cyB0byByZWFkXG4gICAgICAgICAqIEByZXR1cm4gaW50IHJlcHJlc2VudGluZyB0aGUgYml0cyByZWFkLiBUaGUgYml0cyB3aWxsIGFwcGVhciBhcyB0aGUgbGVhc3Qtc2lnbmlmaWNhbnRcbiAgICAgICAgICogICAgICAgICBiaXRzIG9mIHRoZSBpbnRcbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgbnVtQml0cyBpc24ndCBpbiBbMSwzMl0gb3IgbW9yZSB0aGFuIGlzIGF2YWlsYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEJpdHMobnVtQml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDEgfHwgbnVtQml0cyA+IDMyIHx8IG51bUJpdHMgPiB0aGlzLmF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignJyArIG51bUJpdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBsZXQgYml0T2Zmc2V0ID0gdGhpcy5iaXRPZmZzZXQ7XG4gICAgICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IHRoaXMuYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5ieXRlcztcbiAgICAgICAgICAgIC8vIEZpcnN0LCByZWFkIHJlbWFpbmRlciBmcm9tIGN1cnJlbnQgYnl0ZVxuICAgICAgICAgICAgaWYgKGJpdE9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzTGVmdCA9IDggLSBiaXRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9SZWFkID0gbnVtQml0cyA8IGJpdHNMZWZ0ID8gbnVtQml0cyA6IGJpdHNMZWZ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNUb05vdFJlYWQgPSBiaXRzTGVmdCAtIHRvUmVhZDtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RkYgPj4gKDggLSB0b1JlYWQpKSA8PCBiaXRzVG9Ob3RSZWFkO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChieXRlc1tieXRlT2Zmc2V0XSAmIG1hc2spID4+IGJpdHNUb05vdFJlYWQ7XG4gICAgICAgICAgICAgICAgbnVtQml0cyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgYml0T2Zmc2V0ICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICBpZiAoYml0T2Zmc2V0ID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZXh0IHJlYWQgd2hvbGUgYnl0ZXNcbiAgICAgICAgICAgIGlmIChudW1CaXRzID4gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChudW1CaXRzID49IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA4KSB8IChieXRlc1tieXRlT2Zmc2V0XSAmIDB4RkYpO1xuICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIG51bUJpdHMgLT0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSByZWFkIGEgcGFydGlhbCBieXRlXG4gICAgICAgICAgICAgICAgaWYgKG51bUJpdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdHNUb05vdFJlYWQgPSA4IC0gbnVtQml0cztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFzayA9ICgweEZGID4+IGJpdHNUb05vdFJlYWQpIDw8IGJpdHNUb05vdFJlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgbnVtQml0cykgfCAoKGJ5dGVzW2J5dGVPZmZzZXRdICYgbWFzaykgPj4gYml0c1RvTm90UmVhZCk7XG4gICAgICAgICAgICAgICAgICAgIGJpdE9mZnNldCArPSBudW1CaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYml0T2Zmc2V0ID0gYml0T2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gYmUgcmVhZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICovXG4gICAgICAgIGF2YWlsYWJsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiA4ICogKHRoaXMuYnl0ZXMubGVuZ3RoIC0gdGhpcy5ieXRlT2Zmc2V0KSAtIHRoaXMuYml0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIE1vZGU7XG4gICAgKGZ1bmN0aW9uIChNb2RlKSB7XG4gICAgICAgIE1vZGVbTW9kZVtcIlBBRF9FTkNPREVcIl0gPSAwXSA9IFwiUEFEX0VOQ09ERVwiO1xuICAgICAgICBNb2RlW01vZGVbXCJBU0NJSV9FTkNPREVcIl0gPSAxXSA9IFwiQVNDSUlfRU5DT0RFXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkM0MF9FTkNPREVcIl0gPSAyXSA9IFwiQzQwX0VOQ09ERVwiO1xuICAgICAgICBNb2RlW01vZGVbXCJURVhUX0VOQ09ERVwiXSA9IDNdID0gXCJURVhUX0VOQ09ERVwiO1xuICAgICAgICBNb2RlW01vZGVbXCJBTlNJWDEyX0VOQ09ERVwiXSA9IDRdID0gXCJBTlNJWDEyX0VOQ09ERVwiO1xuICAgICAgICBNb2RlW01vZGVbXCJFRElGQUNUX0VOQ09ERVwiXSA9IDVdID0gXCJFRElGQUNUX0VOQ09ERVwiO1xuICAgICAgICBNb2RlW01vZGVbXCJCQVNFMjU2X0VOQ09ERVwiXSA9IDZdID0gXCJCQVNFMjU2X0VOQ09ERVwiO1xuICAgIH0pKE1vZGUgfHwgKE1vZGUgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIDxwPkRhdGEgTWF0cml4IENvZGVzIGNhbiBlbmNvZGUgdGV4dCBhcyBiaXRzIGluIG9uZSBvZiBzZXZlcmFsIG1vZGVzLCBhbmQgY2FuIHVzZSBtdWx0aXBsZSBtb2Rlc1xuICAgICAqIGluIG9uZSBEYXRhIE1hdHJpeCBDb2RlLiBUaGlzIGNsYXNzIGRlY29kZXMgdGhlIGJpdHMgYmFjayBpbnRvIHRleHQuPC9wPlxuICAgICAqXG4gICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuMSAtIDUuMi45LjI8L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZWRCaXRTdHJlYW1QYXJzZXIge1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gbmV3IEJpdFNvdXJjZShieXRlcyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0VHJhaWxlciA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlU2VnbWVudHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGxldCBtb2RlID0gTW9kZS5BU0NJSV9FTkNPREU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IE1vZGUuQVNDSUlfRU5DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSB0aGlzLmRlY29kZUFzY2lpU2VnbWVudChiaXRzLCByZXN1bHQsIHJlc3VsdFRyYWlsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQzQwX0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUM0MFNlZ21lbnQoYml0cywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5URVhUX0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVRleHRTZWdtZW50KGJpdHMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQU5TSVgxMl9FTkNPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVBbnNpWDEyU2VnbWVudChiaXRzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkVESUZBQ1RfRU5DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlRWRpZmFjdFNlZ21lbnQoYml0cywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5CQVNFMjU2X0VOQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUJhc2UyNTZTZWdtZW50KGJpdHMsIHJlc3VsdCwgYnl0ZVNlZ21lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlLkFTQ0lJX0VOQ09ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChtb2RlICE9PSBNb2RlLlBBRF9FTkNPREUgJiYgYml0cy5hdmFpbGFibGUoKSA+IDApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFRyYWlsZXIubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChyZXN1bHRUcmFpbGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVyUmVzdWx0KGJ5dGVzLCByZXN1bHQudG9TdHJpbmcoKSwgYnl0ZVNlZ21lbnRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBieXRlU2VnbWVudHMsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi4zIGFuZCBBbm5leCBDLCBUYWJsZSBDLjJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVBc2NpaVNlZ21lbnQoYml0cywgcmVzdWx0LCByZXN1bHRUcmFpbGVyKSB7XG4gICAgICAgICAgICBsZXQgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBvbmVCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICBpZiAob25lQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uZUJ5dGUgPD0gMTI4KSB7IC8vIEFTQ0lJIGRhdGEgKEFTQ0lJIHZhbHVlICsgMSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZUJ5dGUgKz0gMTI4O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShvbmVCeXRlIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5BU0NJSV9FTkNPREU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uZUJ5dGUgPT09IDEyOSkgeyAvLyBQYWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuUEFEX0VOQ09ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA8PSAyMjkpIHsgLy8gMi1kaWdpdCBkYXRhIDAwLTk5IChOdW1lcmljIFZhbHVlICsgMTMwKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9uZUJ5dGUgLSAxMzA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDEwKSB7IC8vIHBhZCB3aXRoICcwJyBmb3Igc2luZ2xlIGRpZ2l0IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnMCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJycgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9uZUJ5dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjMwOiAvLyBMYXRjaCB0byBDNDAgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkM0MF9FTkNPREU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMTogLy8gTGF0Y2ggdG8gQmFzZSAyNTYgZW5jb2RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkJBU0UyNTZfRU5DT0RFO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzI6IC8vIEZOQzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpKTsgLy8gdHJhbnNsYXRlIGFzIEFTQ0lJIDI5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMzogLy8gU3RydWN0dXJlZCBBcHBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM0OiAvLyBSZWFkZXIgUHJvZ3JhbW1pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhlc2Ugc3ltYm9scyBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgUmVhZGVyRXhjZXB0aW9uLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNTogLy8gVXBwZXIgU2hpZnQgKHNoaWZ0IHRvIEV4dGVuZGVkIEFTQ0lJKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzY6IC8vIDA1IE1hY3JvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnWyk+XFx1MDAxRTA1XFx1MDAxRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFRyYWlsZXIuaW5zZXJ0KDAsICdcXHUwMDFFXFx1MDAwNCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzc6IC8vIDA2IE1hY3JvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnWyk+XFx1MDAxRTA2XFx1MDAxRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFRyYWlsZXIuaW5zZXJ0KDAsICdcXHUwMDFFXFx1MDAwNCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzg6IC8vIExhdGNoIHRvIEFOU0kgWDEyIGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5BTlNJWDEyX0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM5OiAvLyBMYXRjaCB0byBUZXh0IGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5URVhUX0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQwOiAvLyBMYXRjaCB0byBFRElGQUNUIGVuY29kYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5FRElGQUNUX0VOQ09ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQxOiAvLyBFQ0kgQ2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhiYnJvd24pOiBJIHRoaW5rIHdlIG5lZWQgdG8gc3VwcG9ydCBFQ0lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBSZWFkZXJFeGNlcHRpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhpcyBzeW1ib2wgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgdG8gYmUgdXNlZCBpbiBBU0NJSSBlbmNvZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdvcmsgYXJvdW5kIGVuY29kZXJzIHRoYXQgZW5kIHdpdGggMjU0LCBsYXRjaCBiYWNrIHRvIEFTQ0lJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZUJ5dGUgIT09IDI1NCB8fCBiaXRzLmF2YWlsYWJsZSgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgICAgICByZXR1cm4gTW9kZS5BU0NJSV9FTkNPREU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjUgYW5kIEFubmV4IEMsIFRhYmxlIEMuMVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUM0MFNlZ21lbnQoYml0cywgcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBUaHJlZSBDNDAgdmFsdWVzIGFyZSBlbmNvZGVkIGluIGEgMTYtYml0IHZhbHVlIGFzXG4gICAgICAgICAgICAvLyAoMTYwMCAqIEMxKSArICg0MCAqIEMyKSArIEMzICsgMVxuICAgICAgICAgICAgLy8gVE9ETyhiYnJvd24pOiBUaGUgVXBwZXIgU2hpZnQgd2l0aCBDNDAgZG9lc24ndCB3b3JrIGluIHRoZSA0IHZhbHVlIHNjZW5hcmlvIGFsbCB0aGUgdGltZVxuICAgICAgICAgICAgbGV0IHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzaGlmdCA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gY1ZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgdGhpcy5DNDBfQkFTSUNfU0VUX0NIQVJTLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjNDBjaGFyID0gdGhpcy5DNDBfQkFTSUNfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoYzQwY2hhci5jaGFyQ29kZUF0KDApICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGM0MGNoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IHRoaXMuQzQwX1NISUZUMl9TRVRfQ0hBUlMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGM0MGNoYXIgPSB0aGlzLkM0MF9TSElGVDJfU0VUX0NIQVJTW2NWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoYzQwY2hhci5jaGFyQ29kZUF0KDApICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGM0MGNoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gRk5DMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgyOSkpOyAvLyB0cmFuc2xhdGUgYXMgQVNDSUkgMjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzA6IC8vIFVwcGVyIFNoaWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDIyNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgOTYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjYgYW5kIEFubmV4IEMsIFRhYmxlIEMuMlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZVRleHRTZWdtZW50KGJpdHMsIHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gVGhyZWUgVGV4dCB2YWx1ZXMgYXJlIGVuY29kZWQgaW4gYSAxNi1iaXQgdmFsdWUgYXNcbiAgICAgICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXG4gICAgICAgICAgICAvLyBUT0RPKGJicm93bik6IFRoZSBVcHBlciBTaGlmdCB3aXRoIFRleHQgZG9lc24ndCB3b3JrIGluIHRoZSA0IHZhbHVlIHNjZW5hcmlvIGFsbCB0aGUgdGltZVxuICAgICAgICAgICAgbGV0IHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjVmFsdWVzID0gW107XG4gICAgICAgICAgICBsZXQgc2hpZnQgPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIGJ5dGUgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAyNTQpIHsgLy8gVW5sYXRjaCBjb2Rld29yZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUd29CeXRlcyhmaXJzdEJ5dGUsIGJpdHMucmVhZEJpdHMoOCksIGNWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNWYWx1ZSA9IGNWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IGNWYWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNWYWx1ZSA8IHRoaXMuVEVYVF9CQVNJQ19TRVRfQ0hBUlMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDaGFyID0gdGhpcy5URVhUX0JBU0lDX1NFVF9DSEFSU1tjVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKHRleHRDaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGV4dENoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgMiBmb3IgVGV4dCBpcyB0aGUgc2FtZSBlbmNvZGluZyBhcyBDNDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgdGhpcy5URVhUX1NISUZUMl9TRVRfQ0hBUlMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDaGFyID0gdGhpcy5URVhUX1NISUZUMl9TRVRfQ0hBUlNbY1ZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSh0ZXh0Q2hhci5jaGFyQ29kZUF0KDApICsgMTI4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRleHRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIEZOQzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpKTsgLy8gdHJhbnNsYXRlIGFzIEFTQ0lJIDI5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyBVcHBlciBTaGlmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCB0aGlzLlRFWFRfU0hJRlQzX1NFVF9DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENoYXIgPSB0aGlzLlRFWFRfU0hJRlQzX1NFVF9DSEFSU1tjVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKHRleHRDaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGV4dENoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuN1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUFuc2lYMTJTZWdtZW50KGJpdHMsIHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gVGhyZWUgQU5TSSBYMTIgdmFsdWVzIGFyZSBlbmNvZGVkIGluIGEgMTYtYml0IHZhbHVlIGFzXG4gICAgICAgICAgICAvLyAoMTYwMCAqIEMxKSArICg0MCAqIEMyKSArIEMzICsgMVxuICAgICAgICAgICAgY29uc3QgY1ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgb25lIGJ5dGUgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAyNTQpIHsgLy8gVW5sYXRjaCBjb2Rld29yZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VUd29CeXRlcyhmaXJzdEJ5dGUsIGJpdHMucmVhZEJpdHMoOCksIGNWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNWYWx1ZSA9IGNWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IC8vIFgxMiBzZWdtZW50IHRlcm1pbmF0b3IgPENSPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xccicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBYMTIgc2VnbWVudCBzZXBhcmF0b3IgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gWDEyIHN1Yi1lbGVtZW50IHNlcGFyYXRvciA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiAvLyBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IDE0KSB7IC8vIDAgLSA5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA0NCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjVmFsdWUgPCA0MCkgeyAvLyBBIC0gWlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgNTEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHBhcnNlVHdvQnl0ZXMoZmlyc3RCeXRlLCBzZWNvbmRCeXRlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBmdWxsQml0VmFsdWUgPSAoZmlyc3RCeXRlIDw8IDgpICsgc2Vjb25kQnl0ZSAtIDE7XG4gICAgICAgICAgICBsZXQgdGVtcCA9IE1hdGguZmxvb3IoZnVsbEJpdFZhbHVlIC8gMTYwMCk7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wO1xuICAgICAgICAgICAgZnVsbEJpdFZhbHVlIC09IHRlbXAgKiAxNjAwO1xuICAgICAgICAgICAgdGVtcCA9IE1hdGguZmxvb3IoZnVsbEJpdFZhbHVlIC8gNDApO1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcDtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IGZ1bGxCaXRWYWx1ZSAtIHRlbXAgKiA0MDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuOCBhbmQgQW5uZXggQyBUYWJsZSBDLjNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVFZGlmYWN0U2VnbWVudChiaXRzLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IHR3byBvciBsZXNzIGJ5dGVzIGxlZnQgdGhlbiBpdCB3aWxsIGJlIGVuY29kZWQgYXMgQVNDSUlcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8PSAxNikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlZGlmYWN0VmFsdWUgPSBiaXRzLnJlYWRCaXRzKDYpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHVubGF0Y2ggY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGlmYWN0VmFsdWUgPT09IDB4MUYpIHsgLy8gMDExMTExXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIHJlc3Qgb2YgYnl0ZSwgd2hpY2ggc2hvdWxkIGJlIDAsIGFuZCBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaXRzTGVmdCA9IDggLSBiaXRzLmdldEJpdE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNMZWZ0ICE9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5yZWFkQml0cyhiaXRzTGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChlZGlmYWN0VmFsdWUgJiAweDIwKSA9PT0gMCkgeyAvLyBubyAxIGluIHRoZSBsZWFkaW5nICg2dGgpIGJpdFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpZmFjdFZhbHVlIHw9IDB4NDA7IC8vIEFkZCBhIGxlYWRpbmcgMDEgdG8gdGhlIDYgYml0IGJpbmFyeSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShlZGlmYWN0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjkgYW5kIEFubmV4IEIsIEIuMlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUJhc2UyNTZTZWdtZW50KGJpdHMsIHJlc3VsdCwgYnl0ZVNlZ21lbnRzKSB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IGhvdyBsb25nIHRoZSBCYXNlIDI1NiBTZWdtZW50IGlzLlxuICAgICAgICAgICAgbGV0IGNvZGV3b3JkUG9zaXRpb24gPSAxICsgYml0cy5nZXRCeXRlT2Zmc2V0KCk7IC8vIHBvc2l0aW9uIGlzIDEtaW5kZXhlZFxuICAgICAgICAgICAgY29uc3QgZDEgPSB0aGlzLnVucmFuZG9taXplMjU1U3RhdGUoYml0cy5yZWFkQml0cyg4KSwgY29kZXdvcmRQb3NpdGlvbisrKTtcbiAgICAgICAgICAgIGxldCBjb3VudDtcbiAgICAgICAgICAgIGlmIChkMSA9PT0gMCkgeyAvLyBSZWFkIHRoZSByZW1haW5kZXIgb2YgdGhlIHN5bWJvbFxuICAgICAgICAgICAgICAgIGNvdW50ID0gYml0cy5hdmFpbGFibGUoKSAvIDggfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZDEgPCAyNTApIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSAyNTAgKiAoZDEgLSAyNDkpICsgdGhpcy51bnJhbmRvbWl6ZTI1NVN0YXRlKGJpdHMucmVhZEJpdHMoOCksIGNvZGV3b3JkUG9zaXRpb24rKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSdyZSBzZWVpbmcgTmVnYXRpdmVBcnJheVNpemVFeGNlcHRpb24gZXJyb3JzIGZyb20gdXNlcnMuXG4gICAgICAgICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBIYXZlIHNlZW4gdGhpcyBwYXJ0aWN1bGFyIGVycm9yIGluIHRoZSB3aWxkLCBzdWNoIGFzIGF0XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5iY2dlbi5jb20vZGVtby9JREF1dG9tYXRpb25TdHJlYW1pbmdEYXRhTWF0cml4LmFzcHg/TU9ERT0zJkQ9RnJlZCZQRk1UPTMmUFQ9RiZYPTAuMyZPPTAmTE09MC4yXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnl0ZXNbaV0gPSB0aGlzLnVucmFuZG9taXplMjU1U3RhdGUoYml0cy5yZWFkQml0cyg4KSwgY29kZXdvcmRQb3NpdGlvbisrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVTZWdtZW50cy5wdXNoKGJ5dGVzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZy5kZWNvZGUoYnl0ZXMsIFN0cmluZ1V0aWxzLklTTzg4NTkxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAodWVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignUGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBlbmNvZGluZzogJyArIHVlZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCBBbm5leCBCLCBCLjJcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB1bnJhbmRvbWl6ZTI1NVN0YXRlKHJhbmRvbWl6ZWRCYXNlMjU2Q29kZXdvcmQsIGJhc2UyNTZDb2Rld29yZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwc2V1ZG9SYW5kb21OdW1iZXIgPSAoKDE0OSAqIGJhc2UyNTZDb2Rld29yZFBvc2l0aW9uKSAlIDI1NSkgKyAxO1xuICAgICAgICAgICAgY29uc3QgdGVtcFZhcmlhYmxlID0gcmFuZG9taXplZEJhc2UyNTZDb2Rld29yZCAtIHBzZXVkb1JhbmRvbU51bWJlcjtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wVmFyaWFibGUgPj0gMCA/IHRlbXBWYXJpYWJsZSA6IHRlbXBWYXJpYWJsZSArIDI1NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEMgVGFibGUgQy4xXG4gICAgICogVGhlIEM0MCBCYXNpYyBDaGFyYWN0ZXIgU2V0ICgqJ3MgdXNlZCBmb3IgcGxhY2Vob2xkZXJzIGZvciB0aGUgc2hpZnQgdmFsdWVzKVxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX0JBU0lDX1NFVF9DSEFSUyA9IFtcbiAgICAgICAgJyonLCAnKicsICcqJywgJyAnLCAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG4gICAgICAgICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLFxuICAgICAgICAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onXG4gICAgXTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkM0MF9TSElGVDJfU0VUX0NIQVJTID0gW1xuICAgICAgICAnIScsICdcIicsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsICcoJywgJyknLCAnKicsICcrJywgJywnLCAnLScsICcuJyxcbiAgICAgICAgJy8nLCAnOicsICc7JywgJzwnLCAnPScsICc+JywgJz8nLCAnQCcsICdbJywgJ1xcXFwnLCAnXScsICdeJywgJ18nXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEMgVGFibGUgQy4yXG4gICAgICogVGhlIFRleHQgQmFzaWMgQ2hhcmFjdGVyIFNldCAoKidzIHVzZWQgZm9yIHBsYWNlaG9sZGVycyBmb3IgdGhlIHNoaWZ0IHZhbHVlcylcbiAgICAgKi9cbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQkFTSUNfU0VUX0NIQVJTID0gW1xuICAgICAgICAnKicsICcqJywgJyonLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgICAgICAgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsXG4gICAgICAgICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneidcbiAgICBdO1xuICAgIC8vIFNoaWZ0IDIgZm9yIFRleHQgaXMgdGhlIHNhbWUgZW5jb2RpbmcgYXMgQzQwXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX1NISUZUMl9TRVRfQ0hBUlMgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkM0MF9TSElGVDJfU0VUX0NIQVJTO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9TSElGVDNfU0VUX0NIQVJTID0gW1xuICAgICAgICAnYCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLFxuICAgICAgICAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAneycsICd8JywgJ30nLCAnficsIFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KVxuICAgIF07XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoZSBtYWluIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgRGF0YSBNYXRyaXggQ29kZSBkZWNvZGluZyAtLSBhcyBvcHBvc2VkIHRvIGxvY2F0aW5nIGFuZCBleHRyYWN0aW5nXG4gICAgICogdGhlIERhdGEgTWF0cml4IENvZGUgZnJvbSBhbiBpbWFnZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAgICAgKi9cbiAgICBjbGFzcyBEZWNvZGVyJDEge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMucnNEZWNvZGVyID0gbmV3IFJlZWRTb2xvbW9uRGVjb2RlcihHZW5lcmljR0YuREFUQV9NQVRSSVhfRklFTERfMjU2KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RGVjb2RlcyBhIERhdGEgTWF0cml4IENvZGUgcmVwcmVzZW50ZWQgYXMgYSB7QGxpbmsgQml0TWF0cml4fS4gQSAxIG9yIFwidHJ1ZVwiIGlzIHRha2VuXG4gICAgICAgICAqIHRvIG1lYW4gYSBibGFjayBtb2R1bGUuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYml0cyBib29sZWFucyByZXByZXNlbnRpbmcgd2hpdGUvYmxhY2sgRGF0YSBNYXRyaXggQ29kZSBtb2R1bGVzXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCBhbmQgYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIERhdGEgTWF0cml4IENvZGVcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIERhdGEgTWF0cml4IENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGUoYml0cykge1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgcGFyc2VyIGFuZCByZWFkIHZlcnNpb24sIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCaXRNYXRyaXhQYXJzZXIoYml0cyk7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VyLmdldFZlcnNpb24oKTtcbiAgICAgICAgICAgIC8vIFJlYWQgY29kZXdvcmRzXG4gICAgICAgICAgICBjb25zdCBjb2Rld29yZHMgPSBwYXJzZXIucmVhZENvZGV3b3JkcygpO1xuICAgICAgICAgICAgLy8gU2VwYXJhdGUgaW50byBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrcyA9IERhdGFCbG9jay5nZXREYXRhQmxvY2tzKGNvZGV3b3JkcywgdmVyc2lvbik7XG4gICAgICAgICAgICAvLyBDb3VudCB0b3RhbCBudW1iZXIgb2YgZGF0YSBieXRlc1xuICAgICAgICAgICAgbGV0IHRvdGFsQnl0ZXMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgZGIgb2YgZGF0YUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXMgKz0gZGIuZ2V0TnVtRGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFCbG9ja3NDb3VudCA9IGRhdGFCbG9ja3MubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRXJyb3ItY29ycmVjdCBhbmQgY29weSBkYXRhIGJsb2NrcyB0b2dldGhlciBpbnRvIGEgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGFCbG9ja3NDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gZGF0YUJsb2Nrc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2Rld29yZEJ5dGVzID0gZGF0YUJsb2NrLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bURhdGFDb2Rld29yZHMgPSBkYXRhQmxvY2suZ2V0TnVtRGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBEZS1pbnRlcmxhY2UgZGF0YSBibG9ja3MuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEJ5dGVzW2kgKiBkYXRhQmxvY2tzQ291bnQgKyBqXSA9IGNvZGV3b3JkQnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSBjb250ZW50cyBvZiB0aGF0IHN0cmVhbSBvZiBieXRlc1xuICAgICAgICAgICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlKHJlc3VsdEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+R2l2ZW4gZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcmVjZWl2ZWQsIHBvc3NpYmx5IGNvcnJ1cHRlZCBieSBlcnJvcnMsIGF0dGVtcHRzIHRvXG4gICAgICAgICAqIGNvcnJlY3QgdGhlIGVycm9ycyBpbi1wbGFjZSB1c2luZyBSZWVkLVNvbG9tb24gZXJyb3IgY29ycmVjdGlvbi48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZEJ5dGVzIGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBudW1EYXRhQ29kZXdvcmRzIG51bWJlciBvZiBjb2Rld29yZHMgdGhhdCBhcmUgZGF0YSBieXRlc1xuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGNvcnJlY3RFcnJvcnMoY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3Jkcykge1xuICAgICAgICAgICAgLy8gY29uc3QgbnVtQ29kZXdvcmRzID0gY29kZXdvcmRCeXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBGaXJzdCByZWFkIGludG8gYW4gYXJyYXkgb2YgaW50c1xuICAgICAgICAgICAgY29uc3QgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZGV3b3JkQnl0ZXMpO1xuICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgLy8gICBjb2Rld29yZHNJbnRzW2ldID0gY29kZXdvcmRCeXRlc1tpXSAmIDB4RkY7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucnNEZWNvZGVyLmRlY29kZShjb2Rld29yZHNJbnRzLCBjb2Rld29yZEJ5dGVzLmxlbmd0aCAtIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyogUmVlZFNvbG9tb25FeGNlcHRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcHkgYmFjayBpbnRvIGFycmF5IG9mIGJ5dGVzIC0tIG9ubHkgbmVlZCB0byB3b3JyeSBhYm91dCB0aGUgYnl0ZXMgdGhhdCB3ZXJlIGRhdGFcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2Rld29yZEJ5dGVzW2ldID0gY29kZXdvcmRzSW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYSBEYXRhIE1hdHJpeCBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZSBEYXRhIE1hdHJpeCBDb2RlXG4gICAgICogaXMgcm90YXRlZCBvciBza2V3ZWQsIG9yIHBhcnRpYWxseSBvYnNjdXJlZC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERldGVjdG9yJDEge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5yZWN0YW5nbGVEZXRlY3RvciA9IG5ldyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yKHRoaXMuaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZXRlY3RzIGEgRGF0YSBNYXRyaXggQ29kZSBpbiBhbiBpbWFnZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgRGF0YSBNYXRyaXggQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIERhdGEgTWF0cml4IENvZGUgY2FuIGJlIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBjb3JuZXJQb2ludHMgPSB0aGlzLnJlY3RhbmdsZURldGVjdG9yLmRldGVjdCgpO1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IHRoaXMuZGV0ZWN0U29saWQxKGNvcm5lclBvaW50cyk7XG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLmRldGVjdFNvbGlkMihwb2ludHMpO1xuICAgICAgICAgICAgcG9pbnRzWzNdID0gdGhpcy5jb3JyZWN0VG9wUmlnaHQocG9pbnRzKTtcbiAgICAgICAgICAgIGlmICghcG9pbnRzWzNdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLnNoaWZ0VG9Nb2R1bGVDZW50ZXIocG9pbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcExlZnQgPSBwb2ludHNbMF07XG4gICAgICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tUmlnaHQgPSBwb2ludHNbMl07XG4gICAgICAgICAgICBjb25zdCB0b3BSaWdodCA9IHBvaW50c1szXTtcbiAgICAgICAgICAgIGxldCBkaW1lbnNpb25Ub3AgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbih0b3BMZWZ0LCB0b3BSaWdodCkgKyAxO1xuICAgICAgICAgICAgbGV0IGRpbWVuc2lvblJpZ2h0ID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4oYm90dG9tUmlnaHQsIHRvcFJpZ2h0KSArIDE7XG4gICAgICAgICAgICBpZiAoKGRpbWVuc2lvblRvcCAmIDB4MDEpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uVG9wICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRpbWVuc2lvblJpZ2h0ICYgMHgwMSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25SaWdodCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDQgKiBkaW1lbnNpb25Ub3AgPCA3ICogZGltZW5zaW9uUmlnaHQgJiYgNCAqIGRpbWVuc2lvblJpZ2h0IDwgNyAqIGRpbWVuc2lvblRvcCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBtYXRyaXggaXMgc3F1YXJlXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uVG9wID0gZGltZW5zaW9uUmlnaHQgPSBNYXRoLm1heChkaW1lbnNpb25Ub3AsIGRpbWVuc2lvblJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiaXRzID0gRGV0ZWN0b3IkMS5zYW1wbGVHcmlkKHRoaXMuaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgZGltZW5zaW9uVG9wLCBkaW1lbnNpb25SaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERldGVjdG9yUmVzdWx0KGJpdHMsIFt0b3BMZWZ0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodCwgdG9wUmlnaHRdKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2hpZnRQb2ludChwb2ludCwgdG8sIGRpdikge1xuICAgICAgICAgICAgbGV0IHggPSAodG8uZ2V0WCgpIC0gcG9pbnQuZ2V0WCgpKSAvIChkaXYgKyAxKTtcbiAgICAgICAgICAgIGxldCB5ID0gKHRvLmdldFkoKSAtIHBvaW50LmdldFkoKSkgLyAoZGl2ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdFBvaW50KHBvaW50LmdldFgoKSArIHgsIHBvaW50LmdldFkoKSArIHkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtb3ZlQXdheShwb2ludCwgZnJvbVgsIGZyb21ZKSB7XG4gICAgICAgICAgICBsZXQgeCA9IHBvaW50LmdldFgoKTtcbiAgICAgICAgICAgIGxldCB5ID0gcG9pbnQuZ2V0WSgpO1xuICAgICAgICAgICAgaWYgKHggPCBmcm9tWCkge1xuICAgICAgICAgICAgICAgIHggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5IDwgZnJvbVkpIHtcbiAgICAgICAgICAgICAgICB5IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3VsdFBvaW50KHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3QgYSBzb2xpZCBzaWRlIHdoaWNoIGhhcyBtaW5pbXVtIHRyYW5zaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3RTb2xpZDEoY29ybmVyUG9pbnRzKSB7XG4gICAgICAgICAgICAvLyAwICAyXG4gICAgICAgICAgICAvLyAxICAzXG4gICAgICAgICAgICBsZXQgcG9pbnRBID0gY29ybmVyUG9pbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHBvaW50QiA9IGNvcm5lclBvaW50c1sxXTtcbiAgICAgICAgICAgIGxldCBwb2ludEMgPSBjb3JuZXJQb2ludHNbM107XG4gICAgICAgICAgICBsZXQgcG9pbnREID0gY29ybmVyUG9pbnRzWzJdO1xuICAgICAgICAgICAgbGV0IHRyQUIgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEEsIHBvaW50Qik7XG4gICAgICAgICAgICBsZXQgdHJCQyA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QiwgcG9pbnRDKTtcbiAgICAgICAgICAgIGxldCB0ckNEID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDLCBwb2ludEQpO1xuICAgICAgICAgICAgbGV0IHRyREEgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEQsIHBvaW50QSk7XG4gICAgICAgICAgICAvLyAwLi4zXG4gICAgICAgICAgICAvLyA6ICA6XG4gICAgICAgICAgICAvLyAxLS0yXG4gICAgICAgICAgICBsZXQgbWluID0gdHJBQjtcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSBbcG9pbnRELCBwb2ludEEsIHBvaW50QiwgcG9pbnRDXTtcbiAgICAgICAgICAgIGlmIChtaW4gPiB0ckJDKSB7XG4gICAgICAgICAgICAgICAgbWluID0gdHJCQztcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEE7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRCO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50QztcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluID4gdHJDRCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IHRyQ0Q7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRCO1xuICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QztcbiAgICAgICAgICAgICAgICBwb2ludHNbMl0gPSBwb2ludEQ7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnRBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pbiA+IHRyREEpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEM7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnREO1xuICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50QTtcbiAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3QgYSBzZWNvbmQgc29saWQgc2lkZSBuZXh0IHRvIGZpcnN0IHNvbGlkIHNpZGUuXG4gICAgICAgICAqL1xuICAgICAgICBkZXRlY3RTb2xpZDIocG9pbnRzKSB7XG4gICAgICAgICAgICAvLyBBLi5EXG4gICAgICAgICAgICAvLyA6ICA6XG4gICAgICAgICAgICAvLyBCLS1DXG4gICAgICAgICAgICBsZXQgcG9pbnRBID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHBvaW50QiA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIGxldCBwb2ludEMgPSBwb2ludHNbMl07XG4gICAgICAgICAgICBsZXQgcG9pbnREID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiBkZXRlY3Rpb24gb24gdGhlIGVkZ2UgaXMgbm90IHN0YWJsZS5cbiAgICAgICAgICAgIC8vIFRvIHNhZmVseSBkZXRlY3QsIHNoaWZ0IHRoZSBwb2ludHMgdG8gdGhlIG1vZHVsZSBjZW50ZXIuXG4gICAgICAgICAgICBsZXQgdHIgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEEsIHBvaW50RCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRCcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEIsIHBvaW50QywgKHRyICsgMSkgKiA0KTtcbiAgICAgICAgICAgIGxldCBwb2ludENzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QywgcG9pbnRCLCAodHIgKyAxKSAqIDQpO1xuICAgICAgICAgICAgbGV0IHRyQkEgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEJzLCBwb2ludEEpO1xuICAgICAgICAgICAgbGV0IHRyQ0QgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBwb2ludEQpO1xuICAgICAgICAgICAgLy8gMC4uM1xuICAgICAgICAgICAgLy8gfCAgOlxuICAgICAgICAgICAgLy8gMS0tMlxuICAgICAgICAgICAgaWYgKHRyQkEgPCB0ckNEKSB7XG4gICAgICAgICAgICAgICAgLy8gc29saWQgc2lkZXM6IEEtQi1DXG4gICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRBO1xuICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QjtcbiAgICAgICAgICAgICAgICBwb2ludHNbMl0gPSBwb2ludEM7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnREO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc29saWQgc2lkZXM6IEItQy1EXG4gICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRCO1xuICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QztcbiAgICAgICAgICAgICAgICBwb2ludHNbMl0gPSBwb2ludEQ7XG4gICAgICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnRBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgY29ybmVyIHBvc2l0aW9uIG9mIHRoZSB3aGl0ZSB0b3AgcmlnaHQgbW9kdWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29ycmVjdFRvcFJpZ2h0KHBvaW50cykge1xuICAgICAgICAgICAgLy8gQS4uRFxuICAgICAgICAgICAgLy8gfCAgOlxuICAgICAgICAgICAgLy8gQi0tQ1xuICAgICAgICAgICAgbGV0IHBvaW50QSA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIGxldCBwb2ludEIgPSBwb2ludHNbMV07XG4gICAgICAgICAgICBsZXQgcG9pbnRDID0gcG9pbnRzWzJdO1xuICAgICAgICAgICAgbGV0IHBvaW50RCA9IHBvaW50c1szXTtcbiAgICAgICAgICAgIC8vIHNoaWZ0IHBvaW50cyBmb3Igc2FmZSB0cmFuc2l0aW9uIGRldGVjdGlvbi5cbiAgICAgICAgICAgIGxldCB0clRvcCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnREKTtcbiAgICAgICAgICAgIGxldCB0clJpZ2h0ID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRCLCBwb2ludEQpO1xuICAgICAgICAgICAgbGV0IHBvaW50QXMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRBLCBwb2ludEIsICh0clJpZ2h0ICsgMSkgKiA0KTtcbiAgICAgICAgICAgIGxldCBwb2ludENzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QywgcG9pbnRCLCAodHJUb3AgKyAxKSAqIDQpO1xuICAgICAgICAgICAgdHJUb3AgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBwb2ludEQpO1xuICAgICAgICAgICAgdHJSaWdodCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIHBvaW50RCk7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlMSA9IG5ldyBSZXN1bHRQb2ludChwb2ludEQuZ2V0WCgpICsgKHBvaW50Qy5nZXRYKCkgLSBwb2ludEIuZ2V0WCgpKSAvICh0clRvcCArIDEpLCBwb2ludEQuZ2V0WSgpICsgKHBvaW50Qy5nZXRZKCkgLSBwb2ludEIuZ2V0WSgpKSAvICh0clRvcCArIDEpKTtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUyID0gbmV3IFJlc3VsdFBvaW50KHBvaW50RC5nZXRYKCkgKyAocG9pbnRBLmdldFgoKSAtIHBvaW50Qi5nZXRYKCkpIC8gKHRyUmlnaHQgKyAxKSwgcG9pbnRELmdldFkoKSArIChwb2ludEEuZ2V0WSgpIC0gcG9pbnRCLmdldFkoKSkgLyAodHJSaWdodCArIDEpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGNhbmRpZGF0ZTEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZChjYW5kaWRhdGUyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZChjYW5kaWRhdGUyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN1bWMxID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBcywgY2FuZGlkYXRlMSkgKyB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBjYW5kaWRhdGUxKTtcbiAgICAgICAgICAgIGxldCBzdW1jMiA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIGNhbmRpZGF0ZTIpICsgdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgY2FuZGlkYXRlMik7XG4gICAgICAgICAgICBpZiAoc3VtYzEgPiBzdW1jMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNoaWZ0IHRoZSBlZGdlIHBvaW50cyB0byB0aGUgbW9kdWxlIGNlbnRlci5cbiAgICAgICAgICovXG4gICAgICAgIHNoaWZ0VG9Nb2R1bGVDZW50ZXIocG9pbnRzKSB7XG4gICAgICAgICAgICAvLyBBLi5EXG4gICAgICAgICAgICAvLyB8ICA6XG4gICAgICAgICAgICAvLyBCLS1DXG4gICAgICAgICAgICBsZXQgcG9pbnRBID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHBvaW50QiA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIGxldCBwb2ludEMgPSBwb2ludHNbMl07XG4gICAgICAgICAgICBsZXQgcG9pbnREID0gcG9pbnRzWzNdO1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHBzZXVkbyBkaW1lbnNpb25zXG4gICAgICAgICAgICBsZXQgZGltSCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnREKSArIDE7XG4gICAgICAgICAgICBsZXQgZGltViA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QywgcG9pbnREKSArIDE7XG4gICAgICAgICAgICAvLyBzaGlmdCBwb2ludHMgZm9yIHNhZmUgZGltZW5zaW9uIGRldGVjdGlvblxuICAgICAgICAgICAgbGV0IHBvaW50QXMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRBLCBwb2ludEIsIGRpbVYgKiA0KTtcbiAgICAgICAgICAgIGxldCBwb2ludENzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QywgcG9pbnRCLCBkaW1IICogNCk7XG4gICAgICAgICAgICAvLyAgY2FsY3VsYXRlIG1vcmUgcHJlY2lzZSBkaW1lbnNpb25zXG4gICAgICAgICAgICBkaW1IID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBcywgcG9pbnREKSArIDE7XG4gICAgICAgICAgICBkaW1WID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDcywgcG9pbnREKSArIDE7XG4gICAgICAgICAgICBpZiAoKGRpbUggJiAweDAxKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRpbUggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGltViAmIDB4MDEpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGltViArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hpdGVSZWN0YW5nbGVEZXRlY3RvciByZXR1cm5zIHBvaW50cyBpbnNpZGUgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICAgIC8vIEkgd2FudCBwb2ludHMgb24gdGhlIGVkZ2VzLlxuICAgICAgICAgICAgbGV0IGNlbnRlclggPSAocG9pbnRBLmdldFgoKSArIHBvaW50Qi5nZXRYKCkgKyBwb2ludEMuZ2V0WCgpICsgcG9pbnRELmdldFgoKSkgLyA0O1xuICAgICAgICAgICAgbGV0IGNlbnRlclkgPSAocG9pbnRBLmdldFkoKSArIHBvaW50Qi5nZXRZKCkgKyBwb2ludEMuZ2V0WSgpICsgcG9pbnRELmdldFkoKSkgLyA0O1xuICAgICAgICAgICAgcG9pbnRBID0gRGV0ZWN0b3IkMS5tb3ZlQXdheShwb2ludEEsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgICAgcG9pbnRCID0gRGV0ZWN0b3IkMS5tb3ZlQXdheShwb2ludEIsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgICAgcG9pbnRDID0gRGV0ZWN0b3IkMS5tb3ZlQXdheShwb2ludEMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgICAgcG9pbnREID0gRGV0ZWN0b3IkMS5tb3ZlQXdheShwb2ludEQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgICAgbGV0IHBvaW50QnM7XG4gICAgICAgICAgICBsZXQgcG9pbnREcztcbiAgICAgICAgICAgIC8vIHNoaWZ0IHBvaW50cyB0byB0aGUgY2VudGVyIG9mIGVhY2ggbW9kdWxlc1xuICAgICAgICAgICAgcG9pbnRBcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEEsIHBvaW50QiwgZGltViAqIDQpO1xuICAgICAgICAgICAgcG9pbnRBcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEFzLCBwb2ludEQsIGRpbUggKiA0KTtcbiAgICAgICAgICAgIHBvaW50QnMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRCLCBwb2ludEEsIGRpbVYgKiA0KTtcbiAgICAgICAgICAgIHBvaW50QnMgPSBEZXRlY3RvciQxLnNoaWZ0UG9pbnQocG9pbnRCcywgcG9pbnRDLCBkaW1IICogNCk7XG4gICAgICAgICAgICBwb2ludENzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50QywgcG9pbnRELCBkaW1WICogNCk7XG4gICAgICAgICAgICBwb2ludENzID0gRGV0ZWN0b3IkMS5zaGlmdFBvaW50KHBvaW50Q3MsIHBvaW50QiwgZGltSCAqIDQpO1xuICAgICAgICAgICAgcG9pbnREcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludEQsIHBvaW50QywgZGltViAqIDQpO1xuICAgICAgICAgICAgcG9pbnREcyA9IERldGVjdG9yJDEuc2hpZnRQb2ludChwb2ludERzLCBwb2ludEEsIGRpbUggKiA0KTtcbiAgICAgICAgICAgIHJldHVybiBbcG9pbnRBcywgcG9pbnRCcywgcG9pbnRDcywgcG9pbnREc107XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWxpZChwKSB7XG4gICAgICAgICAgICByZXR1cm4gcC5nZXRYKCkgPj0gMCAmJiBwLmdldFgoKSA8IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAmJiBwLmdldFkoKSA+IDAgJiYgcC5nZXRZKCkgPCB0aGlzLmltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzYW1wbGVHcmlkKGltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodCwgdG9wUmlnaHQsIGRpbWVuc2lvblgsIGRpbWVuc2lvblkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZXIgPSBHcmlkU2FtcGxlckluc3RhbmNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlci5zYW1wbGVHcmlkKGltYWdlLCBkaW1lbnNpb25YLCBkaW1lbnNpb25ZLCAwLjUsIDAuNSwgZGltZW5zaW9uWCAtIDAuNSwgMC41LCBkaW1lbnNpb25YIC0gMC41LCBkaW1lbnNpb25ZIC0gMC41LCAwLjUsIGRpbWVuc2lvblkgLSAwLjUsIHRvcExlZnQuZ2V0WCgpLCB0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WCgpLCB0b3BSaWdodC5nZXRZKCksIGJvdHRvbVJpZ2h0LmdldFgoKSwgYm90dG9tUmlnaHQuZ2V0WSgpLCBib3R0b21MZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRZKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBibGFjay93aGl0ZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHR3byBwb2ludHMsIHVzaW5nIHNvbWV0aGluZyBsaWtlIEJyZXNlbmhhbSdzIGFsZ29yaXRobS5cbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zaXRpb25zQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgICAgICAgLy8gU2VlIFFSIENvZGUgRGV0ZWN0b3IsIHNpemVPZkJsYWNrV2hpdGVCbGFja1J1bigpXG4gICAgICAgICAgICBsZXQgZnJvbVggPSBNYXRoLnRydW5jKGZyb20uZ2V0WCgpKTtcbiAgICAgICAgICAgIGxldCBmcm9tWSA9IE1hdGgudHJ1bmMoZnJvbS5nZXRZKCkpO1xuICAgICAgICAgICAgbGV0IHRvWCA9IE1hdGgudHJ1bmModG8uZ2V0WCgpKTtcbiAgICAgICAgICAgIGxldCB0b1kgPSBNYXRoLnRydW5jKHRvLmdldFkoKSk7XG4gICAgICAgICAgICBsZXQgc3RlZXAgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSkgPiBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XG4gICAgICAgICAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGZyb21YO1xuICAgICAgICAgICAgICAgIGZyb21YID0gZnJvbVk7XG4gICAgICAgICAgICAgICAgZnJvbVkgPSB0ZW1wO1xuICAgICAgICAgICAgICAgIHRlbXAgPSB0b1g7XG4gICAgICAgICAgICAgICAgdG9YID0gdG9ZO1xuICAgICAgICAgICAgICAgIHRvWSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZHggPSBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XG4gICAgICAgICAgICBsZXQgZHkgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSk7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSAtZHggLyAyO1xuICAgICAgICAgICAgbGV0IHlzdGVwID0gZnJvbVkgPCB0b1kgPyAxIDogLTE7XG4gICAgICAgICAgICBsZXQgeHN0ZXAgPSBmcm9tWCA8IHRvWCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9ucyA9IDA7XG4gICAgICAgICAgICBsZXQgaW5CbGFjayA9IHRoaXMuaW1hZ2UuZ2V0KHN0ZWVwID8gZnJvbVkgOiBmcm9tWCwgc3RlZXAgPyBmcm9tWCA6IGZyb21ZKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBmcm9tWCwgeSA9IGZyb21ZOyB4ICE9PSB0b1g7IHggKz0geHN0ZXApIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNCbGFjayA9IHRoaXMuaW1hZ2UuZ2V0KHN0ZWVwID8geSA6IHgsIHN0ZWVwID8geCA6IHkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0JsYWNrICE9PSBpbkJsYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zKys7XG4gICAgICAgICAgICAgICAgICAgIGluQmxhY2sgPSBpc0JsYWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciArPSBkeTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID09PSB0b1kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkgKz0geXN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yIC09IGR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9ucztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgRGF0YSBNYXRyaXggY29kZXMgaW4gYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcbiAgICAgKi9cbiAgICBjbGFzcyBEYXRhTWF0cml4UmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgRGVjb2RlciQxKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvY2F0ZXMgYW5kIGRlY29kZXMgYSBEYXRhIE1hdHJpeCBjb2RlIGluIGFuIGltYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGEgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29udGVudCBlbmNvZGVkIGJ5IHRoZSBEYXRhIE1hdHJpeCBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYSBEYXRhIE1hdHJpeCBjb2RlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIERhdGEgTWF0cml4IGNvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgLy8gcHVibGljIFJlc3VsdCBkZWNvZGUoQmluYXJ5Qml0bWFwIGltYWdlKSB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24ge1xuICAgICAgICAvLyAgIHJldHVybiBkZWNvZGUoaW1hZ2UsIG51bGwpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGUoaW1hZ2UsIGhpbnRzID0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGRlY29kZXJSZXN1bHQ7XG4gICAgICAgICAgICBsZXQgcG9pbnRzO1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9IG51bGwgJiYgaGludHMuaGFzKERlY29kZUhpbnRUeXBlJDEuUFVSRV9CQVJDT0RFKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBEYXRhTWF0cml4UmVhZGVyLmV4dHJhY3RQdXJlQml0cyhpbWFnZS5nZXRCbGFja01hdHJpeCgpKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZShiaXRzKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBEYXRhTWF0cml4UmVhZGVyLk5PX1BPSU5UUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdG9yUmVzdWx0ID0gbmV3IERldGVjdG9yJDEoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSkuZGV0ZWN0KCk7XG4gICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IHRoaXMuZGVjb2Rlci5kZWNvZGUoZGV0ZWN0b3JSZXN1bHQuZ2V0Qml0cygpKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhd0J5dGVzID0gZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgcmF3Qnl0ZXMsIDggKiByYXdCeXRlcy5sZW5ndGgsIHBvaW50cywgQmFyY29kZUZvcm1hdCQxLkRBVEFfTUFUUklYLCBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKSk7XG4gICAgICAgICAgICBjb25zdCBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xuICAgICAgICAgICAgaWYgKGJ5dGVTZWdtZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLkJZVEVfU0VHTUVOVFMsIGJ5dGVTZWdtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlY0xldmVsID0gZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCk7XG4gICAgICAgICAgICBpZiAoZWNMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwsIGVjTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGRldGVjdHMgYSBjb2RlIGluIGEgXCJwdXJlXCIgaW1hZ2UgLS0gdGhhdCBpcywgcHVyZSBtb25vY2hyb21lIGltYWdlXG4gICAgICAgICAqIHdoaWNoIGNvbnRhaW5zIG9ubHkgYW4gdW5yb3RhdGVkLCB1bnNrZXdlZCwgaW1hZ2Ugb2YgYSBjb2RlLCB3aXRoIHNvbWUgd2hpdGUgYm9yZGVyXG4gICAgICAgICAqIGFyb3VuZCBpdC4gVGhpcyBpcyBhIHNwZWNpYWxpemVkIG1ldGhvZCB0aGF0IHdvcmtzIGV4Y2VwdGlvbmFsbHkgZmFzdCBpbiB0aGlzIHNwZWNpYWxcbiAgICAgICAgICogY2FzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5RUkNvZGVSZWFkZXIjZXh0cmFjdFB1cmVCaXRzKEJpdE1hdHJpeClcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBleHRyYWN0UHVyZUJpdHMoaW1hZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRUb3BCbGFjayA9IGltYWdlLmdldFRvcExlZnRPbkJpdCgpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRCb3R0b21CbGFjayA9IGltYWdlLmdldEJvdHRvbVJpZ2h0T25CaXQoKTtcbiAgICAgICAgICAgIGlmIChsZWZ0VG9wQmxhY2sgPT0gbnVsbCB8fCByaWdodEJvdHRvbUJsYWNrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSk7XG4gICAgICAgICAgICBsZXQgdG9wID0gbGVmdFRvcEJsYWNrWzFdO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gcmlnaHRCb3R0b21CbGFja1sxXTtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSByaWdodEJvdHRvbUJsYWNrWzBdO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4V2lkdGggPSAocmlnaHQgLSBsZWZ0ICsgMSkgLyBtb2R1bGVTaXplO1xuICAgICAgICAgICAgY29uc3QgbWF0cml4SGVpZ2h0ID0gKGJvdHRvbSAtIHRvcCArIDEpIC8gbW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIGlmIChtYXRyaXhXaWR0aCA8PSAwIHx8IG1hdHJpeEhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQdXNoIGluIHRoZSBcImJvcmRlclwiIGJ5IGhhbGYgdGhlIG1vZHVsZSB3aWR0aCBzbyB0aGF0IHdlIHN0YXJ0XG4gICAgICAgICAgICAvLyBzYW1wbGluZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBtb2R1bGUuIEp1c3QgaW4gY2FzZSB0aGUgaW1hZ2UgaXMgYVxuICAgICAgICAgICAgLy8gbGl0dGxlIG9mZiwgdGhpcyB3aWxsIGhlbHAgcmVjb3Zlci5cbiAgICAgICAgICAgIGNvbnN0IG51ZGdlID0gbW9kdWxlU2l6ZSAvIDI7XG4gICAgICAgICAgICB0b3AgKz0gbnVkZ2U7XG4gICAgICAgICAgICBsZWZ0ICs9IG51ZGdlO1xuICAgICAgICAgICAgLy8gTm93IGp1c3QgcmVhZCBvZmYgdGhlIGJpdHNcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0TWF0cml4KG1hdHJpeFdpZHRoLCBtYXRyaXhIZWlnaHQpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBtYXRyaXhIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlPZmZzZXQgPSB0b3AgKyB5ICogbW9kdWxlU2l6ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1hdHJpeFdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChsZWZ0ICsgeCAqIG1vZHVsZVNpemUsIGlPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnNldCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtb2R1bGVTaXplKGxlZnRUb3BCbGFjaywgaW1hZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGxldCB4ID0gbGVmdFRvcEJsYWNrWzBdO1xuICAgICAgICAgICAgY29uc3QgeSA9IGxlZnRUb3BCbGFja1sxXTtcbiAgICAgICAgICAgIHdoaWxlICh4IDwgd2lkdGggJiYgaW1hZ2UuZ2V0KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0geCAtIGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEYXRhTWF0cml4UmVhZGVyLk5PX1BPSU5UUyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBRUiBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlclFSQ29kZVJlYWRlci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMCkge1xuICAgICAgICAgICAgc3VwZXIobmV3IERhdGFNYXRyaXhSZWFkZXIoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIHZhciBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcztcbiAgICAoZnVuY3Rpb24gKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzKSB7XG4gICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW1wiTFwiXSA9IDBdID0gXCJMXCI7XG4gICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW1wiTVwiXSA9IDFdID0gXCJNXCI7XG4gICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW1wiUVwiXSA9IDJdID0gXCJRXCI7XG4gICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW1wiSFwiXSA9IDNdID0gXCJIXCI7XG4gICAgfSkoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgfHwgKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzID0ge30pKTtcbiAgICAvKipcbiAgICAgKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNS4xLiBUaGlzIGVudW0gZW5jYXBzdWxhdGVzIHRoZSBmb3VyIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxzXG4gICAgICogZGVmaW5lZCBieSB0aGUgUVIgY29kZSBzdGFuZGFyZC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEVycm9yQ29ycmVjdGlvbkxldmVsIHtcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIHN0cmluZ1ZhbHVlLCBiaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUy5zZXQoYml0cywgdGhpcyk7XG4gICAgICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfVkFMVUUuc2V0KHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldEJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tU3RyaW5nKHMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0wnOiByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTDtcbiAgICAgICAgICAgICAgICBjYXNlICdNJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLk07XG4gICAgICAgICAgICAgICAgY2FzZSAnUSc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5RO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0gnOiByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuSDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24ocyArICdub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlcXVhbHMobykge1xuICAgICAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEVycm9yQ29ycmVjdGlvbkxldmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0gbztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGJpdHMgaW50IGNvbnRhaW5pbmcgdGhlIHR3byBiaXRzIGVuY29kaW5nIGEgUVIgQ29kZSdzIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgICogQHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbCByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZvckJpdHMoYml0cyAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoYml0cyA8IDAgfHwgYml0cyA+PSBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUy5zaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLmdldChiaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUyA9IG5ldyBNYXAoKTtcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfVkFMVUUgPSBuZXcgTWFwKCk7XG4gICAgLyoqIEwgPSB+NyUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkwgPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuTCwgJ0wnLCAweDAxKTtcbiAgICAvKiogTSA9IH4xNSUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLk0gPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuTSwgJ00nLCAweDAwKTtcbiAgICAvKiogUSA9IH4yNSUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLlEgPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuUSwgJ1EnLCAweDAzKTtcbiAgICAvKiogSCA9IH4zMCUgY29ycmVjdGlvbiAqL1xuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkggPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuSCwgJ0gnLCAweDAyKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgUVIgQ29kZSdzIGZvcm1hdCBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nIHRoZSBkYXRhIG1hc2sgdXNlZCBhbmRcbiAgICAgKiBlcnJvciBjb3JyZWN0aW9uIGxldmVsLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQHNlZSBEYXRhTWFza1xuICAgICAqIEBzZWUgRXJyb3JDb3JyZWN0aW9uTGV2ZWxcbiAgICAgKi9cbiAgICBjbGFzcyBGb3JtYXRJbmZvcm1hdGlvbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZvcm1hdEluZm8gLyppbnQqLykge1xuICAgICAgICAgICAgLy8gQml0cyAzLDRcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbC5mb3JCaXRzKChmb3JtYXRJbmZvID4+IDMpICYgMHgwMyk7XG4gICAgICAgICAgICAvLyBCb3R0b20gMyBiaXRzXG4gICAgICAgICAgICB0aGlzLmRhdGFNYXNrID0gLyooYnl0ZSkgKi8gKGZvcm1hdEluZm8gJiAweDA3KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbnVtQml0c0RpZmZlcmluZyhhIC8qaW50Ki8sIGIgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuYml0Q291bnQoYSBeIGIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbWFza2VkRm9ybWF0SW5mbzEgZm9ybWF0IGluZm8gaW5kaWNhdG9yLCB3aXRoIG1hc2sgc3RpbGwgYXBwbGllZFxuICAgICAgICAgKiBAcGFyYW0gbWFza2VkRm9ybWF0SW5mbzIgc2Vjb25kIGNvcHkgb2Ygc2FtZSBpbmZvOyBib3RoIGFyZSBjaGVja2VkIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAgICAgICogIHRvIGVzdGFibGlzaCBiZXN0IG1hdGNoXG4gICAgICAgICAqIEByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZvcm1hdCBpdCBzcGVjaWZpZXMsIG9yIHtAY29kZSBudWxsfVxuICAgICAgICAgKiAgaWYgZG9lc24ndCBzZWVtIHRvIG1hdGNoIGFueSBrbm93biBwYXR0ZXJuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEgLyppbnQqLywgbWFza2VkRm9ybWF0SW5mbzIgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0SW5mbyA9IEZvcm1hdEluZm9ybWF0aW9uLmRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEsIG1hc2tlZEZvcm1hdEluZm8yKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaG91bGQgcmV0dXJuIG51bGwsIGJ1dCwgc29tZSBRUiBjb2RlcyBhcHBhcmVudGx5XG4gICAgICAgICAgICAvLyBkbyBub3QgbWFzayB0aGlzIGluZm8uIFRyeSBhZ2FpbiBieSBhY3R1YWxseSBtYXNraW5nIHRoZSBwYXR0ZXJuXG4gICAgICAgICAgICAvLyBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdEluZm9ybWF0aW9uLmRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEgXiBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19NQVNLX1FSLCBtYXNrZWRGb3JtYXRJbmZvMiBeIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uKG1hc2tlZEZvcm1hdEluZm8xIC8qaW50Ki8sIG1hc2tlZEZvcm1hdEluZm8yIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGludCBpbiBGT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQIHdpdGggZmV3ZXN0IGJpdHMgZGlmZmVyaW5nXG4gICAgICAgICAgICBsZXQgYmVzdERpZmZlcmVuY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGxldCBiZXN0Rm9ybWF0SW5mbyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZUluZm8gb2YgRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEluZm8gPSBkZWNvZGVJbmZvWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJbmZvID09PSBtYXNrZWRGb3JtYXRJbmZvMSB8fCB0YXJnZXRJbmZvID09PSBtYXNrZWRGb3JtYXRJbmZvMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhbiBleGFjdCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEluZm9ybWF0aW9uKGRlY29kZUluZm9bMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYml0c0RpZmZlcmVuY2UgPSBGb3JtYXRJbmZvcm1hdGlvbi5udW1CaXRzRGlmZmVyaW5nKG1hc2tlZEZvcm1hdEluZm8xLCB0YXJnZXRJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoYml0c0RpZmZlcmVuY2UgPCBiZXN0RGlmZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SW5mbyA9IGRlY29kZUluZm9bMV07XG4gICAgICAgICAgICAgICAgICAgIGJlc3REaWZmZXJlbmNlID0gYml0c0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXNrZWRGb3JtYXRJbmZvMSAhPT0gbWFza2VkRm9ybWF0SW5mbzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB0cnkgdGhlIG90aGVyIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBiaXRzRGlmZmVyZW5jZSA9IEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcobWFza2VkRm9ybWF0SW5mbzIsIHRhcmdldEluZm8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0c0RpZmZlcmVuY2UgPCBiZXN0RGlmZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdEluZm8gPSBkZWNvZGVJbmZvWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbW1pbmcgZGlzdGFuY2Ugb2YgdGhlIDMyIG1hc2tlZCBjb2RlcyBpcyA3LCBieSBjb25zdHJ1Y3Rpb24sIHNvIDw9IDMgYml0c1xuICAgICAgICAgICAgLy8gZGlmZmVyaW5nIG1lYW5zIHdlIGZvdW5kIGEgbWF0Y2hcbiAgICAgICAgICAgIGlmIChiZXN0RGlmZmVyZW5jZSA8PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRJbmZvcm1hdGlvbihiZXN0Rm9ybWF0SW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBnZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgICB9XG4gICAgICAgIGdldERhdGFNYXNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBoYXNoQ29kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbC5nZXRCaXRzKCkgPDwgMykgfCB0aGlzLmRhdGFNYXNrO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBGb3JtYXRJbmZvcm1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IG87XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9PT0gb3RoZXIuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFNYXNrID09PSBvdGhlci5kYXRhTWFzaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19NQVNLX1FSID0gMHg1NDEyO1xuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiwgQW5uZXggQywgVGFibGUgQy4xXG4gICAgICovXG4gICAgRm9ybWF0SW5mb3JtYXRpb24uRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDU0MTIsIDB4MDBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDUxMjUsIDB4MDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDVFN0MsIDB4MDJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDVCNEIsIDB4MDNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDQ1RjksIDB4MDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDQwQ0UsIDB4MDVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDRGOTcsIDB4MDZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDRBQTAsIDB4MDddKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDc3QzQsIDB4MDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDcyRjMsIDB4MDldKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDdEQUEsIDB4MEFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDc4OUQsIDB4MEJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDY2MkYsIDB4MENdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDYzMTgsIDB4MERdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDZDNDEsIDB4MEVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDY5NzYsIDB4MEZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDE2ODksIDB4MTBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDEzQkUsIDB4MTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDFDRTcsIDB4MTJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDE5RDAsIDB4MTNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDA3NjIsIDB4MTRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDAyNTUsIDB4MTVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDBEMEMsIDB4MTZdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDA4M0IsIDB4MTddKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDM1NUYsIDB4MThdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDMwNjgsIDB4MTldKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDNGMzEsIDB4MUFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDNBMDYsIDB4MUJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDI0QjQsIDB4MUNdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDIxODMsIDB4MURdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDJFREEsIDB4MUVdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDJCRUQsIDB4MUZdKSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgc2V0IG9mIGVycm9yLWNvcnJlY3Rpb24gYmxvY2tzIGluIG9uZSBzeW1ib2wgdmVyc2lvbi4gTW9zdCB2ZXJzaW9ucyB3aWxsXG4gICAgICogdXNlIGJsb2NrcyBvZiBkaWZmZXJpbmcgc2l6ZXMgd2l0aGluIG9uZSB2ZXJzaW9uLCBzbywgdGhpcyBlbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yXG4gICAgICogZWFjaCBzZXQgb2YgYmxvY2tzLiBJdCBhbHNvIGhvbGRzIHRoZSBudW1iZXIgb2YgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcGVyIGJsb2NrIHNpbmNlIGl0XG4gICAgICogd2lsbCBiZSB0aGUgc2FtZSBhY3Jvc3MgYWxsIGJsb2NrcyB3aXRoaW4gb25lIHZlcnNpb24uPC9wPlxuICAgICAqL1xuICAgIGNsYXNzIEVDQmxvY2tzJDEge1xuICAgICAgICBjb25zdHJ1Y3RvcihlY0NvZGV3b3Jkc1BlckJsb2NrIC8qaW50Ki8sIC4uLmVjQmxvY2tzKSB7XG4gICAgICAgICAgICB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2sgPSBlY0NvZGV3b3Jkc1BlckJsb2NrO1xuICAgICAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IGVjQmxvY2tzO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDQ29kZXdvcmRzUGVyQmxvY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3Jkc1BlckJsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGdldE51bUJsb2NrcygpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBjb25zdCBlY0Jsb2NrcyA9IHRoaXMuZWNCbG9ja3M7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVjQmxvY2sgb2YgZWNCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG90YWxFQ0NvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2sgKiB0aGlzLmdldE51bUJsb2NrcygpO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDQmxvY2tzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yIG9uZSBlcnJvci1jb3JyZWN0aW9uIGJsb2NrIGluIG9uZSBzeW1ib2wgdmVyc2lvbi5cbiAgICAgKiBUaGlzIGluY2x1ZGVzIHRoZSBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHMsIGFuZCB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgYmxvY2sgd2l0aCB0aGVzZVxuICAgICAqIHBhcmFtZXRlcnMgaXMgdXNlZCBjb25zZWN1dGl2ZWx5IGluIHRoZSBRUiBjb2RlIHZlcnNpb24ncyBmb3JtYXQuPC9wPlxuICAgICAqL1xuICAgIGNsYXNzIEVDQiQxIHtcbiAgICAgICAgY29uc3RydWN0b3IoY291bnQgLyppbnQqLywgZGF0YUNvZGV3b3JkcyAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgICAgICB0aGlzLmRhdGFDb2Rld29yZHMgPSBkYXRhQ29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIGdldENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YUNvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiBBbm5leCBEXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIFZlcnNpb24kMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZlcnNpb25OdW1iZXIgLyppbnQqLywgYWxpZ25tZW50UGF0dGVybkNlbnRlcnMsIC4uLmVjQmxvY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycyA9IGFsaWdubWVudFBhdHRlcm5DZW50ZXJzO1xuICAgICAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IGVjQmxvY2tzO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVjQ29kZXdvcmRzID0gZWNCbG9ja3NbMF0uZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpO1xuICAgICAgICAgICAgY29uc3QgZWNiQXJyYXkgPSBlY0Jsb2Nrc1swXS5nZXRFQ0Jsb2NrcygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlY0Jsb2NrIG9mIGVjYkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZWNCbG9jay5nZXRDb3VudCgpICogKGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpICsgZWNDb2Rld29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50b3RhbENvZGV3b3JkcyA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGdldFZlcnNpb25OdW1iZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGdldEFsaWdubWVudFBhdHRlcm5DZW50ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG90YWxDb2Rld29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbENvZGV3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBnZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIDE3ICsgNCAqIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzW2VjTGV2ZWwuZ2V0VmFsdWUoKV07XG4gICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogb3JpZ2luYWwgd2FzIHVzaW5nIG9yZGluYWwsIGFuZCB1c2luZyB0aGUgb3JkZXIgb2YgbGV2ZWxzIGFzIGRlZmluZWQgaW4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwgZW51bSAoTE1RSClcbiAgICAgICAgICAgIC8vIEkgd2lsbCB1c2UgdGhlIGRpcmVjdCB2YWx1ZSBmcm9tIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzIGVudW0gd2hpY2ggaW4gdHlwZXNjcmlwdCBnb2VzIHRvIGEgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRlZHVjZXMgdmVyc2lvbiBpbmZvcm1hdGlvbiBwdXJlbHkgZnJvbSBRUiBDb2RlIGRpbWVuc2lvbnMuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGltZW5zaW9uIGRpbWVuc2lvbiBpbiBtb2R1bGVzXG4gICAgICAgICAqIEByZXR1cm4gVmVyc2lvbiBmb3IgYSBRUiBDb2RlIG9mIHRoYXQgZGltZW5zaW9uXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGRpbWVuc2lvbiBpcyBub3QgMSBtb2QgNFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbihkaW1lbnNpb24gLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbiAlIDQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZlcnNpb25Gb3JOdW1iZXIoKGRpbWVuc2lvbiAtIDE3KSAvIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRWZXJzaW9uRm9yTnVtYmVyKHZlcnNpb25OdW1iZXIgLyppbnQqLykge1xuICAgICAgICAgICAgaWYgKHZlcnNpb25OdW1iZXIgPCAxIHx8IHZlcnNpb25OdW1iZXIgPiA0MCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBWZXJzaW9uJDEuVkVSU0lPTlNbdmVyc2lvbk51bWJlciAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMgLyppbnQqLykge1xuICAgICAgICAgICAgbGV0IGJlc3REaWZmZXJlbmNlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICBsZXQgYmVzdFZlcnNpb24gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBWZXJzaW9uJDEuVkVSU0lPTl9ERUNPREVfSU5GTy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZlcnNpb24gPSBWZXJzaW9uJDEuVkVSU0lPTl9ERUNPREVfSU5GT1tpXTtcbiAgICAgICAgICAgICAgICAvLyBEbyB0aGUgdmVyc2lvbiBpbmZvIGJpdHMgbWF0Y2ggZXhhY3RseT8gZG9uZS5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VmVyc2lvbiA9PT0gdmVyc2lvbkJpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24kMS5nZXRWZXJzaW9uRm9yTnVtYmVyKGkgKyA3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNlZSBpZiB0aGlzIGlzIHRoZSBjbG9zZXN0IHRvIGEgcmVhbCB2ZXJzaW9uIGluZm8gYml0IHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgc2VlbiBzbyBmYXJcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzRGlmZmVyZW5jZSA9IEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcodmVyc2lvbkJpdHMsIHRhcmdldFZlcnNpb24pO1xuICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RWZXJzaW9uID0gaSArIDc7XG4gICAgICAgICAgICAgICAgICAgIGJlc3REaWZmZXJlbmNlID0gYml0c0RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgY2FuIHRvbGVyYXRlIHVwIHRvIDMgYml0cyBvZiBlcnJvciBzaW5jZSBubyB0d28gdmVyc2lvbiBpbmZvIGNvZGV3b3JkcyB3aWxsXG4gICAgICAgICAgICAvLyBkaWZmZXIgaW4gbGVzcyB0aGFuIDggYml0cy5cbiAgICAgICAgICAgIGlmIChiZXN0RGlmZmVyZW5jZSA8PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlcnNpb24kMS5nZXRWZXJzaW9uRm9yTnVtYmVyKGJlc3RWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgY2xvc2UgZW5vdWdoIG1hdGNoLCBmYWlsXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIElTTyAxODAwNDoyMDA2IEFubmV4IEVcbiAgICAgICAgICovXG4gICAgICAgIGJ1aWxkRnVuY3Rpb25QYXR0ZXJuKCkge1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCk7XG4gICAgICAgICAgICBjb25zdCBiaXRNYXRyaXggPSBuZXcgQml0TWF0cml4KGRpbWVuc2lvbik7XG4gICAgICAgICAgICAvLyBUb3AgbGVmdCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxuICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCAwLCA5LCA5KTtcbiAgICAgICAgICAgIC8vIFRvcCByaWdodCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxuICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbihkaW1lbnNpb24gLSA4LCAwLCA4LCA5KTtcbiAgICAgICAgICAgIC8vIEJvdHRvbSBsZWZ0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIGRpbWVuc2lvbiAtIDgsIDksIDgpO1xuICAgICAgICAgICAgLy8gQWxpZ25tZW50IHBhdHRlcm5zXG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbWF4OyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t4XSAtIDI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBtYXg7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHggPT09IDAgJiYgKHkgPT09IDAgfHwgeSA9PT0gbWF4IC0gMSkpIHx8ICh4ID09PSBtYXggLSAxICYmIHkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBhbGlnbm1lbnQgcGF0dGVybnMgbmVhciB0aGUgdGhyZWUgZmluZGVyIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnNbeV0gLSAyLCBpLCA1LCA1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCB0aW1pbmcgcGF0dGVyblxuICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbig2LCA5LCAxLCBkaW1lbnNpb24gLSAxNyk7XG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDksIDYsIGRpbWVuc2lvbiAtIDE3LCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnNpb25OdW1iZXIgPiA2KSB7XG4gICAgICAgICAgICAgICAgLy8gVmVyc2lvbiBpbmZvLCB0b3AgcmlnaHRcbiAgICAgICAgICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKGRpbWVuc2lvbiAtIDExLCAwLCAzLCA2KTtcbiAgICAgICAgICAgICAgICAvLyBWZXJzaW9uIGluZm8sIGJvdHRvbSBsZWZ0XG4gICAgICAgICAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSAxMSwgNiwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYml0TWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB0aGlzLnZlcnNpb25OdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgQW5uZXggRC5cbiAgICAgICAqIEVsZW1lbnQgaSByZXByZXNlbnRzIHRoZSByYXcgdmVyc2lvbiBiaXRzIHRoYXQgc3BlY2lmeSB2ZXJzaW9uIGkgKyA3XG4gICAgICAgKi9cbiAgICBWZXJzaW9uJDEuVkVSU0lPTl9ERUNPREVfSU5GTyA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIDB4MDdDOTQsIDB4MDg1QkMsIDB4MDlBOTksIDB4MEE0RDMsIDB4MEJCRjYsXG4gICAgICAgIDB4MEM3NjIsIDB4MEQ4NDcsIDB4MEU2MEQsIDB4MEY5MjgsIDB4MTBCNzgsXG4gICAgICAgIDB4MTE0NUQsIDB4MTJBMTcsIDB4MTM1MzIsIDB4MTQ5QTYsIDB4MTU2ODMsXG4gICAgICAgIDB4MTY4QzksIDB4MTc3RUMsIDB4MThFQzQsIDB4MTkxRTEsIDB4MUFGQUIsXG4gICAgICAgIDB4MUIwOEUsIDB4MUNDMUEsIDB4MUQzM0YsIDB4MUVENzUsIDB4MUYyNTAsXG4gICAgICAgIDB4MjA5RDUsIDB4MjE2RjAsIDB4MjI4QkEsIDB4MjM3OUYsIDB4MjRCMEIsXG4gICAgICAgIDB4MjU0MkUsIDB4MjZBNjQsIDB4Mjc1NDEsIDB4MjhDNjlcbiAgICBdKTtcbiAgICAvKipcbiAgICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiA2LjUuMSBUYWJsZSA5XG4gICAgICAgKi9cbiAgICBWZXJzaW9uJDEuVkVSU0lPTlMgPSBbXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMSwgbmV3IEludDMyQXJyYXkoMCksIG5ldyBFQ0Jsb2NrcyQxKDcsIG5ldyBFQ0IkMSgxLCAxOSkpLCBuZXcgRUNCbG9ja3MkMSgxMCwgbmV3IEVDQiQxKDEsIDE2KSksIG5ldyBFQ0Jsb2NrcyQxKDEzLCBuZXcgRUNCJDEoMSwgMTMpKSwgbmV3IEVDQmxvY2tzJDEoMTcsIG5ldyBFQ0IkMSgxLCA5KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDIsIEludDMyQXJyYXkuZnJvbShbNiwgMThdKSwgbmV3IEVDQmxvY2tzJDEoMTAsIG5ldyBFQ0IkMSgxLCAzNCkpLCBuZXcgRUNCbG9ja3MkMSgxNiwgbmV3IEVDQiQxKDEsIDI4KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoMSwgMjIpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzLCBJbnQzMkFycmF5LmZyb20oWzYsIDIyXSksIG5ldyBFQ0Jsb2NrcyQxKDE1LCBuZXcgRUNCJDEoMSwgNTUpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSgxLCA0NCkpLCBuZXcgRUNCbG9ja3MkMSgxOCwgbmV3IEVDQiQxKDIsIDE3KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoMiwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNl0pLCBuZXcgRUNCbG9ja3MkMSgyMCwgbmV3IEVDQiQxKDEsIDgwKSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgMzIpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSgyLCAyNCkpLCBuZXcgRUNCbG9ja3MkMSgxNiwgbmV3IEVDQiQxKDQsIDkpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoNSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMF0pLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDEsIDEwOCkpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDIsIDQzKSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgMTUpLCBuZXcgRUNCJDEoMiwgMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgyLCAxMSksIG5ldyBFQ0IkMSgyLCAxMikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg2LCBJbnQzMkFycmF5LmZyb20oWzYsIDM0XSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgNjgpKSwgbmV3IEVDQmxvY2tzJDEoMTYsIG5ldyBFQ0IkMSg0LCAyNykpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDQsIDE5KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNCwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoNywgSW50MzJBcnJheS5mcm9tKFs2LCAyMiwgMzhdKSwgbmV3IEVDQmxvY2tzJDEoMjAsIG5ldyBFQ0IkMSgyLCA3OCkpLCBuZXcgRUNCbG9ja3MkMSgxOCwgbmV3IEVDQiQxKDQsIDMxKSksIG5ldyBFQ0Jsb2NrcyQxKDE4LCBuZXcgRUNCJDEoMiwgMTQpLCBuZXcgRUNCJDEoNCwgMTUpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg0LCAxMyksIG5ldyBFQ0IkMSgxLCAxNCkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSg4LCBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA0Ml0pLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDIsIDk3KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoMiwgMzgpLCBuZXcgRUNCJDEoMiwgMzkpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSg0LCAxOCksIG5ldyBFQ0IkMSgyLCAxOSkpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDQsIDE0KSwgbmV3IEVDQiQxKDIsIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDksIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMiwgMTE2KSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoMywgMzYpLCBuZXcgRUNCJDEoMiwgMzcpKSwgbmV3IEVDQmxvY2tzJDEoMjAsIG5ldyBFQ0IkMSg0LCAxNiksIG5ldyBFQ0IkMSg0LCAxNykpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDQsIDEyKSwgbmV3IEVDQiQxKDQsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDEwLCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MF0pLCBuZXcgRUNCbG9ja3MkMSgxOCwgbmV3IEVDQiQxKDIsIDY4KSwgbmV3IEVDQiQxKDIsIDY5KSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoNCwgNDMpLCBuZXcgRUNCJDEoMSwgNDQpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg2LCAxOSksIG5ldyBFQ0IkMSgyLCAyMCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDYsIDE1KSwgbmV3IEVDQiQxKDIsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDExLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NF0pLCBuZXcgRUNCbG9ja3MkMSgyMCwgbmV3IEVDQiQxKDQsIDgxKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMSwgNTApLCBuZXcgRUNCJDEoNCwgNTEpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg0LCAyMiksIG5ldyBFQ0IkMSg0LCAyMykpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDMsIDEyKSwgbmV3IEVDQiQxKDgsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDEyLCBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OF0pLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDIsIDkyKSwgbmV3IEVDQiQxKDIsIDkzKSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoNiwgMzYpLCBuZXcgRUNCJDEoMiwgMzcpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg0LCAyMCksIG5ldyBFQ0IkMSg2LCAyMSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDcsIDE0KSwgbmV3IEVDQiQxKDQsIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDEzLCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2Ml0pLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDQsIDEwNykpLCBuZXcgRUNCbG9ja3MkMSgyMiwgbmV3IEVDQiQxKDgsIDM3KSwgbmV3IEVDQiQxKDEsIDM4KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoOCwgMjApLCBuZXcgRUNCJDEoNCwgMjEpKSwgbmV3IEVDQmxvY2tzJDEoMjIsIG5ldyBFQ0IkMSgxMiwgMTEpLCBuZXcgRUNCJDEoNCwgMTIpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTQsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2LCA2Nl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDMsIDExNSksIG5ldyBFQ0IkMSgxLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg0LCA0MCksIG5ldyBFQ0IkMSg1LCA0MSkpLCBuZXcgRUNCbG9ja3MkMSgyMCwgbmV3IEVDQiQxKDExLCAxNiksIG5ldyBFQ0IkMSg1LCAxNykpLCBuZXcgRUNCbG9ja3MkMSgyNCwgbmV3IEVDQiQxKDExLCAxMiksIG5ldyBFQ0IkMSg1LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgxNSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDgsIDcwXSksIG5ldyBFQ0Jsb2NrcyQxKDIyLCBuZXcgRUNCJDEoNSwgODcpLCBuZXcgRUNCJDEoMSwgODgpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg1LCA0MSksIG5ldyBFQ0IkMSg1LCA0MikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDUsIDI0KSwgbmV3IEVDQiQxKDcsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMTEsIDEyKSwgbmV3IEVDQiQxKDcsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDE2LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzRdKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSg1LCA5OCksIG5ldyBFQ0IkMSgxLCA5OSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDcsIDQ1KSwgbmV3IEVDQiQxKDMsIDQ2KSksIG5ldyBFQ0Jsb2NrcyQxKDI0LCBuZXcgRUNCJDEoMTUsIDE5KSwgbmV3IEVDQiQxKDIsIDIwKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMywgMTUpLCBuZXcgRUNCJDEoMTMsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDE3LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzhdKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxLCAxMDcpLCBuZXcgRUNCJDEoNSwgMTA4KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTAsIDQ2KSwgbmV3IEVDQiQxKDEsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMSwgMjIpLCBuZXcgRUNCJDEoMTUsIDIzKSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMiwgMTQpLCBuZXcgRUNCJDEoMTcsIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDE4LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODJdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg1LCAxMjApLCBuZXcgRUNCJDEoMSwgMTIxKSksIG5ldyBFQ0Jsb2NrcyQxKDI2LCBuZXcgRUNCJDEoOSwgNDMpLCBuZXcgRUNCJDEoNCwgNDQpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxNywgMjIpLCBuZXcgRUNCJDEoMSwgMjMpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyLCAxNCksIG5ldyBFQ0IkMSgxOSwgMTUpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMTksIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4Nl0pLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDMsIDExMyksIG5ldyBFQ0IkMSg0LCAxMTQpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSgzLCA0NCksIG5ldyBFQ0IkMSgxMSwgNDUpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSgxNywgMjEpLCBuZXcgRUNCJDEoNCwgMjIpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSg5LCAxMyksIG5ldyBFQ0IkMSgxNiwgMTQpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjAsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MF0pLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDMsIDEwNyksIG5ldyBFQ0IkMSg1LCAxMDgpKSwgbmV3IEVDQmxvY2tzJDEoMjYsIG5ldyBFQ0IkMSgzLCA0MSksIG5ldyBFQ0IkMSgxMywgNDIpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxNSwgMjQpLCBuZXcgRUNCJDEoNSwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxNSwgMTUpLCBuZXcgRUNCJDEoMTAsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDIxLCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1MCwgNzIsIDk0XSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNCwgMTE2KSwgbmV3IEVDQiQxKDQsIDExNykpLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDE3LCA0MikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDE3LCAyMiksIG5ldyBFQ0IkMSg2LCAyMykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE5LCAxNiksIG5ldyBFQ0IkMSg2LCAxNykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgyMiwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OF0pLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDIsIDExMSksIG5ldyBFQ0IkMSg3LCAxMTIpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxNywgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg3LCAyNCksIG5ldyBFQ0IkMSgxNiwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMjQsIG5ldyBFQ0IkMSgzNCwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjMsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNCwgMTIxKSwgbmV3IEVDQiQxKDUsIDEyMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDQsIDQ3KSwgbmV3IEVDQiQxKDE0LCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDExLCAyNCksIG5ldyBFQ0IkMSgxNCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxNiwgMTUpLCBuZXcgRUNCJDEoMTQsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDI0LCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1NCwgODAsIDEwNl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDYsIDExNyksIG5ldyBFQ0IkMSg0LCAxMTgpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg2LCA0NSksIG5ldyBFQ0IkMSgxNCwgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMSwgMjQpLCBuZXcgRUNCJDEoMTYsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMzAsIDE2KSwgbmV3IEVDQiQxKDIsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDI1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMF0pLCBuZXcgRUNCbG9ja3MkMSgyNiwgbmV3IEVDQiQxKDgsIDEwNiksIG5ldyBFQ0IkMSg0LCAxMDcpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg4LCA0NyksIG5ldyBFQ0IkMSgxMywgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg3LCAyNCksIG5ldyBFQ0IkMSgyMiwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyMiwgMTUpLCBuZXcgRUNCJDEoMTMsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDI2LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODYsIDExNF0pLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEwLCAxMTQpLCBuZXcgRUNCJDEoMiwgMTE1KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTksIDQ2KSwgbmV3IEVDQiQxKDQsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMjgsIDIyKSwgbmV3IEVDQiQxKDYsIDIzKSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMzMsIDE2KSwgbmV3IEVDQiQxKDQsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDI3LCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIDExOF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDgsIDEyMiksIG5ldyBFQ0IkMSg0LCAxMjMpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyMiwgNDUpLCBuZXcgRUNCJDEoMywgNDYpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg4LCAyMyksIG5ldyBFQ0IkMSgyNiwgMjQpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMiwgMTUpLCBuZXcgRUNCJDEoMjgsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDI4LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjJdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzLCAxMTcpLCBuZXcgRUNCJDEoMTAsIDExOCkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDMsIDQ1KSwgbmV3IEVDQiQxKDIzLCA0NikpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQsIDI0KSwgbmV3IEVDQiQxKDMxLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDExLCAxNSksIG5ldyBFQ0IkMSgzMSwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMjksIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjZdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg3LCAxMTYpLCBuZXcgRUNCJDEoNywgMTE3KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMjEsIDQ1KSwgbmV3IEVDQiQxKDcsIDQ2KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMSwgMjMpLCBuZXcgRUNCJDEoMzcsIDI0KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTksIDE1KSwgbmV3IEVDQiQxKDI2LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzMCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDUsIDExNSksIG5ldyBFQ0IkMSgxMCwgMTE2KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTksIDQ3KSwgbmV3IEVDQiQxKDEwLCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE1LCAyNCksIG5ldyBFQ0IkMSgyNSwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyMywgMTUpLCBuZXcgRUNCJDEoMjUsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMxLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTMsIDExNSksIG5ldyBFQ0IkMSgzLCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgyLCA0NiksIG5ldyBFQ0IkMSgyOSwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0MiwgMjQpLCBuZXcgRUNCJDEoMSwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyMywgMTUpLCBuZXcgRUNCJDEoMjgsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDMyLCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MCwgODYsIDExMiwgMTM4XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTcsIDExNSkpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEwLCA0NiksIG5ldyBFQ0IkMSgyMywgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMCwgMjQpLCBuZXcgRUNCJDEoMzUsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTksIDE1KSwgbmV3IEVDQiQxKDM1LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzMywgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0Ml0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE3LCAxMTUpLCBuZXcgRUNCJDEoMSwgMTE2KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTQsIDQ2KSwgbmV3IEVDQiQxKDIxLCA0NykpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDI5LCAyNCksIG5ldyBFQ0IkMSgxOSwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMSwgMTUpLCBuZXcgRUNCJDEoNDYsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM0LCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMTMsIDExNSksIG5ldyBFQ0IkMSg2LCAxMTYpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxNCwgNDYpLCBuZXcgRUNCJDEoMjMsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDQsIDI0KSwgbmV3IEVDQiQxKDcsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNTksIDE2KSwgbmV3IEVDQiQxKDEsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM1LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAxNTBdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxMiwgMTIxKSwgbmV3IEVDQiQxKDcsIDEyMikpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDEyLCA0NyksIG5ldyBFQ0IkMSgyNiwgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgzOSwgMjQpLCBuZXcgRUNCJDEoMTQsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjIsIDE1KSwgbmV3IEVDQiQxKDQxLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzNiwgSW50MzJBcnJheS5mcm9tKFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNiwgMTIxKSwgbmV3IEVDQiQxKDE0LCAxMjIpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSg2LCA0NyksIG5ldyBFQ0IkMSgzNCwgNDgpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0NiwgMjQpLCBuZXcgRUNCJDEoMTAsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMiwgMTUpLCBuZXcgRUNCJDEoNjQsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbiQxKDM3LCBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1NCwgODAsIDEwNiwgMTMyLCAxNThdKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgxNywgMTIyKSwgbmV3IEVDQiQxKDQsIDEyMykpLCBuZXcgRUNCbG9ja3MkMSgyOCwgbmV3IEVDQiQxKDI5LCA0NiksIG5ldyBFQ0IkMSgxNCwgNDcpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSg0OSwgMjQpLCBuZXcgRUNCJDEoMTAsIDI1KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoMjQsIDE1KSwgbmV3IEVDQiQxKDQ2LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24kMSgzOCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNCwgMTIyKSwgbmV3IEVDQiQxKDE4LCAxMjMpKSwgbmV3IEVDQmxvY2tzJDEoMjgsIG5ldyBFQ0IkMSgxMywgNDYpLCBuZXcgRUNCJDEoMzIsIDQ3KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDgsIDI0KSwgbmV3IEVDQiQxKDE0LCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDQyLCAxNSksIG5ldyBFQ0IkMSgzMiwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoMzksIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDU0LCA4MiwgMTEwLCAxMzgsIDE2Nl0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDIwLCAxMTcpLCBuZXcgRUNCJDEoNCwgMTE4KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoNDAsIDQ3KSwgbmV3IEVDQiQxKDcsIDQ4KSksIG5ldyBFQ0Jsb2NrcyQxKDMwLCBuZXcgRUNCJDEoNDMsIDI0KSwgbmV3IEVDQiQxKDIyLCAyNSkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDEwLCAxNSksIG5ldyBFQ0IkMSg2NywgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uJDEoNDAsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF0pLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDE5LCAxMTgpLCBuZXcgRUNCJDEoNiwgMTE5KSksIG5ldyBFQ0Jsb2NrcyQxKDI4LCBuZXcgRUNCJDEoMTgsIDQ3KSwgbmV3IEVDQiQxKDMxLCA0OCkpLCBuZXcgRUNCbG9ja3MkMSgzMCwgbmV3IEVDQiQxKDM0LCAyNCksIG5ldyBFQ0IkMSgzNCwgMjUpKSwgbmV3IEVDQmxvY2tzJDEoMzAsIG5ldyBFQ0IkMSgyMCwgMTUpLCBuZXcgRUNCJDEoNjEsIDE2KSkpXG4gICAgXTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgdmFyIERhdGFNYXNrVmFsdWVzO1xuICAgIChmdW5jdGlvbiAoRGF0YU1hc2tWYWx1ZXMpIHtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMDAwXCJdID0gMF0gPSBcIkRBVEFfTUFTS18wMDBcIjtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMDAxXCJdID0gMV0gPSBcIkRBVEFfTUFTS18wMDFcIjtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMDEwXCJdID0gMl0gPSBcIkRBVEFfTUFTS18wMTBcIjtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMDExXCJdID0gM10gPSBcIkRBVEFfTUFTS18wMTFcIjtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMTAwXCJdID0gNF0gPSBcIkRBVEFfTUFTS18xMDBcIjtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMTAxXCJdID0gNV0gPSBcIkRBVEFfTUFTS18xMDFcIjtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMTEwXCJdID0gNl0gPSBcIkRBVEFfTUFTS18xMTBcIjtcbiAgICAgICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMTExXCJdID0gN10gPSBcIkRBVEFfTUFTS18xMTFcIjtcbiAgICB9KShEYXRhTWFza1ZhbHVlcyB8fCAoRGF0YU1hc2tWYWx1ZXMgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBkYXRhIG1hc2tzIGZvciB0aGUgZGF0YSBiaXRzIGluIGEgUVIgY29kZSwgcGVyIElTTyAxODAwNDoyMDA2IDYuOC4gSW1wbGVtZW50YXRpb25zXG4gICAgICogb2YgdGhpcyBjbGFzcyBjYW4gdW4tbWFzayBhIHJhdyBCaXRNYXRyaXguIEZvciBzaW1wbGljaXR5LCB0aGV5IHdpbGwgdW5tYXNrIHRoZSBlbnRpcmUgQml0TWF0cml4LFxuICAgICAqIGluY2x1ZGluZyBhcmVhcyB1c2VkIGZvciBmaW5kZXIgcGF0dGVybnMsIHRpbWluZyBwYXR0ZXJucywgZXRjLiBUaGVzZSBhcmVhcyBzaG91bGQgYmUgdW51c2VkXG4gICAgICogYWZ0ZXIgdGhlIHBvaW50IHRoZXkgYXJlIHVubWFza2VkIGFueXdheS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5Ob3RlIHRoYXQgdGhlIGRpYWdyYW0gaW4gc2VjdGlvbiA2LjguMSBpcyBtaXNsZWFkaW5nIHNpbmNlIGl0IGluZGljYXRlcyB0aGF0IGkgaXMgY29sdW1uIHBvc2l0aW9uXG4gICAgICogYW5kIGogaXMgcm93IHBvc2l0aW9uLiBJbiBmYWN0LCBhcyB0aGUgdGV4dCBzYXlzLCBpIGlzIHJvdyBwb3NpdGlvbiBhbmQgaiBpcyBjb2x1bW4gcG9zaXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEYXRhTWFzayB7XG4gICAgICAgIC8vIFNlZSBJU08gMTgwMDQ6MjAwNiA2LjguMVxuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgaXNNYXNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNNYXNrZWQgPSBpc01hc2tlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmQgb2YgZW51bSBjb25zdGFudHMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5JbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBtZXRob2QgcmV2ZXJzZSB0aGUgZGF0YSBtYXNraW5nIHByb2Nlc3MgYXBwbGllZCB0byBhIFFSIENvZGUgYW5kXG4gICAgICAgICAqIG1ha2UgaXRzIGJpdHMgcmVhZHkgdG8gcmVhZC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRzIHJlcHJlc2VudGF0aW9uIG9mIFFSIENvZGUgYml0c1xuICAgICAgICAgKiBAcGFyYW0gZGltZW5zaW9uIGRpbWVuc2lvbiBvZiBRUiBDb2RlLCByZXByZXNlbnRlZCBieSBiaXRzLCBiZWluZyB1bm1hc2tlZFxuICAgICAgICAgKi9cbiAgICAgICAgdW5tYXNrQml0TWF0cml4KGJpdHMsIGRpbWVuc2lvbiAvKmludCovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc01hc2tlZChpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIERhdGFNYXNrLnZhbHVlcyA9IG5ldyBNYXAoW1xuICAgICAgICAvKipcbiAgICAgICAgICogMDAwOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4ICsgeSkgbW9kIDIgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDAsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAwLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuICgoaSArIGopICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAwMTogbWFzayBiaXRzIGZvciB3aGljaCB4IG1vZCAyID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDAxLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMSwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoaSAmIDB4MDEpID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAwMTA6IG1hc2sgYml0cyBmb3Igd2hpY2ggeSBtb2QgMyA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTAsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gaiAlIDMgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDAxMTogbWFzayBiaXRzIGZvciB3aGljaCAoeCArIHkpIG1vZCAzID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDExLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMSwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoaSArIGopICUgMyA9PT0gMDsgfSldLFxuICAgICAgICAvKipcbiAgICAgICAgICogMTAwOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4LzIgKyB5LzMpIG1vZCAyID09IDBcbiAgICAgICAgICovXG4gICAgICAgIFtEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAwLCBuZXcgRGF0YU1hc2soRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMCwgKGkgLyppbnQqLywgaiAvKmludCovKSA9PiB7IHJldHVybiAoKE1hdGguZmxvb3IoaSAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykpICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDEwMTogbWFzayBiaXRzIGZvciB3aGljaCB4eSBtb2QgMiArIHh5IG1vZCAzID09IDBcbiAgICAgICAgICogZXF1aXZhbGVudGx5LCBzdWNoIHRoYXQgeHkgbW9kIDYgPT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTAxLCAoaSAvKmludCovLCBqIC8qaW50Ki8pID0+IHsgcmV0dXJuIChpICogaikgJSA2ID09PSAwOyB9KV0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMTA6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHh5IG1vZCAyICsgeHkgbW9kIDMpIG1vZCAyID09IDBcbiAgICAgICAgICogZXF1aXZhbGVudGx5LCBzdWNoIHRoYXQgeHkgbW9kIDYgPCAzXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTAsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKChpICogaikgJSA2KSA8IDM7IH0pXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDExMTogbWFzayBiaXRzIGZvciB3aGljaCAoKHgreSltb2QgMiArIHh5IG1vZCAzKSBtb2QgMiA9PSAwXG4gICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0ICh4ICsgeSArIHh5IG1vZCAzKSBtb2QgMiA9PSAwXG4gICAgICAgICAqL1xuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTEsIChpIC8qaW50Ki8sIGogLyppbnQqLykgPT4geyByZXR1cm4gKChpICsgaiArICgoaSAqIGopICUgMykpICYgMHgwMSkgPT09IDA7IH0pXSxcbiAgICBdKTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBCaXRNYXRyaXhQYXJzZXIkMSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYml0TWF0cml4IHtAbGluayBCaXRNYXRyaXh9IHRvIHBhcnNlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGRpbWVuc2lvbiBpcyBub3QgPj0gMjEgYW5kIDEgbW9kIDRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGJpdE1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbiA8IDIxIHx8IChkaW1lbnNpb24gJiAweDAzKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYml0TWF0cml4ID0gYml0TWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5SZWFkcyBmb3JtYXQgaW5mb3JtYXRpb24gZnJvbSBvbmUgb2YgaXRzIHR3byBsb2NhdGlvbnMgd2l0aGluIHRoZSBRUiBDb2RlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgRm9ybWF0SW5mb3JtYXRpb259IGVuY2Fwc3VsYXRpbmcgdGhlIFFSIENvZGUncyBmb3JtYXQgaW5mb1xuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBib3RoIGZvcm1hdCBpbmZvcm1hdGlvbiBsb2NhdGlvbnMgY2Fubm90IGJlIHBhcnNlZCBhc1xuICAgICAgICAgKiB0aGUgdmFsaWQgZW5jb2Rpbmcgb2YgZm9ybWF0IGluZm9ybWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICByZWFkRm9ybWF0SW5mb3JtYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSBudWxsICYmIHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRm9ybWF0SW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlYWQgdG9wLWxlZnQgZm9ybWF0IGluZm8gYml0c1xuICAgICAgICAgICAgbGV0IGZvcm1hdEluZm9CaXRzMSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdChpLCA4LCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLi4gYW5kIHNraXAgYSBiaXQgaW4gdGhlIHRpbWluZyBwYXR0ZXJuIC4uLlxuICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KDcsIDgsIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgOCwgZm9ybWF0SW5mb0JpdHMxKTtcbiAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg4LCA3LCBmb3JtYXRJbmZvQml0czEpO1xuICAgICAgICAgICAgLy8gLi4gYW5kIHNraXAgYSBiaXQgaW4gdGhlIHRpbWluZyBwYXR0ZXJuIC4uLlxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDU7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KDgsIGosIGZvcm1hdEluZm9CaXRzMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWFkIHRoZSB0b3AtcmlnaHQvYm90dG9tLWxlZnQgcGF0dGVybiB0b29cbiAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgbGV0IGZvcm1hdEluZm9CaXRzMiA9IDA7XG4gICAgICAgICAgICBjb25zdCBqTWluID0gZGltZW5zaW9uIC0gNztcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBkaW1lbnNpb24gLSAxOyBqID49IGpNaW47IGotLSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMiA9IHRoaXMuY29weUJpdCg4LCBqLCBmb3JtYXRJbmZvQml0czIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGRpbWVuc2lvbiAtIDg7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMiA9IHRoaXMuY29weUJpdChpLCA4LCBmb3JtYXRJbmZvQml0czIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID0gRm9ybWF0SW5mb3JtYXRpb24uZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24oZm9ybWF0SW5mb0JpdHMxLCBmb3JtYXRJbmZvQml0czIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEZvcm1hdEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlJlYWRzIHZlcnNpb24gaW5mb3JtYXRpb24gZnJvbSBvbmUgb2YgaXRzIHR3byBsb2NhdGlvbnMgd2l0aGluIHRoZSBRUiBDb2RlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgVmVyc2lvbn0gZW5jYXBzdWxhdGluZyB0aGUgUVIgQ29kZSdzIHZlcnNpb25cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYm90aCB2ZXJzaW9uIGluZm9ybWF0aW9uIGxvY2F0aW9ucyBjYW5ub3QgYmUgcGFyc2VkIGFzXG4gICAgICAgICAqIHRoZSB2YWxpZCBlbmNvZGluZyBvZiB2ZXJzaW9uIGluZm9ybWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICByZWFkVmVyc2lvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhpcy5wYXJzZWRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBwcm92aXNpb25hbFZlcnNpb24gPSBNYXRoLmZsb29yKChkaW1lbnNpb24gLSAxNykgLyA0KTtcbiAgICAgICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24gPD0gNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBWZXJzaW9uJDEuZ2V0VmVyc2lvbkZvck51bWJlcihwcm92aXNpb25hbFZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVhZCB0b3AtcmlnaHQgdmVyc2lvbiBpbmZvOiAzIHdpZGUgYnkgNiB0YWxsXG4gICAgICAgICAgICBsZXQgdmVyc2lvbkJpdHMgPSAwO1xuICAgICAgICAgICAgY29uc3QgaWpNaW4gPSBkaW1lbnNpb24gLSAxMTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA1OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBkaW1lbnNpb24gLSA5OyBpID49IGlqTWluOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbkJpdHMgPSB0aGlzLmNvcHlCaXQoaSwgaiwgdmVyc2lvbkJpdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aGVQYXJzZWRWZXJzaW9uID0gVmVyc2lvbiQxLmRlY29kZVZlcnNpb25JbmZvcm1hdGlvbih2ZXJzaW9uQml0cyk7XG4gICAgICAgICAgICBpZiAodGhlUGFyc2VkVmVyc2lvbiAhPT0gbnVsbCAmJiB0aGVQYXJzZWRWZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKSA9PT0gZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gdGhlUGFyc2VkVmVyc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhlUGFyc2VkVmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhtbSwgZmFpbGVkLiBUcnkgYm90dG9tIGxlZnQ6IDYgd2lkZSBieSAzIHRhbGxcbiAgICAgICAgICAgIHZlcnNpb25CaXRzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSA1OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBkaW1lbnNpb24gLSA5OyBqID49IGlqTWluOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbkJpdHMgPSB0aGlzLmNvcHlCaXQoaSwgaiwgdmVyc2lvbkJpdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoZVBhcnNlZFZlcnNpb24gPSBWZXJzaW9uJDEuZGVjb2RlVmVyc2lvbkluZm9ybWF0aW9uKHZlcnNpb25CaXRzKTtcbiAgICAgICAgICAgIGlmICh0aGVQYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoZVBhcnNlZFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpID09PSBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSB0aGVQYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGVQYXJzZWRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvcHlCaXQoaSAvKmludCovLCBqIC8qaW50Ki8sIHZlcnNpb25CaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdCA9IHRoaXMuaXNNaXJyb3IgPyB0aGlzLmJpdE1hdHJpeC5nZXQoaiwgaSkgOiB0aGlzLmJpdE1hdHJpeC5nZXQoaSwgaik7XG4gICAgICAgICAgICByZXR1cm4gYml0ID8gKHZlcnNpb25CaXRzIDw8IDEpIHwgMHgxIDogdmVyc2lvbkJpdHMgPDwgMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+UmVhZHMgdGhlIGJpdHMgaW4gdGhlIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGluZyB0aGUgZmluZGVyIHBhdHRlcm4gaW4gdGhlXG4gICAgICAgICAqIGNvcnJlY3Qgb3JkZXIgaW4gb3JkZXIgdG8gcmVjb25zdHJ1Y3QgdGhlIGNvZGV3b3JkcyBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZVxuICAgICAgICAgKiBRUiBDb2RlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgZXhhY3QgbnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGlzIG5vdCByZWFkXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29kZXdvcmRzKCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0SW5mbyA9IHRoaXMucmVhZEZvcm1hdEluZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbigpO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBkYXRhIG1hc2sgZm9yIHRoZSBmb3JtYXQgdXNlZCBpbiB0aGlzIFFSIENvZGUuIFRoaXMgd2lsbCBleGNsdWRlXG4gICAgICAgICAgICAvLyBzb21lIGJpdHMgZnJvbSByZWFkaW5nIGFzIHdlIHdpbmQgdGhyb3VnaCB0aGUgYml0IG1hdHJpeC5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFNYXNrID0gRGF0YU1hc2sudmFsdWVzLmdldChmb3JtYXRJbmZvLmdldERhdGFNYXNrKCkpO1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBkYXRhTWFzay51bm1hc2tCaXRNYXRyaXgodGhpcy5iaXRNYXRyaXgsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvblBhdHRlcm4gPSB2ZXJzaW9uLmJ1aWxkRnVuY3Rpb25QYXR0ZXJuKCk7XG4gICAgICAgICAgICBsZXQgcmVhZGluZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICBsZXQgYml0c1JlYWQgPSAwO1xuICAgICAgICAgICAgLy8gUmVhZCBjb2x1bW5zIGluIHBhaXJzLCBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBkaW1lbnNpb24gLSAxOyBqID4gMDsgaiAtPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB3aG9sZSBjb2x1bW4gd2l0aCB2ZXJ0aWNhbCBhbGlnbm1lbnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAvLyBzYXZlcyB0aW1lIGFuZCBtYWtlcyB0aGUgb3RoZXIgY29kZSBwcm9jZWVkIG1vcmUgY2xlYW5seVxuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlYWQgYWx0ZXJuYXRpbmdseSBmcm9tIGJvdHRvbSB0byB0b3AgdGhlbiB0b3AgdG8gYm90dG9tXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY291bnQgPSAwOyBjb3VudCA8IGRpbWVuc2lvbjsgY291bnQrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gcmVhZGluZ1VwID8gZGltZW5zaW9uIC0gMSAtIGNvdW50IDogY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDI7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYml0cyBjb3ZlcmVkIGJ5IHRoZSBmdW5jdGlvbiBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uUGF0dGVybi5nZXQoaiAtIGNvbCwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIGEgYml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0c1JlYWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iaXRNYXRyaXguZ2V0KGogLSBjb2wsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIG1hZGUgYSB3aG9sZSBieXRlLCBzYXZlIGl0IG9mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzUmVhZCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gLyooYnl0ZSkgKi8gY3VycmVudEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHNSZWFkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkaW5nVXAgPSAhcmVhZGluZ1VwOyAvLyByZWFkaW5nVXAgXj0gdHJ1ZTsgLy8gcmVhZGluZ1VwID0gIXJlYWRpbmdVcDsgLy8gc3dpdGNoIGRpcmVjdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgIT09IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldmVydCB0aGUgbWFzayByZW1vdmFsIGRvbmUgd2hpbGUgcmVhZGluZyB0aGUgY29kZSB3b3Jkcy4gVGhlIGJpdCBtYXRyaXggc2hvdWxkIHJldmVydCB0byBpdHMgb3JpZ2luYWwgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICByZW1hc2soKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBoYXZlIG5vIGZvcm1hdCBpbmZvcm1hdGlvbiwgYW5kIGhhdmUgbm8gZGF0YSBtYXNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhTWFzayA9IERhdGFNYXNrLnZhbHVlc1t0aGlzLnBhcnNlZEZvcm1hdEluZm8uZ2V0RGF0YU1hc2soKV07XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGRhdGFNYXNrLnVubWFza0JpdE1hdHJpeCh0aGlzLmJpdE1hdHJpeCwgZGltZW5zaW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUHJlcGFyZSB0aGUgcGFyc2VyIGZvciBhIG1pcnJvcmVkIG9wZXJhdGlvbi5cbiAgICAgICAgICogVGhpcyBmbGFnIGhhcyBlZmZlY3Qgb25seSBvbiB0aGUge0BsaW5rICNyZWFkRm9ybWF0SW5mb3JtYXRpb24oKX0gYW5kIHRoZVxuICAgICAgICAgKiB7QGxpbmsgI3JlYWRWZXJzaW9uKCl9LiBCZWZvcmUgcHJvY2VlZGluZyB3aXRoIHtAbGluayAjcmVhZENvZGV3b3JkcygpfSB0aGVcbiAgICAgICAgICoge0BsaW5rICNtaXJyb3IoKX0gbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtaXJyb3IgV2hldGhlciB0byByZWFkIHZlcnNpb24gYW5kIGZvcm1hdCBpbmZvcm1hdGlvbiBtaXJyb3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldE1pcnJvcihpc01pcnJvcikge1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzTWlycm9yID0gaXNNaXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIE1pcnJvciB0aGUgYml0IG1hdHJpeCBpbiBvcmRlciB0byBhdHRlbXB0IGEgc2Vjb25kIHJlYWRpbmcuICovXG4gICAgICAgIG1pcnJvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdE1hdHJpeCA9IHRoaXMuYml0TWF0cml4O1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHdpZHRoID0gYml0TWF0cml4LmdldFdpZHRoKCk7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IHggKyAxLCBoZWlnaHQgPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0TWF0cml4LmdldCh4LCB5KSAhPT0gYml0TWF0cml4LmdldCh5LCB4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0TWF0cml4LmZsaXAoeSwgeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXguZmxpcCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgYmxvY2sgb2YgZGF0YSB3aXRoaW4gYSBRUiBDb2RlLiBRUiBDb2RlcyBtYXkgc3BsaXQgdGhlaXIgZGF0YSBpbnRvXG4gICAgICogbXVsdGlwbGUgYmxvY2tzLCBlYWNoIG9mIHdoaWNoIGlzIGEgdW5pdCBvZiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkcy4gRWFjaFxuICAgICAqIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBEYXRhQmxvY2skMSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG51bURhdGFDb2Rld29yZHMgLyppbnQqLywgY29kZXdvcmRzKSB7XG4gICAgICAgICAgICB0aGlzLm51bURhdGFDb2Rld29yZHMgPSBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBjb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPldoZW4gUVIgQ29kZXMgdXNlIG11bHRpcGxlIGRhdGEgYmxvY2tzLCB0aGV5IGFyZSBhY3R1YWxseSBpbnRlcmxlYXZlZC5cbiAgICAgICAgICogVGhhdCBpcywgdGhlIGZpcnN0IGJ5dGUgb2YgZGF0YSBibG9jayAxIHRvIG4gaXMgd3JpdHRlbiwgdGhlbiB0aGUgc2Vjb25kIGJ5dGVzLCBhbmQgc28gb24uIFRoaXNcbiAgICAgICAgICogbWV0aG9kIHdpbGwgc2VwYXJhdGUgdGhlIGRhdGEgaW50byBvcmlnaW5hbCBibG9ja3MuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmF3Q29kZXdvcmRzIGJ5dGVzIGFzIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgUVIgQ29kZVxuICAgICAgICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIG9mIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEBwYXJhbSBlY0xldmVsIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWwgb2YgdGhlIFFSIENvZGVcbiAgICAgICAgICogQHJldHVybiBEYXRhQmxvY2tzIGNvbnRhaW5pbmcgb3JpZ2luYWwgYnl0ZXMsIFwiZGUtaW50ZXJsZWF2ZWRcIiBmcm9tIHJlcHJlc2VudGF0aW9uIGluIHRoZVxuICAgICAgICAgKiAgICAgICAgIFFSIENvZGVcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBnZXREYXRhQmxvY2tzKHJhd0NvZGV3b3JkcywgdmVyc2lvbiwgZWNMZXZlbCkge1xuICAgICAgICAgICAgaWYgKHJhd0NvZGV3b3Jkcy5sZW5ndGggIT09IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG51bWJlciBhbmQgc2l6ZSBvZiBkYXRhIGJsb2NrcyB1c2VkIGJ5IHRoaXMgdmVyc2lvbiBhbmRcbiAgICAgICAgICAgIC8vIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuICAgICAgICAgICAgLy8gRmlyc3QgY291bnQgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgbGV0IHRvdGFsQmxvY2tzID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tBcnJheSA9IGVjQmxvY2tzLmdldEVDQmxvY2tzKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVjQmxvY2sgb2YgZWNCbG9ja0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdG90YWxCbG9ja3MgKz0gZWNCbG9jay5nZXRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGVzdGFibGlzaCBEYXRhQmxvY2tzIG9mIHRoZSBhcHByb3ByaWF0ZSBzaXplIGFuZCBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHNcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSh0b3RhbEJsb2Nrcyk7XG4gICAgICAgICAgICBsZXQgbnVtUmVzdWx0QmxvY2tzID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWNCbG9jayBvZiBlY0Jsb2NrQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVjQmxvY2suZ2V0Q291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bURhdGFDb2Rld29yZHMgPSBlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtQmxvY2tDb2Rld29yZHMgPSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3Jkc1BlckJsb2NrKCkgKyBudW1EYXRhQ29kZXdvcmRzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbnVtUmVzdWx0QmxvY2tzKytdID0gbmV3IERhdGFCbG9jayQxKG51bURhdGFDb2Rld29yZHMsIG5ldyBVaW50OEFycmF5KG51bUJsb2NrQ29kZXdvcmRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIGJsb2NrcyBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBkYXRhLCBleGNlcHQgdGhhdCB0aGUgbGFzdCBuXG4gICAgICAgICAgICAvLyAod2hlcmUgbiBtYXkgYmUgMCkgaGF2ZSAxIG1vcmUgYnl0ZS4gRmlndXJlIG91dCB3aGVyZSB0aGVzZSBzdGFydC5cbiAgICAgICAgICAgIGNvbnN0IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGxvbmdlckJsb2Nrc1N0YXJ0QXQgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBjaGVjayBsZW5ndGggaXMgY29ycmVjdCBoZXJlXG4gICAgICAgICAgICB3aGlsZSAobG9uZ2VyQmxvY2tzU3RhcnRBdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtQ29kZXdvcmRzID0gcmVzdWx0W2xvbmdlckJsb2Nrc1N0YXJ0QXRdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG51bUNvZGV3b3JkcyA9PT0gc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb25nZXJCbG9ja3NTdGFydEF0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb25nZXJCbG9ja3NTdGFydEF0Kys7XG4gICAgICAgICAgICBjb25zdCBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyA9IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyAtIGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzUGVyQmxvY2soKTtcbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGVsZW1lbnRzIG9mIHJlc3VsdCBtYXkgYmUgMSBlbGVtZW50IGxvbmdlclxuICAgICAgICAgICAgLy8gZmlyc3QgZmlsbCBvdXQgYXMgbWFueSBlbGVtZW50cyBhcyBhbGwgb2YgdGhlbSBoYXZlXG4gICAgICAgICAgICBsZXQgcmF3Q29kZXdvcmRzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlsbCBvdXQgdGhlIGxhc3QgZGF0YSBibG9jayBpbiB0aGUgbG9uZ2VyIG9uZXNcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBsb25nZXJCbG9ja3NTdGFydEF0OyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW3Nob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgYWRkIGluIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXG4gICAgICAgICAgICBjb25zdCBtYXggPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpT2Zmc2V0ID0gaiA8IGxvbmdlckJsb2Nrc1N0YXJ0QXQgPyBpIDogaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbaU9mZnNldF0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TnVtRGF0YUNvZGV3b3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bURhdGFDb2Rld29yZHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICB2YXIgTW9kZVZhbHVlcztcbiAgICAoZnVuY3Rpb24gKE1vZGVWYWx1ZXMpIHtcbiAgICAgICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiVEVSTUlOQVRPUlwiXSA9IDBdID0gXCJURVJNSU5BVE9SXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIk5VTUVSSUNcIl0gPSAxXSA9IFwiTlVNRVJJQ1wiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJBTFBIQU5VTUVSSUNcIl0gPSAyXSA9IFwiQUxQSEFOVU1FUklDXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIlNUUlVDVFVSRURfQVBQRU5EXCJdID0gM10gPSBcIlNUUlVDVFVSRURfQVBQRU5EXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkJZVEVcIl0gPSA0XSA9IFwiQllURVwiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJFQ0lcIl0gPSA1XSA9IFwiRUNJXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIktBTkpJXCJdID0gNl0gPSBcIktBTkpJXCI7XG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkZOQzFfRklSU1RfUE9TSVRJT05cIl0gPSA3XSA9IFwiRk5DMV9GSVJTVF9QT1NJVElPTlwiO1xuICAgICAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJGTkMxX1NFQ09ORF9QT1NJVElPTlwiXSA9IDhdID0gXCJGTkMxX1NFQ09ORF9QT1NJVElPTlwiO1xuICAgICAgICAvKiogU2VlIEdCVCAxODI4NC0yMDAwOyBcIkhhbnppXCIgaXMgYSB0cmFuc2xpdGVyYXRpb24gb2YgdGhpcyBtb2RlIG5hbWUuICovXG4gICAgICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIkhBTlpJXCJdID0gOV0gPSBcIkhBTlpJXCI7XG4gICAgfSkoTW9kZVZhbHVlcyB8fCAoTW9kZVZhbHVlcyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjQuMSwgVGFibGVzIDIgYW5kIDMuIFRoaXMgZW51bSBlbmNhcHN1bGF0ZXMgdGhlIHZhcmlvdXMgbW9kZXMgaW4gd2hpY2hcbiAgICAgKiBkYXRhIGNhbiBiZSBlbmNvZGVkIHRvIGJpdHMgaW4gdGhlIFFSIGNvZGUgc3RhbmRhcmQuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBNb2RlJDEge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc3RyaW5nVmFsdWUsIGNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zLCBiaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnMgPSBjaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucztcbiAgICAgICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgICAgICBNb2RlJDEuRk9SX0JJVFMuc2V0KGJpdHMsIHRoaXMpO1xuICAgICAgICAgICAgTW9kZSQxLkZPUl9WQUxVRS5zZXQodmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYml0cyBmb3VyIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlIGRhdGEgbW9kZVxuICAgICAgICAgKiBAcmV0dXJuIE1vZGUgZW5jb2RlZCBieSB0aGVzZSBiaXRzXG4gICAgICAgICAqIEB0aHJvd3MgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIGlmIGJpdHMgZG8gbm90IGNvcnJlc3BvbmQgdG8gYSBrbm93biBtb2RlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZm9yQml0cyhiaXRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBNb2RlJDEuRk9SX0JJVFMuZ2V0KGJpdHMpO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbW9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gdmVyc2lvbiB2ZXJzaW9uIGluIHF1ZXN0aW9uXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGJpdHMgdXNlZCwgaW4gdGhpcyBRUiBDb2RlIHN5bWJvbCB7QGxpbmsgVmVyc2lvbn0sIHRvIGVuY29kZSB0aGVcbiAgICAgICAgICogICAgICAgICBjb3VudCBvZiBjaGFyYWN0ZXJzIHRoYXQgd2lsbCBmb2xsb3cgZW5jb2RlZCBpbiB0aGlzIE1vZGVcbiAgICAgICAgICovXG4gICAgICAgIGdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uTnVtYmVyID0gdmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHZlcnNpb25OdW1iZXIgPD0gOSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2ZXJzaW9uTnVtYmVyIDw9IDI2KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9uc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgZXF1YWxzKG8pIHtcbiAgICAgICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBNb2RlJDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTW9kZSQxLkZPUl9CSVRTID0gbmV3IE1hcCgpO1xuICAgIE1vZGUkMS5GT1JfVkFMVUUgPSBuZXcgTWFwKCk7XG4gICAgTW9kZSQxLlRFUk1JTkFUT1IgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuVEVSTUlOQVRPUiwgJ1RFUk1JTkFUT1InLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwMCk7IC8vIE5vdCByZWFsbHkgYSBtb2RlLi4uXG4gICAgTW9kZSQxLk5VTUVSSUMgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuTlVNRVJJQywgJ05VTUVSSUMnLCBJbnQzMkFycmF5LmZyb20oWzEwLCAxMiwgMTRdKSwgMHgwMSk7XG4gICAgTW9kZSQxLkFMUEhBTlVNRVJJQyA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5BTFBIQU5VTUVSSUMsICdBTFBIQU5VTUVSSUMnLCBJbnQzMkFycmF5LmZyb20oWzksIDExLCAxM10pLCAweDAyKTtcbiAgICBNb2RlJDEuU1RSVUNUVVJFRF9BUFBFTkQgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuU1RSVUNUVVJFRF9BUFBFTkQsICdTVFJVQ1RVUkVEX0FQUEVORCcsIEludDMyQXJyYXkuZnJvbShbMCwgMCwgMF0pLCAweDAzKTsgLy8gTm90IHN1cHBvcnRlZFxuICAgIE1vZGUkMS5CWVRFID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkJZVEUsICdCWVRFJywgSW50MzJBcnJheS5mcm9tKFs4LCAxNiwgMTZdKSwgMHgwNCk7XG4gICAgTW9kZSQxLkVDSSA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5FQ0ksICdFQ0knLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwNyk7IC8vIGNoYXJhY3RlciBjb3VudHMgZG9uJ3QgYXBwbHlcbiAgICBNb2RlJDEuS0FOSkkgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuS0FOSkksICdLQU5KSScsIEludDMyQXJyYXkuZnJvbShbOCwgMTAsIDEyXSksIDB4MDgpO1xuICAgIE1vZGUkMS5GTkMxX0ZJUlNUX1BPU0lUSU9OID0gbmV3IE1vZGUkMShNb2RlVmFsdWVzLkZOQzFfRklSU1RfUE9TSVRJT04sICdGTkMxX0ZJUlNUX1BPU0lUSU9OJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDUpO1xuICAgIE1vZGUkMS5GTkMxX1NFQ09ORF9QT1NJVElPTiA9IG5ldyBNb2RlJDEoTW9kZVZhbHVlcy5GTkMxX1NFQ09ORF9QT1NJVElPTiwgJ0ZOQzFfU0VDT05EX1BPU0lUSU9OJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDkpO1xuICAgIC8qKiBTZWUgR0JUIDE4Mjg0LTIwMDA7IFwiSGFuemlcIiBpcyBhIHRyYW5zbGl0ZXJhdGlvbiBvZiB0aGlzIG1vZGUgbmFtZS4gKi9cbiAgICBNb2RlJDEuSEFOWkkgPSBuZXcgTW9kZSQxKE1vZGVWYWx1ZXMuSEFOWkksICdIQU5aSScsIEludDMyQXJyYXkuZnJvbShbOCwgMTAsIDEyXSksIDB4MEQpO1xuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLmlvLlVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb247Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiA8cD5RUiBDb2RlcyBjYW4gZW5jb2RlIHRleHQgYXMgYml0cyBpbiBvbmUgb2Ygc2V2ZXJhbCBtb2RlcywgYW5kIGNhbiB1c2UgbXVsdGlwbGUgbW9kZXNcbiAgICAgKiBpbiBvbmUgUVIgQ29kZS4gVGhpcyBjbGFzcyBkZWNvZGVzIHRoZSBiaXRzIGJhY2sgaW50byB0ZXh0LjwvcD5cbiAgICAgKlxuICAgICAqIDxwPlNlZSBJU08gMTgwMDQ6MjAwNiwgNi40LjMgLSA2LjQuNzwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxIHtcbiAgICAgICAgc3RhdGljIGRlY29kZShieXRlcywgdmVyc2lvbiwgZWNMZXZlbCwgaGludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBuZXcgQml0U291cmNlKGJ5dGVzKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZVNlZ21lbnRzID0gbmV3IEFycmF5KCk7IC8vIDFcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBJIGRvIG5vdCB1c2UgY29uc3RydWN0b3Igd2l0aCBzaXplIDEgYXMgaW4gb3JpZ2luYWwgSmF2YSBtZWFucyBjYXBhY2l0eSBhbmQgdGhlIGFycmF5IGxlbmd0aCBpcyBjaGVja2VkIGJlbG93XG4gICAgICAgICAgICBsZXQgc3ltYm9sU2VxdWVuY2UgPSAtMTtcbiAgICAgICAgICAgIGxldCBwYXJpdHlEYXRhID0gLTE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZmMxSW5FZmZlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbW9kZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoaWxlIHN0aWxsIGFub3RoZXIgc2VnbWVudCB0byByZWFkLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT0ssIGFzc3VtZSB3ZSdyZSBkb25lLiBSZWFsbHksIGEgVEVSTUlOQVRPUiBtb2RlIHNob3VsZCBoYXZlIGJlZW4gcmVjb3JkZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUkMS5URVJNSU5BVE9SO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kZUJpdHMgPSBiaXRzLnJlYWRCaXRzKDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUkMS5mb3JCaXRzKG1vZGVCaXRzKTsgLy8gbW9kZSBpcyBlbmNvZGVkIGJ5IDQgYml0c1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkZOQzFfRklSU1RfUE9TSVRJT046XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5GTkMxX1NFQ09ORF9QT1NJVElPTjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyBsaXR0bGUgd2l0aCBGTkMxIGV4Y2VwdCBhbHRlciB0aGUgcGFyc2VkIHJlc3VsdCBhIGJpdCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYzFJbkVmZmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5TVFJVQ1RVUkVEX0FQUEVORDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIGFuZCBwYXJpdHkgaXMgYWRkZWQgbGF0ZXIgdG8gdGhlIHJlc3VsdCBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgbmV4dCA4IGJpdHMgKHN5bWJvbCBzZXF1ZW5jZSAjKSBhbmQgOCBiaXRzIChkYXRhOiBwYXJpdHkpLCB0aGVuIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sU2VxdWVuY2UgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcml0eURhdGEgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuRUNJOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50IGRvZXNuJ3QgYXBwbHkgdG8gRUNJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEucGFyc2VFQ0lWYWx1ZShiaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJLmdldENoYXJhY3RlclNldEVDSUJ5VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5IQU5aSTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBoYW5kbGUgSGFuemkgbW9kZSB3aGljaCBkb2VzIG5vdCBzdGFydCB3aXRoIGNoYXJhY3RlciBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoaW5lc2UgbW9kZSBjb250YWlucyBhIHN1YiBzZXQgaW5kaWNhdG9yIHJpZ2h0IGFmdGVyIG1vZGUgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2V0ID0gYml0cy5yZWFkQml0cyg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudEhhbnppID0gYml0cy5yZWFkQml0cyhtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNldCA9PT0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLkdCMjMxMl9TVUJTRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLmRlY29kZUhhbnppU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50SGFuemkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJOb3JtYWxcIiBRUiBjb2RlIG1vZGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyBtYW55IGNoYXJhY3RlcnMgd2lsbCBmb2xsb3csIGVuY29kZWQgaW4gdGhpcyBtb2RlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gYml0cy5yZWFkQml0cyhtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLk5VTUVSSUM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlTnVtZXJpY1NlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuQUxQSEFOVU1FUklDOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLmRlY29kZUFscGhhbnVtZXJpY1NlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCwgZmMxSW5FZmZlY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkJZVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlQnl0ZVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCwgY3VycmVudENoYXJhY3RlclNldEVDSSwgYnl0ZVNlZ21lbnRzLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuS0FOSkk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuZGVjb2RlS2FuamlTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobW9kZSAhPT0gTW9kZSQxLlRFUk1JTkFUT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlhZSAvKjogSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHJlYWRCaXRzKCkgY2FsbHNcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZXJSZXN1bHQoYnl0ZXMsIHJlc3VsdC50b1N0cmluZygpLCBieXRlU2VnbWVudHMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJ5dGVTZWdtZW50cywgZWNMZXZlbCA9PT0gbnVsbCA/IG51bGwgOiBlY0xldmVsLnRvU3RyaW5nKCksIHN5bWJvbFNlcXVlbmNlLCBwYXJpdHlEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIHNwZWNpZmljYXRpb24gR0JUIDE4Mjg0LTIwMDBcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVIYW56aVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIGlmIChjb3VudCAqIDEzID4gYml0cy5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVhY2ggY2hhcmFjdGVyIHdpbGwgcmVxdWlyZSAyIGJ5dGVzLiBSZWFkIHRoZSBjaGFyYWN0ZXJzIGFzIDItYnl0ZSBwYWlyc1xuICAgICAgICAgICAgLy8gYW5kIGRlY29kZSBhcyBHQjIzMTIgYWZ0ZXJ3YXJkc1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMiAqIGNvdW50KTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggMTMgYml0cyBlbmNvZGVzIGEgMi1ieXRlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGNvbnN0IHR3b0J5dGVzID0gYml0cy5yZWFkQml0cygxMyk7XG4gICAgICAgICAgICAgICAgbGV0IGFzc2VtYmxlZFR3b0J5dGVzID0gKCgodHdvQnl0ZXMgLyAweDA2MCkgPDwgOCkgJiAweEZGRkZGRkZGKSB8ICh0d29CeXRlcyAlIDB4MDYwKTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZW1ibGVkVHdvQnl0ZXMgPCAweDAwM0JGKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweEExQTEgdG8gMHhBQUZFIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MEExQTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHhCMEExIHRvIDB4RkFGRSByYW5nZVxuICAgICAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDBBNkExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IC8qKGJ5dGUpICovICgoYXNzZW1ibGVkVHdvQnl0ZXMgPj4gOCkgJiAweEZGKTtcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAvKihieXRlKSAqLyAoYXNzZW1ibGVkVHdvQnl0ZXMgJiAweEZGKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nLmRlY29kZShidWZmZXIsIFN0cmluZ1V0aWxzLkdCMjMxMikpO1xuICAgICAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBUT0RPOiBpbXBsZW1lbnQgR0IyMzEyIGRlY29kZS4gU3RyaW5nVmlldyBmcm9tIE1ETiBjb3VsZCBiZSBhIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbihpZ25vcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGVjb2RlS2FuamlTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLykge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY3Jhc2ggdHJ5aW5nIHRvIHJlYWQgbW9yZSBiaXRzIHRoYW4gd2UgaGF2ZSBhdmFpbGFibGUuXG4gICAgICAgICAgICBpZiAoY291bnQgKiAxMyA+IGJpdHMuYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFYWNoIGNoYXJhY3RlciB3aWxsIHJlcXVpcmUgMiBieXRlcy4gUmVhZCB0aGUgY2hhcmFjdGVycyBhcyAyLWJ5dGUgcGFpcnNcbiAgICAgICAgICAgIC8vIGFuZCBkZWNvZGUgYXMgU2hpZnRfSklTIGFmdGVyd2FyZHNcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDIgKiBjb3VudCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIDEzIGJpdHMgZW5jb2RlcyBhIDItYnl0ZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCB0d29CeXRlcyA9IGJpdHMucmVhZEJpdHMoMTMpO1xuICAgICAgICAgICAgICAgIGxldCBhc3NlbWJsZWRUd29CeXRlcyA9ICgoKHR3b0J5dGVzIC8gMHgwQzApIDw8IDgpICYgMHhGRkZGRkZGRikgfCAodHdvQnl0ZXMgJSAweDBDMCk7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2VtYmxlZFR3b0J5dGVzIDwgMHgwMUYwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHg4MTQwIHRvIDB4OUZGQyByYW5nZVxuICAgICAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDA4MTQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4RTA0MCB0byAweEVCQkYgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQzE0MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAvKihieXRlKSAqLyAoYXNzZW1ibGVkVHdvQnl0ZXMgPj4gOCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gLyooYnl0ZSkgKi8gYXNzZW1ibGVkVHdvQnl0ZXM7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNoaWZ0X0pJUyBtYXkgbm90IGJlIHN1cHBvcnRlZCBpbiBzb21lIGVudmlyb25tZW50czpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZy5kZWNvZGUoYnVmZmVyLCBTdHJpbmdVdGlscy5TSElGVF9KSVMpKTtcbiAgICAgICAgICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogVE9ETzogaW1wbGVtZW50IFNISUZUX0pJUyBkZWNvZGUuIFN0cmluZ1ZpZXcgZnJvbSBNRE4gY291bGQgYmUgYSBzdGFydGluZyBwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oaWdub3JlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZUJ5dGVTZWdtZW50KGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLywgY3VycmVudENoYXJhY3RlclNldEVDSSwgYnl0ZVNlZ21lbnRzLCBoaW50cykge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY3Jhc2ggdHJ5aW5nIHRvIHJlYWQgbW9yZSBiaXRzIHRoYW4gd2UgaGF2ZSBhdmFpbGFibGUuXG4gICAgICAgICAgICBpZiAoOCAqIGNvdW50ID4gYml0cy5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlYWRCeXRlc1tpXSA9IC8qKGJ5dGUpICovIGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5jb2Rpbmc7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlclNldEVDSSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzcGVjIGlzbid0IGNsZWFyIG9uIHRoaXMgbW9kZTsgc2VlXG4gICAgICAgICAgICAgICAgLy8gc2VjdGlvbiA2LjQuNTogdCBkb2VzIG5vdCBzYXkgd2hpY2ggZW5jb2RpbmcgdG8gYXNzdW1pbmdcbiAgICAgICAgICAgICAgICAvLyB1cG9uIGRlY29kaW5nLiBJIGhhdmUgc2VlbiBJU08tODg1OS0xIHVzZWQgYXMgd2VsbCBhc1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0X0pJUyAtLSB3aXRob3V0IGFueXRoaW5nIGxpa2UgYW4gRUNJIGRlc2lnbmF0b3IgdG9cbiAgICAgICAgICAgICAgICAvLyBnaXZlIGEgaGludC5cbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IFN0cmluZ1V0aWxzLmd1ZXNzRW5jb2RpbmcocmVhZEJ5dGVzLCBoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nLmRlY29kZShyZWFkQnl0ZXMsIGVuY29kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbihpZ25vcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVTZWdtZW50cy5wdXNoKHJlYWRCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvQWxwaGFOdW1lcmljQ2hhcih2YWx1ZSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLkFMUEhBTlVNRVJJQ19DSEFSUy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLkFMUEhBTlVNRVJJQ19DSEFSU1t2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRlY29kZUFscGhhbnVtZXJpY1NlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovLCBmYzFJbkVmZmVjdCkge1xuICAgICAgICAgICAgLy8gUmVhZCB0d28gY2hhcmFjdGVycyBhdCBhIHRpbWVcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzdWx0Lmxlbmd0aCgpO1xuICAgICAgICAgICAgd2hpbGUgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VHdvQ2hhcnNCaXRzID0gYml0cy5yZWFkQml0cygxMSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IobmV4dFR3b0NoYXJzQml0cyAvIDQ1KSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihuZXh0VHdvQ2hhcnNCaXRzICUgNDUpKTtcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbmUgY2hhcmFjdGVyIGxlZnRcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS50b0FscGhhTnVtZXJpY0NoYXIoYml0cy5yZWFkQml0cyg2KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VlIHNlY3Rpb24gNi40LjguMSwgNi40LjguMlxuICAgICAgICAgICAgaWYgKGZjMUluRWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYXNzYWdlIHRoZSByZXN1bHQgYSBiaXQgaWYgaW4gYW4gRk5DMSBtb2RlOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHJlc3VsdC5sZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY2hhckF0KGkpID09PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgcmVzdWx0Lmxlbmd0aCgpIC0gMSAmJiByZXN1bHQuY2hhckF0KGkgKyAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJSUgaXMgcmVuZGVyZWQgYXMgJVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kZWxldGVDaGFyQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gYWxwaGEgbW9kZSwgJSBzaG91bGQgYmUgY29udmVydGVkIHRvIEZOQzEgc2VwYXJhdG9yIDB4MURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0Q2hhckF0KGksIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgxRCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBkZWNvZGVOdW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIFJlYWQgdGhyZWUgZGlnaXRzIGF0IGEgdGltZVxuICAgICAgICAgICAgd2hpbGUgKGNvdW50ID49IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBFYWNoIDEwIGJpdHMgZW5jb2RlcyB0aHJlZSBkaWdpdHNcbiAgICAgICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGhyZWVEaWdpdHNCaXRzID0gYml0cy5yZWFkQml0cygxMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRocmVlRGlnaXRzQml0cyA+PSAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodGhyZWVEaWdpdHNCaXRzIC8gMTAwKSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcihNYXRoLmZsb29yKHRocmVlRGlnaXRzQml0cyAvIDEwKSAlIDEwKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKHRocmVlRGlnaXRzQml0cyAlIDEwKSk7XG4gICAgICAgICAgICAgICAgY291bnQgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIFR3byBkaWdpdHMgbGVmdCBvdmVyIHRvIHJlYWQsIGVuY29kZWQgaW4gNyBiaXRzXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHdvRGlnaXRzQml0cyA9IGJpdHMucmVhZEJpdHMoNyk7XG4gICAgICAgICAgICAgICAgaWYgKHR3b0RpZ2l0c0JpdHMgPj0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodHdvRGlnaXRzQml0cyAvIDEwKSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLnRvQWxwaGFOdW1lcmljQ2hhcih0d29EaWdpdHNCaXRzICUgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gT25lIGRpZ2l0IGxlZnQgb3ZlciB0byByZWFkXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlnaXRCaXRzID0gYml0cy5yZWFkQml0cyg0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlnaXRCaXRzID49IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEudG9BbHBoYU51bWVyaWNDaGFyKGRpZ2l0Qml0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBwYXJzZUVDSVZhbHVlKGJpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XG4gICAgICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4ODApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBvbmUgYnl0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdEJ5dGUgJiAweDdGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIC8vIHR3byBieXRlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZEJ5dGUgPSBiaXRzLnJlYWRCaXRzKDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKChmaXJzdEJ5dGUgJiAweDNGKSA8PCA4KSAmIDB4RkZGRkZGRkYpIHwgc2Vjb25kQnl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3RCeXRlICYgMHhFMCkgPT09IDB4QzApIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJlZSBieXRlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZFRoaXJkQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDE2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCgoZmlyc3RCeXRlICYgMHgxRikgPDwgMTYpICYgMHhGRkZGRkZGRikgfCBzZWNvbmRUaGlyZEJ5dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiwgNi40LjQgVGFibGUgNVxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMS5BTFBIQU5VTUVSSUNfQ0hBUlMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaICQlKistLi86JztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDEuR0IyMzEyX1NVQlNFVCA9IDE7XG4gICAgLy8gZnVuY3Rpb24gVWludDhBcnJheVRvU3RyaW5nKGE6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICAgIC8vICAgICBjb25zdCBDSFVOS19TWiA9IDB4ODAwMDtcbiAgICAvLyAgICAgY29uc3QgYyA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgLy8gICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBhLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSBDSFVOS19TWikge1xuICAgIC8vICAgICAgICAgYy5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhLnN1YmFycmF5KGksIGkgKyBDSFVOS19TWikpKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gYy50b1N0cmluZygpO1xuICAgIC8vIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTWV0YS1kYXRhIGNvbnRhaW5lciBmb3IgUVIgQ29kZSBkZWNvZGluZy4gSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgbWF5IGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGJhY2sgdG8gdGhlXG4gICAgICogZGVjb2RpbmcgY2FsbGVyLiBDYWxsZXJzIGFyZSBleHBlY3RlZCB0byBwcm9jZXNzIHRoaXMuXG4gICAgICpcbiAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkRlY29kZXJSZXN1bHQjZ2V0T3RoZXIoKVxuICAgICAqL1xuICAgIGNsYXNzIFFSQ29kZURlY29kZXJNZXRhRGF0YSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG1pcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1pcnJvcmVkID0gbWlycm9yZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgUVIgQ29kZSB3YXMgbWlycm9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpc01pcnJvcmVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlycm9yZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHRoZSByZXN1bHQgcG9pbnRzJyBvcmRlciBjb3JyZWN0aW9uIGR1ZSB0byBtaXJyb3JpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzIHRvIGFwcGx5IG1pcnJvciBjb3JyZWN0aW9uIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlNaXJyb3JlZENvcnJlY3Rpb24ocG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWlycm9yZWQgfHwgcG9pbnRzID09PSBudWxsIHx8IHBvaW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50c1syXTtcbiAgICAgICAgICAgIHBvaW50c1syXSA9IGJvdHRvbUxlZnQ7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvICdmaXgnIHRvcC1sZWZ0IGFuZCBhbGlnbm1lbnQgcGF0dGVybi5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIDxwPlRoZSBtYWluIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgUVIgQ29kZSBkZWNvZGluZyAtLSBhcyBvcHBvc2VkIHRvIGxvY2F0aW5nIGFuZCBleHRyYWN0aW5nXG4gICAgICogdGhlIFFSIENvZGUgZnJvbSBhbiBpbWFnZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERlY29kZXIkMiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyKEdlbmVyaWNHRi5RUl9DT0RFX0ZJRUxEXzI1Nik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVibGljIGRlY29kZShpbWFnZTogYm9vbGVhbltdW10pOiBEZWNvZGVyUmVzdWx0IC8qdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24qLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGRlY29kZShpbWFnZSwgbnVsbClcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY2FuIGRlY29kZSBhIFFSIENvZGUgcmVwcmVzZW50ZWQgYXMgYSAyRCBhcnJheSBvZiBib29sZWFucy5cbiAgICAgICAgICogXCJ0cnVlXCIgaXMgdGFrZW4gdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBib29sZWFucyByZXByZXNlbnRpbmcgd2hpdGUvYmxhY2sgUVIgQ29kZSBtb2R1bGVzXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBkZWNvZGluZyBoaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGluZmx1ZW5jZSBkZWNvZGluZ1xuICAgICAgICAgKiBAcmV0dXJuIHRleHQgYW5kIGJ5dGVzIGVuY29kZWQgd2l0aGluIHRoZSBRUiBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBRUiBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlQm9vbGVhbkFycmF5KGltYWdlLCBoaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQml0TWF0cml4KEJpdE1hdHJpeC5wYXJzZUZyb21Cb29sZWFuQXJyYXkoaW1hZ2UpLCBoaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHVibGljIGRlY29kZUJpdE1hdHJpeChiaXRzOiBCaXRNYXRyaXgpOiBEZWNvZGVyUmVzdWx0IC8qdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24qLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGRlY29kZShiaXRzLCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZWNvZGVzIGEgUVIgQ29kZSByZXByZXNlbnRlZCBhcyBhIHtAbGluayBCaXRNYXRyaXh9LiBBIDEgb3IgXCJ0cnVlXCIgaXMgdGFrZW4gdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBiaXRzIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBRUiBDb2RlIG1vZHVsZXNcbiAgICAgICAgICogQHBhcmFtIGhpbnRzIGRlY29kaW5nIGhpbnRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gaW5mbHVlbmNlIGRlY29kaW5nXG4gICAgICAgICAqIEByZXR1cm4gdGV4dCBhbmQgYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIENvZGVcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGVCaXRNYXRyaXgoYml0cywgaGludHMpIHtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBhIHBhcnNlciBhbmQgcmVhZCB2ZXJzaW9uLCBlcnJvci1jb3JyZWN0aW9uIGxldmVsXG4gICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgQml0TWF0cml4UGFyc2VyJDEoYml0cyk7XG4gICAgICAgICAgICBsZXQgZXggPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVCaXRNYXRyaXhQYXJzZXIocGFyc2VyLCBoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSAvKjogRm9ybWF0RXhjZXB0aW9uLCBDaGVja3N1bUV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgZXggPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIGJpdCBtYXRyaXhcbiAgICAgICAgICAgICAgICBwYXJzZXIucmVtYXNrKCk7XG4gICAgICAgICAgICAgICAgLy8gV2lsbCBiZSBhdHRlbXB0aW5nIGEgbWlycm9yZWQgcmVhZGluZyBvZiB0aGUgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm8uXG4gICAgICAgICAgICAgICAgcGFyc2VyLnNldE1pcnJvcih0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBQcmVlbXB0aXZlbHkgcmVhZCB0aGUgdmVyc2lvbi5cbiAgICAgICAgICAgICAgICBwYXJzZXIucmVhZFZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBQcmVlbXB0aXZlbHkgcmVhZCB0aGUgZm9ybWF0IGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgIHBhcnNlci5yZWFkRm9ybWF0SW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFNpbmNlIHdlJ3JlIGhlcmUsIHRoaXMgbWVhbnMgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgZGV0ZWN0ZWQgc29tZSBraW5kXG4gICAgICAgICAgICAgICAgICogb2YgdmVyc2lvbiBhbmQgZm9ybWF0IGluZm9ybWF0aW9uIHdoZW4gbWlycm9yZWQuIFRoaXMgaXMgYSBnb29kIHNpZ24sXG4gICAgICAgICAgICAgICAgICogdGhhdCB0aGUgUVIgY29kZSBtYXkgYmUgbWlycm9yZWQsIGFuZCB3ZSBzaG91bGQgdHJ5IG9uY2UgbW9yZSB3aXRoIGFcbiAgICAgICAgICAgICAgICAgKiBtaXJyb3JlZCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgZm9yIGEgbWlycm9yZWQgcmVhZGluZy5cbiAgICAgICAgICAgICAgICBwYXJzZXIubWlycm9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kZWNvZGVCaXRNYXRyaXhQYXJzZXIocGFyc2VyLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyEgTm90aWZ5IHRoZSBjYWxsZXIgdGhhdCB0aGUgY29kZSB3YXMgbWlycm9yZWQuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldE90aGVyKG5ldyBRUkNvZGVEZWNvZGVyTWV0YURhdGEodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSAvKkZvcm1hdEV4Y2VwdGlvbiB8IENoZWNrc3VtRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyB0aGUgZXhjZXB0aW9uIGZyb20gdGhlIG9yaWdpbmFsIHJlYWRpbmdcbiAgICAgICAgICAgICAgICBpZiAoZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlQml0TWF0cml4UGFyc2VyKHBhcnNlciwgaGludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZXIucmVhZFZlcnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGVjTGV2ZWwgPSBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCkuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKTtcbiAgICAgICAgICAgIC8vIFJlYWQgY29kZXdvcmRzXG4gICAgICAgICAgICBjb25zdCBjb2Rld29yZHMgPSBwYXJzZXIucmVhZENvZGV3b3JkcygpO1xuICAgICAgICAgICAgLy8gU2VwYXJhdGUgaW50byBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrcyA9IERhdGFCbG9jayQxLmdldERhdGFCbG9ja3MoY29kZXdvcmRzLCB2ZXJzaW9uLCBlY0xldmVsKTtcbiAgICAgICAgICAgIC8vIENvdW50IHRvdGFsIG51bWJlciBvZiBkYXRhIGJ5dGVzXG4gICAgICAgICAgICBsZXQgdG90YWxCeXRlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGFCbG9jayBvZiBkYXRhQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxCeXRlcyArPSBkYXRhQmxvY2suZ2V0TnVtRGF0YUNvZGV3b3JkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgLy8gRXJyb3ItY29ycmVjdCBhbmQgY29weSBkYXRhIGJsb2NrcyB0b2dldGhlciBpbnRvIGEgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdGFCbG9jayBvZiBkYXRhQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZXdvcmRCeXRlcyA9IGRhdGFCbG9jay5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1EYXRhQ29kZXdvcmRzID0gZGF0YUJsb2NrLmdldE51bURhdGFDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcnJlY3RFcnJvcnMoY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3Jkcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Qnl0ZXNbcmVzdWx0T2Zmc2V0KytdID0gY29kZXdvcmRCeXRlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGNvbnRlbnRzIG9mIHRoYXQgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgICAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxLmRlY29kZShyZXN1bHRCeXRlcywgdmVyc2lvbiwgZWNMZXZlbCwgaGludHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5HaXZlbiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyByZWNlaXZlZCwgcG9zc2libHkgY29ycnVwdGVkIGJ5IGVycm9ycywgYXR0ZW1wdHMgdG9cbiAgICAgICAgICogY29ycmVjdCB0aGUgZXJyb3JzIGluLXBsYWNlIHVzaW5nIFJlZWQtU29sb21vbiBlcnJvciBjb3JyZWN0aW9uLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkQnl0ZXMgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIG51bURhdGFDb2Rld29yZHMgbnVtYmVyIG9mIGNvZGV3b3JkcyB0aGF0IGFyZSBkYXRhIGJ5dGVzXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIGNvbnN0IG51bUNvZGV3b3JkcyA9IGNvZGV3b3JkQnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRmlyc3QgcmVhZCBpbnRvIGFuIGFycmF5IG9mIGludHNcbiAgICAgICAgICAgIGNvbnN0IGNvZGV3b3Jkc0ludHMgPSBuZXcgSW50MzJBcnJheShjb2Rld29yZEJ5dGVzKTtcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBub3QgcmVhbHkgbmVjZXNzYXJ5IHRvIHRyYW5zZm9ybSB0byBpbnRzPyBjb3VsZCByZWRlc2lnbiBldmVyeXRoaW5nIHRvIHdvcmsgd2l0aCB1bnNpZ25lZCBieXRlcz9cbiAgICAgICAgICAgIC8vIGNvbnN0IGNvZGV3b3Jkc0ludHMgPSBuZXcgSW50MzJBcnJheShudW1Db2Rld29yZHMpXG4gICAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgIGNvZGV3b3Jkc0ludHNbaV0gPSBjb2Rld29yZEJ5dGVzW2ldICYgMHhGRlxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJzRGVjb2Rlci5kZWNvZGUoY29kZXdvcmRzSW50cywgY29kZXdvcmRCeXRlcy5sZW5ndGggLSBudW1EYXRhQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBSZWVkU29sb21vbkV4Y2VwdGlvbiovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb3B5IGJhY2sgaW50byBhcnJheSBvZiBieXRlcyAtLSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlIGJ5dGVzIHRoYXQgd2VyZSBkYXRhXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IGVycm9ycyBpbiB0aGUgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmRCeXRlc1tpXSA9IC8qKGJ5dGUpICovIGNvZGV3b3Jkc0ludHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBhbiBhbGlnbm1lbnQgcGF0dGVybiwgd2hpY2ggYXJlIHRoZSBzbWFsbGVyIHNxdWFyZSBwYXR0ZXJucyBmb3VuZCBpblxuICAgICAqIGFsbCBidXQgdGhlIHNpbXBsZXN0IFFSIENvZGVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQWxpZ25tZW50UGF0dGVybiBleHRlbmRzIFJlc3VsdFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocG9zWCAvKmZsb2F0Ki8sIHBvc1kgLypmbG9hdCovLCBlc3RpbWF0ZWRNb2R1bGVTaXplIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgc3VwZXIocG9zWCwgcG9zWSk7XG4gICAgICAgICAgICB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgPSBlc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZXRlcm1pbmVzIGlmIHRoaXMgYWxpZ25tZW50IHBhdHRlcm4gXCJhYm91dCBlcXVhbHNcIiBhbiBhbGlnbm1lbnQgcGF0dGVybiBhdCB0aGUgc3RhdGVkXG4gICAgICAgICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHkgdGhlIHNhbWUgc2l6ZS48L3A+XG4gICAgICAgICAqL1xuICAgICAgICBhYm91dEVxdWFscyhtb2R1bGVTaXplIC8qZmxvYXQqLywgaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMuZ2V0WSgpKSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLmdldFgoKSkgPD0gbW9kdWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fCBtb2R1bGVTaXplRGlmZiA8PSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIHRoaXMgb2JqZWN0J3MgY3VycmVudCBlc3RpbWF0ZSBvZiBhIGZpbmRlciBwYXR0ZXJuIHBvc2l0aW9uIGFuZCBtb2R1bGUgc2l6ZVxuICAgICAgICAgKiB3aXRoIGEgbmV3IGVzdGltYXRlLiBJdCByZXR1cm5zIGEgbmV3IHtAY29kZSBGaW5kZXJQYXR0ZXJufSBjb250YWluaW5nIGFuIGF2ZXJhZ2Ugb2YgdGhlIHR3by5cbiAgICAgICAgICovXG4gICAgICAgIGNvbWJpbmVFc3RpbWF0ZShpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8sIG5ld01vZHVsZVNpemUgLypmbG9hdCovKSB7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFggPSAodGhpcy5nZXRYKCkgKyBqKSAvIDIuMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkWSA9ICh0aGlzLmdldFkoKSArIGkpIC8gMi4wO1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRNb2R1bGVTaXplID0gKHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSArIG5ld01vZHVsZVNpemUpIC8gMi4wO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGlnbm1lbnRQYXR0ZXJuKGNvbWJpbmVkWCwgY29tYmluZWRZLCBjb21iaW5lZE1vZHVsZVNpemUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGF0dGVtcHRzIHRvIGZpbmQgYWxpZ25tZW50IHBhdHRlcm5zIGluIGEgUVIgQ29kZS4gQWxpZ25tZW50IHBhdHRlcm5zIGxvb2sgbGlrZSBmaW5kZXJcbiAgICAgKiBwYXR0ZXJucyBidXQgYXJlIHNtYWxsZXIgYW5kIGFwcGVhciBhdCByZWd1bGFyIGludGVydmFscyB0aHJvdWdob3V0IHRoZSBpbWFnZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5BdCB0aGUgbW9tZW50IHRoaXMgb25seSBsb29rcyBmb3IgdGhlIGJvdHRvbS1yaWdodCBhbGlnbm1lbnQgcGF0dGVybi48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGlzIG1vc3RseSBhIHNpbXBsaWZpZWQgY29weSBvZiB7QGxpbmsgRmluZGVyUGF0dGVybkZpbmRlcn0uIEl0IGlzIGNvcGllZCxcbiAgICAgKiBwYXN0ZWQgYW5kIHN0cmlwcGVkIGRvd24gaGVyZSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZSBidXQgZG9lcyB1bmZvcnR1bmF0ZWx5IGR1cGxpY2F0ZVxuICAgICAqIHNvbWUgY29kZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50LiBFYWNoIHRocmVhZCBtdXN0IGFsbG9jYXRlIGl0cyBvd24gb2JqZWN0LjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgQWxpZ25tZW50UGF0dGVybkZpbmRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5DcmVhdGVzIGEgZmluZGVyIHRoYXQgd2lsbCBsb29rIGluIGEgcG9ydGlvbiBvZiB0aGUgd2hvbGUgaW1hZ2UuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgaW1hZ2UgdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBzdGFydFggbGVmdCBjb2x1bW4gZnJvbSB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0WSB0b3Agcm93IGZyb20gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCB3aWR0aCBvZiByZWdpb24gdG8gc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHQgaGVpZ2h0IG9mIHJlZ2lvbiB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIG1vZHVsZVNpemUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIHNvIGZhclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoaW1hZ2UsIHN0YXJ0WCAvKmludCovLCBzdGFydFkgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIG1vZHVsZVNpemUgLypmbG9hdCovLCByZXN1bHRQb2ludENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0WCA9IHN0YXJ0WDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRZID0gc3RhcnRZO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZVNpemUgPSBtb2R1bGVTaXplO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gcmVzdWx0UG9pbnRDYWxsYmFjaztcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzID0gW107IC8vIG5ldyBBcnJheTxhbnk+KDUpKVxuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IGFycmF5IGluaXRpYWxpemF0aW9uIHdpdGhvdXQgc2l6ZSBhcyB0aGUgbGVuZ3RoIGlzIGNoZWNrZWQgYmVsb3dcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSgzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+VGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZmluZCB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuIGluIHRoZSBpbWFnZS4gSXQgaXMgYSBiaXQgbWVzc3kgc2luY2VcbiAgICAgICAgICogaXQncyBwcmV0dHkgcGVyZm9ybWFuY2UtY3JpdGljYWwgYW5kIHNvIGlzIHdyaXR0ZW4gdG8gYmUgZmFzdCBmb3JlbW9zdC48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEFsaWdubWVudFBhdHRlcm59IGlmIGZvdW5kXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm90IGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gdGhpcy5zdGFydFg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IG1heEogPSBzdGFydFggKyB3aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZUkgPSB0aGlzLnN0YXJ0WSArIChoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciBibGFjay93aGl0ZS9ibGFjayBtb2R1bGVzIGluIDE6MToxIHJhdGlvXG4gICAgICAgICAgICAvLyB0aGlzIHRyYWNrcyB0aGUgbnVtYmVyIG9mIGJsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgc2VlbiBzbyBmYXJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSgzKTtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGZvciAobGV0IGlHZW4gPSAwOyBpR2VuIDwgaGVpZ2h0OyBpR2VuKyspIHtcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggZnJvbSBtaWRkbGUgb3V0d2FyZHNcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gbWlkZGxlSSArICgoaUdlbiAmIDB4MDEpID09PSAwID8gTWF0aC5mbG9vcigoaUdlbiArIDEpIC8gMikgOiAtTWF0aC5mbG9vcigoaUdlbiArIDEpIC8gMikpO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBqID0gc3RhcnRYO1xuICAgICAgICAgICAgICAgIC8vIEJ1cm4gb2ZmIGxlYWRpbmcgd2hpdGUgcGl4ZWxzIGJlZm9yZSBhbnl0aGluZyBlbHNlOyBpZiB3ZSBzdGFydCBpbiB0aGUgbWlkZGxlIG9mXG4gICAgICAgICAgICAgICAgLy8gYSB3aGl0ZSBydW4sIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBjb3VudCBpdHMgbGVuZ3RoLCBzaW5jZSB3ZSBkb24ndCBrbm93IGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHdoaXRlIHJ1biBjb250aW51ZWQgdG8gdGhlIGxlZnQgb2YgdGhlIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmICFpbWFnZS5nZXQoaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IG1heEopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDEpIHsgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIENvdW50aW5nIHdoaXRlIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDIpIHsgLy8gQSB3aW5uZXI/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7IC8vIFllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlybWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WysrY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gV2hpdGUgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDEpIHsgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4Sik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maXJtZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIbW0sIG5vdGhpbmcgd2Ugc2F3IHdhcyBvYnNlcnZlZCBhbmQgY29uZmlybWVkIHR3aWNlLiBJZiB3ZSBoYWRcbiAgICAgICAgICAgIC8vIGFueSBndWVzcyBhdCBhbGwsIHJldHVybiBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZUNlbnRlcnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCBzZWVuIGFuZCBhbiBlbmQgcG9zaXRpb24sXG4gICAgICAgICAqIGZpZ3VyZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBibGFjay93aGl0ZS9ibGFjayBydW4uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBlbmQgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIChlbmQgLSBzdGF0ZUNvdW50WzJdKSAtIHN0YXRlQ291bnRbMV0gLyAyLjA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IGNvdW50IG9mIGJsYWNrL3doaXRlL2JsYWNrIHBpeGVscyBqdXN0IHJlYWRcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8xIHJhdGlvc1xuICAgICAgICAgKiAgICAgICAgIHVzZWQgYnkgYWxpZ25tZW50IHBhdHRlcm5zIHRvIGJlIGNvbnNpZGVyZWQgYSBtYXRjaFxuICAgICAgICAgKi9cbiAgICAgICAgZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IG1heFZhcmlhbmNlID0gbW9kdWxlU2l6ZSAvIDIuMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50W2ldKSA+PSBtYXhWYXJpYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkFmdGVyIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG90ZW50aWFsIGFsaWdubWVudCBwYXR0ZXJuLCB0aGlzIG1ldGhvZFxuICAgICAgICAgKiBcImNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gdmVydGljYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXG4gICAgICAgICAqIGFsaWdubWVudCBwYXR0ZXJuIHRvIHNlZSBpZiB0aGUgc2FtZSBwcm9wb3J0aW9uIGlzIGRldGVjdGVkLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0SSByb3cgd2hlcmUgYW4gYWxpZ25tZW50IHBhdHRlcm4gd2FzIGRldGVjdGVkXG4gICAgICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYW4gYWxpZ25tZW50IHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG1heENvdW50IG1heGltdW0gcmVhc29uYWJsZSBudW1iZXIgb2YgbW9kdWxlcyB0aGF0IHNob3VsZCBiZVxuICAgICAgICAgKiBvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlIGhvcml6b250YWwgc2NhblxuICAgICAgICAgKiBAcmV0dXJuIHZlcnRpY2FsIGNlbnRlciBvZiBhbGlnbm1lbnQgcGF0dGVybiwgb3Ige0BsaW5rIEZsb2F0I05hTn0gaWYgbm90IGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBjcm9zc0NoZWNrVmVydGljYWwoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgY29uc3QgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQ7XG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICAvLyBTdGFydCBjb3VudGluZyB1cCBmcm9tIGNlbnRlclxuICAgICAgICAgICAgbGV0IGkgPSBzdGFydEk7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biBmcm9tIGNlbnRlclxuICAgICAgICAgICAgaSA9IHN0YXJ0SSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IG1heEkgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMl0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlQ291bnRbMl0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PSAyICogb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaSkgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPlRoaXMgaXMgY2FsbGVkIHdoZW4gYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybi4gSXQgd2lsbFxuICAgICAgICAgKiBjcm9zcyBjaGVjayB3aXRoIGEgdmVydGljYWwgc2NhbiwgYW5kIGlmIHN1Y2Nlc3NmdWwsIHdpbGwgc2VlIGlmIHRoaXMgcGF0dGVybiBoYWQgYmVlblxuICAgICAgICAgKiBmb3VuZCBvbiBhIHByZXZpb3VzIGhvcml6b250YWwgc2Nhbi4gSWYgc28sIHdlIGNvbnNpZGVyIGl0IGNvbmZpcm1lZCBhbmQgY29uY2x1ZGUgd2UgaGF2ZVxuICAgICAgICAgKiBmb3VuZCB0aGUgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCByZWFkaW5nIHN0YXRlIG1vZHVsZSBjb3VudHMgZnJvbSBob3Jpem9udGFsIHNjYW5cbiAgICAgICAgICogQHBhcmFtIGkgcm93IHdoZXJlIGFsaWdubWVudCBwYXR0ZXJuIG1heSBiZSBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0gaiBlbmQgb2YgcG9zc2libGUgYWxpZ25tZW50IHBhdHRlcm4gaW4gcm93XG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIEFsaWdubWVudFBhdHRlcm59IGlmIHdlIGhhdmUgZm91bmQgdGhlIHNhbWUgcGF0dGVybiB0d2ljZSwgb3IgbnVsbCBpZiBub3RcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGkgLyppbnQqLywgaiAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJKID0gQWxpZ25tZW50UGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopO1xuICAgICAgICAgICAgY29uc3QgY2VudGVySSA9IHRoaXMuY3Jvc3NDaGVja1ZlcnRpY2FsKGksIC8qKGludCkgKi8gY2VudGVySiwgMiAqIHN0YXRlQ291bnRbMV0sIHN0YXRlQ291bnRUb3RhbCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IChzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0pIC8gMy4wO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VudGVyIG9mIHRoaXMucG9zc2libGVDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFib3V0IHRoZSBzYW1lIGNlbnRlciBhbmQgbW9kdWxlIHNpemU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuYWJvdXRFcXVhbHMoZXN0aW1hdGVkTW9kdWxlU2l6ZSwgY2VudGVySSwgY2VudGVySikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIuY29tYmluZUVzdGltYXRlKGNlbnRlckksIGNlbnRlckosIGVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhZG4ndCBmb3VuZCB0aGlzIGJlZm9yZTsgc2F2ZSBpdFxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IEFsaWdubWVudFBhdHRlcm4oY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NzaWJsZUNlbnRlcnMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+RW5jYXBzdWxhdGVzIGEgZmluZGVyIHBhdHRlcm4sIHdoaWNoIGFyZSB0aGUgdGhyZWUgc3F1YXJlIHBhdHRlcm5zIGZvdW5kIGluXG4gICAgICogdGhlIGNvcm5lcnMgb2YgUVIgQ29kZXMuIEl0IGFsc28gZW5jYXBzdWxhdGVzIGEgY291bnQgb2Ygc2ltaWxhciBmaW5kZXIgcGF0dGVybnMsXG4gICAgICogYXMgYSBjb252ZW5pZW5jZSB0byB0aGUgZmluZGVyJ3MgYm9va2tlZXBpbmcuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBGaW5kZXJQYXR0ZXJuJDEgZXh0ZW5kcyBSZXN1bHRQb2ludCB7XG4gICAgICAgIC8vIEZpbmRlclBhdHRlcm4ocG9zWDogbnVtYmVyLypmbG9hdCovLCBwb3NZOiBudW1iZXIvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemU6IG51bWJlci8qZmxvYXQqLykge1xuICAgICAgICAvLyAgIHRoaXMocG9zWCwgcG9zWSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSwgMSlcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdHJ1Y3Rvcihwb3NYIC8qZmxvYXQqLywgcG9zWSAvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemUgLypmbG9hdCovLCBjb3VudCAvKmludCovKSB7XG4gICAgICAgICAgICBzdXBlcihwb3NYLCBwb3NZKTtcbiAgICAgICAgICAgIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldEVzdGltYXRlZE1vZHVsZVNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGdldENvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgdm9pZCBpbmNyZW1lbnRDb3VudCgpIHtcbiAgICAgICAgICB0aGlzLmNvdW50KytcbiAgICAgICAgfVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVybWluZXMgaWYgdGhpcyBmaW5kZXIgcGF0dGVybiBcImFib3V0IGVxdWFsc1wiIGEgZmluZGVyIHBhdHRlcm4gYXQgdGhlIHN0YXRlZFxuICAgICAgICAgKiBwb3NpdGlvbiBhbmQgc2l6ZSAtLSBtZWFuaW5nLCBpdCBpcyBhdCBuZWFybHkgdGhlIHNhbWUgY2VudGVyIHdpdGggbmVhcmx5IHRoZSBzYW1lIHNpemUuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgYWJvdXRFcXVhbHMobW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGkgLypmbG9hdCovLCBqIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGkgLSB0aGlzLmdldFkoKSkgPD0gbW9kdWxlU2l6ZSAmJiBNYXRoLmFicyhqIC0gdGhpcy5nZXRYKCkpIDw9IG1vZHVsZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplRGlmZiA9IE1hdGguYWJzKG1vZHVsZVNpemUgLSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRGlmZiA8PSAxLjAgfHwgbW9kdWxlU2l6ZURpZmYgPD0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lcyB0aGlzIG9iamVjdCdzIGN1cnJlbnQgZXN0aW1hdGUgb2YgYSBmaW5kZXIgcGF0dGVybiBwb3NpdGlvbiBhbmQgbW9kdWxlIHNpemVcbiAgICAgICAgICogd2l0aCBhIG5ldyBlc3RpbWF0ZS4gSXQgcmV0dXJucyBhIG5ldyB7QGNvZGUgRmluZGVyUGF0dGVybn0gY29udGFpbmluZyBhIHdlaWdodGVkIGF2ZXJhZ2VcbiAgICAgICAgICogYmFzZWQgb24gY291bnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb21iaW5lRXN0aW1hdGUoaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovLCBuZXdNb2R1bGVTaXplIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRDb3VudCA9IHRoaXMuY291bnQgKyAxO1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRYID0gKHRoaXMuY291bnQgKiB0aGlzLmdldFgoKSArIGopIC8gY29tYmluZWRDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkWSA9ICh0aGlzLmNvdW50ICogdGhpcy5nZXRZKCkgKyBpKSAvIGNvbWJpbmVkQ291bnQ7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZE1vZHVsZVNpemUgPSAodGhpcy5jb3VudCAqIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSArIG5ld01vZHVsZVNpemUpIC8gY29tYmluZWRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybiQxKGNvbWJpbmVkWCwgY29tYmluZWRZLCBjb21iaW5lZE1vZHVsZVNpemUsIGNvbWJpbmVkQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgaW5mb3JtYXRpb24gYWJvdXQgZmluZGVyIHBhdHRlcm5zIGluIGFuIGltYWdlLCBpbmNsdWRpbmcgdGhlIGxvY2F0aW9uIG9mXG4gICAgICogdGhlIHRocmVlIGZpbmRlciBwYXR0ZXJucywgYW5kIHRoZWlyIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIEZpbmRlclBhdHRlcm5JbmZvIHtcbiAgICAgICAgY29uc3RydWN0b3IocGF0dGVybkNlbnRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdCA9IHBhdHRlcm5DZW50ZXJzWzBdO1xuICAgICAgICAgICAgdGhpcy50b3BMZWZ0ID0gcGF0dGVybkNlbnRlcnNbMV07XG4gICAgICAgICAgICB0aGlzLnRvcFJpZ2h0ID0gcGF0dGVybkNlbnRlcnNbMl07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qm90dG9tTGVmdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG9wTGVmdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BSaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyppbXBvcnQgamF2YS5pby5TZXJpYWxpemFibGU7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb25zOyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkNvbXBhcmF0b3I7Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGF0dGVtcHRzIHRvIGZpbmQgZmluZGVyIHBhdHRlcm5zIGluIGEgUVIgQ29kZS4gRmluZGVyIHBhdHRlcm5zIGFyZSB0aGUgc3F1YXJlXG4gICAgICogbWFya2VycyBhdCB0aHJlZSBjb3JuZXJzIG9mIGEgUVIgQ29kZS48L3A+XG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGNsYXNzIGlzIHRocmVhZC1zYWZlIGJ1dCBub3QgcmVlbnRyYW50LiBFYWNoIHRocmVhZCBtdXN0IGFsbG9jYXRlIGl0cyBvd24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBGaW5kZXJQYXR0ZXJuRmluZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkNyZWF0ZXMgYSBmaW5kZXIgdGhhdCB3aWxsIHNlYXJjaCB0aGUgaW1hZ2UgZm9yIHRocmVlIGZpbmRlciBwYXR0ZXJucy48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSB0byBzZWFyY2hcbiAgICAgICAgICovXG4gICAgICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihpbWFnZTogQml0TWF0cml4KSB7XG4gICAgICAgIC8vICAgdGhpcyhpbWFnZSwgbnVsbClcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSwgcmVzdWx0UG9pbnRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gcmVzdWx0UG9pbnRDYWxsYmFjaztcbiAgICAgICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoNSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGdldEltYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UG9zc2libGVDZW50ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVDZW50ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGZpbmQoaGludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyeUhhcmRlciA9IChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkKSAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlRSWV9IQVJERVIpO1xuICAgICAgICAgICAgY29uc3QgcHVyZUJhcmNvZGUgPSAoaGludHMgIT09IG51bGwgJiYgaGludHMgIT09IHVuZGVmaW5lZCkgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5QVVJFX0JBUkNPREUpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgY29uc3QgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgbWF4SiA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICAvLyBXZSBhcmUgbG9va2luZyBmb3IgYmxhY2svd2hpdGUvYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBpblxuICAgICAgICAgICAgLy8gMToxOjM6MToxIHJhdGlvOyB0aGlzIHRyYWNrcyB0aGUgbnVtYmVyIG9mIHN1Y2ggbW9kdWxlcyBzZWVuIHNvIGZhclxuICAgICAgICAgICAgLy8gTGV0J3MgYXNzdW1lIHRoYXQgdGhlIG1heGltdW0gdmVyc2lvbiBRUiBDb2RlIHdlIHN1cHBvcnQgdGFrZXMgdXAgMS80IHRoZSBoZWlnaHQgb2YgdGhlXG4gICAgICAgICAgICAvLyBpbWFnZSwgYW5kIHRoZW4gYWNjb3VudCBmb3IgdGhlIGNlbnRlciBiZWluZyAzIG1vZHVsZXMgaW4gc2l6ZS4gVGhpcyBnaXZlcyB0aGUgc21hbGxlc3RcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBwaXhlbHMgdGhlIGNlbnRlciBjb3VsZCBiZSwgc28gc2tpcCB0aGlzIG9mdGVuLiBXaGVuIHRyeWluZyBoYXJkZXIsIGxvb2sgZm9yIGFsbFxuICAgICAgICAgICAgLy8gUVIgdmVyc2lvbnMgcmVnYXJkbGVzcyBvZiBob3cgZGVuc2UgdGhleSBhcmUuXG4gICAgICAgICAgICBsZXQgaVNraXAgPSBNYXRoLmZsb29yKCgzICogbWF4SSkgLyAoNCAqIEZpbmRlclBhdHRlcm5GaW5kZXIuTUFYX01PRFVMRVMpKTtcbiAgICAgICAgICAgIGlmIChpU2tpcCA8IEZpbmRlclBhdHRlcm5GaW5kZXIuTUlOX1NLSVAgfHwgdHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgaVNraXAgPSBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSg1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpU2tpcCAtIDE7IGkgPCBtYXhJICYmICFkb25lOyBpICs9IGlTa2lwKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAwO1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF4SjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRTdGF0ZSAmIDEpID09PSAxKSB7IC8vIENvdW50aW5nIHdoaXRlIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIFdoaXRlIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRTdGF0ZSAmIDEpID09PSAwKSB7IC8vIENvdW50aW5nIGJsYWNrIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDQpIHsgLy8gQSB3aW5uZXI/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7IC8vIFllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBqLCBwdXJlQmFyY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgZXhhbWluaW5nIGV2ZXJ5IG90aGVyIGxpbmUuIENoZWNraW5nIGVhY2ggbGluZSB0dXJuZWQgb3V0IHRvIGJlIHRvb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGVuc2l2ZSBhbmQgZGlkbid0IGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVNraXAgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1NraXBwZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRoaXMuaGF2ZU11bHRpcGx5Q29uZmlybWVkQ2VudGVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93U2tpcCA9IHRoaXMuZmluZFJvd1NraXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd1NraXAgPiBzdGF0ZUNvdW50WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHJvd3MgYmV0d2VlbiByb3cgb2YgbG93ZXIgY29uZmlybWVkIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRvcCBvZiBwcmVzdW1lZCB0aGlyZCBjb25maXJtZWQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgYmFjayB1cCBhIGJpdCB0byBnZXQgYSBmdWxsIGNoYW5jZSBvZiBkZXRlY3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0LCBlbnRpcmUgd2lkdGggb2YgY2VudGVyIG9mIGZpbmRlciBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGJ5IHJvd1NraXAsIGJ1dCBiYWNrIG9mZiBieSBzdGF0ZUNvdW50WzJdIChzaXplIG9mIGxhc3QgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBwYXR0ZXJuIHdlIHNhdykgdG8gYmUgY29uc2VydmF0aXZlLCBhbmQgYWxzbyBiYWNrIG9mZiBieSBpU2tpcCB3aGljaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgYWJvdXQgdG8gYmUgcmUtYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gcm93U2tpcCAtIHN0YXRlQ291bnRbMl0gLSBpU2tpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBtYXhKIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSBzdGF0ZUNvdW50WzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBzdGF0ZSB0byBzdGFydCBsb29raW5nIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTm8sIHNoaWZ0IGNvdW50cyBiYWNrIGJ5IHR3b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gc3RhdGVDb3VudFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbKytjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIENvdW50aW5nIHdoaXRlIHBpeGVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4SiwgcHVyZUJhcmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpU2tpcCA9IHN0YXRlQ291bnRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTa2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYSB0aGlyZCBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuSW5mbyA9IHRoaXMuc2VsZWN0QmVzdFBhdHRlcm5zKCk7XG4gICAgICAgICAgICBSZXN1bHRQb2ludC5vcmRlckJlc3RQYXR0ZXJucyhwYXR0ZXJuSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm5JbmZvKHBhdHRlcm5JbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCBzZWVuIGFuZCBhbiBlbmQgcG9zaXRpb24sXG4gICAgICAgICAqIGZpZ3VyZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhpcyBydW4uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBlbmQgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIChlbmQgLSBzdGF0ZUNvdW50WzRdIC0gc3RhdGVDb3VudFszXSkgLSBzdGF0ZUNvdW50WzJdIC8gMi4wO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCByZWFkXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhlIHByb3BvcnRpb25zIG9mIHRoZSBjb3VudHMgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSAxLzEvMy8xLzEgcmF0aW9zXG4gICAgICAgICAqICAgICAgICAgdXNlZCBieSBmaW5kZXIgcGF0dGVybnMgdG8gYmUgY29uc2lkZXJlZCBhIG1hdGNoXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkge1xuICAgICAgICAgICAgbGV0IHRvdGFsTW9kdWxlU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gc3RhdGVDb3VudFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG90YWxNb2R1bGVTaXplIDwgNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNpemUgPSB0b3RhbE1vZHVsZVNpemUgLyA3LjA7XG4gICAgICAgICAgICBjb25zdCBtYXhWYXJpYW5jZSA9IG1vZHVsZVNpemUgLyAyLjA7XG4gICAgICAgICAgICAvLyBBbGxvdyBsZXNzIHRoYW4gNTAlIHZhcmlhbmNlIGZyb20gMS0xLTMtMS0xIHByb3BvcnRpb25zXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMF0pIDwgbWF4VmFyaWFuY2UgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFsxXSkgPCBtYXhWYXJpYW5jZSAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKDMuMCAqIG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzJdKSA8IDMgKiBtYXhWYXJpYW5jZSAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzNdKSA8IG1heFZhcmlhbmNlICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbNF0pIDwgbWF4VmFyaWFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBjcm9zc0NoZWNrU3RhdGVDb3VudCA9IHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQ7XG4gICAgICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFszXSA9IDA7XG4gICAgICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gY3Jvc3NDaGVja1N0YXRlQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFmdGVyIGEgdmVydGljYWwgYW5kIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBmaW5kZXIgcGF0dGVybiwgdGhpcyBtZXRob2RcbiAgICAgICAgICogXCJjcm9zcy1jcm9zcy1jcm9zcy1jaGVja3NcIiBieSBzY2FubmluZyBkb3duIGRpYWdvbmFsbHkgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBwb3NzaWJsZVxuICAgICAgICAgKiBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0SSByb3cgd2hlcmUgYSBmaW5kZXIgcGF0dGVybiB3YXMgZGV0ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIGNlbnRlckogY2VudGVyIG9mIHRoZSBzZWN0aW9uIHRoYXQgYXBwZWFycyB0byBjcm9zcyBhIGZpbmRlciBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmVcbiAgICAgICAgICogIG9ic2VydmVkIGluIGFueSByZWFkaW5nIHN0YXRlLCBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FuXG4gICAgICAgICAqIEBwYXJhbSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCBUaGUgb3JpZ2luYWwgc3RhdGUgY291bnQgdG90YWwuXG4gICAgICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9wb3J0aW9ucyBhcmUgd2l0aGluZyBleHBlY3RlZCBsaW1pdHNcbiAgICAgICAgICovXG4gICAgICAgIGNyb3NzQ2hlY2tEaWFnb25hbChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50ID0gdGhpcy5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpO1xuICAgICAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAsIGxlZnQgZnJvbSBjZW50ZXIgZmluZGluZyBibGFjayBjZW50ZXIgbWFzc1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiBpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEkgPCBpIHx8IGNlbnRlckogPCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29udGludWUgdXAsIGxlZnQgZmluZGluZyB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSB0b28gbWFueSBtb2R1bGVzIGluIHRoaXMgc3RhdGUgb3IgcmFuIG9mZiB0aGUgZWRnZTpcbiAgICAgICAgICAgIGlmIChzdGFydEkgPCBpIHx8IGNlbnRlckogPCBpIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHVwLCBsZWZ0IGZpbmRpbmcgYmxhY2sgYm9yZGVyXG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJID49IGkgJiYgY2VudGVySiA+PSBpICYmIGltYWdlLmdldChjZW50ZXJKIC0gaSwgc3RhcnRJIC0gaSkgJiZcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIC8vIE5vdyBhbHNvIGNvdW50IGRvd24sIHJpZ2h0IGZyb20gY2VudGVyXG4gICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgaW1hZ2UuZ2V0KGNlbnRlckogKyBpLCBzdGFydEkgKyBpKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSYW4gb2ZmIHRoZSBlZGdlP1xuICAgICAgICAgICAgaWYgKHN0YXJ0SSArIGkgPj0gbWF4SSB8fCBjZW50ZXJKICsgaSA+PSBtYXhKKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SSArIGkgPCBtYXhJICYmIGNlbnRlckogKyBpIDwgbWF4SiAmJiAhaW1hZ2UuZ2V0KGNlbnRlckogKyBpLCBzdGFydEkgKyBpKSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRJICsgaSA+PSBtYXhJIHx8IGNlbnRlckogKyBpID49IG1heEogfHwgc3RhdGVDb3VudFszXSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgaW1hZ2UuZ2V0KGNlbnRlckogKyBpLCBzdGFydEkgKyBpKSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgbW9yZSB0aGFuIDEwMCUgZGlmZmVyZW50IHRoYW5cbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArIHN0YXRlQ291bnRbNF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIDwgMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsICYmXG4gICAgICAgICAgICAgICAgRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+QWZ0ZXIgYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3RlbnRpYWwgZmluZGVyIHBhdHRlcm4sIHRoaXMgbWV0aG9kXG4gICAgICAgICAqIFwiY3Jvc3MtY2hlY2tzXCIgYnkgc2Nhbm5pbmcgZG93biB2ZXJ0aWNhbGx5IHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgcG9zc2libGVcbiAgICAgICAgICogZmluZGVyIHBhdHRlcm4gdG8gc2VlIGlmIHRoZSBzYW1lIHByb3BvcnRpb24gaXMgZGV0ZWN0ZWQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhIGZpbmRlciBwYXR0ZXJuIHdhcyBkZXRlY3RlZFxuICAgICAgICAgKiBAcGFyYW0gY2VudGVySiBjZW50ZXIgb2YgdGhlIHNlY3Rpb24gdGhhdCBhcHBlYXJzIHRvIGNyb3NzIGEgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIG1heENvdW50IG1heGltdW0gcmVhc29uYWJsZSBudW1iZXIgb2YgbW9kdWxlcyB0aGF0IHNob3VsZCBiZVxuICAgICAgICAgKiBvYnNlcnZlZCBpbiBhbnkgcmVhZGluZyBzdGF0ZSwgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlIGhvcml6b250YWwgc2NhblxuICAgICAgICAgKiBAcmV0dXJuIHZlcnRpY2FsIGNlbnRlciBvZiBmaW5kZXIgcGF0dGVybiwgb3Ige0BsaW5rIEZsb2F0I05hTn0gaWYgbm90IGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICBjcm9zc0NoZWNrVmVydGljYWwoc3RhcnRJIC8qaW50Ki8sIGNlbnRlckogLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICAgICAgY29uc3QgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IHRoaXMuZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IGNvdW50aW5nIHVwIGZyb20gY2VudGVyXG4gICAgICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhbHJlYWR5IHRvbyBtYW55IG1vZHVsZXMgaW4gdGhpcyBzdGF0ZSBvciByYW4gb2ZmIHRoZSBlZGdlOlxuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGFsc28gY291bnQgZG93biBmcm9tIGNlbnRlclxuICAgICAgICAgICAgaSA9IHN0YXJ0SSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBtYXhJKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10rKztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gbWF4SSB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgbW9yZSB0aGFuIDQwJSBkaWZmZXJlbnQgdGhhblxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID8gRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGkpIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5MaWtlIHtAbGluayAjY3Jvc3NDaGVja1ZlcnRpY2FsKGludCwgaW50LCBpbnQsIGludCl9LCBhbmQgaW4gZmFjdCBpcyBiYXNpY2FsbHkgaWRlbnRpY2FsLFxuICAgICAgICAgKiBleGNlcHQgaXQgcmVhZHMgaG9yaXpvbnRhbGx5IGluc3RlYWQgb2YgdmVydGljYWxseS4gVGhpcyBpcyB1c2VkIHRvIGNyb3NzLWNyb3NzXG4gICAgICAgICAqIGNoZWNrIGEgdmVydGljYWwgY3Jvc3MgY2hlY2sgYW5kIGxvY2F0ZSB0aGUgcmVhbCBjZW50ZXIgb2YgdGhlIGFsaWdubWVudCBwYXR0ZXJuLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGNyb3NzQ2hlY2tIb3Jpem9udGFsKHN0YXJ0SiAvKmludCovLCBjZW50ZXJJIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgICAgIGNvbnN0IG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudCA9IHRoaXMuZ2V0Q3Jvc3NDaGVja1N0YXRlQ291bnQoKTtcbiAgICAgICAgICAgIGxldCBqID0gc3RhcnRKO1xuICAgICAgICAgICAgd2hpbGUgKGogPj0gMCAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqID49IDAgJiYgIWltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGogPj0gMCAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0rKztcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFswXSA+IG1heENvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGogPSBzdGFydEogKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PT0gbWF4Sikge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgIWltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzNdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdKys7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT09IG1heEogfHwgc3RhdGVDb3VudFszXSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbNF0gPCBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKztcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzIHNpZ25pZmljYW50bHkgZGlmZmVyZW50IHRoYW5cbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID8gRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5UaGlzIGlzIGNhbGxlZCB3aGVuIGEgaG9yaXpvbnRhbCBzY2FuIGZpbmRzIGEgcG9zc2libGUgYWxpZ25tZW50IHBhdHRlcm4uIEl0IHdpbGxcbiAgICAgICAgICogY3Jvc3MgY2hlY2sgd2l0aCBhIHZlcnRpY2FsIHNjYW4sIGFuZCBpZiBzdWNjZXNzZnVsLCB3aWxsLCBhaCwgY3Jvc3MtY3Jvc3MtY2hlY2tcbiAgICAgICAgICogd2l0aCBhbm90aGVyIGhvcml6b250YWwgc2Nhbi4gVGhpcyBpcyBuZWVkZWQgcHJpbWFyaWx5IHRvIGxvY2F0ZSB0aGUgcmVhbCBob3Jpem9udGFsXG4gICAgICAgICAqIGNlbnRlciBvZiB0aGUgcGF0dGVybiBpbiBjYXNlcyBvZiBleHRyZW1lIHNrZXcuXG4gICAgICAgICAqIEFuZCB0aGVuIHdlIGNyb3NzLWNyb3NzLWNyb3NzIGNoZWNrIHdpdGggYW5vdGhlciBkaWFnb25hbCBzY2FuLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+SWYgdGhhdCBzdWNjZWVkcyB0aGUgZmluZGVyIHBhdHRlcm4gbG9jYXRpb24gaXMgYWRkZWQgdG8gYSBsaXN0IHRoYXQgdHJhY2tzXG4gICAgICAgICAqIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBsb2NhdGlvbiBoYXMgYmVlbiBuZWFybHktbWF0Y2hlZCBhcyBhIGZpbmRlciBwYXR0ZXJuLlxuICAgICAgICAgKiBFYWNoIGFkZGl0aW9uYWwgZmluZCBpcyBtb3JlIGV2aWRlbmNlIHRoYXQgdGhlIGxvY2F0aW9uIGlzIGluIGZhY3QgYSBmaW5kZXJcbiAgICAgICAgICogcGF0dGVybiBjZW50ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0YXRlQ291bnQgcmVhZGluZyBzdGF0ZSBtb2R1bGUgY291bnRzIGZyb20gaG9yaXpvbnRhbCBzY2FuXG4gICAgICAgICAqIEBwYXJhbSBpIHJvdyB3aGVyZSBmaW5kZXIgcGF0dGVybiBtYXkgYmUgZm91bmRcbiAgICAgICAgICogQHBhcmFtIGogZW5kIG9mIHBvc3NpYmxlIGZpbmRlciBwYXR0ZXJuIGluIHJvd1xuICAgICAgICAgKiBAcGFyYW0gcHVyZUJhcmNvZGUgdHJ1ZSBpZiBpbiBcInB1cmUgYmFyY29kZVwiIG1vZGVcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGEgZmluZGVyIHBhdHRlcm4gY2FuZGlkYXRlIHdhcyBmb3VuZCB0aGlzIHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGkgLyppbnQqLywgaiAvKmludCovLCBwdXJlQmFyY29kZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArXG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgICAgIGxldCBjZW50ZXJKID0gRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopO1xuICAgICAgICAgICAgbGV0IGNlbnRlckkgPSB0aGlzLmNyb3NzQ2hlY2tWZXJ0aWNhbChpLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySiksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckkpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmUtY3Jvc3MgY2hlY2tcbiAgICAgICAgICAgICAgICBjZW50ZXJKID0gdGhpcy5jcm9zc0NoZWNrSG9yaXpvbnRhbCgvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySiksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJJKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckopICYmXG4gICAgICAgICAgICAgICAgICAgICghcHVyZUJhcmNvZGUgfHwgdGhpcy5jcm9zc0NoZWNrRGlhZ29uYWwoLyooaW50KSAqLyBNYXRoLmZsb29yKGNlbnRlckkpLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySiksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZE1vZHVsZVNpemUgPSBzdGF0ZUNvdW50VG90YWwgLyA3LjA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZUNlbnRlcnMgPSB0aGlzLnBvc3NpYmxlQ2VudGVycztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gcG9zc2libGVDZW50ZXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFib3V0IHRoZSBzYW1lIGNlbnRlciBhbmQgbW9kdWxlIHNpemU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VudGVyLmFib3V0RXF1YWxzKGVzdGltYXRlZE1vZHVsZVNpemUsIGNlbnRlckksIGNlbnRlckopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzW2luZGV4XSA9IGNlbnRlci5jb21iaW5lRXN0aW1hdGUoY2VudGVySSwgY2VudGVySiwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IEZpbmRlclBhdHRlcm4kMShjZW50ZXJKLCBjZW50ZXJJLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IG51bGwgJiYgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIHJvd3Mgd2UgY291bGQgc2FmZWx5IHNraXAgZHVyaW5nIHNjYW5uaW5nLCBiYXNlZCBvbiB0aGUgZmlyc3RcbiAgICAgICAgICogICAgICAgICB0d28gZmluZGVyIHBhdHRlcm5zIHRoYXQgaGF2ZSBiZWVuIGxvY2F0ZWQuIEluIHNvbWUgY2FzZXMgdGhlaXIgcG9zaXRpb24gd2lsbFxuICAgICAgICAgKiAgICAgICAgIGFsbG93IHVzIHRvIGluZmVyIHRoYXQgdGhlIHRoaXJkIHBhdHRlcm4gbXVzdCBsaWUgYmVsb3cgYSBjZXJ0YWluIHBvaW50IGZhcnRoZXJcbiAgICAgICAgICogICAgICAgICBkb3duIGluIHRoZSBpbWFnZS5cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRSb3dTa2lwKCkge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG1heCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmlyc3RDb25maXJtZWRDZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjZW50ZXIgb2YgdGhpcy5wb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2VudGVyLmdldENvdW50KCkgPj0gRmluZGVyUGF0dGVybkZpbmRlci5DRU5URVJfUVVPUlVNKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdENvbmZpcm1lZENlbnRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENvbmZpcm1lZENlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdHdvIGNvbmZpcm1lZCBjZW50ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3cgZmFyIGRvd24gY2FuIHdlIHNraXAgYmVmb3JlIHJlc3VtaW5nIGxvb2tpbmcgZm9yIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXR0ZXJuPyBJbiB0aGUgd29yc3QgY2FzZSwgb25seSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiB0aGUgeCAvIHkgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjZW50ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB5b3UgZmluZCB0b3AgbGVmdCBsYXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNTa2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvKihpbnQpICovIE1hdGguZmxvb3IoKE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFgoKSAtIGNlbnRlci5nZXRYKCkpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhmaXJzdENvbmZpcm1lZENlbnRlci5nZXRZKCkgLSBjZW50ZXIuZ2V0WSgpKSkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHdlIGhhdmUgZm91bmQgYXQgbGVhc3QgMyBmaW5kZXIgcGF0dGVybnMgdGhhdCBoYXZlIGJlZW4gZGV0ZWN0ZWRcbiAgICAgICAgICogICAgICAgICBhdCBsZWFzdCB7QGxpbmsgI0NFTlRFUl9RVU9SVU19IHRpbWVzIGVhY2gsIGFuZCwgdGhlIGVzdGltYXRlZCBtb2R1bGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgICogICAgICAgICBjYW5kaWRhdGVzIGlzIFwicHJldHR5IHNpbWlsYXJcIlxuICAgICAgICAgKi9cbiAgICAgICAgaGF2ZU11bHRpcGx5Q29uZmlybWVkQ2VudGVycygpIHtcbiAgICAgICAgICAgIGxldCBjb25maXJtZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgdG90YWxNb2R1bGVTaXplID0gMC4wO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMucG9zc2libGVDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4uZ2V0Q291bnQoKSA+PSBGaW5kZXJQYXR0ZXJuRmluZGVyLkNFTlRFUl9RVU9SVU0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maXJtZWRDb3VudCA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPSywgd2UgaGF2ZSBhdCBsZWFzdCAzIGNvbmZpcm1lZCBjZW50ZXJzLCBidXQsIGl0J3MgcG9zc2libGUgdGhhdCBvbmUgaXMgYSBcImZhbHNlIHBvc2l0aXZlXCJcbiAgICAgICAgICAgIC8vIGFuZCB0aGF0IHdlIG5lZWQgdG8ga2VlcCBsb29raW5nLiBXZSBkZXRlY3QgdGhpcyBieSBhc2tpbmcgaWYgdGhlIGVzdGltYXRlZCBtb2R1bGUgc2l6ZXNcbiAgICAgICAgICAgIC8vIHZhcnkgdG9vIG11Y2guIFdlIGFyYml0cmFyaWx5IHNheSB0aGF0IHdoZW4gdGhlIHRvdGFsIGRldmlhdGlvbiBmcm9tIGF2ZXJhZ2UgZXhjZWVkc1xuICAgICAgICAgICAgLy8gNSUgb2YgdGhlIHRvdGFsIG1vZHVsZSBzaXplIGVzdGltYXRlcywgaXQncyB0b28gbXVjaC5cbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBtYXg7XG4gICAgICAgICAgICBsZXQgdG90YWxEZXZpYXRpb24gPSAwLjA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wb3NzaWJsZUNlbnRlcnMpIHtcbiAgICAgICAgICAgICAgICB0b3RhbERldmlhdGlvbiArPSBNYXRoLmFicyhwYXR0ZXJuLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsRGV2aWF0aW9uIDw9IDAuMDUgKiB0b3RhbE1vZHVsZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gdGhlIDMgYmVzdCB7QGxpbmsgRmluZGVyUGF0dGVybn1zIGZyb20gb3VyIGxpc3Qgb2YgY2FuZGlkYXRlcy4gVGhlIFwiYmVzdFwiIGFyZVxuICAgICAgICAgKiAgICAgICAgIHRob3NlIHRoYXQgaGF2ZSBiZWVuIGRldGVjdGVkIGF0IGxlYXN0IHtAbGluayAjQ0VOVEVSX1FVT1JVTX0gdGltZXMsIGFuZCB3aG9zZSBtb2R1bGVcbiAgICAgICAgICogICAgICAgICBzaXplIGRpZmZlcnMgZnJvbSB0aGUgYXZlcmFnZSBhbW9uZyB0aG9zZSBwYXR0ZXJucyB0aGUgbGVhc3RcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiAzIHN1Y2ggZmluZGVyIHBhdHRlcm5zIGRvIG5vdCBleGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0QmVzdFBhdHRlcm5zKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRTaXplID0gdGhpcy5wb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YXJ0U2l6ZSA8IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VsZG4ndCBmaW5kIGVub3VnaCBmaW5kZXIgcGF0dGVybnNcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzO1xuICAgICAgICAgICAgbGV0IGF2ZXJhZ2U7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0bGllciBwb3NzaWJpbGl0aWVzIHdob3NlIG1vZHVsZSBzaXplIGlzIHRvbyBkaWZmZXJlbnRcbiAgICAgICAgICAgIGlmIChzdGFydFNpemUgPiAzKSB7XG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBvbmx5IGFmZm9yZCB0byBkbyBzbyBpZiB3ZSBoYXZlIGF0IGxlYXN0IDQgcG9zc2liaWxpdGllcyB0byBjaG9vc2UgZnJvbVxuICAgICAgICAgICAgICAgIGxldCB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XG4gICAgICAgICAgICAgICAgbGV0IHNxdWFyZSA9IDAuMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbnRlciBvZiB0aGlzLnBvc3NpYmxlQ2VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gY2VudGVyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZSArPSBzaXplICogc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIHN0YXJ0U2l6ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RkRGV2ID0gTWF0aC5zcXJ0KHNxdWFyZSAvIHN0YXJ0U2l6ZSAtIGF2ZXJhZ2UgKiBhdmVyYWdlKTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc29ydChcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiA8cD5PcmRlcnMgYnkgZnVydGhlc3QgZnJvbSBhdmVyYWdlPC9wPlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vIEZ1cnRoZXN0RnJvbUF2ZXJhZ2VDb21wYXJhdG9yIGltcGxlbWVudHMgQ29tcGFyYXRvcjxGaW5kZXJQYXR0ZXJuPlxuICAgICAgICAgICAgICAgIChjZW50ZXIxLCBjZW50ZXIyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRBID0gTWF0aC5hYnMoY2VudGVyMi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZEIgPSBNYXRoLmFicyhjZW50ZXIxLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZEEgPCBkQiA/IC0xIDogZEEgPiBkQiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5tYXgoMC4yICogYXZlcmFnZSwgc3RkRGV2KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc3NpYmxlQ2VudGVycy5sZW5ndGggJiYgcG9zc2libGVDZW50ZXJzLmxlbmd0aCA+IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gcG9zc2libGVDZW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKSA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlQ2VudGVycy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBhbGwgYnV0IHRob3NlIGZpcnN0IHNpemUgY2FuZGlkYXRlIHBvaW50cyB3ZSBmb3VuZC5cbiAgICAgICAgICAgICAgICBsZXQgdG90YWxNb2R1bGVTaXplID0gMC4wO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9zc2libGVDZW50ZXIgb2YgcG9zc2libGVDZW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBwb3NzaWJsZUNlbnRlci5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBwb3NzaWJsZUNlbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zb3J0KFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIDxwPk9yZGVycyBieSB7QGxpbmsgRmluZGVyUGF0dGVybiNnZXRDb3VudCgpfSwgZGVzY2VuZGluZy48L3A+XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gQ2VudGVyQ29tcGFyYXRvciBpbXBsZW1lbnRzIENvbXBhcmF0b3I8RmluZGVyUGF0dGVybj5cbiAgICAgICAgICAgICAgICAoY2VudGVyMSwgY2VudGVyMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VudGVyMi5nZXRDb3VudCgpID09PSBjZW50ZXIxLmdldENvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRBID0gTWF0aC5hYnMoY2VudGVyMi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRCID0gTWF0aC5hYnMoY2VudGVyMS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkQSA8IGRCID8gMSA6IGRBID4gZEIgPyAtMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyMi5nZXRDb3VudCgpIC0gY2VudGVyMS5nZXRDb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNwbGljZSgzKTsgLy8gdGhpcyBpcyBub3QgcmVhbHkgbmVjZXNzYXJ5IGFzIHdlIG9ubHkgcmV0dXJuIGZpcnN0IDMgYW55d2F5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1swXSxcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMV0sXG4gICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzJdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSA9IDI7XG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5NSU5fU0tJUCA9IDM7IC8vIDEgcGl4ZWwvbW9kdWxlIHRpbWVzIDMgbW9kdWxlcy9jZW50ZXJcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLk1BWF9NT0RVTEVTID0gNTc7IC8vIHN1cHBvcnQgdXAgdG8gdmVyc2lvbiAxMCBmb3IgbW9iaWxlIGNsaWVudHNcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIDxwPkVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYSBRUiBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZSBRUiBDb2RlXG4gICAgICogaXMgcm90YXRlZCBvciBza2V3ZWQsIG9yIHBhcnRpYWxseSBvYnNjdXJlZC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqL1xuICAgIGNsYXNzIERldGVjdG9yJDIge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbWFnZSkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGdldEltYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmVzdWx0UG9pbnRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkRldGVjdHMgYSBRUiBDb2RlIGluIGFuIGltYWdlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBRUiBDb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgUVIgQ29kZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBRUiBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkXG4gICAgICAgICAqL1xuICAgICAgICAvLyBwdWJsaWMgZGV0ZWN0KCk6IERldGVjdG9yUmVzdWx0IC8qdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24qLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGRldGVjdChudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZXRlY3RzIGEgUVIgQ29kZSBpbiBhbiBpbWFnZS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBvcHRpb25hbCBoaW50cyB0byBkZXRlY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhIFFSIENvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBRUiBDb2RlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICovXG4gICAgICAgIGRldGVjdChoaW50cykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gKGhpbnRzID09PSBudWxsIHx8IGhpbnRzID09PSB1bmRlZmluZWQpID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgLyooUmVzdWx0UG9pbnRDYWxsYmFjaykgKi8gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlJDEuTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0spO1xuICAgICAgICAgICAgY29uc3QgZmluZGVyID0gbmV3IEZpbmRlclBhdHRlcm5GaW5kZXIodGhpcy5pbWFnZSwgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBmaW5kZXIuZmluZChoaW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRmluZGVyUGF0dGVybkluZm8oaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0ZpbmRlclBhdHRlcm5JbmZvKGluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcExlZnQgPSBpbmZvLmdldFRvcExlZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gaW5mby5nZXRUb3BSaWdodCgpO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IGluZm8uZ2V0Qm90dG9tTGVmdCgpO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZSA9IHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZSh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCk7XG4gICAgICAgICAgICBpZiAobW9kdWxlU2l6ZSA8IDEuMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignTm8gcGF0dGVybiBmb3VuZCBpbiBwcm9jY2VzcyBmaW5kZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSBEZXRlY3RvciQyLmNvbXB1dGVEaW1lbnNpb24odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uYWxWZXJzaW9uID0gVmVyc2lvbiQxLmdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbihkaW1lbnNpb24pO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlc0JldHdlZW5GUENlbnRlcnMgPSBwcm92aXNpb25hbFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpIC0gNztcbiAgICAgICAgICAgIGxldCBhbGlnbm1lbnRQYXR0ZXJuID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGFib3ZlIHZlcnNpb24gMSBoYXMgYW4gYWxpZ25tZW50IHBhdHRlcm5cbiAgICAgICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24uZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gR3Vlc3Mgd2hlcmUgYSBcImJvdHRvbSByaWdodFwiIGZpbmRlciBwYXR0ZXJuIHdvdWxkIGhhdmUgYmVlblxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0WCA9IHRvcFJpZ2h0LmdldFgoKSAtIHRvcExlZnQuZ2V0WCgpICsgYm90dG9tTGVmdC5nZXRYKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tUmlnaHRZID0gdG9wUmlnaHQuZ2V0WSgpIC0gdG9wTGVmdC5nZXRZKCkgKyBib3R0b21MZWZ0LmdldFkoKTtcbiAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSB0aGF0IGFsaWdubWVudCBwYXR0ZXJuIGlzIGNsb3NlciBieSAzIG1vZHVsZXNcbiAgICAgICAgICAgICAgICAvLyBmcm9tIFwiYm90dG9tIHJpZ2h0XCIgdG8ga25vd24gdG9wIGxlZnQgbG9jYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uVG9Ub3BMZWZ0ID0gMS4wIC0gMy4wIC8gbW9kdWxlc0JldHdlZW5GUENlbnRlcnM7XG4gICAgICAgICAgICAgICAgY29uc3QgZXN0QWxpZ25tZW50WCA9IC8qKGludCkgKi8gTWF0aC5mbG9vcih0b3BMZWZ0LmdldFgoKSArIGNvcnJlY3Rpb25Ub1RvcExlZnQgKiAoYm90dG9tUmlnaHRYIC0gdG9wTGVmdC5nZXRYKCkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RBbGlnbm1lbnRZID0gLyooaW50KSAqLyBNYXRoLmZsb29yKHRvcExlZnQuZ2V0WSgpICsgY29ycmVjdGlvblRvVG9wTGVmdCAqIChib3R0b21SaWdodFkgLSB0b3BMZWZ0LmdldFkoKSkpO1xuICAgICAgICAgICAgICAgIC8vIEtpbmQgb2YgYXJiaXRyYXJ5IC0tIGV4cGFuZCBzZWFyY2ggcmFkaXVzIGJlZm9yZSBnaXZpbmcgdXBcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gNDsgaSA8PSAxNjsgaSA8PD0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50UGF0dGVybiA9IHRoaXMuZmluZEFsaWdubWVudEluUmVnaW9uKG1vZHVsZVNpemUsIGVzdEFsaWdubWVudFgsIGVzdEFsaWdubWVudFksIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHJlIC8qTm90Rm91bmRFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSBuZXh0IHJvdW5kXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYWxpZ25tZW50IHBhdHRlcm4uLi4gd2VsbCB0cnkgYW55d2F5IHdpdGhvdXQgaXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IERldGVjdG9yJDIuY3JlYXRlVHJhbnNmb3JtKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBhbGlnbm1lbnRQYXR0ZXJuLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IERldGVjdG9yJDIuc2FtcGxlR3JpZCh0aGlzLmltYWdlLCB0cmFuc2Zvcm0sIGRpbWVuc2lvbik7XG4gICAgICAgICAgICBsZXQgcG9pbnRzO1xuICAgICAgICAgICAgaWYgKGFsaWdubWVudFBhdHRlcm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBbYm90dG9tTGVmdCwgdG9wTGVmdCwgdG9wUmlnaHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gW2JvdHRvbUxlZnQsIHRvcExlZnQsIHRvcFJpZ2h0LCBhbGlnbm1lbnRQYXR0ZXJuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV0ZWN0b3JSZXN1bHQoYml0cywgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY3JlYXRlVHJhbnNmb3JtKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBhbGlnbm1lbnRQYXR0ZXJuLCBkaW1lbnNpb24gLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgZGltTWludXNUaHJlZSA9IGRpbWVuc2lvbiAtIDMuNTtcbiAgICAgICAgICAgIGxldCBib3R0b21SaWdodFg7IC8qZmxvYXQqL1xuICAgICAgICAgICAgbGV0IGJvdHRvbVJpZ2h0WTsgLypmbG9hdCovXG4gICAgICAgICAgICBsZXQgc291cmNlQm90dG9tUmlnaHRYOyAvKmZsb2F0Ki9cbiAgICAgICAgICAgIGxldCBzb3VyY2VCb3R0b21SaWdodFk7IC8qZmxvYXQqL1xuICAgICAgICAgICAgaWYgKGFsaWdubWVudFBhdHRlcm4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodFggPSBhbGlnbm1lbnRQYXR0ZXJuLmdldFgoKTtcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodFkgPSBhbGlnbm1lbnRQYXR0ZXJuLmdldFkoKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFggPSBkaW1NaW51c1RocmVlIC0gMy4wO1xuICAgICAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WSA9IHNvdXJjZUJvdHRvbVJpZ2h0WDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGhhdmUgYW4gYWxpZ25tZW50IHBhdHRlcm4sIGp1c3QgbWFrZSB1cCB0aGUgYm90dG9tLXJpZ2h0IHBvaW50XG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHRYID0gKHRvcFJpZ2h0LmdldFgoKSAtIHRvcExlZnQuZ2V0WCgpKSArIGJvdHRvbUxlZnQuZ2V0WCgpO1xuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0WSA9ICh0b3BSaWdodC5nZXRZKCkgLSB0b3BMZWZ0LmdldFkoKSkgKyBib3R0b21MZWZ0LmdldFkoKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFggPSBkaW1NaW51c1RocmVlO1xuICAgICAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WSA9IGRpbU1pbnVzVGhyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbCgzLjUsIDMuNSwgZGltTWludXNUaHJlZSwgMy41LCBzb3VyY2VCb3R0b21SaWdodFgsIHNvdXJjZUJvdHRvbVJpZ2h0WSwgMy41LCBkaW1NaW51c1RocmVlLCB0b3BMZWZ0LmdldFgoKSwgdG9wTGVmdC5nZXRZKCksIHRvcFJpZ2h0LmdldFgoKSwgdG9wUmlnaHQuZ2V0WSgpLCBib3R0b21SaWdodFgsIGJvdHRvbVJpZ2h0WSwgYm90dG9tTGVmdC5nZXRYKCksIGJvdHRvbUxlZnQuZ2V0WSgpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgc2FtcGxlR3JpZChpbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24gLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWRXaXRoVHJhbnNmb3JtKGltYWdlLCBkaW1lbnNpb24sIGRpbWVuc2lvbiwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+Q29tcHV0ZXMgdGhlIGRpbWVuc2lvbiAobnVtYmVyIG9mIG1vZHVsZXMgb24gYSBzaXplKSBvZiB0aGUgUVIgQ29kZSBiYXNlZCBvbiB0aGUgcG9zaXRpb25cbiAgICAgICAgICogb2YgdGhlIGZpbmRlciBwYXR0ZXJucyBhbmQgZXN0aW1hdGVkIG1vZHVsZSBzaXplLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb21wdXRlRGltZW5zaW9uKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBtb2R1bGVTaXplIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgY29uc3QgdGx0ckNlbnRlcnNEaW1lbnNpb24gPSBNYXRoVXRpbHMucm91bmQoUmVzdWx0UG9pbnQuZGlzdGFuY2UodG9wTGVmdCwgdG9wUmlnaHQpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCB0bGJsQ2VudGVyc0RpbWVuc2lvbiA9IE1hdGhVdGlscy5yb3VuZChSZXN1bHRQb2ludC5kaXN0YW5jZSh0b3BMZWZ0LCBib3R0b21MZWZ0KSAvIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgbGV0IGRpbWVuc2lvbiA9IE1hdGguZmxvb3IoKHRsdHJDZW50ZXJzRGltZW5zaW9uICsgdGxibENlbnRlcnNEaW1lbnNpb24pIC8gMikgKyA3O1xuICAgICAgICAgICAgc3dpdGNoIChkaW1lbnNpb24gJiAweDAzKSB7IC8vIG1vZCA0XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb24rKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gMT8gZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCdEaW1lbnNpb25zIGNvdWxkIGJlIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaW1lbnNpb247XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkNvbXB1dGVzIGFuIGF2ZXJhZ2UgZXN0aW1hdGVkIG1vZHVsZSBzaXplIGJhc2VkIG9uIGVzdGltYXRlZCBkZXJpdmVkIGZyb20gdGhlIHBvc2l0aW9uc1xuICAgICAgICAgKiBvZiB0aGUgdGhyZWUgZmluZGVyIHBhdHRlcm5zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRvcExlZnQgZGV0ZWN0ZWQgdG9wLWxlZnQgZmluZGVyIHBhdHRlcm4gY2VudGVyXG4gICAgICAgICAqIEBwYXJhbSB0b3BSaWdodCBkZXRlY3RlZCB0b3AtcmlnaHQgZmluZGVyIHBhdHRlcm4gY2VudGVyXG4gICAgICAgICAqIEBwYXJhbSBib3R0b21MZWZ0IGRldGVjdGVkIGJvdHRvbS1sZWZ0IGZpbmRlciBwYXR0ZXJuIGNlbnRlclxuICAgICAgICAgKiBAcmV0dXJuIGVzdGltYXRlZCBtb2R1bGUgc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlTW9kdWxlU2l6ZSh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCkge1xuICAgICAgICAgICAgLy8gVGFrZSB0aGUgYXZlcmFnZVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkodG9wTGVmdCwgdG9wUmlnaHQpICtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkodG9wTGVmdCwgYm90dG9tTGVmdCkpIC8gMi4wO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5Fc3RpbWF0ZXMgbW9kdWxlIHNpemUgYmFzZWQgb24gdHdvIGZpbmRlciBwYXR0ZXJucyAtLSBpdCB1c2VzXG4gICAgICAgICAqIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoaW50LCBpbnQsIGludCwgaW50KX0gdG8gZmlndXJlIHRoZVxuICAgICAgICAgKiB3aWR0aCBvZiBlYWNoLCBtZWFzdXJpbmcgYWxvbmcgdGhlIGF4aXMgYmV0d2VlbiB0aGVpciBjZW50ZXJzLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkocGF0dGVybiwgb3RoZXJQYXR0ZXJuKSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplRXN0MSA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WCgpKSwgXG4gICAgICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRZKCkpLCBcbiAgICAgICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WCgpKSwgXG4gICAgICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFkoKSkpO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlU2l6ZUVzdDIgPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzKC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WCgpKSwgXG4gICAgICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFkoKSksIFxuICAgICAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WCgpKSwgXG4gICAgICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRZKCkpKTtcbiAgICAgICAgICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDIgLyA3LjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4obW9kdWxlU2l6ZUVzdDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVFc3QxIC8gNy4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXZlcmFnZSB0aGVtLCBhbmQgZGl2aWRlIGJ5IDcgc2luY2Ugd2UndmUgY291bnRlZCB0aGUgd2lkdGggb2YgMyBibGFjayBtb2R1bGVzLFxuICAgICAgICAgICAgLy8gYW5kIDEgd2hpdGUgYW5kIDEgYmxhY2sgbW9kdWxlIG9uIGVpdGhlciBzaWRlLiBFcmdvLCBkaXZpZGUgc3VtIGJ5IDE0LlxuICAgICAgICAgICAgcmV0dXJuIChtb2R1bGVTaXplRXN0MSArIG1vZHVsZVNpemVFc3QyKSAvIDE0LjA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSB7QGxpbmsgI3NpemVPZkJsYWNrV2hpdGVCbGFja1J1bihpbnQsIGludCwgaW50LCBpbnQpfTsgY29tcHV0ZXMgdGhlIHRvdGFsIHdpZHRoIG9mXG4gICAgICAgICAqIGEgZmluZGVyIHBhdHRlcm4gYnkgbG9va2luZyBmb3IgYSBibGFjay13aGl0ZS1ibGFjayBydW4gZnJvbSB0aGUgY2VudGVyIGluIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICogb2YgYW5vdGhlciBwb2ludCAoYW5vdGhlciBmaW5kZXIgcGF0dGVybiBjZW50ZXIpLCBhbmQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0b28uXG4gICAgICAgICAqL1xuICAgICAgICBzaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cyhmcm9tWCAvKmludCovLCBmcm9tWSAvKmludCovLCB0b1ggLyppbnQqLywgdG9ZIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bihmcm9tWCwgZnJvbVksIHRvWCwgdG9ZKTtcbiAgICAgICAgICAgIC8vIE5vdyBjb3VudCBvdGhlciB3YXkgLS0gZG9uJ3QgcnVuIG9mZiBpbWFnZSB0aG91Z2ggb2YgY291cnNlXG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAxLjA7XG4gICAgICAgICAgICBsZXQgb3RoZXJUb1ggPSBmcm9tWCAtICh0b1ggLSBmcm9tWCk7XG4gICAgICAgICAgICBpZiAob3RoZXJUb1ggPCAwKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBmcm9tWCAvIC8qKGZsb2F0KSAqLyAoZnJvbVggLSBvdGhlclRvWCk7XG4gICAgICAgICAgICAgICAgb3RoZXJUb1ggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJUb1ggPj0gdGhpcy5pbWFnZS5nZXRXaWR0aCgpKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAodGhpcy5pbWFnZS5nZXRXaWR0aCgpIC0gMSAtIGZyb21YKSAvIC8qKGZsb2F0KSAqLyAob3RoZXJUb1ggLSBmcm9tWCk7XG4gICAgICAgICAgICAgICAgb3RoZXJUb1ggPSB0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG90aGVyVG9ZID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGZyb21ZIC0gKHRvWSAtIGZyb21ZKSAqIHNjYWxlKTtcbiAgICAgICAgICAgIHNjYWxlID0gMS4wO1xuICAgICAgICAgICAgaWYgKG90aGVyVG9ZIDwgMCkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gZnJvbVkgLyAvKihmbG9hdCkgKi8gKGZyb21ZIC0gb3RoZXJUb1kpO1xuICAgICAgICAgICAgICAgIG90aGVyVG9ZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyVG9ZID49IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9ICh0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMSAtIGZyb21ZKSAvIC8qKGZsb2F0KSAqLyAob3RoZXJUb1kgLSBmcm9tWSk7XG4gICAgICAgICAgICAgICAgb3RoZXJUb1kgPSB0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG90aGVyVG9YID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGZyb21YICsgKG90aGVyVG9YIC0gZnJvbVgpICogc2NhbGUpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGZyb21YLCBmcm9tWSwgb3RoZXJUb1gsIG90aGVyVG9ZKTtcbiAgICAgICAgICAgIC8vIE1pZGRsZSBwaXhlbCBpcyBkb3VibGUtY291bnRlZCB0aGlzIHdheTsgc3VidHJhY3QgMVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAtIDEuMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+VGhpcyBtZXRob2QgdHJhY2VzIGEgbGluZSBmcm9tIGEgcG9pbnQgaW4gdGhlIGltYWdlLCBpbiB0aGUgZGlyZWN0aW9uIHRvd2FyZHMgYW5vdGhlciBwb2ludC5cbiAgICAgICAgICogSXQgYmVnaW5zIGluIGEgYmxhY2sgcmVnaW9uLCBhbmQga2VlcHMgZ29pbmcgdW50aWwgaXQgZmluZHMgd2hpdGUsIHRoZW4gYmxhY2ssIHRoZW4gd2hpdGUgYWdhaW4uXG4gICAgICAgICAqIEl0IHJlcG9ydHMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHN0YXJ0IHRvIHRoaXMgcG9pbnQuPC9wPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD5UaGlzIGlzIHVzZWQgd2hlbiBmaWd1cmluZyBvdXQgaG93IHdpZGUgYSBmaW5kZXIgcGF0dGVybiBpcywgd2hlbiB0aGUgZmluZGVyIHBhdHRlcm5cbiAgICAgICAgICogbWF5IGJlIHNrZXdlZCBvciByb3RhdGVkLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIHNpemVPZkJsYWNrV2hpdGVCbGFja1J1bihmcm9tWCAvKmludCovLCBmcm9tWSAvKmludCovLCB0b1ggLyppbnQqLywgdG9ZIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIC8vIE1pbGQgdmFyaWFudCBvZiBCcmVzZW5oYW0ncyBhbGdvcml0aG1cbiAgICAgICAgICAgIC8vIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZXNlbmhhbSdzX2xpbmVfYWxnb3JpdGhtXG4gICAgICAgICAgICBjb25zdCBzdGVlcCA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKSA+IE1hdGguYWJzKHRvWCAtIGZyb21YKTtcbiAgICAgICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gZnJvbVg7XG4gICAgICAgICAgICAgICAgZnJvbVggPSBmcm9tWTtcbiAgICAgICAgICAgICAgICBmcm9tWSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHRvWDtcbiAgICAgICAgICAgICAgICB0b1ggPSB0b1k7XG4gICAgICAgICAgICAgICAgdG9ZID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR4ID0gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICAgICAgY29uc3QgZHkgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSk7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSAtZHggLyAyO1xuICAgICAgICAgICAgY29uc3QgeHN0ZXAgPSBmcm9tWCA8IHRvWCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IHlzdGVwID0gZnJvbVkgPCB0b1kgPyAxIDogLTE7XG4gICAgICAgICAgICAvLyBJbiBibGFjayBwaXhlbHMsIGxvb2tpbmcgZm9yIHdoaXRlLCBmaXJzdCBvciBzZWNvbmQgdGltZS5cbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAvLyBMb29wIHVwIHVudGlsIHggPT0gdG9YLCBidXQgbm90IGJleW9uZFxuICAgICAgICAgICAgY29uc3QgeExpbWl0ID0gdG9YICsgeHN0ZXA7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gZnJvbVgsIHkgPSBmcm9tWTsgeCAhPT0geExpbWl0OyB4ICs9IHhzdGVwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhbFggPSBzdGVlcCA/IHkgOiB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWxZID0gc3RlZXAgPyB4IDogeTtcbiAgICAgICAgICAgICAgICAvLyBEb2VzIGN1cnJlbnQgcGl4ZWwgbWVhbiB3ZSBoYXZlIG1vdmVkIHdoaXRlIHRvIGJsYWNrIG9yIHZpY2UgdmVyc2E/XG4gICAgICAgICAgICAgICAgLy8gU2Nhbm5pbmcgYmxhY2sgaW4gc3RhdGUgMCwyIGFuZCB3aGl0ZSBpbiBzdGF0ZSAxLCBzbyBpZiB3ZSBmaW5kIHRoZSB3cm9uZ1xuICAgICAgICAgICAgICAgIC8vIGNvbG9yLCBhZHZhbmNlIHRvIG5leHQgc3RhdGUgb3IgZW5kIGlmIHdlIGFyZSBpbiBzdGF0ZSAyIGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAoKHN0YXRlID09PSAxKSA9PT0gdGhpcy5pbWFnZS5nZXQocmVhbFgsIHJlYWxZKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuZGlzdGFuY2UoeCwgeSwgZnJvbVgsIGZyb21ZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciArPSBkeTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID09PSB0b1kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkgKz0geXN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yIC09IGR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvdW5kIGJsYWNrLXdoaXRlLWJsYWNrOyBnaXZlIHRoZSBiZW5lZml0IG9mIHRoZSBkb3VidCB0aGF0IHRoZSBuZXh0IHBpeGVsIG91dHNpZGUgdGhlIGltYWdlXG4gICAgICAgICAgICAvLyBpcyBcIndoaXRlXCIgc28gdGhpcyBsYXN0IHBvaW50IGF0ICh0b1greFN0ZXAsdG9ZKSBpcyB0aGUgcmlnaHQgZW5kaW5nLiBUaGlzIGlzIHJlYWxseSBhXG4gICAgICAgICAgICAvLyBzbWFsbCBhcHByb3hpbWF0aW9uOyAodG9YK3hTdGVwLHRvWSt5U3RlcCkgbWlnaHQgYmUgcmVhbGx5IGNvcnJlY3QuIElnbm9yZSB0aGlzLlxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5kaXN0YW5jZSh0b1ggKyB4c3RlcCwgdG9ZLCBmcm9tWCwgZnJvbVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSB3ZSBkaWRuJ3QgZmluZCBldmVuIGJsYWNrLXdoaXRlLWJsYWNrOyBubyBlc3RpbWF0ZSBpcyByZWFsbHkgcG9zc2libGVcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIDxwPkF0dGVtcHRzIHRvIGxvY2F0ZSBhbiBhbGlnbm1lbnQgcGF0dGVybiBpbiBhIGxpbWl0ZWQgcmVnaW9uIG9mIHRoZSBpbWFnZSwgd2hpY2ggaXNcbiAgICAgICAgICogZ3Vlc3NlZCB0byBjb250YWluIGl0LiBUaGlzIG1ldGhvZCB1c2VzIHtAbGluayBBbGlnbm1lbnRQYXR0ZXJufS48L3A+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvdmVyYWxsRXN0TW9kdWxlU2l6ZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgc28gZmFyXG4gICAgICAgICAqIEBwYXJhbSBlc3RBbGlnbm1lbnRYIHggY29vcmRpbmF0ZSBvZiBjZW50ZXIgb2YgYXJlYSBwcm9iYWJseSBjb250YWluaW5nIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgICAqIEBwYXJhbSBlc3RBbGlnbm1lbnRZIHkgY29vcmRpbmF0ZSBvZiBhYm92ZVxuICAgICAgICAgKiBAcGFyYW0gYWxsb3dhbmNlRmFjdG9yIG51bWJlciBvZiBwaXhlbHMgaW4gYWxsIGRpcmVjdGlvbnMgdG8gc2VhcmNoIGZyb20gdGhlIGNlbnRlclxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBBbGlnbm1lbnRQYXR0ZXJufSBpZiBmb3VuZCwgb3IgbnVsbCBvdGhlcndpc2VcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBhbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycyBkdXJpbmcgZGV0ZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kQWxpZ25tZW50SW5SZWdpb24ob3ZlcmFsbEVzdE1vZHVsZVNpemUgLypmbG9hdCovLCBlc3RBbGlnbm1lbnRYIC8qaW50Ki8sIGVzdEFsaWdubWVudFkgLyppbnQqLywgYWxsb3dhbmNlRmFjdG9yIC8qZmxvYXQqLykge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW4gYWxpZ25tZW50IHBhdHRlcm4gKDMgbW9kdWxlcyBpbiBzaXplKSBhcm91bmQgd2hlcmUgaXRcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZVxuICAgICAgICAgICAgY29uc3QgYWxsb3dhbmNlID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGFsbG93YW5jZUZhY3RvciAqIG92ZXJhbGxFc3RNb2R1bGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudEFyZWFMZWZ0WCA9IE1hdGgubWF4KDAsIGVzdEFsaWdubWVudFggLSBhbGxvd2FuY2UpO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50QXJlYVJpZ2h0WCA9IE1hdGgubWluKHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAtIDEsIGVzdEFsaWdubWVudFggKyBhbGxvd2FuY2UpO1xuICAgICAgICAgICAgaWYgKGFsaWdubWVudEFyZWFSaWdodFggLSBhbGlnbm1lbnRBcmVhTGVmdFggPCBvdmVyYWxsRXN0TW9kdWxlU2l6ZSAqIDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ0FsaWdubWVudCB0b3AgZXhjZWVkcyBlc3RpbWF0ZWQgbW9kdWxlIHNpemUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnRBcmVhVG9wWSA9IE1hdGgubWF4KDAsIGVzdEFsaWdubWVudFkgLSBhbGxvd2FuY2UpO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50QXJlYUJvdHRvbVkgPSBNYXRoLm1pbih0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMSwgZXN0QWxpZ25tZW50WSArIGFsbG93YW5jZSk7XG4gICAgICAgICAgICBpZiAoYWxpZ25tZW50QXJlYUJvdHRvbVkgLSBhbGlnbm1lbnRBcmVhVG9wWSA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbignQWxpZ25tZW50IGJvdHRvbSBleGNlZWRzIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudEZpbmRlciA9IG5ldyBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyKHRoaXMuaW1hZ2UsIGFsaWdubWVudEFyZWFMZWZ0WCwgYWxpZ25tZW50QXJlYVRvcFksIGFsaWdubWVudEFyZWFSaWdodFggLSBhbGlnbm1lbnRBcmVhTGVmdFgsIGFsaWdubWVudEFyZWFCb3R0b21ZIC0gYWxpZ25tZW50QXJlYVRvcFksIG92ZXJhbGxFc3RNb2R1bGVTaXplLCB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudEZpbmRlci5maW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qaW1wb3J0IGphdmEudXRpbC5MaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIFFSIENvZGVzIGluIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKi9cbiAgICBjbGFzcyBRUkNvZGVSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyJDIoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXREZWNvZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIFFSIGNvZGUgaW4gYW4gaW1hZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gYSByZXByZXNlbnRpbmc6IHN0cmluZyB0aGUgY29udGVudCBlbmNvZGVkIGJ5IHRoZSBRUiBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYSBRUiBjb2RlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFFSIGNvZGUgY2Fubm90IGJlIGRlY29kZWRcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXG4gICAgICAgICAqL1xuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIC8vIHB1YmxpYyBkZWNvZGUoaW1hZ2U6IEJpbmFyeUJpdG1hcCk6IFJlc3VsdCAvKnRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiAqLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMuZGVjb2RlKGltYWdlLCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZGVjb2RlKGltYWdlLCBoaW50cykge1xuICAgICAgICAgICAgbGV0IGRlY29kZXJSZXN1bHQ7XG4gICAgICAgICAgICBsZXQgcG9pbnRzO1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9PSB1bmRlZmluZWQgJiYgaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5QVVJFX0JBUkNPREUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0cyA9IFFSQ29kZVJlYWRlci5leHRyYWN0UHVyZUJpdHMoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7XG4gICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IHRoaXMuZGVjb2Rlci5kZWNvZGVCaXRNYXRyaXgoYml0cywgaGludHMpO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IFFSQ29kZVJlYWRlci5OT19QT0lOVFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3RvclJlc3VsdCA9IG5ldyBEZXRlY3RvciQyKGltYWdlLmdldEJsYWNrTWF0cml4KCkpLmRldGVjdChoaW50cyk7XG4gICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IHRoaXMuZGVjb2Rlci5kZWNvZGVCaXRNYXRyaXgoZGV0ZWN0b3JSZXN1bHQuZ2V0Qml0cygpLCBoaW50cyk7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29kZSB3YXMgbWlycm9yZWQ6IHN3YXAgdGhlIGJvdHRvbS1sZWZ0IGFuZCB0aGUgdG9wLXJpZ2h0IHBvaW50cy5cbiAgICAgICAgICAgIGlmIChkZWNvZGVyUmVzdWx0LmdldE90aGVyKCkgaW5zdGFuY2VvZiBRUkNvZGVEZWNvZGVyTWV0YURhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyUmVzdWx0LmdldE90aGVyKCkuYXBwbHlNaXJyb3JlZENvcnJlY3Rpb24ocG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSZXN1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKSwgdW5kZWZpbmVkLCBwb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZVNlZ21lbnRzID0gZGVjb2RlclJlc3VsdC5nZXRCeXRlU2VnbWVudHMoKTtcbiAgICAgICAgICAgIGlmIChieXRlU2VnbWVudHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuQllURV9TRUdNRU5UUywgYnl0ZVNlZ21lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTtcbiAgICAgICAgICAgIGlmIChlY0xldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwsIGVjTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQuaGFzU3RydWN0dXJlZEFwcGVuZCgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZSQxLlNUUlVDVFVSRURfQVBQRU5EX1NFUVVFTkNFLCBkZWNvZGVyUmVzdWx0LmdldFN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcigpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZLCBkZWNvZGVyUmVzdWx0LmdldFN0cnVjdHVyZWRBcHBlbmRQYXJpdHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGRldGVjdHMgYSBjb2RlIGluIGEgXCJwdXJlXCIgaW1hZ2UgLS0gdGhhdCBpcywgcHVyZSBtb25vY2hyb21lIGltYWdlXG4gICAgICAgICAqIHdoaWNoIGNvbnRhaW5zIG9ubHkgYW4gdW5yb3RhdGVkLCB1bnNrZXdlZCwgaW1hZ2Ugb2YgYSBjb2RlLCB3aXRoIHNvbWUgd2hpdGUgYm9yZGVyXG4gICAgICAgICAqIGFyb3VuZCBpdC4gVGhpcyBpcyBhIHNwZWNpYWxpemVkIG1ldGhvZCB0aGF0IHdvcmtzIGV4Y2VwdGlvbmFsbHkgZmFzdCBpbiB0aGlzIHNwZWNpYWxcbiAgICAgICAgICogY2FzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBjb20uZ29vZ2xlLnp4aW5nLmRhdGFtYXRyaXguRGF0YU1hdHJpeFJlYWRlciNleHRyYWN0UHVyZUJpdHMoQml0TWF0cml4KVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGV4dHJhY3RQdXJlQml0cyhpbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFRvcEJsYWNrID0gaW1hZ2UuZ2V0VG9wTGVmdE9uQml0KCk7XG4gICAgICAgICAgICBjb25zdCByaWdodEJvdHRvbUJsYWNrID0gaW1hZ2UuZ2V0Qm90dG9tUmlnaHRPbkJpdCgpO1xuICAgICAgICAgICAgaWYgKGxlZnRUb3BCbGFjayA9PT0gbnVsbCB8fCByaWdodEJvdHRvbUJsYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVTaXplID0gdGhpcy5tb2R1bGVTaXplKGxlZnRUb3BCbGFjaywgaW1hZ2UpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IGxlZnRUb3BCbGFja1sxXTtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBsZWZ0VG9wQmxhY2tbMF07XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByaWdodEJvdHRvbUJsYWNrWzBdO1xuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrIVxuICAgICAgICAgICAgaWYgKGxlZnQgPj0gcmlnaHQgfHwgdG9wID49IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJvdHRvbSAtIHRvcCAhPT0gcmlnaHQgLSBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlLCB3aGVyZSBib3R0b20tcmlnaHQgbW9kdWxlIHdhc24ndCBibGFjayBzbyB3ZSBmb3VuZCBzb21ldGhpbmcgZWxzZSBpbiB0aGUgbGFzdCByb3dcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgaXQncyBhIHNxdWFyZSwgc28gdXNlIGhlaWdodCBhcyB0aGUgd2lkdGhcbiAgICAgICAgICAgICAgICByaWdodCA9IGxlZnQgKyAoYm90dG9tIC0gdG9wKTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgPj0gaW1hZ2UuZ2V0V2lkdGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiB0aGF0IHdvdWxkIG5vdCBtYWtlIHNlbnNlIC0tIG9mZiBpbWFnZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhXaWR0aCA9IE1hdGgucm91bmQoKHJpZ2h0IC0gbGVmdCArIDEpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXhIZWlnaHQgPSBNYXRoLnJvdW5kKChib3R0b20gLSB0b3AgKyAxKSAvIG1vZHVsZVNpemUpO1xuICAgICAgICAgICAgaWYgKG1hdHJpeFdpZHRoIDw9IDAgfHwgbWF0cml4SGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRyaXhIZWlnaHQgIT09IG1hdHJpeFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBwb3NzaWJseSBkZWNvZGUgc3F1YXJlIHJlZ2lvbnNcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1c2ggaW4gdGhlIFwiYm9yZGVyXCIgYnkgaGFsZiB0aGUgbW9kdWxlIHdpZHRoIHNvIHRoYXQgd2Ugc3RhcnRcbiAgICAgICAgICAgIC8vIHNhbXBsaW5nIGluIHRoZSBtaWRkbGUgb2YgdGhlIG1vZHVsZS4gSnVzdCBpbiBjYXNlIHRoZSBpbWFnZSBpcyBhXG4gICAgICAgICAgICAvLyBsaXR0bGUgb2ZmLCB0aGlzIHdpbGwgaGVscCByZWNvdmVyLlxuICAgICAgICAgICAgY29uc3QgbnVkZ2UgPSAvKihpbnQpICovIE1hdGguZmxvb3IobW9kdWxlU2l6ZSAvIDIuMCk7XG4gICAgICAgICAgICB0b3AgKz0gbnVkZ2U7XG4gICAgICAgICAgICBsZWZ0ICs9IG51ZGdlO1xuICAgICAgICAgICAgLy8gQnV0IGNhcmVmdWwgdGhhdCB0aGlzIGRvZXMgbm90IHNhbXBsZSBvZmYgdGhlIGVkZ2VcbiAgICAgICAgICAgIC8vIFwicmlnaHRcIiBpcyB0aGUgZmFydGhlc3QtcmlnaHQgdmFsaWQgcGl4ZWwgbG9jYXRpb24gLS0gcmlnaHQrMSBpcyBub3QgbmVjZXNzYXJpbHlcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9zaXRpdmUgYnkgaG93IG11Y2ggdGhlIGlubmVyIHggbG9vcCBiZWxvdyB3b3VsZCBiZSB0b28gbGFyZ2VcbiAgICAgICAgICAgIGNvbnN0IG51ZGdlZFRvb0ZhclJpZ2h0ID0gbGVmdCArIC8qKGludCkgKi8gTWF0aC5mbG9vcigobWF0cml4V2lkdGggLSAxKSAqIG1vZHVsZVNpemUpIC0gcmlnaHQ7XG4gICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51ZGdlZFRvb0ZhclJpZ2h0ID4gbnVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVpdGhlciB3YXkgZml0czsgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnQgLT0gbnVkZ2VkVG9vRmFyUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWUgbG9naWMgYWJvdmVcbiAgICAgICAgICAgIGNvbnN0IG51ZGdlZFRvb0ZhckRvd24gPSB0b3AgKyAvKihpbnQpICovIE1hdGguZmxvb3IoKG1hdHJpeEhlaWdodCAtIDEpICogbW9kdWxlU2l6ZSkgLSBib3R0b207XG4gICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyRG93biA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyRG93biA+IG51ZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5laXRoZXIgd2F5IGZpdHM7IGFib3J0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b3AgLT0gbnVkZ2VkVG9vRmFyRG93bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBqdXN0IHJlYWQgb2ZmIHRoZSBiaXRzXG4gICAgICAgICAgICBjb25zdCBiaXRzID0gbmV3IEJpdE1hdHJpeChtYXRyaXhXaWR0aCwgbWF0cml4SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgbWF0cml4SGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpT2Zmc2V0ID0gdG9wICsgLyooaW50KSAqLyBNYXRoLmZsb29yKHkgKiBtb2R1bGVTaXplKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1hdHJpeFdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChsZWZ0ICsgLyooaW50KSAqLyBNYXRoLmZsb29yKHggKiBtb2R1bGVTaXplKSwgaU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG1vZHVsZVNpemUobGVmdFRvcEJsYWNrLCBpbWFnZSkge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBsZXQgeCA9IGxlZnRUb3BCbGFja1swXTtcbiAgICAgICAgICAgIGxldCB5ID0gbGVmdFRvcEJsYWNrWzFdO1xuICAgICAgICAgICAgbGV0IGluQmxhY2sgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb25zID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh4IDwgd2lkdGggJiYgeSA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChpbkJsYWNrICE9PSBpbWFnZS5nZXQoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrdHJhbnNpdGlvbnMgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluQmxhY2sgPSAhaW5CbGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgICAgIHkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID09PSB3aWR0aCB8fCB5ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoeCAtIGxlZnRUb3BCbGFja1swXSkgLyA3LjA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUVJDb2RlUmVhZGVyLk5PX1BPSU5UUyA9IG5ldyBBcnJheSgpO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBTSVRBIExhYiAoa2V2aW4ub3N1bGxpdmFuQHNpdGEuYWVybylcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIFBERjQxN0NvbW1vbiB7XG4gICAgICAgIFBERjQxN0NvbW1vbigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG1vZHVsZUJpdENvdW50IHZhbHVlcyB0byBzdW1cbiAgICAgICAgICogQHJldHVybiBzdW0gb2YgdmFsdWVzXG4gICAgICAgICAqIEBkZXByZWNhdGVkIGNhbGwge0BsaW5rIE1hdGhVdGlscyNzdW0oaW50W10pfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQERlcHJlY2F0ZWRcbiAgICAgICAgc3RhdGljIGdldEJpdENvdW50U3VtKG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLnN1bShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvSW50QXJyYXkobGlzdCkge1xuICAgICAgICAgICAgaWYgKGxpc3QgPT0gbnVsbCB8fCAhbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUERGNDE3Q29tbW9uLkVNUFRZX0lOVF9BUlJBWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KGxpc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW50ZWdlciBvZiBsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBpbnRlZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHN5bWJvbCBlbmNvZGVkIHN5bWJvbCB0byB0cmFuc2xhdGUgdG8gYSBjb2Rld29yZFxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjb2Rld29yZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzeW1ib2wuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0Q29kZXdvcmQoc3ltYm9sIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheXMuYmluYXJ5U2VhcmNoKFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEUsIHN5bWJvbCAmIDB4M0ZGRkYpO1xuICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChQREY0MTdDb21tb24uQ09ERVdPUkRfVEFCTEVbaV0gLSAxKSAlIFBERjQxN0NvbW1vbi5OVU1CRVJfT0ZfQ09ERVdPUkRTO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBERjQxN0NvbW1vbi5OVU1CRVJfT0ZfQ09ERVdPUkRTID0gOTI5O1xuICAgIC8vIE1heGltdW0gQ29kZXdvcmRzIChEYXRhICsgRXJyb3IpLlxuICAgIFBERjQxN0NvbW1vbi5NQVhfQ09ERVdPUkRTX0lOX0JBUkNPREUgPSBQREY0MTdDb21tb24uTlVNQkVSX09GX0NPREVXT1JEUyAtIDE7XG4gICAgUERGNDE3Q29tbW9uLk1JTl9ST1dTX0lOX0JBUkNPREUgPSAzO1xuICAgIFBERjQxN0NvbW1vbi5NQVhfUk9XU19JTl9CQVJDT0RFID0gOTA7XG4gICAgLy8gT25lIGxlZnQgcm93IGluZGljYXRpb24gY29sdW1uICsgbWF4IDMwIGRhdGEgY29sdW1ucyArIG9uZSByaWdodCByb3cgaW5kaWNhdG9yIGNvbHVtblxuICAgIC8vIHB1YmxpYyBzdGF0aWMgLypmaW5hbCovIE1BWF9DT0RFV09SRFNfSU5fUk9XOiAvKmludCovIG51bWJlciA9IDMyO1xuICAgIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEID0gMTc7XG4gICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOID0gMTg7XG4gICAgUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFID0gODtcbiAgICBQREY0MTdDb21tb24uRU1QVFlfSU5UX0FSUkFZID0gbmV3IEludDMyQXJyYXkoW10pO1xuICAgIC8qKlxuICAgICAqIFRoZSBzb3J0ZWQgdGFibGUgb2YgYWxsIHBvc3NpYmxlIHN5bWJvbHMuIEV4dHJhY3RlZCBmcm9tIHRoZSBQREY0MTdcbiAgICAgKiBzcGVjaWZpY2F0aW9uLiBUaGUgaW5kZXggb2YgYSBzeW1ib2wgaW4gdGhpcyB0YWJsZSBjb3JyZXNwb25kcyB0byB0aGVcbiAgICAgKiBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCB0YWJsZS5cbiAgICAgKi9cbiAgICBQREY0MTdDb21tb24uU1lNQk9MX1RBQkxFID0gSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgMHgxMDI1ZSwgMHgxMDI3YSwgMHgxMDI5ZSwgMHgxMDJiYywgMHgxMDJmMiwgMHgxMDJmNCwgMHgxMDMyZSwgMHgxMDM0ZSwgMHgxMDM1YywgMHgxMDM5NiwgMHgxMDNhNiwgMHgxMDNhYyxcbiAgICAgICAgMHgxMDQyMiwgMHgxMDQyOCwgMHgxMDQzNiwgMHgxMDQ0MiwgMHgxMDQ0NCwgMHgxMDQ0OCwgMHgxMDQ1MCwgMHgxMDQ1ZSwgMHgxMDQ2NiwgMHgxMDQ2YywgMHgxMDQ3YSwgMHgxMDQ4MixcbiAgICAgICAgMHgxMDQ5ZSwgMHgxMDRhMCwgMHgxMDRiYywgMHgxMDRjNiwgMHgxMDRkOCwgMHgxMDRlZSwgMHgxMDRmMiwgMHgxMDRmNCwgMHgxMDUwNCwgMHgxMDUwOCwgMHgxMDUxMCwgMHgxMDUxZSxcbiAgICAgICAgMHgxMDUyMCwgMHgxMDUzYywgMHgxMDU0MCwgMHgxMDU3OCwgMHgxMDU4NiwgMHgxMDU4YywgMHgxMDU5OCwgMHgxMDViMCwgMHgxMDViZSwgMHgxMDVjZSwgMHgxMDVkYywgMHgxMDVlMixcbiAgICAgICAgMHgxMDVlNCwgMHgxMDVlOCwgMHgxMDVmNiwgMHgxMDYyZSwgMHgxMDY0ZSwgMHgxMDY1YywgMHgxMDY4ZSwgMHgxMDY5YywgMHgxMDZiOCwgMHgxMDZkZSwgMHgxMDZmYSwgMHgxMDcxNixcbiAgICAgICAgMHgxMDcyNiwgMHgxMDcyYywgMHgxMDc0NiwgMHgxMDc0YywgMHgxMDc1OCwgMHgxMDc2ZSwgMHgxMDc5MiwgMHgxMDc5NCwgMHgxMDdhMiwgMHgxMDdhNCwgMHgxMDdhOCwgMHgxMDdiNixcbiAgICAgICAgMHgxMDgyMiwgMHgxMDgyOCwgMHgxMDg0MiwgMHgxMDg0OCwgMHgxMDg1MCwgMHgxMDg1ZSwgMHgxMDg2NiwgMHgxMDg2YywgMHgxMDg3YSwgMHgxMDg4MiwgMHgxMDg4NCwgMHgxMDg5MCxcbiAgICAgICAgMHgxMDg5ZSwgMHgxMDhhMCwgMHgxMDhiYywgMHgxMDhjNiwgMHgxMDhjYywgMHgxMDhkOCwgMHgxMDhlZSwgMHgxMDhmMiwgMHgxMDhmNCwgMHgxMDkwMiwgMHgxMDkwOCwgMHgxMDkxZSxcbiAgICAgICAgMHgxMDkyMCwgMHgxMDkzYywgMHgxMDk0MCwgMHgxMDk3OCwgMHgxMDk4NiwgMHgxMDk5OCwgMHgxMDliMCwgMHgxMDliZSwgMHgxMDljZSwgMHgxMDlkYywgMHgxMDllMiwgMHgxMDllNCxcbiAgICAgICAgMHgxMDllOCwgMHgxMDlmNiwgMHgxMGEwOCwgMHgxMGExMCwgMHgxMGExZSwgMHgxMGEyMCwgMHgxMGEzYywgMHgxMGE0MCwgMHgxMGE3OCwgMHgxMGFmMCwgMHgxMGIwNiwgMHgxMGIwYyxcbiAgICAgICAgMHgxMGIxOCwgMHgxMGIzMCwgMHgxMGIzZSwgMHgxMGI2MCwgMHgxMGI3YywgMHgxMGI4ZSwgMHgxMGI5YywgMHgxMGJiOCwgMHgxMGJjMiwgMHgxMGJjNCwgMHgxMGJjOCwgMHgxMGJkMCxcbiAgICAgICAgMHgxMGJkZSwgMHgxMGJlNiwgMHgxMGJlYywgMHgxMGMyZSwgMHgxMGM0ZSwgMHgxMGM1YywgMHgxMGM2MiwgMHgxMGM2NCwgMHgxMGM2OCwgMHgxMGM3NiwgMHgxMGM4ZSwgMHgxMGM5YyxcbiAgICAgICAgMHgxMGNiOCwgMHgxMGNjMiwgMHgxMGNjNCwgMHgxMGNjOCwgMHgxMGNkMCwgMHgxMGNkZSwgMHgxMGNlNiwgMHgxMGNlYywgMHgxMGNmYSwgMHgxMGQwZSwgMHgxMGQxYywgMHgxMGQzOCxcbiAgICAgICAgMHgxMGQ3MCwgMHgxMGQ3ZSwgMHgxMGQ4MiwgMHgxMGQ4NCwgMHgxMGQ4OCwgMHgxMGQ5MCwgMHgxMGQ5ZSwgMHgxMGRhMCwgMHgxMGRiYywgMHgxMGRjNiwgMHgxMGRjYywgMHgxMGRkOCxcbiAgICAgICAgMHgxMGRlZSwgMHgxMGRmMiwgMHgxMGRmNCwgMHgxMGUxNiwgMHgxMGUyNiwgMHgxMGUyYywgMHgxMGU0NiwgMHgxMGU1OCwgMHgxMGU2ZSwgMHgxMGU4NiwgMHgxMGU4YywgMHgxMGU5OCxcbiAgICAgICAgMHgxMGViMCwgMHgxMGViZSwgMHgxMGVjZSwgMHgxMGVkYywgMHgxMGYwYSwgMHgxMGYxMiwgMHgxMGYxNCwgMHgxMGYyMiwgMHgxMGYyOCwgMHgxMGYzNiwgMHgxMGY0MiwgMHgxMGY0NCxcbiAgICAgICAgMHgxMGY0OCwgMHgxMGY1MCwgMHgxMGY1ZSwgMHgxMGY2NiwgMHgxMGY2YywgMHgxMGZiMiwgMHgxMGZiNCwgMHgxMTAyMiwgMHgxMTAyOCwgMHgxMTA0MiwgMHgxMTA0OCwgMHgxMTA1MCxcbiAgICAgICAgMHgxMTA1ZSwgMHgxMTA3YSwgMHgxMTA4MiwgMHgxMTA4NCwgMHgxMTA5MCwgMHgxMTA5ZSwgMHgxMTBhMCwgMHgxMTBiYywgMHgxMTBjNiwgMHgxMTBjYywgMHgxMTBkOCwgMHgxMTBlZSxcbiAgICAgICAgMHgxMTBmMiwgMHgxMTBmNCwgMHgxMTEwMiwgMHgxMTExZSwgMHgxMTEyMCwgMHgxMTEzYywgMHgxMTE0MCwgMHgxMTE3OCwgMHgxMTE4NiwgMHgxMTE5OCwgMHgxMTFiMCwgMHgxMTFiZSxcbiAgICAgICAgMHgxMTFjZSwgMHgxMTFkYywgMHgxMTFlMiwgMHgxMTFlNCwgMHgxMTFlOCwgMHgxMTFmNiwgMHgxMTIwOCwgMHgxMTIxZSwgMHgxMTIyMCwgMHgxMTI3OCwgMHgxMTJmMCwgMHgxMTMwYyxcbiAgICAgICAgMHgxMTMzMCwgMHgxMTMzZSwgMHgxMTM2MCwgMHgxMTM3YywgMHgxMTM4ZSwgMHgxMTM5YywgMHgxMTNiOCwgMHgxMTNjMiwgMHgxMTNjOCwgMHgxMTNkMCwgMHgxMTNkZSwgMHgxMTNlNixcbiAgICAgICAgMHgxMTNlYywgMHgxMTQwOCwgMHgxMTQxMCwgMHgxMTQxZSwgMHgxMTQyMCwgMHgxMTQzYywgMHgxMTQ0MCwgMHgxMTQ3OCwgMHgxMTRmMCwgMHgxMTVlMCwgMHgxMTYwYywgMHgxMTYxOCxcbiAgICAgICAgMHgxMTYzMCwgMHgxMTYzZSwgMHgxMTY2MCwgMHgxMTY3YywgMHgxMTZjMCwgMHgxMTZmOCwgMHgxMTcxYywgMHgxMTczOCwgMHgxMTc3MCwgMHgxMTc3ZSwgMHgxMTc4MiwgMHgxMTc4NCxcbiAgICAgICAgMHgxMTc4OCwgMHgxMTc5MCwgMHgxMTc5ZSwgMHgxMTdhMCwgMHgxMTdiYywgMHgxMTdjNiwgMHgxMTdjYywgMHgxMTdkOCwgMHgxMTdlZSwgMHgxMTgyZSwgMHgxMTgzNCwgMHgxMTg0ZSxcbiAgICAgICAgMHgxMTg1YywgMHgxMTg2MiwgMHgxMTg2NCwgMHgxMTg2OCwgMHgxMTg3NiwgMHgxMTg4ZSwgMHgxMTg5YywgMHgxMThiOCwgMHgxMThjMiwgMHgxMThjOCwgMHgxMThkMCwgMHgxMThkZSxcbiAgICAgICAgMHgxMThlNiwgMHgxMThlYywgMHgxMThmYSwgMHgxMTkwZSwgMHgxMTkxYywgMHgxMTkzOCwgMHgxMTk3MCwgMHgxMTk3ZSwgMHgxMTk4MiwgMHgxMTk4NCwgMHgxMTk5MCwgMHgxMTk5ZSxcbiAgICAgICAgMHgxMTlhMCwgMHgxMTliYywgMHgxMTljNiwgMHgxMTljYywgMHgxMTlkOCwgMHgxMTllZSwgMHgxMTlmMiwgMHgxMTlmNCwgMHgxMWEwZSwgMHgxMWExYywgMHgxMWEzOCwgMHgxMWE3MCxcbiAgICAgICAgMHgxMWE3ZSwgMHgxMWFlMCwgMHgxMWFmYywgMHgxMWIwOCwgMHgxMWIxMCwgMHgxMWIxZSwgMHgxMWIyMCwgMHgxMWIzYywgMHgxMWI0MCwgMHgxMWI3OCwgMHgxMWI4YywgMHgxMWI5OCxcbiAgICAgICAgMHgxMWJiMCwgMHgxMWJiZSwgMHgxMWJjZSwgMHgxMWJkYywgMHgxMWJlMiwgMHgxMWJlNCwgMHgxMWJlOCwgMHgxMWJmNiwgMHgxMWMxNiwgMHgxMWMyNiwgMHgxMWMyYywgMHgxMWM0NixcbiAgICAgICAgMHgxMWM0YywgMHgxMWM1OCwgMHgxMWM2ZSwgMHgxMWM4NiwgMHgxMWM5OCwgMHgxMWNiMCwgMHgxMWNiZSwgMHgxMWNjZSwgMHgxMWNkYywgMHgxMWNlMiwgMHgxMWNlNCwgMHgxMWNlOCxcbiAgICAgICAgMHgxMWNmNiwgMHgxMWQwNiwgMHgxMWQwYywgMHgxMWQxOCwgMHgxMWQzMCwgMHgxMWQzZSwgMHgxMWQ2MCwgMHgxMWQ3YywgMHgxMWQ4ZSwgMHgxMWQ5YywgMHgxMWRiOCwgMHgxMWRjNCxcbiAgICAgICAgMHgxMWRjOCwgMHgxMWRkMCwgMHgxMWRkZSwgMHgxMWRlNiwgMHgxMWRlYywgMHgxMWRmYSwgMHgxMWUwYSwgMHgxMWUxMiwgMHgxMWUxNCwgMHgxMWUyMiwgMHgxMWUyNCwgMHgxMWUyOCxcbiAgICAgICAgMHgxMWUzNiwgMHgxMWU0MiwgMHgxMWU0NCwgMHgxMWU1MCwgMHgxMWU1ZSwgMHgxMWU2NiwgMHgxMWU2YywgMHgxMWU4MiwgMHgxMWU4NCwgMHgxMWU4OCwgMHgxMWU5MCwgMHgxMWU5ZSxcbiAgICAgICAgMHgxMWVhMCwgMHgxMWViYywgMHgxMWVjNiwgMHgxMWVjYywgMHgxMWVkOCwgMHgxMWVlZSwgMHgxMWYxYSwgMHgxMWYyZSwgMHgxMWYzMiwgMHgxMWYzNCwgMHgxMWY0ZSwgMHgxMWY1YyxcbiAgICAgICAgMHgxMWY2MiwgMHgxMWY2NCwgMHgxMWY2OCwgMHgxMWY3NiwgMHgxMjA0OCwgMHgxMjA1ZSwgMHgxMjA4MiwgMHgxMjA4NCwgMHgxMjA5MCwgMHgxMjA5ZSwgMHgxMjBhMCwgMHgxMjBiYyxcbiAgICAgICAgMHgxMjBkOCwgMHgxMjBmMiwgMHgxMjBmNCwgMHgxMjEwOCwgMHgxMjExZSwgMHgxMjEyMCwgMHgxMjEzYywgMHgxMjE0MCwgMHgxMjE3OCwgMHgxMjE4NiwgMHgxMjE5OCwgMHgxMjFiMCxcbiAgICAgICAgMHgxMjFiZSwgMHgxMjFlMiwgMHgxMjFlNCwgMHgxMjFlOCwgMHgxMjFmNiwgMHgxMjIwNCwgMHgxMjIxMCwgMHgxMjIxZSwgMHgxMjIyMCwgMHgxMjI3OCwgMHgxMjJmMCwgMHgxMjMwNixcbiAgICAgICAgMHgxMjMwYywgMHgxMjMzMCwgMHgxMjMzZSwgMHgxMjM2MCwgMHgxMjM3YywgMHgxMjM4ZSwgMHgxMjM5YywgMHgxMjNiOCwgMHgxMjNjMiwgMHgxMjNjOCwgMHgxMjNkMCwgMHgxMjNlNixcbiAgICAgICAgMHgxMjNlYywgMHgxMjQxZSwgMHgxMjQyMCwgMHgxMjQzYywgMHgxMjRmMCwgMHgxMjVlMCwgMHgxMjYxOCwgMHgxMjYzZSwgMHgxMjY2MCwgMHgxMjY3YywgMHgxMjZjMCwgMHgxMjZmOCxcbiAgICAgICAgMHgxMjczOCwgMHgxMjc3MCwgMHgxMjc3ZSwgMHgxMjc4MiwgMHgxMjc4NCwgMHgxMjc5MCwgMHgxMjc5ZSwgMHgxMjdhMCwgMHgxMjdiYywgMHgxMjdjNiwgMHgxMjdjYywgMHgxMjdkOCxcbiAgICAgICAgMHgxMjdlZSwgMHgxMjgyMCwgMHgxMjgzYywgMHgxMjg0MCwgMHgxMjg3OCwgMHgxMjhmMCwgMHgxMjllMCwgMHgxMmJjMCwgMHgxMmMxOCwgMHgxMmMzMCwgMHgxMmMzZSwgMHgxMmM2MCxcbiAgICAgICAgMHgxMmM3YywgMHgxMmNjMCwgMHgxMmNmOCwgMHgxMmRmMCwgMHgxMmUxYywgMHgxMmUzOCwgMHgxMmU3MCwgMHgxMmU3ZSwgMHgxMmVlMCwgMHgxMmVmYywgMHgxMmYwNCwgMHgxMmYwOCxcbiAgICAgICAgMHgxMmYxMCwgMHgxMmYyMCwgMHgxMmYzYywgMHgxMmY0MCwgMHgxMmY3OCwgMHgxMmY4NiwgMHgxMmY4YywgMHgxMmY5OCwgMHgxMmZiMCwgMHgxMmZiZSwgMHgxMmZjZSwgMHgxMmZkYyxcbiAgICAgICAgMHgxMzAyZSwgMHgxMzA0ZSwgMHgxMzA1YywgMHgxMzA2MiwgMHgxMzA2OCwgMHgxMzA4ZSwgMHgxMzA5YywgMHgxMzBiOCwgMHgxMzBjMiwgMHgxMzBjOCwgMHgxMzBkMCwgMHgxMzBkZSxcbiAgICAgICAgMHgxMzBlYywgMHgxMzBmYSwgMHgxMzEwZSwgMHgxMzEzOCwgMHgxMzE3MCwgMHgxMzE3ZSwgMHgxMzE4MiwgMHgxMzE4NCwgMHgxMzE5MCwgMHgxMzE5ZSwgMHgxMzFhMCwgMHgxMzFiYyxcbiAgICAgICAgMHgxMzFjNiwgMHgxMzFjYywgMHgxMzFkOCwgMHgxMzFmMiwgMHgxMzFmNCwgMHgxMzIwZSwgMHgxMzIxYywgMHgxMzI3MCwgMHgxMzI3ZSwgMHgxMzJlMCwgMHgxMzJmYywgMHgxMzMwOCxcbiAgICAgICAgMHgxMzMxZSwgMHgxMzMyMCwgMHgxMzMzYywgMHgxMzM0MCwgMHgxMzM3OCwgMHgxMzM4NiwgMHgxMzM5OCwgMHgxMzNiMCwgMHgxMzNiZSwgMHgxMzNjZSwgMHgxMzNkYywgMHgxMzNlMixcbiAgICAgICAgMHgxMzNlNCwgMHgxMzNlOCwgMHgxMzNmNiwgMHgxMzQwZSwgMHgxMzQxYywgMHgxMzQzOCwgMHgxMzQ3MCwgMHgxMzQ3ZSwgMHgxMzRlMCwgMHgxMzRmYywgMHgxMzVjMCwgMHgxMzVmOCxcbiAgICAgICAgMHgxMzYwOCwgMHgxMzYxMCwgMHgxMzYxZSwgMHgxMzYyMCwgMHgxMzYzYywgMHgxMzY0MCwgMHgxMzY3OCwgMHgxMzZmMCwgMHgxMzcwYywgMHgxMzcxOCwgMHgxMzczMCwgMHgxMzczZSxcbiAgICAgICAgMHgxMzc2MCwgMHgxMzc3YywgMHgxMzc5YywgMHgxMzdiOCwgMHgxMzdjMiwgMHgxMzdjNCwgMHgxMzdjOCwgMHgxMzdkMCwgMHgxMzdkZSwgMHgxMzdlNiwgMHgxMzdlYywgMHgxMzgxNixcbiAgICAgICAgMHgxMzgyNiwgMHgxMzgyYywgMHgxMzg0NiwgMHgxMzg0YywgMHgxMzg1OCwgMHgxMzg2ZSwgMHgxMzg3NCwgMHgxMzg4NiwgMHgxMzg5OCwgMHgxMzhiMCwgMHgxMzhiZSwgMHgxMzhjZSxcbiAgICAgICAgMHgxMzhkYywgMHgxMzhlMiwgMHgxMzhlNCwgMHgxMzhlOCwgMHgxMzkwNiwgMHgxMzkwYywgMHgxMzkzMCwgMHgxMzkzZSwgMHgxMzk2MCwgMHgxMzk3YywgMHgxMzk4ZSwgMHgxMzk5YyxcbiAgICAgICAgMHgxMzliOCwgMHgxMzljOCwgMHgxMzlkMCwgMHgxMzlkZSwgMHgxMzllNiwgMHgxMzllYywgMHgxMzlmYSwgMHgxM2EwNiwgMHgxM2EwYywgMHgxM2ExOCwgMHgxM2EzMCwgMHgxM2EzZSxcbiAgICAgICAgMHgxM2E2MCwgMHgxM2E3YywgMHgxM2FjMCwgMHgxM2FmOCwgMHgxM2IwZSwgMHgxM2IxYywgMHgxM2IzOCwgMHgxM2I3MCwgMHgxM2I3ZSwgMHgxM2I4OCwgMHgxM2I5MCwgMHgxM2I5ZSxcbiAgICAgICAgMHgxM2JhMCwgMHgxM2JiYywgMHgxM2JjYywgMHgxM2JkOCwgMHgxM2JlZSwgMHgxM2JmMiwgMHgxM2JmNCwgMHgxM2MxMiwgMHgxM2MxNCwgMHgxM2MyMiwgMHgxM2MyNCwgMHgxM2MyOCxcbiAgICAgICAgMHgxM2MzNiwgMHgxM2M0MiwgMHgxM2M0OCwgMHgxM2M1MCwgMHgxM2M1ZSwgMHgxM2M2NiwgMHgxM2M2YywgMHgxM2M4MiwgMHgxM2M4NCwgMHgxM2M5MCwgMHgxM2M5ZSwgMHgxM2NhMCxcbiAgICAgICAgMHgxM2NiYywgMHgxM2NjNiwgMHgxM2NjYywgMHgxM2NkOCwgMHgxM2NlZSwgMHgxM2QwMiwgMHgxM2QwNCwgMHgxM2QwOCwgMHgxM2QxMCwgMHgxM2QxZSwgMHgxM2QyMCwgMHgxM2QzYyxcbiAgICAgICAgMHgxM2Q0MCwgMHgxM2Q3OCwgMHgxM2Q4NiwgMHgxM2Q4YywgMHgxM2Q5OCwgMHgxM2RiMCwgMHgxM2RiZSwgMHgxM2RjZSwgMHgxM2RkYywgMHgxM2RlNCwgMHgxM2RlOCwgMHgxM2RmNixcbiAgICAgICAgMHgxM2UxYSwgMHgxM2UyZSwgMHgxM2UzMiwgMHgxM2UzNCwgMHgxM2U0ZSwgMHgxM2U1YywgMHgxM2U2MiwgMHgxM2U2NCwgMHgxM2U2OCwgMHgxM2U3NiwgMHgxM2U4ZSwgMHgxM2U5YyxcbiAgICAgICAgMHgxM2ViOCwgMHgxM2VjMiwgMHgxM2VjNCwgMHgxM2VjOCwgMHgxM2VkMCwgMHgxM2VkZSwgMHgxM2VlNiwgMHgxM2VlYywgMHgxM2YyNiwgMHgxM2YyYywgMHgxM2YzYSwgMHgxM2Y0NixcbiAgICAgICAgMHgxM2Y0YywgMHgxM2Y1OCwgMHgxM2Y2ZSwgMHgxM2Y3MiwgMHgxM2Y3NCwgMHgxNDA4MiwgMHgxNDA5ZSwgMHgxNDBhMCwgMHgxNDBiYywgMHgxNDEwNCwgMHgxNDEwOCwgMHgxNDExMCxcbiAgICAgICAgMHgxNDExZSwgMHgxNDEyMCwgMHgxNDEzYywgMHgxNDE0MCwgMHgxNDE3OCwgMHgxNDE4YywgMHgxNDE5OCwgMHgxNDFiMCwgMHgxNDFiZSwgMHgxNDFlMiwgMHgxNDFlNCwgMHgxNDFlOCxcbiAgICAgICAgMHgxNDIwOCwgMHgxNDIxMCwgMHgxNDIxZSwgMHgxNDIyMCwgMHgxNDIzYywgMHgxNDI0MCwgMHgxNDI3OCwgMHgxNDJmMCwgMHgxNDMwNiwgMHgxNDMwYywgMHgxNDMxOCwgMHgxNDMzMCxcbiAgICAgICAgMHgxNDMzZSwgMHgxNDM2MCwgMHgxNDM3YywgMHgxNDM4ZSwgMHgxNDNjMiwgMHgxNDNjNCwgMHgxNDNjOCwgMHgxNDNkMCwgMHgxNDNlNiwgMHgxNDNlYywgMHgxNDQwOCwgMHgxNDQxMCxcbiAgICAgICAgMHgxNDQxZSwgMHgxNDQyMCwgMHgxNDQzYywgMHgxNDQ0MCwgMHgxNDQ3OCwgMHgxNDRmMCwgMHgxNDVlMCwgMHgxNDYwYywgMHgxNDYxOCwgMHgxNDYzMCwgMHgxNDYzZSwgMHgxNDY2MCxcbiAgICAgICAgMHgxNDY3YywgMHgxNDZjMCwgMHgxNDZmOCwgMHgxNDcxYywgMHgxNDczOCwgMHgxNDc3MCwgMHgxNDc3ZSwgMHgxNDc4MiwgMHgxNDc4NCwgMHgxNDc4OCwgMHgxNDc5MCwgMHgxNDdhMCxcbiAgICAgICAgMHgxNDdiYywgMHgxNDdjNiwgMHgxNDdjYywgMHgxNDdkOCwgMHgxNDdlZSwgMHgxNDgxMCwgMHgxNDgyMCwgMHgxNDgzYywgMHgxNDg0MCwgMHgxNDg3OCwgMHgxNDhmMCwgMHgxNDllMCxcbiAgICAgICAgMHgxNGJjMCwgMHgxNGMzMCwgMHgxNGMzZSwgMHgxNGM2MCwgMHgxNGM3YywgMHgxNGNjMCwgMHgxNGNmOCwgMHgxNGRmMCwgMHgxNGUzOCwgMHgxNGU3MCwgMHgxNGU3ZSwgMHgxNGVlMCxcbiAgICAgICAgMHgxNGVmYywgMHgxNGYwNCwgMHgxNGYwOCwgMHgxNGYxMCwgMHgxNGYxZSwgMHgxNGYyMCwgMHgxNGYzYywgMHgxNGY0MCwgMHgxNGY3OCwgMHgxNGY4NiwgMHgxNGY4YywgMHgxNGY5OCxcbiAgICAgICAgMHgxNGZiMCwgMHgxNGZjZSwgMHgxNGZkYywgMHgxNTAyMCwgMHgxNTA0MCwgMHgxNTA3OCwgMHgxNTBmMCwgMHgxNTFlMCwgMHgxNTNjMCwgMHgxNTg2MCwgMHgxNTg3YywgMHgxNThjMCxcbiAgICAgICAgMHgxNThmOCwgMHgxNTlmMCwgMHgxNWJlMCwgMHgxNWM3MCwgMHgxNWM3ZSwgMHgxNWNlMCwgMHgxNWNmYywgMHgxNWRjMCwgMHgxNWRmOCwgMHgxNWUwOCwgMHgxNWUxMCwgMHgxNWUyMCxcbiAgICAgICAgMHgxNWU0MCwgMHgxNWU3OCwgMHgxNWVmMCwgMHgxNWYwYywgMHgxNWYxOCwgMHgxNWYzMCwgMHgxNWY2MCwgMHgxNWY3YywgMHgxNWY4ZSwgMHgxNWY5YywgMHgxNWZiOCwgMHgxNjA0ZSxcbiAgICAgICAgMHgxNjA1YywgMHgxNjA4ZSwgMHgxNjA5YywgMHgxNjBiOCwgMHgxNjBjMiwgMHgxNjBjNCwgMHgxNjBjOCwgMHgxNjBkZSwgMHgxNjEwZSwgMHgxNjExYywgMHgxNjEzOCwgMHgxNjE3MCxcbiAgICAgICAgMHgxNjE3ZSwgMHgxNjE4NCwgMHgxNjE4OCwgMHgxNjE5MCwgMHgxNjE5ZSwgMHgxNjFhMCwgMHgxNjFiYywgMHgxNjFjNiwgMHgxNjFjYywgMHgxNjFkOCwgMHgxNjFmMiwgMHgxNjFmNCxcbiAgICAgICAgMHgxNjIwZSwgMHgxNjIxYywgMHgxNjIzOCwgMHgxNjI3MCwgMHgxNjI3ZSwgMHgxNjJlMCwgMHgxNjJmYywgMHgxNjMwNCwgMHgxNjMwOCwgMHgxNjMxMCwgMHgxNjMxZSwgMHgxNjMyMCxcbiAgICAgICAgMHgxNjMzYywgMHgxNjM0MCwgMHgxNjM3OCwgMHgxNjM4NiwgMHgxNjM4YywgMHgxNjM5OCwgMHgxNjNiMCwgMHgxNjNiZSwgMHgxNjNjZSwgMHgxNjNkYywgMHgxNjNlMiwgMHgxNjNlNCxcbiAgICAgICAgMHgxNjNlOCwgMHgxNjNmNiwgMHgxNjQwZSwgMHgxNjQxYywgMHgxNjQzOCwgMHgxNjQ3MCwgMHgxNjQ3ZSwgMHgxNjRlMCwgMHgxNjRmYywgMHgxNjVjMCwgMHgxNjVmOCwgMHgxNjYxMCxcbiAgICAgICAgMHgxNjYxZSwgMHgxNjYyMCwgMHgxNjYzYywgMHgxNjY0MCwgMHgxNjY3OCwgMHgxNjZmMCwgMHgxNjcxOCwgMHgxNjczMCwgMHgxNjczZSwgMHgxNjc2MCwgMHgxNjc3YywgMHgxNjc4ZSxcbiAgICAgICAgMHgxNjc5YywgMHgxNjdiOCwgMHgxNjdjMiwgMHgxNjdjNCwgMHgxNjdjOCwgMHgxNjdkMCwgMHgxNjdkZSwgMHgxNjdlNiwgMHgxNjdlYywgMHgxNjgxYywgMHgxNjgzOCwgMHgxNjg3MCxcbiAgICAgICAgMHgxNjhlMCwgMHgxNjhmYywgMHgxNjljMCwgMHgxNjlmOCwgMHgxNmJmMCwgMHgxNmMxMCwgMHgxNmMxZSwgMHgxNmMyMCwgMHgxNmMzYywgMHgxNmM0MCwgMHgxNmM3OCwgMHgxNmNmMCxcbiAgICAgICAgMHgxNmRlMCwgMHgxNmUxOCwgMHgxNmUzMCwgMHgxNmUzZSwgMHgxNmU2MCwgMHgxNmU3YywgMHgxNmVjMCwgMHgxNmVmOCwgMHgxNmYxYywgMHgxNmYzOCwgMHgxNmY3MCwgMHgxNmY3ZSxcbiAgICAgICAgMHgxNmY4NCwgMHgxNmY4OCwgMHgxNmY5MCwgMHgxNmY5ZSwgMHgxNmZhMCwgMHgxNmZiYywgMHgxNmZjNiwgMHgxNmZjYywgMHgxNmZkOCwgMHgxNzAyNiwgMHgxNzAyYywgMHgxNzA0NixcbiAgICAgICAgMHgxNzA0YywgMHgxNzA1OCwgMHgxNzA2ZSwgMHgxNzA4NiwgMHgxNzA4YywgMHgxNzA5OCwgMHgxNzBiMCwgMHgxNzBiZSwgMHgxNzBjZSwgMHgxNzBkYywgMHgxNzBlOCwgMHgxNzEwNixcbiAgICAgICAgMHgxNzEwYywgMHgxNzExOCwgMHgxNzEzMCwgMHgxNzEzZSwgMHgxNzE2MCwgMHgxNzE3YywgMHgxNzE4ZSwgMHgxNzE5YywgMHgxNzFiOCwgMHgxNzFjMiwgMHgxNzFjNCwgMHgxNzFjOCxcbiAgICAgICAgMHgxNzFkMCwgMHgxNzFkZSwgMHgxNzFlNiwgMHgxNzFlYywgMHgxNzFmYSwgMHgxNzIwNiwgMHgxNzIwYywgMHgxNzIxOCwgMHgxNzIzMCwgMHgxNzIzZSwgMHgxNzI2MCwgMHgxNzI3YyxcbiAgICAgICAgMHgxNzJjMCwgMHgxNzJmOCwgMHgxNzMwZSwgMHgxNzMxYywgMHgxNzMzOCwgMHgxNzM3MCwgMHgxNzM3ZSwgMHgxNzM4OCwgMHgxNzM5MCwgMHgxNzM5ZSwgMHgxNzNhMCwgMHgxNzNiYyxcbiAgICAgICAgMHgxNzNjYywgMHgxNzNkOCwgMHgxNzNlZSwgMHgxNzNmMiwgMHgxNzNmNCwgMHgxNzQwYywgMHgxNzQxOCwgMHgxNzQzMCwgMHgxNzQzZSwgMHgxNzQ2MCwgMHgxNzQ3YywgMHgxNzRjMCxcbiAgICAgICAgMHgxNzRmOCwgMHgxNzVmMCwgMHgxNzYwZSwgMHgxNzYxYywgMHgxNzYzOCwgMHgxNzY3MCwgMHgxNzY3ZSwgMHgxNzZlMCwgMHgxNzZmYywgMHgxNzcwOCwgMHgxNzcxMCwgMHgxNzcxZSxcbiAgICAgICAgMHgxNzcyMCwgMHgxNzczYywgMHgxNzc0MCwgMHgxNzc3OCwgMHgxNzc5OCwgMHgxNzdiMCwgMHgxNzdiZSwgMHgxNzdkYywgMHgxNzdlMiwgMHgxNzdlNCwgMHgxNzdlOCwgMHgxNzgyMixcbiAgICAgICAgMHgxNzgyNCwgMHgxNzgyOCwgMHgxNzgzNiwgMHgxNzg0MiwgMHgxNzg0NCwgMHgxNzg0OCwgMHgxNzg1MCwgMHgxNzg1ZSwgMHgxNzg2NiwgMHgxNzg2YywgMHgxNzg4MiwgMHgxNzg4NCxcbiAgICAgICAgMHgxNzg4OCwgMHgxNzg5MCwgMHgxNzg5ZSwgMHgxNzhhMCwgMHgxNzhiYywgMHgxNzhjNiwgMHgxNzhjYywgMHgxNzhkOCwgMHgxNzhlZSwgMHgxNzhmMiwgMHgxNzhmNCwgMHgxNzkwMixcbiAgICAgICAgMHgxNzkwNCwgMHgxNzkwOCwgMHgxNzkxMCwgMHgxNzkxZSwgMHgxNzkyMCwgMHgxNzkzYywgMHgxNzk0MCwgMHgxNzk3OCwgMHgxNzk4NiwgMHgxNzk4YywgMHgxNzk5OCwgMHgxNzliMCxcbiAgICAgICAgMHgxNzliZSwgMHgxNzljZSwgMHgxNzlkYywgMHgxNzllMiwgMHgxNzllNCwgMHgxNzllOCwgMHgxNzlmNiwgMHgxN2EwNCwgMHgxN2EwOCwgMHgxN2ExMCwgMHgxN2ExZSwgMHgxN2EyMCxcbiAgICAgICAgMHgxN2EzYywgMHgxN2E0MCwgMHgxN2E3OCwgMHgxN2FmMCwgMHgxN2IwNiwgMHgxN2IwYywgMHgxN2IxOCwgMHgxN2IzMCwgMHgxN2IzZSwgMHgxN2I2MCwgMHgxN2I3YywgMHgxN2I4ZSxcbiAgICAgICAgMHgxN2I5YywgMHgxN2JiOCwgMHgxN2JjNCwgMHgxN2JjOCwgMHgxN2JkMCwgMHgxN2JkZSwgMHgxN2JlNiwgMHgxN2JlYywgMHgxN2MyZSwgMHgxN2MzMiwgMHgxN2MzNCwgMHgxN2M0ZSxcbiAgICAgICAgMHgxN2M1YywgMHgxN2M2MiwgMHgxN2M2NCwgMHgxN2M2OCwgMHgxN2M3NiwgMHgxN2M4ZSwgMHgxN2M5YywgMHgxN2NiOCwgMHgxN2NjMiwgMHgxN2NjNCwgMHgxN2NjOCwgMHgxN2NkMCxcbiAgICAgICAgMHgxN2NkZSwgMHgxN2NlNiwgMHgxN2NlYywgMHgxN2QwZSwgMHgxN2QxYywgMHgxN2QzOCwgMHgxN2Q3MCwgMHgxN2Q4MiwgMHgxN2Q4NCwgMHgxN2Q4OCwgMHgxN2Q5MCwgMHgxN2Q5ZSxcbiAgICAgICAgMHgxN2RhMCwgMHgxN2RiYywgMHgxN2RjNiwgMHgxN2RjYywgMHgxN2RkOCwgMHgxN2RlZSwgMHgxN2UyNiwgMHgxN2UyYywgMHgxN2UzYSwgMHgxN2U0NiwgMHgxN2U0YywgMHgxN2U1OCxcbiAgICAgICAgMHgxN2U2ZSwgMHgxN2U3MiwgMHgxN2U3NCwgMHgxN2U4NiwgMHgxN2U4YywgMHgxN2U5OCwgMHgxN2ViMCwgMHgxN2VjZSwgMHgxN2VkYywgMHgxN2VlMiwgMHgxN2VlNCwgMHgxN2VlOCxcbiAgICAgICAgMHgxN2VmNiwgMHgxODEzYSwgMHgxODE3MiwgMHgxODE3NCwgMHgxODIxNiwgMHgxODIyNiwgMHgxODIzYSwgMHgxODI0YywgMHgxODI1OCwgMHgxODI2ZSwgMHgxODI3MiwgMHgxODI3NCxcbiAgICAgICAgMHgxODI5OCwgMHgxODJiZSwgMHgxODJlMiwgMHgxODJlNCwgMHgxODJlOCwgMHgxODJmNiwgMHgxODM1ZSwgMHgxODM3YSwgMHgxODNhZSwgMHgxODNkNiwgMHgxODQxNiwgMHgxODQyNixcbiAgICAgICAgMHgxODQyYywgMHgxODQzYSwgMHgxODQ0NiwgMHgxODQ1OCwgMHgxODQ2ZSwgMHgxODQ3MiwgMHgxODQ3NCwgMHgxODQ4NiwgMHgxODRiMCwgMHgxODRiZSwgMHgxODRjZSwgMHgxODRkYyxcbiAgICAgICAgMHgxODRlMiwgMHgxODRlNCwgMHgxODRlOCwgMHgxODRmNiwgMHgxODUwNiwgMHgxODUwYywgMHgxODUxOCwgMHgxODUzMCwgMHgxODUzZSwgMHgxODU2MCwgMHgxODU3YywgMHgxODU4ZSxcbiAgICAgICAgMHgxODU5YywgMHgxODViOCwgMHgxODVjMiwgMHgxODVjNCwgMHgxODVjOCwgMHgxODVkMCwgMHgxODVkZSwgMHgxODVlNiwgMHgxODVlYywgMHgxODVmYSwgMHgxODYxMiwgMHgxODYxNCxcbiAgICAgICAgMHgxODYyMiwgMHgxODYyOCwgMHgxODYzNiwgMHgxODY0MiwgMHgxODY1MCwgMHgxODY1ZSwgMHgxODY3YSwgMHgxODY4MiwgMHgxODY4NCwgMHgxODY4OCwgMHgxODY5MCwgMHgxODY5ZSxcbiAgICAgICAgMHgxODZhMCwgMHgxODZiYywgMHgxODZjNiwgMHgxODZjYywgMHgxODZkOCwgMHgxODZlZSwgMHgxODZmMiwgMHgxODZmNCwgMHgxODcyZSwgMHgxODc0ZSwgMHgxODc1YywgMHgxODc5NixcbiAgICAgICAgMHgxODdhNiwgMHgxODdhYywgMHgxODdkMiwgMHgxODdkNCwgMHgxODgyNiwgMHgxODgyYywgMHgxODgzYSwgMHgxODg0NiwgMHgxODg0YywgMHgxODg1OCwgMHgxODg2ZSwgMHgxODg3MixcbiAgICAgICAgMHgxODg3NCwgMHgxODg4NiwgMHgxODg5OCwgMHgxODhiMCwgMHgxODhiZSwgMHgxODhjZSwgMHgxODhkYywgMHgxODhlMiwgMHgxODhlNCwgMHgxODhlOCwgMHgxODhmNiwgMHgxODkwYyxcbiAgICAgICAgMHgxODkzMCwgMHgxODkzZSwgMHgxODk2MCwgMHgxODk3YywgMHgxODk4ZSwgMHgxODliOCwgMHgxODljMiwgMHgxODljOCwgMHgxODlkMCwgMHgxODlkZSwgMHgxODllNiwgMHgxODllYyxcbiAgICAgICAgMHgxODlmYSwgMHgxOGExOCwgMHgxOGEzMCwgMHgxOGEzZSwgMHgxOGE2MCwgMHgxOGE3YywgMHgxOGFjMCwgMHgxOGFmOCwgMHgxOGIxYywgMHgxOGIzOCwgMHgxOGI3MCwgMHgxOGI3ZSxcbiAgICAgICAgMHgxOGI4MiwgMHgxOGI4NCwgMHgxOGI4OCwgMHgxOGI5MCwgMHgxOGI5ZSwgMHgxOGJhMCwgMHgxOGJiYywgMHgxOGJjNiwgMHgxOGJjYywgMHgxOGJkOCwgMHgxOGJlZSwgMHgxOGJmMixcbiAgICAgICAgMHgxOGJmNCwgMHgxOGMyMiwgMHgxOGMyNCwgMHgxOGMyOCwgMHgxOGMzNiwgMHgxOGM0MiwgMHgxOGM0OCwgMHgxOGM1MCwgMHgxOGM1ZSwgMHgxOGM2NiwgMHgxOGM3YSwgMHgxOGM4MixcbiAgICAgICAgMHgxOGM4NCwgMHgxOGM5MCwgMHgxOGM5ZSwgMHgxOGNhMCwgMHgxOGNiYywgMHgxOGNjYywgMHgxOGNmMiwgMHgxOGNmNCwgMHgxOGQwNCwgMHgxOGQwOCwgMHgxOGQxMCwgMHgxOGQxZSxcbiAgICAgICAgMHgxOGQyMCwgMHgxOGQzYywgMHgxOGQ0MCwgMHgxOGQ3OCwgMHgxOGQ4NiwgMHgxOGQ5OCwgMHgxOGRjZSwgMHgxOGRlMiwgMHgxOGRlNCwgMHgxOGRlOCwgMHgxOGUyZSwgMHgxOGUzMixcbiAgICAgICAgMHgxOGUzNCwgMHgxOGU0ZSwgMHgxOGU1YywgMHgxOGU2MiwgMHgxOGU2NCwgMHgxOGU2OCwgMHgxOGU4ZSwgMHgxOGU5YywgMHgxOGViOCwgMHgxOGVjMiwgMHgxOGVjNCwgMHgxOGVjOCxcbiAgICAgICAgMHgxOGVkMCwgMHgxOGVmYSwgMHgxOGYxNiwgMHgxOGYyNiwgMHgxOGYyYywgMHgxOGY0NiwgMHgxOGY0YywgMHgxOGY1OCwgMHgxOGY2ZSwgMHgxOGY4YSwgMHgxOGY5MiwgMHgxOGY5NCxcbiAgICAgICAgMHgxOGZhMiwgMHgxOGZhNCwgMHgxOGZhOCwgMHgxOGZiNiwgMHgxOTAyYywgMHgxOTAzYSwgMHgxOTA0NiwgMHgxOTA0YywgMHgxOTA1OCwgMHgxOTA3MiwgMHgxOTA3NCwgMHgxOTA4NixcbiAgICAgICAgMHgxOTA5OCwgMHgxOTBiMCwgMHgxOTBiZSwgMHgxOTBjZSwgMHgxOTBkYywgMHgxOTBlMiwgMHgxOTBlOCwgMHgxOTBmNiwgMHgxOTEwNiwgMHgxOTEwYywgMHgxOTEzMCwgMHgxOTEzZSxcbiAgICAgICAgMHgxOTE2MCwgMHgxOTE3YywgMHgxOTE4ZSwgMHgxOTE5YywgMHgxOTFiOCwgMHgxOTFjMiwgMHgxOTFjOCwgMHgxOTFkMCwgMHgxOTFkZSwgMHgxOTFlNiwgMHgxOTFlYywgMHgxOTFmYSxcbiAgICAgICAgMHgxOTIxOCwgMHgxOTIzZSwgMHgxOTI2MCwgMHgxOTI3YywgMHgxOTJjMCwgMHgxOTJmOCwgMHgxOTMzOCwgMHgxOTM3MCwgMHgxOTM3ZSwgMHgxOTM4MiwgMHgxOTM4NCwgMHgxOTM5MCxcbiAgICAgICAgMHgxOTM5ZSwgMHgxOTNhMCwgMHgxOTNiYywgMHgxOTNjNiwgMHgxOTNjYywgMHgxOTNkOCwgMHgxOTNlZSwgMHgxOTNmMiwgMHgxOTNmNCwgMHgxOTQzMCwgMHgxOTQzZSwgMHgxOTQ2MCxcbiAgICAgICAgMHgxOTQ3YywgMHgxOTRjMCwgMHgxOTRmOCwgMHgxOTVmMCwgMHgxOTYzOCwgMHgxOTY3MCwgMHgxOTY3ZSwgMHgxOTZlMCwgMHgxOTZmYywgMHgxOTcwMiwgMHgxOTcwNCwgMHgxOTcwOCxcbiAgICAgICAgMHgxOTcxMCwgMHgxOTcyMCwgMHgxOTczYywgMHgxOTc0MCwgMHgxOTc3OCwgMHgxOTc4NiwgMHgxOTc4YywgMHgxOTc5OCwgMHgxOTdiMCwgMHgxOTdiZSwgMHgxOTdjZSwgMHgxOTdkYyxcbiAgICAgICAgMHgxOTdlMiwgMHgxOTdlNCwgMHgxOTdlOCwgMHgxOTgyMiwgMHgxOTgyNCwgMHgxOTg0MiwgMHgxOTg0OCwgMHgxOTg1MCwgMHgxOTg1ZSwgMHgxOTg2NiwgMHgxOTg3YSwgMHgxOTg4MixcbiAgICAgICAgMHgxOTg4NCwgMHgxOTg5MCwgMHgxOTg5ZSwgMHgxOThhMCwgMHgxOThiYywgMHgxOThjYywgMHgxOThmMiwgMHgxOThmNCwgMHgxOTkwMiwgMHgxOTkwOCwgMHgxOTkxZSwgMHgxOTkyMCxcbiAgICAgICAgMHgxOTkzYywgMHgxOTk0MCwgMHgxOTk3OCwgMHgxOTk4NiwgMHgxOTk5OCwgMHgxOTljZSwgMHgxOTllMiwgMHgxOTllNCwgMHgxOTllOCwgMHgxOWEwOCwgMHgxOWExMCwgMHgxOWExZSxcbiAgICAgICAgMHgxOWEyMCwgMHgxOWEzYywgMHgxOWE0MCwgMHgxOWE3OCwgMHgxOWFmMCwgMHgxOWIxOCwgMHgxOWIzZSwgMHgxOWI2MCwgMHgxOWI5YywgMHgxOWJjMiwgMHgxOWJjNCwgMHgxOWJjOCxcbiAgICAgICAgMHgxOWJkMCwgMHgxOWJlNiwgMHgxOWMyZSwgMHgxOWMzNCwgMHgxOWM0ZSwgMHgxOWM1YywgMHgxOWM2MiwgMHgxOWM2NCwgMHgxOWM2OCwgMHgxOWM4ZSwgMHgxOWM5YywgMHgxOWNiOCxcbiAgICAgICAgMHgxOWNjMiwgMHgxOWNjOCwgMHgxOWNkMCwgMHgxOWNlNiwgMHgxOWNmYSwgMHgxOWQwZSwgMHgxOWQxYywgMHgxOWQzOCwgMHgxOWQ3MCwgMHgxOWQ3ZSwgMHgxOWQ4MiwgMHgxOWQ4NCxcbiAgICAgICAgMHgxOWQ4OCwgMHgxOWQ5MCwgMHgxOWRhMCwgMHgxOWRjYywgMHgxOWRmMiwgMHgxOWRmNCwgMHgxOWUxNiwgMHgxOWUyNiwgMHgxOWUyYywgMHgxOWU0NiwgMHgxOWU0YywgMHgxOWU1OCxcbiAgICAgICAgMHgxOWU3NCwgMHgxOWU4NiwgMHgxOWU4YywgMHgxOWU5OCwgMHgxOWViMCwgMHgxOWViZSwgMHgxOWVjZSwgMHgxOWVlMiwgMHgxOWVlNCwgMHgxOWVlOCwgMHgxOWYwYSwgMHgxOWYxMixcbiAgICAgICAgMHgxOWYxNCwgMHgxOWYyMiwgMHgxOWYyNCwgMHgxOWYyOCwgMHgxOWY0MiwgMHgxOWY0NCwgMHgxOWY0OCwgMHgxOWY1MCwgMHgxOWY1ZSwgMHgxOWY2YywgMHgxOWY5YSwgMHgxOWZhZSxcbiAgICAgICAgMHgxOWZiMiwgMHgxOWZiNCwgMHgxYTA0NiwgMHgxYTA0YywgMHgxYTA3MiwgMHgxYTA3NCwgMHgxYTA4NiwgMHgxYTA4YywgMHgxYTA5OCwgMHgxYTBiMCwgMHgxYTBiZSwgMHgxYTBlMixcbiAgICAgICAgMHgxYTBlNCwgMHgxYTBlOCwgMHgxYTBmNiwgMHgxYTEwNiwgMHgxYTEwYywgMHgxYTExOCwgMHgxYTEzMCwgMHgxYTEzZSwgMHgxYTE2MCwgMHgxYTE3YywgMHgxYTE4ZSwgMHgxYTE5YyxcbiAgICAgICAgMHgxYTFiOCwgMHgxYTFjMiwgMHgxYTFjNCwgMHgxYTFjOCwgMHgxYTFkMCwgMHgxYTFkZSwgMHgxYTFlNiwgMHgxYTFlYywgMHgxYTIxOCwgMHgxYTIzMCwgMHgxYTIzZSwgMHgxYTI2MCxcbiAgICAgICAgMHgxYTI3YywgMHgxYTJjMCwgMHgxYTJmOCwgMHgxYTMxYywgMHgxYTMzOCwgMHgxYTM3MCwgMHgxYTM3ZSwgMHgxYTM4MiwgMHgxYTM4NCwgMHgxYTM4OCwgMHgxYTM5MCwgMHgxYTM5ZSxcbiAgICAgICAgMHgxYTNhMCwgMHgxYTNiYywgMHgxYTNjNiwgMHgxYTNjYywgMHgxYTNkOCwgMHgxYTNlZSwgMHgxYTNmMiwgMHgxYTNmNCwgMHgxYTQxOCwgMHgxYTQzMCwgMHgxYTQzZSwgMHgxYTQ2MCxcbiAgICAgICAgMHgxYTQ3YywgMHgxYTRjMCwgMHgxYTRmOCwgMHgxYTVmMCwgMHgxYTYxYywgMHgxYTYzOCwgMHgxYTY3MCwgMHgxYTY3ZSwgMHgxYTZlMCwgMHgxYTZmYywgMHgxYTcwMiwgMHgxYTcwNCxcbiAgICAgICAgMHgxYTcwOCwgMHgxYTcxMCwgMHgxYTcxZSwgMHgxYTcyMCwgMHgxYTczYywgMHgxYTc0MCwgMHgxYTc3OCwgMHgxYTc4NiwgMHgxYTc4YywgMHgxYTc5OCwgMHgxYTdiMCwgMHgxYTdiZSxcbiAgICAgICAgMHgxYTdjZSwgMHgxYTdkYywgMHgxYTdlMiwgMHgxYTdlNCwgMHgxYTdlOCwgMHgxYTgzMCwgMHgxYTg2MCwgMHgxYTg3YywgMHgxYThjMCwgMHgxYThmOCwgMHgxYTlmMCwgMHgxYWJlMCxcbiAgICAgICAgMHgxYWM3MCwgMHgxYWM3ZSwgMHgxYWNlMCwgMHgxYWNmYywgMHgxYWRjMCwgMHgxYWRmOCwgMHgxYWUwNCwgMHgxYWUwOCwgMHgxYWUxMCwgMHgxYWUyMCwgMHgxYWUzYywgMHgxYWU0MCxcbiAgICAgICAgMHgxYWU3OCwgMHgxYWVmMCwgMHgxYWYwNiwgMHgxYWYwYywgMHgxYWYxOCwgMHgxYWYzMCwgMHgxYWYzZSwgMHgxYWY2MCwgMHgxYWY3YywgMHgxYWY4ZSwgMHgxYWY5YywgMHgxYWZiOCxcbiAgICAgICAgMHgxYWZjNCwgMHgxYWZjOCwgMHgxYWZkMCwgMHgxYWZkZSwgMHgxYjA0MiwgMHgxYjA1ZSwgMHgxYjA3YSwgMHgxYjA4MiwgMHgxYjA4NCwgMHgxYjA4OCwgMHgxYjA5MCwgMHgxYjA5ZSxcbiAgICAgICAgMHgxYjBhMCwgMHgxYjBiYywgMHgxYjBjYywgMHgxYjBmMiwgMHgxYjBmNCwgMHgxYjEwMiwgMHgxYjEwNCwgMHgxYjEwOCwgMHgxYjExMCwgMHgxYjExZSwgMHgxYjEyMCwgMHgxYjEzYyxcbiAgICAgICAgMHgxYjE0MCwgMHgxYjE3OCwgMHgxYjE4NiwgMHgxYjE5OCwgMHgxYjFjZSwgMHgxYjFlMiwgMHgxYjFlNCwgMHgxYjFlOCwgMHgxYjIwNCwgMHgxYjIwOCwgMHgxYjIxMCwgMHgxYjIxZSxcbiAgICAgICAgMHgxYjIyMCwgMHgxYjIzYywgMHgxYjI0MCwgMHgxYjI3OCwgMHgxYjJmMCwgMHgxYjMwYywgMHgxYjMzZSwgMHgxYjM2MCwgMHgxYjM5YywgMHgxYjNjMiwgMHgxYjNjNCwgMHgxYjNjOCxcbiAgICAgICAgMHgxYjNkMCwgMHgxYjNlNiwgMHgxYjQxMCwgMHgxYjQxZSwgMHgxYjQyMCwgMHgxYjQzYywgMHgxYjQ0MCwgMHgxYjQ3OCwgMHgxYjRmMCwgMHgxYjVlMCwgMHgxYjYxOCwgMHgxYjY2MCxcbiAgICAgICAgMHgxYjY3YywgMHgxYjZjMCwgMHgxYjczOCwgMHgxYjc4MiwgMHgxYjc4NCwgMHgxYjc4OCwgMHgxYjc5MCwgMHgxYjc5ZSwgMHgxYjdhMCwgMHgxYjdjYywgMHgxYjgyZSwgMHgxYjg0ZSxcbiAgICAgICAgMHgxYjg1YywgMHgxYjg4ZSwgMHgxYjg5YywgMHgxYjhiOCwgMHgxYjhjMiwgMHgxYjhjNCwgMHgxYjhjOCwgMHgxYjhkMCwgMHgxYjhlNiwgMHgxYjhmYSwgMHgxYjkwZSwgMHgxYjkxYyxcbiAgICAgICAgMHgxYjkzOCwgMHgxYjk3MCwgMHgxYjk3ZSwgMHgxYjk4MiwgMHgxYjk4NCwgMHgxYjk4OCwgMHgxYjk5MCwgMHgxYjk5ZSwgMHgxYjlhMCwgMHgxYjljYywgMHgxYjlmMiwgMHgxYjlmNCxcbiAgICAgICAgMHgxYmEwZSwgMHgxYmExYywgMHgxYmEzOCwgMHgxYmE3MCwgMHgxYmE3ZSwgMHgxYmFlMCwgMHgxYmFmYywgMHgxYmIwOCwgMHgxYmIxMCwgMHgxYmIyMCwgMHgxYmIzYywgMHgxYmI0MCxcbiAgICAgICAgMHgxYmI5OCwgMHgxYmJjZSwgMHgxYmJlMiwgMHgxYmJlNCwgMHgxYmJlOCwgMHgxYmMxNiwgMHgxYmMyNiwgMHgxYmMyYywgMHgxYmM0NiwgMHgxYmM0YywgMHgxYmM1OCwgMHgxYmM3MixcbiAgICAgICAgMHgxYmM3NCwgMHgxYmM4NiwgMHgxYmM4YywgMHgxYmM5OCwgMHgxYmNiMCwgMHgxYmNiZSwgMHgxYmNjZSwgMHgxYmNlMiwgMHgxYmNlNCwgMHgxYmNlOCwgMHgxYmQwNiwgMHgxYmQwYyxcbiAgICAgICAgMHgxYmQxOCwgMHgxYmQzMCwgMHgxYmQzZSwgMHgxYmQ2MCwgMHgxYmQ3YywgMHgxYmQ5YywgMHgxYmRjMiwgMHgxYmRjNCwgMHgxYmRjOCwgMHgxYmRkMCwgMHgxYmRlNiwgMHgxYmRmYSxcbiAgICAgICAgMHgxYmUxMiwgMHgxYmUxNCwgMHgxYmUyMiwgMHgxYmUyNCwgMHgxYmUyOCwgMHgxYmU0MiwgMHgxYmU0NCwgMHgxYmU0OCwgMHgxYmU1MCwgMHgxYmU1ZSwgMHgxYmU2NiwgMHgxYmU4MixcbiAgICAgICAgMHgxYmU4NCwgMHgxYmU4OCwgMHgxYmU5MCwgMHgxYmU5ZSwgMHgxYmVhMCwgMHgxYmViYywgMHgxYmVjYywgMHgxYmVmNCwgMHgxYmYxYSwgMHgxYmYyZSwgMHgxYmYzMiwgMHgxYmYzNCxcbiAgICAgICAgMHgxYmY0ZSwgMHgxYmY1YywgMHgxYmY2MiwgMHgxYmY2NCwgMHgxYmY2OCwgMHgxYzA5YSwgMHgxYzBiMiwgMHgxYzBiNCwgMHgxYzExYSwgMHgxYzEzMiwgMHgxYzEzNCwgMHgxYzE2MixcbiAgICAgICAgMHgxYzE2NCwgMHgxYzE2OCwgMHgxYzE3NiwgMHgxYzFiYSwgMHgxYzIxYSwgMHgxYzIzMiwgMHgxYzIzNCwgMHgxYzI0ZSwgMHgxYzI1YywgMHgxYzI2MiwgMHgxYzI2NCwgMHgxYzI2OCxcbiAgICAgICAgMHgxYzI3NiwgMHgxYzI4ZSwgMHgxYzJjMiwgMHgxYzJjNCwgMHgxYzJjOCwgMHgxYzJkMCwgMHgxYzJkZSwgMHgxYzJlNiwgMHgxYzJlYywgMHgxYzJmYSwgMHgxYzMxNiwgMHgxYzMyNixcbiAgICAgICAgMHgxYzMzYSwgMHgxYzM0NiwgMHgxYzM0YywgMHgxYzM3MiwgMHgxYzM3NCwgMHgxYzQxYSwgMHgxYzQyZSwgMHgxYzQzMiwgMHgxYzQzNCwgMHgxYzQ0ZSwgMHgxYzQ1YywgMHgxYzQ2MixcbiAgICAgICAgMHgxYzQ2NCwgMHgxYzQ2OCwgMHgxYzQ3NiwgMHgxYzQ4ZSwgMHgxYzQ5YywgMHgxYzRiOCwgMHgxYzRjMiwgMHgxYzRjOCwgMHgxYzRkMCwgMHgxYzRkZSwgMHgxYzRlNiwgMHgxYzRlYyxcbiAgICAgICAgMHgxYzRmYSwgMHgxYzUxYywgMHgxYzUzOCwgMHgxYzU3MCwgMHgxYzU3ZSwgMHgxYzU4MiwgMHgxYzU4NCwgMHgxYzU4OCwgMHgxYzU5MCwgMHgxYzU5ZSwgMHgxYzVhMCwgMHgxYzViYyxcbiAgICAgICAgMHgxYzVjNiwgMHgxYzVjYywgMHgxYzVkOCwgMHgxYzVlZSwgMHgxYzVmMiwgMHgxYzVmNCwgMHgxYzYxNiwgMHgxYzYyNiwgMHgxYzYyYywgMHgxYzYzYSwgMHgxYzY0NiwgMHgxYzY0YyxcbiAgICAgICAgMHgxYzY1OCwgMHgxYzY2ZSwgMHgxYzY3MiwgMHgxYzY3NCwgMHgxYzY4NiwgMHgxYzY4YywgMHgxYzY5OCwgMHgxYzZiMCwgMHgxYzZiZSwgMHgxYzZjZSwgMHgxYzZkYywgMHgxYzZlMixcbiAgICAgICAgMHgxYzZlNCwgMHgxYzZlOCwgMHgxYzcxMiwgMHgxYzcxNCwgMHgxYzcyMiwgMHgxYzcyOCwgMHgxYzczNiwgMHgxYzc0MiwgMHgxYzc0NCwgMHgxYzc0OCwgMHgxYzc1MCwgMHgxYzc1ZSxcbiAgICAgICAgMHgxYzc2NiwgMHgxYzc2YywgMHgxYzc3YSwgMHgxYzdhZSwgMHgxYzdkNiwgMHgxYzdlYSwgMHgxYzgxYSwgMHgxYzgyZSwgMHgxYzgzMiwgMHgxYzgzNCwgMHgxYzg0ZSwgMHgxYzg1YyxcbiAgICAgICAgMHgxYzg2MiwgMHgxYzg2NCwgMHgxYzg2OCwgMHgxYzg3NiwgMHgxYzg4ZSwgMHgxYzg5YywgMHgxYzhiOCwgMHgxYzhjMiwgMHgxYzhjOCwgMHgxYzhkMCwgMHgxYzhkZSwgMHgxYzhlNixcbiAgICAgICAgMHgxYzhlYywgMHgxYzhmYSwgMHgxYzkwZSwgMHgxYzkzOCwgMHgxYzk3MCwgMHgxYzk3ZSwgMHgxYzk4MiwgMHgxYzk4NCwgMHgxYzk5MCwgMHgxYzk5ZSwgMHgxYzlhMCwgMHgxYzliYyxcbiAgICAgICAgMHgxYzljNiwgMHgxYzljYywgMHgxYzlkOCwgMHgxYzllZSwgMHgxYzlmMiwgMHgxYzlmNCwgMHgxY2EzOCwgMHgxY2E3MCwgMHgxY2E3ZSwgMHgxY2FlMCwgMHgxY2FmYywgMHgxY2IwMixcbiAgICAgICAgMHgxY2IwNCwgMHgxY2IwOCwgMHgxY2IxMCwgMHgxY2IyMCwgMHgxY2IzYywgMHgxY2I0MCwgMHgxY2I3OCwgMHgxY2I4NiwgMHgxY2I4YywgMHgxY2I5OCwgMHgxY2JiMCwgMHgxY2JiZSxcbiAgICAgICAgMHgxY2JjZSwgMHgxY2JkYywgMHgxY2JlMiwgMHgxY2JlNCwgMHgxY2JlOCwgMHgxY2JmNiwgMHgxY2MxNiwgMHgxY2MyNiwgMHgxY2MyYywgMHgxY2MzYSwgMHgxY2M0NiwgMHgxY2M1OCxcbiAgICAgICAgMHgxY2M3MiwgMHgxY2M3NCwgMHgxY2M4NiwgMHgxY2NiMCwgMHgxY2NiZSwgMHgxY2NjZSwgMHgxY2NlMiwgMHgxY2NlNCwgMHgxY2NlOCwgMHgxY2QwNiwgMHgxY2QwYywgMHgxY2QxOCxcbiAgICAgICAgMHgxY2QzMCwgMHgxY2QzZSwgMHgxY2Q2MCwgMHgxY2Q3YywgMHgxY2Q5YywgMHgxY2RjMiwgMHgxY2RjNCwgMHgxY2RjOCwgMHgxY2RkMCwgMHgxY2RkZSwgMHgxY2RlNiwgMHgxY2RmYSxcbiAgICAgICAgMHgxY2UyMiwgMHgxY2UyOCwgMHgxY2U0MiwgMHgxY2U1MCwgMHgxY2U1ZSwgMHgxY2U2NiwgMHgxY2U3YSwgMHgxY2U4MiwgMHgxY2U4NCwgMHgxY2U4OCwgMHgxY2U5MCwgMHgxY2U5ZSxcbiAgICAgICAgMHgxY2VhMCwgMHgxY2ViYywgMHgxY2VjYywgMHgxY2VmMiwgMHgxY2VmNCwgMHgxY2YyZSwgMHgxY2YzMiwgMHgxY2YzNCwgMHgxY2Y0ZSwgMHgxY2Y1YywgMHgxY2Y2MiwgMHgxY2Y2NCxcbiAgICAgICAgMHgxY2Y2OCwgMHgxY2Y5NiwgMHgxY2ZhNiwgMHgxY2ZhYywgMHgxY2ZjYSwgMHgxY2ZkMiwgMHgxY2ZkNCwgMHgxZDAyZSwgMHgxZDAzMiwgMHgxZDAzNCwgMHgxZDA0ZSwgMHgxZDA1YyxcbiAgICAgICAgMHgxZDA2MiwgMHgxZDA2NCwgMHgxZDA2OCwgMHgxZDA3NiwgMHgxZDA4ZSwgMHgxZDA5YywgMHgxZDBiOCwgMHgxZDBjMiwgMHgxZDBjNCwgMHgxZDBjOCwgMHgxZDBkMCwgMHgxZDBkZSxcbiAgICAgICAgMHgxZDBlNiwgMHgxZDBlYywgMHgxZDBmYSwgMHgxZDExYywgMHgxZDEzOCwgMHgxZDE3MCwgMHgxZDE3ZSwgMHgxZDE4MiwgMHgxZDE4NCwgMHgxZDE4OCwgMHgxZDE5MCwgMHgxZDE5ZSxcbiAgICAgICAgMHgxZDFhMCwgMHgxZDFiYywgMHgxZDFjNiwgMHgxZDFjYywgMHgxZDFkOCwgMHgxZDFlZSwgMHgxZDFmMiwgMHgxZDFmNCwgMHgxZDIxYywgMHgxZDIzOCwgMHgxZDI3MCwgMHgxZDI3ZSxcbiAgICAgICAgMHgxZDJlMCwgMHgxZDJmYywgMHgxZDMwMiwgMHgxZDMwNCwgMHgxZDMwOCwgMHgxZDMxMCwgMHgxZDMxZSwgMHgxZDMyMCwgMHgxZDMzYywgMHgxZDM0MCwgMHgxZDM3OCwgMHgxZDM4NixcbiAgICAgICAgMHgxZDM4YywgMHgxZDM5OCwgMHgxZDNiMCwgMHgxZDNiZSwgMHgxZDNjZSwgMHgxZDNkYywgMHgxZDNlMiwgMHgxZDNlNCwgMHgxZDNlOCwgMHgxZDNmNiwgMHgxZDQ3MCwgMHgxZDQ3ZSxcbiAgICAgICAgMHgxZDRlMCwgMHgxZDRmYywgMHgxZDVjMCwgMHgxZDVmOCwgMHgxZDYwNCwgMHgxZDYwOCwgMHgxZDYxMCwgMHgxZDYyMCwgMHgxZDY0MCwgMHgxZDY3OCwgMHgxZDZmMCwgMHgxZDcwNixcbiAgICAgICAgMHgxZDcwYywgMHgxZDcxOCwgMHgxZDczMCwgMHgxZDczZSwgMHgxZDc2MCwgMHgxZDc3YywgMHgxZDc4ZSwgMHgxZDc5YywgMHgxZDdiOCwgMHgxZDdjMiwgMHgxZDdjNCwgMHgxZDdjOCxcbiAgICAgICAgMHgxZDdkMCwgMHgxZDdkZSwgMHgxZDdlNiwgMHgxZDdlYywgMHgxZDgyNiwgMHgxZDgyYywgMHgxZDgzYSwgMHgxZDg0NiwgMHgxZDg0YywgMHgxZDg1OCwgMHgxZDg3MiwgMHgxZDg3NCxcbiAgICAgICAgMHgxZDg4NiwgMHgxZDg4YywgMHgxZDg5OCwgMHgxZDhiMCwgMHgxZDhiZSwgMHgxZDhjZSwgMHgxZDhlMiwgMHgxZDhlNCwgMHgxZDhlOCwgMHgxZDhmNiwgMHgxZDkwYywgMHgxZDkxOCxcbiAgICAgICAgMHgxZDkzMCwgMHgxZDkzZSwgMHgxZDk2MCwgMHgxZDk3YywgMHgxZDk5YywgMHgxZDljMiwgMHgxZDljNCwgMHgxZDljOCwgMHgxZDlkMCwgMHgxZDllNiwgMHgxZDlmYSwgMHgxZGEwYyxcbiAgICAgICAgMHgxZGExOCwgMHgxZGEzMCwgMHgxZGEzZSwgMHgxZGE2MCwgMHgxZGE3YywgMHgxZGFjMCwgMHgxZGFmOCwgMHgxZGIzOCwgMHgxZGI4MiwgMHgxZGI4NCwgMHgxZGI4OCwgMHgxZGI5MCxcbiAgICAgICAgMHgxZGI5ZSwgMHgxZGJhMCwgMHgxZGJjYywgMHgxZGJmMiwgMHgxZGJmNCwgMHgxZGMyMiwgMHgxZGM0MiwgMHgxZGM0NCwgMHgxZGM0OCwgMHgxZGM1MCwgMHgxZGM1ZSwgMHgxZGM2NixcbiAgICAgICAgMHgxZGM3YSwgMHgxZGM4MiwgMHgxZGM4NCwgMHgxZGM4OCwgMHgxZGM5MCwgMHgxZGM5ZSwgMHgxZGNhMCwgMHgxZGNiYywgMHgxZGNjYywgMHgxZGNmMiwgMHgxZGNmNCwgMHgxZGQwNCxcbiAgICAgICAgMHgxZGQwOCwgMHgxZGQxMCwgMHgxZGQxZSwgMHgxZGQyMCwgMHgxZGQzYywgMHgxZGQ0MCwgMHgxZGQ3OCwgMHgxZGQ4NiwgMHgxZGQ5OCwgMHgxZGRjZSwgMHgxZGRlMiwgMHgxZGRlNCxcbiAgICAgICAgMHgxZGRlOCwgMHgxZGUyZSwgMHgxZGUzMiwgMHgxZGUzNCwgMHgxZGU0ZSwgMHgxZGU1YywgMHgxZGU2MiwgMHgxZGU2NCwgMHgxZGU2OCwgMHgxZGU4ZSwgMHgxZGU5YywgMHgxZGViOCxcbiAgICAgICAgMHgxZGVjMiwgMHgxZGVjNCwgMHgxZGVjOCwgMHgxZGVkMCwgMHgxZGVlNiwgMHgxZGVmYSwgMHgxZGYxNiwgMHgxZGYyNiwgMHgxZGYyYywgMHgxZGY0NiwgMHgxZGY0YywgMHgxZGY1OCxcbiAgICAgICAgMHgxZGY3MiwgMHgxZGY3NCwgMHgxZGY4YSwgMHgxZGY5MiwgMHgxZGY5NCwgMHgxZGZhMiwgMHgxZGZhNCwgMHgxZGZhOCwgMHgxZTA4YSwgMHgxZTA5MiwgMHgxZTA5NCwgMHgxZTBhMixcbiAgICAgICAgMHgxZTBhNCwgMHgxZTBhOCwgMHgxZTBiNiwgMHgxZTBkYSwgMHgxZTEwYSwgMHgxZTExMiwgMHgxZTExNCwgMHgxZTEyMiwgMHgxZTEyNCwgMHgxZTEyOCwgMHgxZTEzNiwgMHgxZTE0MixcbiAgICAgICAgMHgxZTE0NCwgMHgxZTE0OCwgMHgxZTE1MCwgMHgxZTE2NiwgMHgxZTE2YywgMHgxZTE3YSwgMHgxZTE5YSwgMHgxZTFiMiwgMHgxZTFiNCwgMHgxZTIwYSwgMHgxZTIxMiwgMHgxZTIxNCxcbiAgICAgICAgMHgxZTIyMiwgMHgxZTIyNCwgMHgxZTIyOCwgMHgxZTIzNiwgMHgxZTI0MiwgMHgxZTI0OCwgMHgxZTI1MCwgMHgxZTI1ZSwgMHgxZTI2NiwgMHgxZTI2YywgMHgxZTI3YSwgMHgxZTI4MixcbiAgICAgICAgMHgxZTI4NCwgMHgxZTI4OCwgMHgxZTI5MCwgMHgxZTJhMCwgMHgxZTJiYywgMHgxZTJjNiwgMHgxZTJjYywgMHgxZTJkOCwgMHgxZTJlZSwgMHgxZTJmMiwgMHgxZTJmNCwgMHgxZTMxYSxcbiAgICAgICAgMHgxZTMzMiwgMHgxZTMzNCwgMHgxZTM1YywgMHgxZTM2MiwgMHgxZTM2NCwgMHgxZTM2OCwgMHgxZTNiYSwgMHgxZTQwYSwgMHgxZTQxMiwgMHgxZTQxNCwgMHgxZTQyMiwgMHgxZTQyOCxcbiAgICAgICAgMHgxZTQzNiwgMHgxZTQ0MiwgMHgxZTQ0OCwgMHgxZTQ1MCwgMHgxZTQ1ZSwgMHgxZTQ2NiwgMHgxZTQ2YywgMHgxZTQ3YSwgMHgxZTQ4MiwgMHgxZTQ4NCwgMHgxZTQ5MCwgMHgxZTQ5ZSxcbiAgICAgICAgMHgxZTRhMCwgMHgxZTRiYywgMHgxZTRjNiwgMHgxZTRjYywgMHgxZTRkOCwgMHgxZTRlZSwgMHgxZTRmMiwgMHgxZTRmNCwgMHgxZTUwMiwgMHgxZTUwNCwgMHgxZTUwOCwgMHgxZTUxMCxcbiAgICAgICAgMHgxZTUxZSwgMHgxZTUyMCwgMHgxZTUzYywgMHgxZTU0MCwgMHgxZTU3OCwgMHgxZTU4NiwgMHgxZTU4YywgMHgxZTU5OCwgMHgxZTViMCwgMHgxZTViZSwgMHgxZTVjZSwgMHgxZTVkYyxcbiAgICAgICAgMHgxZTVlMiwgMHgxZTVlNCwgMHgxZTVlOCwgMHgxZTVmNiwgMHgxZTYxYSwgMHgxZTYyZSwgMHgxZTYzMiwgMHgxZTYzNCwgMHgxZTY0ZSwgMHgxZTY1YywgMHgxZTY2MiwgMHgxZTY2OCxcbiAgICAgICAgMHgxZTY4ZSwgMHgxZTY5YywgMHgxZTZiOCwgMHgxZTZjMiwgMHgxZTZjNCwgMHgxZTZjOCwgMHgxZTZkMCwgMHgxZTZlNiwgMHgxZTZmYSwgMHgxZTcxNiwgMHgxZTcyNiwgMHgxZTcyYyxcbiAgICAgICAgMHgxZTczYSwgMHgxZTc0NiwgMHgxZTc0YywgMHgxZTc1OCwgMHgxZTc3MiwgMHgxZTc3NCwgMHgxZTc5MiwgMHgxZTc5NCwgMHgxZTdhMiwgMHgxZTdhNCwgMHgxZTdhOCwgMHgxZTdiNixcbiAgICAgICAgMHgxZTgxMiwgMHgxZTgxNCwgMHgxZTgyMiwgMHgxZTgyNCwgMHgxZTgyOCwgMHgxZTgzNiwgMHgxZTg0MiwgMHgxZTg0NCwgMHgxZTg0OCwgMHgxZTg1MCwgMHgxZTg1ZSwgMHgxZTg2NixcbiAgICAgICAgMHgxZTg2YywgMHgxZTg3YSwgMHgxZTg4MiwgMHgxZTg4NCwgMHgxZTg4OCwgMHgxZTg5MCwgMHgxZTg5ZSwgMHgxZThhMCwgMHgxZThiYywgMHgxZThjNiwgMHgxZThjYywgMHgxZThkOCxcbiAgICAgICAgMHgxZThlZSwgMHgxZThmMiwgMHgxZThmNCwgMHgxZTkwMiwgMHgxZTkwNCwgMHgxZTkwOCwgMHgxZTkxMCwgMHgxZTkyMCwgMHgxZTkzYywgMHgxZTk0MCwgMHgxZTk3OCwgMHgxZTk4NixcbiAgICAgICAgMHgxZTk4YywgMHgxZTk5OCwgMHgxZTliMCwgMHgxZTliZSwgMHgxZTljZSwgMHgxZTlkYywgMHgxZTllMiwgMHgxZTllNCwgMHgxZTllOCwgMHgxZTlmNiwgMHgxZWEwNCwgMHgxZWEwOCxcbiAgICAgICAgMHgxZWExMCwgMHgxZWEyMCwgMHgxZWE0MCwgMHgxZWE3OCwgMHgxZWFmMCwgMHgxZWIwNiwgMHgxZWIwYywgMHgxZWIxOCwgMHgxZWIzMCwgMHgxZWIzZSwgMHgxZWI2MCwgMHgxZWI3YyxcbiAgICAgICAgMHgxZWI4ZSwgMHgxZWI5YywgMHgxZWJiOCwgMHgxZWJjMiwgMHgxZWJjNCwgMHgxZWJjOCwgMHgxZWJkMCwgMHgxZWJkZSwgMHgxZWJlNiwgMHgxZWJlYywgMHgxZWMxYSwgMHgxZWMyZSxcbiAgICAgICAgMHgxZWMzMiwgMHgxZWMzNCwgMHgxZWM0ZSwgMHgxZWM1YywgMHgxZWM2MiwgMHgxZWM2NCwgMHgxZWM2OCwgMHgxZWM4ZSwgMHgxZWM5YywgMHgxZWNiOCwgMHgxZWNjMiwgMHgxZWNjNCxcbiAgICAgICAgMHgxZWNjOCwgMHgxZWNkMCwgMHgxZWNlNiwgMHgxZWNmYSwgMHgxZWQwZSwgMHgxZWQxYywgMHgxZWQzOCwgMHgxZWQ3MCwgMHgxZWQ3ZSwgMHgxZWQ4MiwgMHgxZWQ4NCwgMHgxZWQ4OCxcbiAgICAgICAgMHgxZWQ5MCwgMHgxZWQ5ZSwgMHgxZWRhMCwgMHgxZWRjYywgMHgxZWRmMiwgMHgxZWRmNCwgMHgxZWUxNiwgMHgxZWUyNiwgMHgxZWUyYywgMHgxZWUzYSwgMHgxZWU0NiwgMHgxZWU0YyxcbiAgICAgICAgMHgxZWU1OCwgMHgxZWU2ZSwgMHgxZWU3MiwgMHgxZWU3NCwgMHgxZWU4NiwgMHgxZWU4YywgMHgxZWU5OCwgMHgxZWViMCwgMHgxZWViZSwgMHgxZWVjZSwgMHgxZWVkYywgMHgxZWVlMixcbiAgICAgICAgMHgxZWVlNCwgMHgxZWVlOCwgMHgxZWYxMiwgMHgxZWYyMiwgMHgxZWYyNCwgMHgxZWYyOCwgMHgxZWYzNiwgMHgxZWY0MiwgMHgxZWY0NCwgMHgxZWY0OCwgMHgxZWY1MCwgMHgxZWY1ZSxcbiAgICAgICAgMHgxZWY2NiwgMHgxZWY2YywgMHgxZWY3YSwgMHgxZWZhZSwgMHgxZWZiMiwgMHgxZWZiNCwgMHgxZWZkNiwgMHgxZjA5NiwgMHgxZjBhNiwgMHgxZjBhYywgMHgxZjBiYSwgMHgxZjBjYSxcbiAgICAgICAgMHgxZjBkMiwgMHgxZjBkNCwgMHgxZjExNiwgMHgxZjEyNiwgMHgxZjEyYywgMHgxZjEzYSwgMHgxZjE0NiwgMHgxZjE0YywgMHgxZjE1OCwgMHgxZjE2ZSwgMHgxZjE3MiwgMHgxZjE3NCxcbiAgICAgICAgMHgxZjE4YSwgMHgxZjE5MiwgMHgxZjE5NCwgMHgxZjFhMiwgMHgxZjFhNCwgMHgxZjFhOCwgMHgxZjFkYSwgMHgxZjIxNiwgMHgxZjIyNiwgMHgxZjIyYywgMHgxZjIzYSwgMHgxZjI0NixcbiAgICAgICAgMHgxZjI1OCwgMHgxZjI2ZSwgMHgxZjI3MiwgMHgxZjI3NCwgMHgxZjI4NiwgMHgxZjI4YywgMHgxZjI5OCwgMHgxZjJiMCwgMHgxZjJiZSwgMHgxZjJjZSwgMHgxZjJkYywgMHgxZjJlMixcbiAgICAgICAgMHgxZjJlNCwgMHgxZjJlOCwgMHgxZjJmNiwgMHgxZjMwYSwgMHgxZjMxMiwgMHgxZjMxNCwgMHgxZjMyMiwgMHgxZjMyOCwgMHgxZjM0MiwgMHgxZjM0NCwgMHgxZjM0OCwgMHgxZjM1MCxcbiAgICAgICAgMHgxZjM1ZSwgMHgxZjM2NiwgMHgxZjM3YSwgMHgxZjM5YSwgMHgxZjNhZSwgMHgxZjNiMiwgMHgxZjNiNCwgMHgxZjQxNiwgMHgxZjQyNiwgMHgxZjQyYywgMHgxZjQzYSwgMHgxZjQ0NixcbiAgICAgICAgMHgxZjQ0YywgMHgxZjQ1OCwgMHgxZjQ2ZSwgMHgxZjQ3MiwgMHgxZjQ3NCwgMHgxZjQ4NiwgMHgxZjQ4YywgMHgxZjQ5OCwgMHgxZjRiMCwgMHgxZjRiZSwgMHgxZjRjZSwgMHgxZjRkYyxcbiAgICAgICAgMHgxZjRlMiwgMHgxZjRlNCwgMHgxZjRlOCwgMHgxZjRmNiwgMHgxZjUwNiwgMHgxZjUwYywgMHgxZjUxOCwgMHgxZjUzMCwgMHgxZjUzZSwgMHgxZjU2MCwgMHgxZjU3YywgMHgxZjU4ZSxcbiAgICAgICAgMHgxZjU5YywgMHgxZjViOCwgMHgxZjVjMiwgMHgxZjVjNCwgMHgxZjVjOCwgMHgxZjVkMCwgMHgxZjVkZSwgMHgxZjVlNiwgMHgxZjVlYywgMHgxZjVmYSwgMHgxZjYwYSwgMHgxZjYxMixcbiAgICAgICAgMHgxZjYxNCwgMHgxZjYyMiwgMHgxZjYyNCwgMHgxZjYyOCwgMHgxZjYzNiwgMHgxZjY0MiwgMHgxZjY0NCwgMHgxZjY0OCwgMHgxZjY1MCwgMHgxZjY1ZSwgMHgxZjY2NiwgMHgxZjY3YSxcbiAgICAgICAgMHgxZjY4MiwgMHgxZjY4NCwgMHgxZjY4OCwgMHgxZjY5MCwgMHgxZjY5ZSwgMHgxZjZhMCwgMHgxZjZiYywgMHgxZjZjYywgMHgxZjZmMiwgMHgxZjZmNCwgMHgxZjcxYSwgMHgxZjcyZSxcbiAgICAgICAgMHgxZjczMiwgMHgxZjczNCwgMHgxZjc0ZSwgMHgxZjc1YywgMHgxZjc2MiwgMHgxZjc2NCwgMHgxZjc2OCwgMHgxZjc3NiwgMHgxZjc5NiwgMHgxZjdhNiwgMHgxZjdhYywgMHgxZjdiYSxcbiAgICAgICAgMHgxZjdkMiwgMHgxZjdkNCwgMHgxZjg5YSwgMHgxZjhhZSwgMHgxZjhiMiwgMHgxZjhiNCwgMHgxZjhkNiwgMHgxZjhlYSwgMHgxZjkxYSwgMHgxZjkyZSwgMHgxZjkzMiwgMHgxZjkzNCxcbiAgICAgICAgMHgxZjk0ZSwgMHgxZjk1YywgMHgxZjk2MiwgMHgxZjk2NCwgMHgxZjk2OCwgMHgxZjk3NiwgMHgxZjk5NiwgMHgxZjlhNiwgMHgxZjlhYywgMHgxZjliYSwgMHgxZjljYSwgMHgxZjlkMixcbiAgICAgICAgMHgxZjlkNCwgMHgxZmExYSwgMHgxZmEyZSwgMHgxZmEzMiwgMHgxZmEzNCwgMHgxZmE0ZSwgMHgxZmE1YywgMHgxZmE2MiwgMHgxZmE2NCwgMHgxZmE2OCwgMHgxZmE3NiwgMHgxZmE4ZSxcbiAgICAgICAgMHgxZmE5YywgMHgxZmFiOCwgMHgxZmFjMiwgMHgxZmFjNCwgMHgxZmFjOCwgMHgxZmFkMCwgMHgxZmFkZSwgMHgxZmFlNiwgMHgxZmFlYywgMHgxZmIxNiwgMHgxZmIyNiwgMHgxZmIyYyxcbiAgICAgICAgMHgxZmIzYSwgMHgxZmI0NiwgMHgxZmI0YywgMHgxZmI1OCwgMHgxZmI2ZSwgMHgxZmI3MiwgMHgxZmI3NCwgMHgxZmI4YSwgMHgxZmI5MiwgMHgxZmI5NCwgMHgxZmJhMiwgMHgxZmJhNCxcbiAgICAgICAgMHgxZmJhOCwgMHgxZmJiNiwgMHgxZmJkYVxuICAgIF0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgdGFibGUgY29udGFpbnMgdG8gY29kZXdvcmRzIGZvciBhbGwgc3ltYm9scy5cbiAgICAgKi9cbiAgICBQREY0MTdDb21tb24uQ09ERVdPUkRfVEFCTEUgPSBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAyNjI3LCAxODE5LCAyNjIyLCAyNjIxLCAxODEzLCAxODEyLCAyNzI5LCAyNzI0LCAyNzIzLCAyNzc5LCAyNzc0LCAyNzczLCA5MDIsIDg5NiwgOTA4LCA4NjgsIDg2NSwgODYxLCA4NTksIDI1MTEsXG4gICAgICAgIDg3MywgODcxLCAxNzgwLCA4MzUsIDI0OTMsIDgyNSwgMjQ5MSwgODQyLCA4MzcsIDg0NCwgMTc2NCwgMTc2MiwgODExLCA4MTAsIDgwOSwgMjQ4MywgODA3LCAyNDgyLCA4MDYsIDI0ODAsIDgxNSxcbiAgICAgICAgODE0LCA4MTMsIDgxMiwgMjQ4NCwgODE3LCA4MTYsIDE3NDUsIDE3NDQsIDE3NDIsIDE3NDYsIDI2NTUsIDI2MzcsIDI2MzUsIDI2MjYsIDI2MjUsIDI2MjMsIDI2MjgsIDE4MjAsIDI3NTIsXG4gICAgICAgIDI3MzksIDI3MzcsIDI3MjgsIDI3MjcsIDI3MjUsIDI3MzAsIDI3ODUsIDI3ODMsIDI3NzgsIDI3NzcsIDI3NzUsIDI3ODAsIDc4NywgNzgxLCA3NDcsIDczOSwgNzM2LCAyNDEzLCA3NTQsIDc1MixcbiAgICAgICAgMTcxOSwgNjkyLCA2ODksIDY4MSwgMjM3MSwgNjc4LCAyMzY5LCA3MDAsIDY5NywgNjk0LCA3MDMsIDE2ODgsIDE2ODYsIDY0MiwgNjM4LCAyMzQzLCA2MzEsIDIzNDEsIDYyNywgMjMzOCwgNjUxLFxuICAgICAgICA2NDYsIDY0MywgMjM0NSwgNjU0LCA2NTIsIDE2NTIsIDE2NTAsIDE2NDcsIDE2NTQsIDYwMSwgNTk5LCAyMzIyLCA1OTYsIDIzMjEsIDU5NCwgMjMxOSwgMjMxNywgNjExLCA2MTAsIDYwOCwgNjA2LFxuICAgICAgICAyMzI0LCA2MDMsIDIzMjMsIDYxNSwgNjE0LCA2MTIsIDE2MTcsIDE2MTYsIDE2MTQsIDE2MTIsIDYxNiwgMTYxOSwgMTYxOCwgMjU3NSwgMjUzOCwgMjUzNiwgOTA1LCA5MDEsIDg5OCwgOTA5LFxuICAgICAgICAyNTA5LCAyNTA3LCAyNTA0LCA4NzAsIDg2NywgODY0LCA4NjAsIDI1MTIsIDg3NSwgODcyLCAxNzgxLCAyNDkwLCAyNDg5LCAyNDg3LCAyNDg1LCAxNzQ4LCA4MzYsIDgzNCwgODMyLCA4MzAsXG4gICAgICAgIDI0OTQsIDgyNywgMjQ5MiwgODQzLCA4NDEsIDgzOSwgODQ1LCAxNzY1LCAxNzYzLCAyNzAxLCAyNjc2LCAyNjc0LCAyNjUzLCAyNjQ4LCAyNjU2LCAyNjM0LCAyNjMzLCAyNjMxLCAyNjI5LFxuICAgICAgICAxODIxLCAyNjM4LCAyNjM2LCAyNzcwLCAyNzYzLCAyNzYxLCAyNzUwLCAyNzQ1LCAyNzUzLCAyNzM2LCAyNzM1LCAyNzMzLCAyNzMxLCAxODQ4LCAyNzQwLCAyNzM4LCAyNzg2LCAyNzg0LCA1OTEsXG4gICAgICAgIDU4OCwgNTc2LCA1NjksIDU2NiwgMjI5NiwgMTU5MCwgNTM3LCA1MzQsIDUyNiwgMjI3NiwgNTIyLCAyMjc0LCA1NDUsIDU0MiwgNTM5LCA1NDgsIDE1NzIsIDE1NzAsIDQ4MSwgMjI0NSwgNDY2LFxuICAgICAgICAyMjQyLCA0NjIsIDIyMzksIDQ5MiwgNDg1LCA0ODIsIDIyNDksIDQ5NiwgNDk0LCAxNTM0LCAxNTMxLCAxNTI4LCAxNTM4LCA0MTMsIDIxOTYsIDQwNiwgMjE5MSwgMjE4OCwgNDI1LCA0MTksXG4gICAgICAgIDIyMDIsIDQxNSwgMjE5OSwgNDMyLCA0MzAsIDQyNywgMTQ3MiwgMTQ2NywgMTQ2NCwgNDMzLCAxNDc2LCAxNDc0LCAzNjgsIDM2NywgMjE2MCwgMzY1LCAyMTU5LCAzNjIsIDIxNTcsIDIxNTUsXG4gICAgICAgIDIxNTIsIDM3OCwgMzc3LCAzNzUsIDIxNjYsIDM3MiwgMjE2NSwgMzY5LCAyMTYyLCAzODMsIDM4MSwgMzc5LCAyMTY4LCAxNDE5LCAxNDE4LCAxNDE2LCAxNDE0LCAzODUsIDE0MTEsIDM4NCxcbiAgICAgICAgMTQyMywgMTQyMiwgMTQyMCwgMTQyNCwgMjQ2MSwgODAyLCAyNDQxLCAyNDM5LCA3OTAsIDc4NiwgNzgzLCA3OTQsIDI0MDksIDI0MDYsIDI0MDMsIDc1MCwgNzQyLCA3MzgsIDI0MTQsIDc1NixcbiAgICAgICAgNzUzLCAxNzIwLCAyMzY3LCAyMzY1LCAyMzYyLCAyMzU5LCAxNjYzLCA2OTMsIDY5MSwgNjg0LCAyMzczLCA2ODAsIDIzNzAsIDcwMiwgNjk5LCA2OTYsIDcwNCwgMTY5MCwgMTY4NywgMjMzNyxcbiAgICAgICAgMjMzNiwgMjMzNCwgMjMzMiwgMTYyNCwgMjMyOSwgMTYyMiwgNjQwLCA2MzcsIDIzNDQsIDYzNCwgMjM0MiwgNjMwLCAyMzQwLCA2NTAsIDY0OCwgNjQ1LCAyMzQ2LCA2NTUsIDY1MywgMTY1MyxcbiAgICAgICAgMTY1MSwgMTY0OSwgMTY1NSwgMjYxMiwgMjU5NywgMjU5NSwgMjU3MSwgMjU2OCwgMjU2NSwgMjU3NiwgMjUzNCwgMjUyOSwgMjUyNiwgMTc4NywgMjU0MCwgMjUzNywgOTA3LCA5MDQsIDkwMCxcbiAgICAgICAgOTEwLCAyNTAzLCAyNTAyLCAyNTAwLCAyNDk4LCAxNzY4LCAyNDk1LCAxNzY3LCAyNTEwLCAyNTA4LCAyNTA2LCA4NjksIDg2NiwgODYzLCAyNTEzLCA4NzYsIDg3NCwgMTc4MiwgMjcyMCwgMjcxMyxcbiAgICAgICAgMjcxMSwgMjY5NywgMjY5NCwgMjY5MSwgMjcwMiwgMjY3MiwgMjY3MCwgMjY2NCwgMTgyOCwgMjY3OCwgMjY3NSwgMjY0NywgMjY0NiwgMjY0NCwgMjY0MiwgMTgyMywgMjYzOSwgMTgyMiwgMjY1NCxcbiAgICAgICAgMjY1MiwgMjY1MCwgMjY1NywgMjc3MSwgMTg1NSwgMjc2NSwgMjc2MiwgMTg1MCwgMTg0OSwgMjc1MSwgMjc0OSwgMjc0NywgMjc1NCwgMzUzLCAyMTQ4LCAzNDQsIDM0MiwgMzM2LCAyMTQyLFxuICAgICAgICAzMzIsIDIxNDAsIDM0NSwgMTM3NSwgMTM3MywgMzA2LCAyMTMwLCAyOTksIDIxMjgsIDI5NSwgMjEyNSwgMzE5LCAzMTQsIDMxMSwgMjEzMiwgMTM1NCwgMTM1MiwgMTM0OSwgMTM1NiwgMjYyLFxuICAgICAgICAyNTcsIDIxMDEsIDI1MywgMjA5NiwgMjA5MywgMjc0LCAyNzMsIDI2NywgMjEwNywgMjYzLCAyMTA0LCAyODAsIDI3OCwgMjc1LCAxMzE2LCAxMzExLCAxMzA4LCAxMzIwLCAxMzE4LCAyMDUyLFxuICAgICAgICAyMDIsIDIwNTAsIDIwNDQsIDIwNDAsIDIxOSwgMjA2MywgMjEyLCAyMDYwLCAyMDgsIDIwNTUsIDIyNCwgMjIxLCAyMDY2LCAxMjYwLCAxMjU4LCAxMjUyLCAyMzEsIDEyNDgsIDIyOSwgMTI2NixcbiAgICAgICAgMTI2NCwgMTI2MSwgMTI2OCwgMTU1LCAxOTk4LCAxNTMsIDE5OTYsIDE5OTQsIDE5OTEsIDE5ODgsIDE2NSwgMTY0LCAyMDA3LCAxNjIsIDIwMDYsIDE1OSwgMjAwMywgMjAwMCwgMTcyLCAxNzEsXG4gICAgICAgIDE2OSwgMjAxMiwgMTY2LCAyMDEwLCAxMTg2LCAxMTg0LCAxMTgyLCAxMTc5LCAxNzUsIDExNzYsIDE3MywgMTE5MiwgMTE5MSwgMTE4OSwgMTE4NywgMTc2LCAxMTk0LCAxMTkzLCAyMzEzLFxuICAgICAgICAyMzA3LCAyMzA1LCA1OTIsIDU4OSwgMjI5NCwgMjI5MiwgMjI4OSwgNTc4LCA1NzIsIDU2OCwgMjI5NywgNTgwLCAxNTkxLCAyMjcyLCAyMjY3LCAyMjY0LCAxNTQ3LCA1MzgsIDUzNiwgNTI5LFxuICAgICAgICAyMjc4LCA1MjUsIDIyNzUsIDU0NywgNTQ0LCA1NDEsIDE1NzQsIDE1NzEsIDIyMzcsIDIyMzUsIDIyMjksIDE0OTMsIDIyMjUsIDE0ODksIDQ3OCwgMjI0NywgNDcwLCAyMjQ0LCA0NjUsIDIyNDEsXG4gICAgICAgIDQ5MywgNDg4LCA0ODQsIDIyNTAsIDQ5OCwgNDk1LCAxNTM2LCAxNTMzLCAxNTMwLCAxNTM5LCAyMTg3LCAyMTg2LCAyMTg0LCAyMTgyLCAxNDMyLCAyMTc5LCAxNDMwLCAyMTc2LCAxNDI3LCA0MTQsXG4gICAgICAgIDQxMiwgMjE5NywgNDA5LCAyMTk1LCA0MDUsIDIxOTMsIDIxOTAsIDQyNiwgNDI0LCA0MjEsIDIyMDMsIDQxOCwgMjIwMSwgNDMxLCA0MjksIDE0NzMsIDE0NzEsIDE0NjksIDE0NjYsIDQzNCxcbiAgICAgICAgMTQ3NywgMTQ3NSwgMjQ3OCwgMjQ3MiwgMjQ3MCwgMjQ1OSwgMjQ1NywgMjQ1NCwgMjQ2MiwgODAzLCAyNDM3LCAyNDMyLCAyNDI5LCAxNzI2LCAyNDQzLCAyNDQwLCA3OTIsIDc4OSwgNzg1LFxuICAgICAgICAyNDAxLCAyMzk5LCAyMzkzLCAxNzAyLCAyMzg5LCAxNjk5LCAyNDExLCAyNDA4LCAyNDA1LCA3NDUsIDc0MSwgMjQxNSwgNzU4LCA3NTUsIDE3MjEsIDIzNTgsIDIzNTcsIDIzNTUsIDIzNTMsXG4gICAgICAgIDE2NjEsIDIzNTAsIDE2NjAsIDIzNDcsIDE2NTcsIDIzNjgsIDIzNjYsIDIzNjQsIDIzNjEsIDE2NjYsIDY5MCwgNjg3LCAyMzc0LCA2ODMsIDIzNzIsIDcwMSwgNjk4LCA3MDUsIDE2OTEsIDE2ODksXG4gICAgICAgIDI2MTksIDI2MTcsIDI2MTAsIDI2MDgsIDI2MDUsIDI2MTMsIDI1OTMsIDI1ODgsIDI1ODUsIDE4MDMsIDI1OTksIDI1OTYsIDI1NjMsIDI1NjEsIDI1NTUsIDE3OTcsIDI1NTEsIDE3OTUsIDI1NzMsXG4gICAgICAgIDI1NzAsIDI1NjcsIDI1NzcsIDI1MjUsIDI1MjQsIDI1MjIsIDI1MjAsIDE3ODYsIDI1MTcsIDE3ODUsIDI1MTQsIDE3ODMsIDI1MzUsIDI1MzMsIDI1MzEsIDI1MjgsIDE3ODgsIDI1NDEsIDI1MzksXG4gICAgICAgIDkwNiwgOTAzLCA5MTEsIDI3MjEsIDE4NDQsIDI3MTUsIDI3MTIsIDE4MzgsIDE4MzYsIDI2OTksIDI2OTYsIDI2OTMsIDI3MDMsIDE4MjcsIDE4MjYsIDE4MjQsIDI2NzMsIDI2NzEsIDI2NjksXG4gICAgICAgIDI2NjYsIDE4MjksIDI2NzksIDI2NzcsIDE4NTgsIDE4NTcsIDI3NzIsIDE4NTQsIDE4NTMsIDE4NTEsIDE4NTYsIDI3NjYsIDI3NjQsIDE0MywgMTk4NywgMTM5LCAxOTg2LCAxMzUsIDEzMyxcbiAgICAgICAgMTMxLCAxOTg0LCAxMjgsIDE5ODMsIDEyNSwgMTk4MSwgMTM4LCAxMzcsIDEzNiwgMTk4NSwgMTEzMywgMTEzMiwgMTEzMCwgMTEyLCAxMTAsIDE5NzQsIDEwNywgMTk3MywgMTA0LCAxOTcxLFxuICAgICAgICAxOTY5LCAxMjIsIDEyMSwgMTE5LCAxMTcsIDE5NzcsIDExNCwgMTk3NiwgMTI0LCAxMTE1LCAxMTE0LCAxMTEyLCAxMTEwLCAxMTE3LCAxMTE2LCA4NCwgODMsIDE5NTMsIDgxLCAxOTUyLCA3OCxcbiAgICAgICAgMTk1MCwgMTk0OCwgMTk0NSwgOTQsIDkzLCA5MSwgMTk1OSwgODgsIDE5NTgsIDg1LCAxOTU1LCA5OSwgOTcsIDk1LCAxOTYxLCAxMDg2LCAxMDg1LCAxMDgzLCAxMDgxLCAxMDc4LCAxMDAsXG4gICAgICAgIDEwOTAsIDEwODksIDEwODcsIDEwOTEsIDQ5LCA0NywgMTkxNywgNDQsIDE5MTUsIDE5MTMsIDE5MTAsIDE5MDcsIDU5LCAxOTI2LCA1NiwgMTkyNSwgNTMsIDE5MjIsIDE5MTksIDY2LCA2NCxcbiAgICAgICAgMTkzMSwgNjEsIDE5MjksIDEwNDIsIDEwNDAsIDEwMzgsIDcxLCAxMDM1LCA3MCwgMTAzMiwgNjgsIDEwNDgsIDEwNDcsIDEwNDUsIDEwNDMsIDEwNTAsIDEwNDksIDEyLCAxMCwgMTg2OSwgMTg2NyxcbiAgICAgICAgMTg2NCwgMTg2MSwgMjEsIDE4ODAsIDE5LCAxODc3LCAxODc0LCAxODcxLCAyOCwgMTg4OCwgMjUsIDE4ODYsIDIyLCAxODgzLCA5ODIsIDk4MCwgOTc3LCA5NzQsIDMyLCAzMCwgOTkxLCA5ODksXG4gICAgICAgIDk4NywgOTg0LCAzNCwgOTk1LCA5OTQsIDk5MiwgMjE1MSwgMjE1MCwgMjE0NywgMjE0NiwgMjE0NCwgMzU2LCAzNTUsIDM1NCwgMjE0OSwgMjEzOSwgMjEzOCwgMjEzNiwgMjEzNCwgMTM1OSxcbiAgICAgICAgMzQzLCAzNDEsIDMzOCwgMjE0MywgMzM1LCAyMTQxLCAzNDgsIDM0NywgMzQ2LCAxMzc2LCAxMzc0LCAyMTI0LCAyMTIzLCAyMTIxLCAyMTE5LCAxMzI2LCAyMTE2LCAxMzI0LCAzMTAsIDMwOCxcbiAgICAgICAgMzA1LCAyMTMxLCAzMDIsIDIxMjksIDI5OCwgMjEyNywgMzIwLCAzMTgsIDMxNiwgMzEzLCAyMTMzLCAzMjIsIDMyMSwgMTM1NSwgMTM1MywgMTM1MSwgMTM1NywgMjA5MiwgMjA5MSwgMjA4OSxcbiAgICAgICAgMjA4NywgMTI3NiwgMjA4NCwgMTI3NCwgMjA4MSwgMTI3MSwgMjU5LCAyMTAyLCAyNTYsIDIxMDAsIDI1MiwgMjA5OCwgMjA5NSwgMjcyLCAyNjksIDIxMDgsIDI2NiwgMjEwNiwgMjgxLCAyNzksXG4gICAgICAgIDI3NywgMTMxNywgMTMxNSwgMTMxMywgMTMxMCwgMjgyLCAxMzIxLCAxMzE5LCAyMDM5LCAyMDM3LCAyMDM1LCAyMDMyLCAxMjAzLCAyMDI5LCAxMjAwLCAxMTk3LCAyMDcsIDIwNTMsIDIwNSxcbiAgICAgICAgMjA1MSwgMjAxLCAyMDQ5LCAyMDQ2LCAyMDQzLCAyMjAsIDIxOCwgMjA2NCwgMjE1LCAyMDYyLCAyMTEsIDIwNTksIDIyOCwgMjI2LCAyMjMsIDIwNjksIDEyNTksIDEyNTcsIDEyNTQsIDIzMixcbiAgICAgICAgMTI1MSwgMjMwLCAxMjY3LCAxMjY1LCAxMjYzLCAyMzE2LCAyMzE1LCAyMzEyLCAyMzExLCAyMzA5LCAyMzE0LCAyMzA0LCAyMzAzLCAyMzAxLCAyMjk5LCAxNTkzLCAyMzA4LCAyMzA2LCA1OTAsXG4gICAgICAgIDIyODgsIDIyODcsIDIyODUsIDIyODMsIDE1NzgsIDIyODAsIDE1NzcsIDIyOTUsIDIyOTMsIDIyOTEsIDU3OSwgNTc3LCA1NzQsIDU3MSwgMjI5OCwgNTgyLCA1ODEsIDE1OTIsIDIyNjMsIDIyNjIsXG4gICAgICAgIDIyNjAsIDIyNTgsIDE1NDUsIDIyNTUsIDE1NDQsIDIyNTIsIDE1NDEsIDIyNzMsIDIyNzEsIDIyNjksIDIyNjYsIDE1NTAsIDUzNSwgNTMyLCAyMjc5LCA1MjgsIDIyNzcsIDU0NiwgNTQzLCA1NDksXG4gICAgICAgIDE1NzUsIDE1NzMsIDIyMjQsIDIyMjIsIDIyMjAsIDE0ODYsIDIyMTcsIDE0ODUsIDIyMTQsIDE0ODIsIDE0NzksIDIyMzgsIDIyMzYsIDIyMzQsIDIyMzEsIDE0OTYsIDIyMjgsIDE0OTIsIDQ4MCxcbiAgICAgICAgNDc3LCAyMjQ4LCA0NzMsIDIyNDYsIDQ2OSwgMjI0MywgNDkwLCA0ODcsIDIyNTEsIDQ5NywgMTUzNywgMTUzNSwgMTUzMiwgMjQ3NywgMjQ3NiwgMjQ3NCwgMjQ3OSwgMjQ2OSwgMjQ2OCwgMjQ2NixcbiAgICAgICAgMjQ2NCwgMTczMCwgMjQ3MywgMjQ3MSwgMjQ1MywgMjQ1MiwgMjQ1MCwgMjQ0OCwgMTcyOSwgMjQ0NSwgMTcyOCwgMjQ2MCwgMjQ1OCwgMjQ1NiwgMjQ2MywgODA1LCA4MDQsIDI0MjgsIDI0MjcsXG4gICAgICAgIDI0MjUsIDI0MjMsIDE3MjUsIDI0MjAsIDE3MjQsIDI0MTcsIDE3MjIsIDI0MzgsIDI0MzYsIDI0MzQsIDI0MzEsIDE3MjcsIDI0NDQsIDI0NDIsIDc5MywgNzkxLCA3ODgsIDc5NSwgMjM4OCxcbiAgICAgICAgMjM4NiwgMjM4NCwgMTY5NywgMjM4MSwgMTY5NiwgMjM3OCwgMTY5NCwgMTY5MiwgMjQwMiwgMjQwMCwgMjM5OCwgMjM5NSwgMTcwMywgMjM5MiwgMTcwMSwgMjQxMiwgMjQxMCwgMjQwNywgNzUxLFxuICAgICAgICA3NDgsIDc0NCwgMjQxNiwgNzU5LCA3NTcsIDE4MDcsIDI2MjAsIDI2MTgsIDE4MDYsIDE4MDUsIDI2MTEsIDI2MDksIDI2MDcsIDI2MTQsIDE4MDIsIDE4MDEsIDE3OTksIDI1OTQsIDI1OTIsXG4gICAgICAgIDI1OTAsIDI1ODcsIDE4MDQsIDI2MDAsIDI1OTgsIDE3OTQsIDE3OTMsIDE3OTEsIDE3ODksIDI1NjQsIDI1NjIsIDI1NjAsIDI1NTcsIDE3OTgsIDI1NTQsIDE3OTYsIDI1NzQsIDI1NzIsIDI1NjksXG4gICAgICAgIDI1NzgsIDE4NDcsIDE4NDYsIDI3MjIsIDE4NDMsIDE4NDIsIDE4NDAsIDE4NDUsIDI3MTYsIDI3MTQsIDE4MzUsIDE4MzQsIDE4MzIsIDE4MzAsIDE4MzksIDE4MzcsIDI3MDAsIDI2OTgsIDI2OTUsXG4gICAgICAgIDI3MDQsIDE4MTcsIDE4MTEsIDE4MTAsIDg5NywgODYyLCAxNzc3LCA4MjksIDgyNiwgODM4LCAxNzYwLCAxNzU4LCA4MDgsIDI0ODEsIDE3NDEsIDE3NDAsIDE3MzgsIDE3NDMsIDI2MjQsIDE4MTgsXG4gICAgICAgIDI3MjYsIDI3NzYsIDc4MiwgNzQwLCA3MzcsIDE3MTUsIDY4NiwgNjc5LCA2OTUsIDE2ODIsIDE2ODAsIDYzOSwgNjI4LCAyMzM5LCA2NDcsIDY0NCwgMTY0NSwgMTY0MywgMTY0MCwgMTY0OCxcbiAgICAgICAgNjAyLCA2MDAsIDU5NywgNTk1LCAyMzIwLCA1OTMsIDIzMTgsIDYwOSwgNjA3LCA2MDQsIDE2MTEsIDE2MTAsIDE2MDgsIDE2MDYsIDYxMywgMTYxNSwgMTYxMywgMjMyOCwgOTI2LCA5MjQsIDg5MixcbiAgICAgICAgODg2LCA4OTksIDg1NywgODUwLCAyNTA1LCAxNzc4LCA4MjQsIDgyMywgODIxLCA4MTksIDI0ODgsIDgxOCwgMjQ4NiwgODMzLCA4MzEsIDgyOCwgODQwLCAxNzYxLCAxNzU5LCAyNjQ5LCAyNjMyLFxuICAgICAgICAyNjMwLCAyNzQ2LCAyNzM0LCAyNzMyLCAyNzgyLCAyNzgxLCA1NzAsIDU2NywgMTU4NywgNTMxLCA1MjcsIDUyMywgNTQwLCAxNTY2LCAxNTY0LCA0NzYsIDQ2NywgNDYzLCAyMjQwLCA0ODYsXG4gICAgICAgIDQ4MywgMTUyNCwgMTUyMSwgMTUxOCwgMTUyOSwgNDExLCA0MDMsIDIxOTIsIDM5OSwgMjE4OSwgNDIzLCA0MTYsIDE0NjIsIDE0NTcsIDE0NTQsIDQyOCwgMTQ2OCwgMTQ2NSwgMjIxMCwgMzY2LFxuICAgICAgICAzNjMsIDIxNTgsIDM2MCwgMjE1NiwgMzU3LCAyMTUzLCAzNzYsIDM3MywgMzcwLCAyMTYzLCAxNDEwLCAxNDA5LCAxNDA3LCAxNDA1LCAzODIsIDE0MDIsIDM4MCwgMTQxNywgMTQxNSwgMTQxMixcbiAgICAgICAgMTQyMSwgMjE3NSwgMjE3NCwgNzc3LCA3NzQsIDc3MSwgNzg0LCA3MzIsIDcyNSwgNzIyLCAyNDA0LCA3NDMsIDE3MTYsIDY3NiwgNjc0LCA2NjgsIDIzNjMsIDY2NSwgMjM2MCwgNjg1LCAxNjg0LFxuICAgICAgICAxNjgxLCA2MjYsIDYyNCwgNjIyLCAyMzM1LCA2MjAsIDIzMzMsIDYxNywgMjMzMCwgNjQxLCA2MzUsIDY0OSwgMTY0NiwgMTY0NCwgMTY0MiwgMjU2NiwgOTI4LCA5MjUsIDI1MzAsIDI1MjcsXG4gICAgICAgIDg5NCwgODkxLCA4ODgsIDI1MDEsIDI0OTksIDI0OTYsIDg1OCwgODU2LCA4NTQsIDg1MSwgMTc3OSwgMjY5MiwgMjY2OCwgMjY2NSwgMjY0NSwgMjY0MywgMjY0MCwgMjY1MSwgMjc2OCwgMjc1OSxcbiAgICAgICAgMjc1NywgMjc0NCwgMjc0MywgMjc0MSwgMjc0OCwgMzUyLCAxMzgyLCAzNDAsIDMzNywgMzMzLCAxMzcxLCAxMzY5LCAzMDcsIDMwMCwgMjk2LCAyMTI2LCAzMTUsIDMxMiwgMTM0NywgMTM0MixcbiAgICAgICAgMTM1MCwgMjYxLCAyNTgsIDI1MCwgMjA5NywgMjQ2LCAyMDk0LCAyNzEsIDI2OCwgMjY0LCAxMzA2LCAxMzAxLCAxMjk4LCAyNzYsIDEzMTIsIDEzMDksIDIxMTUsIDIwMywgMjA0OCwgMTk1LFxuICAgICAgICAyMDQ1LCAxOTEsIDIwNDEsIDIxMywgMjA5LCAyMDU2LCAxMjQ2LCAxMjQ0LCAxMjM4LCAyMjUsIDEyMzQsIDIyMiwgMTI1NiwgMTI1MywgMTI0OSwgMTI2MiwgMjA4MCwgMjA3OSwgMTU0LCAxOTk3LFxuICAgICAgICAxNTAsIDE5OTUsIDE0NywgMTk5MiwgMTk4OSwgMTYzLCAxNjAsIDIwMDQsIDE1NiwgMjAwMSwgMTE3NSwgMTE3NCwgMTE3MiwgMTE3MCwgMTE2NywgMTcwLCAxMTY0LCAxNjcsIDExODUsIDExODMsXG4gICAgICAgIDExODAsIDExNzcsIDE3NCwgMTE5MCwgMTE4OCwgMjAyNSwgMjAyNCwgMjAyMiwgNTg3LCA1ODYsIDU2NCwgNTU5LCA1NTYsIDIyOTAsIDU3MywgMTU4OCwgNTIwLCA1MTgsIDUxMiwgMjI2OCxcbiAgICAgICAgNTA4LCAyMjY1LCA1MzAsIDE1NjgsIDE1NjUsIDQ2MSwgNDU3LCAyMjMzLCA0NTAsIDIyMzAsIDQ0NiwgMjIyNiwgNDc5LCA0NzEsIDQ4OSwgMTUyNiwgMTUyMywgMTUyMCwgMzk3LCAzOTUsXG4gICAgICAgIDIxODUsIDM5MiwgMjE4MywgMzg5LCAyMTgwLCAyMTc3LCA0MTAsIDIxOTQsIDQwMiwgNDIyLCAxNDYzLCAxNDYxLCAxNDU5LCAxNDU2LCAxNDcwLCAyNDU1LCA3OTksIDI0MzMsIDI0MzAsIDc3OSxcbiAgICAgICAgNzc2LCA3NzMsIDIzOTcsIDIzOTQsIDIzOTAsIDczNCwgNzI4LCA3MjQsIDc0NiwgMTcxNywgMjM1NiwgMjM1NCwgMjM1MSwgMjM0OCwgMTY1OCwgNjc3LCA2NzUsIDY3MywgNjcwLCA2NjcsIDY4OCxcbiAgICAgICAgMTY4NSwgMTY4MywgMjYwNiwgMjU4OSwgMjU4NiwgMjU1OSwgMjU1NiwgMjU1MiwgOTI3LCAyNTIzLCAyNTIxLCAyNTE4LCAyNTE1LCAxNzg0LCAyNTMyLCA4OTUsIDg5MywgODkwLCAyNzE4LFxuICAgICAgICAyNzA5LCAyNzA3LCAyNjg5LCAyNjg3LCAyNjg0LCAyNjYzLCAyNjYyLCAyNjYwLCAyNjU4LCAxODI1LCAyNjY3LCAyNzY5LCAxODUyLCAyNzYwLCAyNzU4LCAxNDIsIDE0MSwgMTEzOSwgMTEzOCxcbiAgICAgICAgMTM0LCAxMzIsIDEyOSwgMTI2LCAxOTgyLCAxMTI5LCAxMTI4LCAxMTI2LCAxMTMxLCAxMTMsIDExMSwgMTA4LCAxMDUsIDE5NzIsIDEwMSwgMTk3MCwgMTIwLCAxMTgsIDExNSwgMTEwOSwgMTEwOCxcbiAgICAgICAgMTEwNiwgMTEwNCwgMTIzLCAxMTEzLCAxMTExLCA4MiwgNzksIDE5NTEsIDc1LCAxOTQ5LCA3MiwgMTk0NiwgOTIsIDg5LCA4NiwgMTk1NiwgMTA3NywgMTA3NiwgMTA3NCwgMTA3MiwgOTgsXG4gICAgICAgIDEwNjksIDk2LCAxMDg0LCAxMDgyLCAxMDc5LCAxMDg4LCAxOTY4LCAxOTY3LCA0OCwgNDUsIDE5MTYsIDQyLCAxOTE0LCAzOSwgMTkxMSwgMTkwOCwgNjAsIDU3LCA1NCwgMTkyMywgNTAsIDE5MjAsXG4gICAgICAgIDEwMzEsIDEwMzAsIDEwMjgsIDEwMjYsIDY3LCAxMDIzLCA2NSwgMTAyMCwgNjIsIDEwNDEsIDEwMzksIDEwMzYsIDEwMzMsIDY5LCAxMDQ2LCAxMDQ0LCAxOTQ0LCAxOTQzLCAxOTQxLCAxMSwgOSxcbiAgICAgICAgMTg2OCwgNywgMTg2NSwgMTg2MiwgMTg1OSwgMjAsIDE4NzgsIDE2LCAxODc1LCAxMywgMTg3MiwgOTcwLCA5NjgsIDk2NiwgOTYzLCAyOSwgOTYwLCAyNiwgMjMsIDk4MywgOTgxLCA5NzgsIDk3NSxcbiAgICAgICAgMzMsIDk3MSwgMzEsIDk5MCwgOTg4LCA5ODUsIDE5MDYsIDE5MDQsIDE5MDIsIDk5MywgMzUxLCAyMTQ1LCAxMzgzLCAzMzEsIDMzMCwgMzI4LCAzMjYsIDIxMzcsIDMyMywgMjEzNSwgMzM5LFxuICAgICAgICAxMzcyLCAxMzcwLCAyOTQsIDI5MywgMjkxLCAyODksIDIxMjIsIDI4NiwgMjEyMCwgMjgzLCAyMTE3LCAzMDksIDMwMywgMzE3LCAxMzQ4LCAxMzQ2LCAxMzQ0LCAyNDUsIDI0NCwgMjQyLCAyMDkwLFxuICAgICAgICAyMzksIDIwODgsIDIzNiwgMjA4NSwgMjA4MiwgMjYwLCAyMDk5LCAyNDksIDI3MCwgMTMwNywgMTMwNSwgMTMwMywgMTMwMCwgMTMxNCwgMTg5LCAyMDM4LCAxODYsIDIwMzYsIDE4MywgMjAzMyxcbiAgICAgICAgMjAzMCwgMjAyNiwgMjA2LCAxOTgsIDIwNDcsIDE5NCwgMjE2LCAxMjQ3LCAxMjQ1LCAxMjQzLCAxMjQwLCAyMjcsIDEyMzcsIDEyNTUsIDIzMTAsIDIzMDIsIDIzMDAsIDIyODYsIDIyODQsXG4gICAgICAgIDIyODEsIDU2NSwgNTYzLCA1NjEsIDU1OCwgNTc1LCAxNTg5LCAyMjYxLCAyMjU5LCAyMjU2LCAyMjUzLCAxNTQyLCA1MjEsIDUxOSwgNTE3LCA1MTQsIDIyNzAsIDUxMSwgNTMzLCAxNTY5LFxuICAgICAgICAxNTY3LCAyMjIzLCAyMjIxLCAyMjE4LCAyMjE1LCAxNDgzLCAyMjExLCAxNDgwLCA0NTksIDQ1NiwgNDUzLCAyMjMyLCA0NDksIDQ3NCwgNDkxLCAxNTI3LCAxNTI1LCAxNTIyLCAyNDc1LCAyNDY3LFxuICAgICAgICAyNDY1LCAyNDUxLCAyNDQ5LCAyNDQ2LCA4MDEsIDgwMCwgMjQyNiwgMjQyNCwgMjQyMSwgMjQxOCwgMTcyMywgMjQzNSwgNzgwLCA3NzgsIDc3NSwgMjM4NywgMjM4NSwgMjM4MiwgMjM3OSxcbiAgICAgICAgMTY5NSwgMjM3NSwgMTY5MywgMjM5NiwgNzM1LCA3MzMsIDczMCwgNzI3LCA3NDksIDE3MTgsIDI2MTYsIDI2MTUsIDI2MDQsIDI2MDMsIDI2MDEsIDI1ODQsIDI1ODMsIDI1ODEsIDI1NzksXG4gICAgICAgIDE4MDAsIDI1OTEsIDI1NTAsIDI1NDksIDI1NDcsIDI1NDUsIDE3OTIsIDI1NDIsIDE3OTAsIDI1NTgsIDkyOSwgMjcxOSwgMTg0MSwgMjcxMCwgMjcwOCwgMTgzMywgMTgzMSwgMjY5MCwgMjY4OCxcbiAgICAgICAgMjY4NiwgMTgxNSwgMTgwOSwgMTgwOCwgMTc3NCwgMTc1NiwgMTc1NCwgMTczNywgMTczNiwgMTczNCwgMTczOSwgMTgxNiwgMTcxMSwgMTY3NiwgMTY3NCwgNjMzLCA2MjksIDE2MzgsIDE2MzYsXG4gICAgICAgIDE2MzMsIDE2NDEsIDU5OCwgMTYwNSwgMTYwNCwgMTYwMiwgMTYwMCwgNjA1LCAxNjA5LCAxNjA3LCAyMzI3LCA4ODcsIDg1MywgMTc3NSwgODIyLCA4MjAsIDE3NTcsIDE3NTUsIDE1ODQsIDUyNCxcbiAgICAgICAgMTU2MCwgMTU1OCwgNDY4LCA0NjQsIDE1MTQsIDE1MTEsIDE1MDgsIDE1MTksIDQwOCwgNDA0LCA0MDAsIDE0NTIsIDE0NDcsIDE0NDQsIDQxNywgMTQ1OCwgMTQ1NSwgMjIwOCwgMzY0LCAzNjEsXG4gICAgICAgIDM1OCwgMjE1NCwgMTQwMSwgMTQwMCwgMTM5OCwgMTM5NiwgMzc0LCAxMzkzLCAzNzEsIDE0MDgsIDE0MDYsIDE0MDMsIDE0MTMsIDIxNzMsIDIxNzIsIDc3MiwgNzI2LCA3MjMsIDE3MTIsIDY3MixcbiAgICAgICAgNjY5LCA2NjYsIDY4MiwgMTY3OCwgMTY3NSwgNjI1LCA2MjMsIDYyMSwgNjE4LCAyMzMxLCA2MzYsIDYzMiwgMTYzOSwgMTYzNywgMTYzNSwgOTIwLCA5MTgsIDg4NCwgODgwLCA4ODksIDg0OSxcbiAgICAgICAgODQ4LCA4NDcsIDg0NiwgMjQ5NywgODU1LCA4NTIsIDE3NzYsIDI2NDEsIDI3NDIsIDI3ODcsIDEzODAsIDMzNCwgMTM2NywgMTM2NSwgMzAxLCAyOTcsIDEzNDAsIDEzMzgsIDEzMzUsIDEzNDMsXG4gICAgICAgIDI1NSwgMjUxLCAyNDcsIDEyOTYsIDEyOTEsIDEyODgsIDI2NSwgMTMwMiwgMTI5OSwgMjExMywgMjA0LCAxOTYsIDE5MiwgMjA0MiwgMTIzMiwgMTIzMCwgMTIyNCwgMjE0LCAxMjIwLCAyMTAsXG4gICAgICAgIDEyNDIsIDEyMzksIDEyMzUsIDEyNTAsIDIwNzcsIDIwNzUsIDE1MSwgMTQ4LCAxOTkzLCAxNDQsIDE5OTAsIDExNjMsIDExNjIsIDExNjAsIDExNTgsIDExNTUsIDE2MSwgMTE1MiwgMTU3LFxuICAgICAgICAxMTczLCAxMTcxLCAxMTY4LCAxMTY1LCAxNjgsIDExODEsIDExNzgsIDIwMjEsIDIwMjAsIDIwMTgsIDIwMjMsIDU4NSwgNTYwLCA1NTcsIDE1ODUsIDUxNiwgNTA5LCAxNTYyLCAxNTU5LCA0NTgsXG4gICAgICAgIDQ0NywgMjIyNywgNDcyLCAxNTE2LCAxNTEzLCAxNTEwLCAzOTgsIDM5NiwgMzkzLCAzOTAsIDIxODEsIDM4NiwgMjE3OCwgNDA3LCAxNDUzLCAxNDUxLCAxNDQ5LCAxNDQ2LCA0MjAsIDE0NjAsXG4gICAgICAgIDIyMDksIDc2OSwgNzY0LCA3MjAsIDcxMiwgMjM5MSwgNzI5LCAxNzEzLCA2NjQsIDY2MywgNjYxLCA2NTksIDIzNTIsIDY1NiwgMjM0OSwgNjcxLCAxNjc5LCAxNjc3LCAyNTUzLCA5MjIsIDkxOSxcbiAgICAgICAgMjUxOSwgMjUxNiwgODg1LCA4ODMsIDg4MSwgMjY4NSwgMjY2MSwgMjY1OSwgMjc2NywgMjc1NiwgMjc1NSwgMTQwLCAxMTM3LCAxMTM2LCAxMzAsIDEyNywgMTEyNSwgMTEyNCwgMTEyMiwgMTEyNyxcbiAgICAgICAgMTA5LCAxMDYsIDEwMiwgMTEwMywgMTEwMiwgMTEwMCwgMTA5OCwgMTE2LCAxMTA3LCAxMTA1LCAxOTgwLCA4MCwgNzYsIDczLCAxOTQ3LCAxMDY4LCAxMDY3LCAxMDY1LCAxMDYzLCA5MCwgMTA2MCxcbiAgICAgICAgODcsIDEwNzUsIDEwNzMsIDEwNzAsIDEwODAsIDE5NjYsIDE5NjUsIDQ2LCA0MywgNDAsIDE5MTIsIDM2LCAxOTA5LCAxMDE5LCAxMDE4LCAxMDE2LCAxMDE0LCA1OCwgMTAxMSwgNTUsIDEwMDgsXG4gICAgICAgIDUxLCAxMDI5LCAxMDI3LCAxMDI0LCAxMDIxLCA2MywgMTAzNywgMTAzNCwgMTk0MCwgMTkzOSwgMTkzNywgMTk0MiwgOCwgMTg2NiwgNCwgMTg2MywgMSwgMTg2MCwgOTU2LCA5NTQsIDk1MixcbiAgICAgICAgOTQ5LCA5NDYsIDE3LCAxNCwgOTY5LCA5NjcsIDk2NCwgOTYxLCAyNywgOTU3LCAyNCwgOTc5LCA5NzYsIDk3MiwgMTkwMSwgMTkwMCwgMTg5OCwgMTg5NiwgOTg2LCAxOTA1LCAxOTAzLCAzNTAsXG4gICAgICAgIDM0OSwgMTM4MSwgMzI5LCAzMjcsIDMyNCwgMTM2OCwgMTM2NiwgMjkyLCAyOTAsIDI4NywgMjg0LCAyMTE4LCAzMDQsIDEzNDEsIDEzMzksIDEzMzcsIDEzNDUsIDI0MywgMjQwLCAyMzcsIDIwODYsXG4gICAgICAgIDIzMywgMjA4MywgMjU0LCAxMjk3LCAxMjk1LCAxMjkzLCAxMjkwLCAxMzA0LCAyMTE0LCAxOTAsIDE4NywgMTg0LCAyMDM0LCAxODAsIDIwMzEsIDE3NywgMjAyNywgMTk5LCAxMjMzLCAxMjMxLFxuICAgICAgICAxMjI5LCAxMjI2LCAyMTcsIDEyMjMsIDEyNDEsIDIwNzgsIDIwNzYsIDU4NCwgNTU1LCA1NTQsIDU1MiwgNTUwLCAyMjgyLCA1NjIsIDE1ODYsIDUwNywgNTA2LCA1MDQsIDUwMiwgMjI1NywgNDk5LFxuICAgICAgICAyMjU0LCA1MTUsIDE1NjMsIDE1NjEsIDQ0NSwgNDQzLCA0NDEsIDIyMTksIDQzOCwgMjIxNiwgNDM1LCAyMjEyLCA0NjAsIDQ1NCwgNDc1LCAxNTE3LCAxNTE1LCAxNTEyLCAyNDQ3LCA3OTgsXG4gICAgICAgIDc5NywgMjQyMiwgMjQxOSwgNzcwLCA3NjgsIDc2NiwgMjM4MywgMjM4MCwgMjM3NiwgNzIxLCA3MTksIDcxNywgNzE0LCA3MzEsIDE3MTQsIDI2MDIsIDI1ODIsIDI1ODAsIDI1NDgsIDI1NDYsXG4gICAgICAgIDI1NDMsIDkyMywgOTIxLCAyNzE3LCAyNzA2LCAyNzA1LCAyNjgzLCAyNjgyLCAyNjgwLCAxNzcxLCAxNzUyLCAxNzUwLCAxNzMzLCAxNzMyLCAxNzMxLCAxNzM1LCAxODE0LCAxNzA3LCAxNjcwLFxuICAgICAgICAxNjY4LCAxNjMxLCAxNjI5LCAxNjI2LCAxNjM0LCAxNTk5LCAxNTk4LCAxNTk2LCAxNTk0LCAxNjAzLCAxNjAxLCAyMzI2LCAxNzcyLCAxNzUzLCAxNzUxLCAxNTgxLCAxNTU0LCAxNTUyLCAxNTA0LFxuICAgICAgICAxNTAxLCAxNDk4LCAxNTA5LCAxNDQyLCAxNDM3LCAxNDM0LCA0MDEsIDE0NDgsIDE0NDUsIDIyMDYsIDEzOTIsIDEzOTEsIDEzODksIDEzODcsIDEzODQsIDM1OSwgMTM5OSwgMTM5NywgMTM5NCxcbiAgICAgICAgMTQwNCwgMjE3MSwgMjE3MCwgMTcwOCwgMTY3MiwgMTY2OSwgNjE5LCAxNjMyLCAxNjMwLCAxNjI4LCAxNzczLCAxMzc4LCAxMzYzLCAxMzYxLCAxMzMzLCAxMzI4LCAxMzM2LCAxMjg2LCAxMjgxLFxuICAgICAgICAxMjc4LCAyNDgsIDEyOTIsIDEyODksIDIxMTEsIDEyMTgsIDEyMTYsIDEyMTAsIDE5NywgMTIwNiwgMTkzLCAxMjI4LCAxMjI1LCAxMjIxLCAxMjM2LCAyMDczLCAyMDcxLCAxMTUxLCAxMTUwLFxuICAgICAgICAxMTQ4LCAxMTQ2LCAxNTIsIDExNDMsIDE0OSwgMTE0MCwgMTQ1LCAxMTYxLCAxMTU5LCAxMTU2LCAxMTUzLCAxNTgsIDExNjksIDExNjYsIDIwMTcsIDIwMTYsIDIwMTQsIDIwMTksIDE1ODIsXG4gICAgICAgIDUxMCwgMTU1NiwgMTU1MywgNDUyLCA0NDgsIDE1MDYsIDE1MDAsIDM5NCwgMzkxLCAzODcsIDE0NDMsIDE0NDEsIDE0MzksIDE0MzYsIDE0NTAsIDIyMDcsIDc2NSwgNzE2LCA3MTMsIDE3MDksXG4gICAgICAgIDY2MiwgNjYwLCA2NTcsIDE2NzMsIDE2NzEsIDkxNiwgOTE0LCA4NzksIDg3OCwgODc3LCA4ODIsIDExMzUsIDExMzQsIDExMjEsIDExMjAsIDExMTgsIDExMjMsIDEwOTcsIDEwOTYsIDEwOTQsXG4gICAgICAgIDEwOTIsIDEwMywgMTEwMSwgMTA5OSwgMTk3OSwgMTA1OSwgMTA1OCwgMTA1NiwgMTA1NCwgNzcsIDEwNTEsIDc0LCAxMDY2LCAxMDY0LCAxMDYxLCAxMDcxLCAxOTY0LCAxOTYzLCAxMDA3LFxuICAgICAgICAxMDA2LCAxMDA0LCAxMDAyLCA5OTksIDQxLCA5OTYsIDM3LCAxMDE3LCAxMDE1LCAxMDEyLCAxMDA5LCA1MiwgMTAyNSwgMTAyMiwgMTkzNiwgMTkzNSwgMTkzMywgMTkzOCwgOTQyLCA5NDAsXG4gICAgICAgIDkzOCwgOTM1LCA5MzIsIDUsIDIsIDk1NSwgOTUzLCA5NTAsIDk0NywgMTgsIDk0MywgMTUsIDk2NSwgOTYyLCA5NTgsIDE4OTUsIDE4OTQsIDE4OTIsIDE4OTAsIDk3MywgMTg5OSwgMTg5NyxcbiAgICAgICAgMTM3OSwgMzI1LCAxMzY0LCAxMzYyLCAyODgsIDI4NSwgMTMzNCwgMTMzMiwgMTMzMCwgMjQxLCAyMzgsIDIzNCwgMTI4NywgMTI4NSwgMTI4MywgMTI4MCwgMTI5NCwgMjExMiwgMTg4LCAxODUsXG4gICAgICAgIDE4MSwgMTc4LCAyMDI4LCAxMjE5LCAxMjE3LCAxMjE1LCAxMjEyLCAyMDAsIDEyMDksIDEyMjcsIDIwNzQsIDIwNzIsIDU4MywgNTUzLCA1NTEsIDE1ODMsIDUwNSwgNTAzLCA1MDAsIDUxMyxcbiAgICAgICAgMTU1NywgMTU1NSwgNDQ0LCA0NDIsIDQzOSwgNDM2LCAyMjEzLCA0NTUsIDQ1MSwgMTUwNywgMTUwNSwgMTUwMiwgNzk2LCA3NjMsIDc2MiwgNzYwLCA3NjcsIDcxMSwgNzEwLCA3MDgsIDcwNixcbiAgICAgICAgMjM3NywgNzE4LCA3MTUsIDE3MTAsIDI1NDQsIDkxNywgOTE1LCAyNjgxLCAxNjI3LCAxNTk3LCAxNTk1LCAyMzI1LCAxNzY5LCAxNzQ5LCAxNzQ3LCAxNDk5LCAxNDM4LCAxNDM1LCAyMjA0LFxuICAgICAgICAxMzkwLCAxMzg4LCAxMzg1LCAxMzk1LCAyMTY5LCAyMTY3LCAxNzA0LCAxNjY1LCAxNjYyLCAxNjI1LCAxNjIzLCAxNjIwLCAxNzcwLCAxMzI5LCAxMjgyLCAxMjc5LCAyMTA5LCAxMjE0LCAxMjA3LFxuICAgICAgICAxMjIyLCAyMDY4LCAyMDY1LCAxMTQ5LCAxMTQ3LCAxMTQ0LCAxMTQxLCAxNDYsIDExNTcsIDExNTQsIDIwMTMsIDIwMTEsIDIwMDgsIDIwMTUsIDE1NzksIDE1NDksIDE1NDYsIDE0OTUsIDE0ODcsXG4gICAgICAgIDE0MzMsIDE0MzEsIDE0MjgsIDE0MjUsIDM4OCwgMTQ0MCwgMjIwNSwgMTcwNSwgNjU4LCAxNjY3LCAxNjY0LCAxMTE5LCAxMDk1LCAxMDkzLCAxOTc4LCAxMDU3LCAxMDU1LCAxMDUyLCAxMDYyLFxuICAgICAgICAxOTYyLCAxOTYwLCAxMDA1LCAxMDAzLCAxMDAwLCA5OTcsIDM4LCAxMDEzLCAxMDEwLCAxOTMyLCAxOTMwLCAxOTI3LCAxOTM0LCA5NDEsIDkzOSwgOTM2LCA5MzMsIDYsIDkzMCwgMywgOTUxLFxuICAgICAgICA5NDgsIDk0NCwgMTg4OSwgMTg4NywgMTg4NCwgMTg4MSwgOTU5LCAxODkzLCAxODkxLCAzNSwgMTM3NywgMTM2MCwgMTM1OCwgMTMyNywgMTMyNSwgMTMyMiwgMTMzMSwgMTI3NywgMTI3NSxcbiAgICAgICAgMTI3MiwgMTI2OSwgMjM1LCAxMjg0LCAyMTEwLCAxMjA1LCAxMjA0LCAxMjAxLCAxMTk4LCAxODIsIDExOTUsIDE3OSwgMTIxMywgMjA3MCwgMjA2NywgMTU4MCwgNTAxLCAxNTUxLCAxNTQ4LFxuICAgICAgICA0NDAsIDQzNywgMTQ5NywgMTQ5NCwgMTQ5MCwgMTUwMywgNzYxLCA3MDksIDcwNywgMTcwNiwgOTEzLCA5MTIsIDIxOTgsIDEzODYsIDIxNjQsIDIxNjEsIDE2MjEsIDE3NjYsIDIxMDMsIDEyMDgsXG4gICAgICAgIDIwNTgsIDIwNTQsIDExNDUsIDExNDIsIDIwMDUsIDIwMDIsIDE5OTksIDIwMDksIDE0ODgsIDE0MjksIDE0MjYsIDIyMDAsIDE2OTgsIDE2NTksIDE2NTYsIDE5NzUsIDEwNTMsIDE5NTcsIDE5NTQsXG4gICAgICAgIDEwMDEsIDk5OCwgMTkyNCwgMTkyMSwgMTkxOCwgMTkyOCwgOTM3LCA5MzQsIDkzMSwgMTg3OSwgMTg3NiwgMTg3MywgMTg3MCwgOTQ1LCAxODg1LCAxODgyLCAxMzIzLCAxMjczLCAxMjcwLFxuICAgICAgICAyMTA1LCAxMjAyLCAxMTk5LCAxMTk2LCAxMjExLCAyMDYxLCAyMDU3LCAxNTc2LCAxNTQzLCAxNTQwLCAxNDg0LCAxNDgxLCAxNDc4LCAxNDkxLCAxNzAwXG4gICAgXSk7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBQREY0MTdEZXRlY3RvclJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJpdHMsIHBvaW50cykge1xuICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB9XG4gICAgICAgIGdldEJpdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xuICAgICAgICB9XG4gICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlzO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcbiAgICAvKipcbiAgICAgKiA8cD5FbmNhcHN1bGF0ZXMgbG9naWMgdGhhdCBjYW4gZGV0ZWN0IGEgUERGNDE3IENvZGUgaW4gYW4gaW1hZ2UsIGV2ZW4gaWYgdGhlXG4gICAgICogUERGNDE3IENvZGUgaXMgcm90YXRlZCBvciBza2V3ZWQsIG9yIHBhcnRpYWxseSBvYnNjdXJlZC48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNJVEEgTGFiIChrZXZpbi5vc3VsbGl2YW5Ac2l0YS5hZXJvKVxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypwdWJsaWMqLyAvKmZpbmFsKi8gY2xhc3MgRGV0ZWN0b3IkMyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5EZXRlY3RzIGEgUERGNDE3IENvZGUgaW4gYW4gaW1hZ2UuIE9ubHkgY2hlY2tzIDAgYW5kIDE4MCBkZWdyZWUgcm90YXRpb25zLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIGJhcmNvZGUgaW1hZ2UgdG8gZGVjb2RlXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBvcHRpb25hbCBoaW50cyB0byBkZXRlY3RvclxuICAgICAgICAgKiBAcGFyYW0gbXVsdGlwbGUgaWYgdHJ1ZSwgdGhlbiB0aGUgaW1hZ2UgaXMgc2VhcmNoZWQgZm9yIG11bHRpcGxlIGNvZGVzLiBJZiBmYWxzZSwgdGhlbiBhdCBtb3N0IG9uZSBjb2RlIHdpbGxcbiAgICAgICAgICogYmUgZm91bmQgYW5kIHJldHVybmVkXG4gICAgICAgICAqIEByZXR1cm4ge0BsaW5rIFBERjQxN0RldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgUERGNDE3IGNvZGVcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBQREY0MTcgQ29kZSBjYW4gYmUgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZXRlY3RNdWx0aXBsZShpbWFnZSwgaGludHMsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGRldGVjdGlvbiBpbXByb3ZlbWVudCwgdHJ5SGFyZGVyIGNvdWxkIHRyeSBzZXZlcmFsIGRpZmZlcmVudCBsdW1pbmFuY2UgdGhyZXNob2xkcy9ibGFja3BvaW50cyBvciBldmVuXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgYmluYXJpemVyc1xuICAgICAgICAgICAgLy8gYm9vbGVhbiB0cnlIYXJkZXIgPSBoaW50cyAhPSBudWxsICYmIGhpbnRzLmNvbnRhaW5zS2V5KERlY29kZUhpbnRUeXBlLlRSWV9IQVJERVIpO1xuICAgICAgICAgICAgbGV0IGJpdE1hdHJpeCA9IGltYWdlLmdldEJsYWNrTWF0cml4KCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZUNvb3JkaW5hdGVzID0gRGV0ZWN0b3IkMy5kZXRlY3QobXVsdGlwbGUsIGJpdE1hdHJpeCk7XG4gICAgICAgICAgICBpZiAoIWJhcmNvZGVDb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBiaXRNYXRyaXggPSBiaXRNYXRyaXguY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBiaXRNYXRyaXgucm90YXRlMTgwKCk7XG4gICAgICAgICAgICAgICAgYmFyY29kZUNvb3JkaW5hdGVzID0gRGV0ZWN0b3IkMy5kZXRlY3QobXVsdGlwbGUsIGJpdE1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBERjQxN0RldGVjdG9yUmVzdWx0KGJpdE1hdHJpeCwgYmFyY29kZUNvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0cyBQREY0MTcgY29kZXMgaW4gYW4gaW1hZ2UuIE9ubHkgY2hlY2tzIDAgZGVncmVlIHJvdGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBtdWx0aXBsZSBpZiB0cnVlLCB0aGVuIHRoZSBpbWFnZSBpcyBzZWFyY2hlZCBmb3IgbXVsdGlwbGUgY29kZXMuIElmIGZhbHNlLCB0aGVuIGF0IG1vc3Qgb25lIGNvZGUgd2lsbFxuICAgICAgICAgKiBiZSBmb3VuZCBhbmQgcmV0dXJuZWRcbiAgICAgICAgICogQHBhcmFtIGJpdE1hdHJpeCBiaXQgbWF0cml4IHRvIGRldGVjdCBiYXJjb2RlcyBpblxuICAgICAgICAgKiBAcmV0dXJuIExpc3Qgb2YgUmVzdWx0UG9pbnQgYXJyYXlzIGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIGZvdW5kIGJhcmNvZGVzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGV0ZWN0KG11bHRpcGxlLCBiaXRNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhcmNvZGVDb29yZGluYXRlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICAgICAgICBsZXQgY29sdW1uID0gMDtcbiAgICAgICAgICAgIGxldCBmb3VuZEJhcmNvZGVJblJvdyA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHJvdyA8IGJpdE1hdHJpeC5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2VzID0gRGV0ZWN0b3IkMy5maW5kVmVydGljZXMoYml0TWF0cml4LCByb3csIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzWzBdID09IG51bGwgJiYgdmVydGljZXNbM10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kQmFyY29kZUluUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkaWRuJ3QgZmluZCBhbnkgYmFyY29kZSBzbyB0aGF0J3MgdGhlIGVuZCBvZiBzZWFyY2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZG4ndCBmaW5kIGEgYmFyY29kZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gY29sdW1uIGFuZCByb3cuIFRyeSBhZ2FpbiBmcm9tIHRoZSBmaXJzdCBjb2x1bW4gYW5kIHNsaWdodGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlbG93IHRoZSBsb3dlc3QgYmFyY29kZSB3ZSBmb3VuZCBzbyBmYXIuXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQmFyY29kZUluUm93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmFyY29kZUNvb3JkaW5hdGUgb2YgYmFyY29kZUNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFyY29kZUNvb3JkaW5hdGVbMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgudHJ1bmMoTWF0aC5tYXgocm93LCBiYXJjb2RlQ29vcmRpbmF0ZVsxXS5nZXRZKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlQ29vcmRpbmF0ZVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gTWF0aC5tYXgocm93LCBNYXRoLnRydW5jKGJhcmNvZGVDb29yZGluYXRlWzNdLmdldFkoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJvdyArPSBEZXRlY3RvciQzLlJPV19TVEVQO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmRCYXJjb2RlSW5Sb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJhcmNvZGVDb29yZGluYXRlcy5wdXNoKHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIHJpZ2h0IHJvdyBpbmRpY2F0b3IgY29sdW1uLCB0aGVuIGNvbnRpbnVlIHRoZSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJhcmNvZGUgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgcGF0dGVybiBvZiB0aGUgYmFyY29kZSBqdXN0IGZvdW5kLlxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1syXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IE1hdGgudHJ1bmModmVydGljZXNbMl0uZ2V0WCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gTWF0aC50cnVuYyh2ZXJ0aWNlc1syXS5nZXRZKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gTWF0aC50cnVuYyh2ZXJ0aWNlc1s0XS5nZXRYKCkpO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKHZlcnRpY2VzWzRdLmdldFkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhcmNvZGVDb29yZGluYXRlcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlIHRoZSB2ZXJ0aWNlcyBhbmQgdGhlIGNvZGV3b3JkcyBhcmVhIG9mIGEgYmxhY2sgYmxvYiB1c2luZyB0aGUgU3RhcnRcbiAgICAgICAgICogYW5kIFN0b3AgcGF0dGVybnMgYXMgbG9jYXRvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtYXRyaXggdGhlIHNjYW5uZWQgYmFyY29kZSBpbWFnZS5cbiAgICAgICAgICogQHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSB2ZXJ0aWNlczpcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzBdIHgsIHkgdG9wIGxlZnQgYmFyY29kZVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbMV0geCwgeSBib3R0b20gbGVmdCBiYXJjb2RlXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1syXSB4LCB5IHRvcCByaWdodCBiYXJjb2RlXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1szXSB4LCB5IGJvdHRvbSByaWdodCBiYXJjb2RlXG4gICAgICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1s0XSB4LCB5IHRvcCBsZWZ0IGNvZGV3b3JkIGFyZWFcbiAgICAgICAgICogICAgICAgICAgIHZlcnRpY2VzWzVdIHgsIHkgYm90dG9tIGxlZnQgY29kZXdvcmQgYXJlYVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbNl0geCwgeSB0b3AgcmlnaHQgY29kZXdvcmQgYXJlYVxuICAgICAgICAgKiAgICAgICAgICAgdmVydGljZXNbN10geCwgeSBib3R0b20gcmlnaHQgY29kZXdvcmQgYXJlYVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZpbmRWZXJ0aWNlcyhtYXRyaXgsIHN0YXJ0Um93LCBzdGFydENvbHVtbikge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHJlc3VsdCA9IG5ldyBSZXN1bHRQb2ludFs4XTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgICAgIERldGVjdG9yJDMuY29weVRvUmVzdWx0KHJlc3VsdCwgRGV0ZWN0b3IkMy5maW5kUm93c1dpdGhQYXR0ZXJuKG1hdHJpeCwgaGVpZ2h0LCB3aWR0aCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBEZXRlY3RvciQzLlNUQVJUX1BBVFRFUk4pLCBEZXRlY3RvciQzLklOREVYRVNfU1RBUlRfUEFUVEVSTik7XG4gICAgICAgICAgICBpZiAocmVzdWx0WzRdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IE1hdGgudHJ1bmMocmVzdWx0WzRdLmdldFgoKSk7XG4gICAgICAgICAgICAgICAgc3RhcnRSb3cgPSBNYXRoLnRydW5jKHJlc3VsdFs0XS5nZXRZKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRGV0ZWN0b3IkMy5jb3B5VG9SZXN1bHQocmVzdWx0LCBEZXRlY3RvciQzLmZpbmRSb3dzV2l0aFBhdHRlcm4obWF0cml4LCBoZWlnaHQsIHdpZHRoLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIERldGVjdG9yJDMuU1RPUF9QQVRURVJOKSwgRGV0ZWN0b3IkMy5JTkRFWEVTX1NUT1BfUEFUVEVSTik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjb3B5VG9SZXN1bHQocmVzdWx0LCB0bXBSZXN1bHQsIGRlc3RpbmF0aW9uSW5kZXhlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXN0aW5hdGlvbkluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZGVzdGluYXRpb25JbmRleGVzW2ldXSA9IHRtcFJlc3VsdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZmluZFJvd3NXaXRoUGF0dGVybihtYXRyaXgsIGhlaWdodCwgd2lkdGgsIHN0YXJ0Um93LCBzdGFydENvbHVtbiwgcGF0dGVybikge1xuICAgICAgICAgICAgLy8gY29uc3QgcmVzdWx0ID0gbmV3IFJlc3VsdFBvaW50WzRdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVycyA9IG5ldyBJbnQzMkFycmF5KHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoOyBzdGFydFJvdyA8IGhlaWdodDsgc3RhcnRSb3cgKz0gRGV0ZWN0b3IkMy5ST1dfU1RFUCkge1xuICAgICAgICAgICAgICAgIGxldCBsb2MgPSBEZXRlY3RvciQzLmZpbmRHdWFyZFBhdHRlcm4obWF0cml4LCBzdGFydENvbHVtbiwgc3RhcnRSb3csIHdpZHRoLCBmYWxzZSwgcGF0dGVybiwgY291bnRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChsb2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhcnRSb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1Jvd0xvYyA9IERldGVjdG9yJDMuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHN0YXJ0Q29sdW1uLCAtLXN0YXJ0Um93LCB3aWR0aCwgZmFsc2UsIHBhdHRlcm4sIGNvdW50ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1Jvd0xvYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jID0gcHJldmlvdXNSb3dMb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFJvdysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IG5ldyBSZXN1bHRQb2ludChsb2NbMF0sIHN0YXJ0Um93KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WzFdID0gbmV3IFJlc3VsdFBvaW50KGxvY1sxXSwgc3RhcnRSb3cpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdG9wUm93ID0gc3RhcnRSb3cgKyAxO1xuICAgICAgICAgICAgLy8gTGFzdCByb3cgb2YgdGhlIGN1cnJlbnQgc3ltYm9sIHRoYXQgY29udGFpbnMgcGF0dGVyblxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNraXBwZWRSb3dDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzUm93TG9jID0gSW50MzJBcnJheS5mcm9tKFtNYXRoLnRydW5jKHJlc3VsdFswXS5nZXRYKCkpLCBNYXRoLnRydW5jKHJlc3VsdFsxXS5nZXRYKCkpXSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IHN0b3BSb3cgPCBoZWlnaHQ7IHN0b3BSb3crKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2MgPSBEZXRlY3RvciQzLmZpbmRHdWFyZFBhdHRlcm4obWF0cml4LCBwcmV2aW91c1Jvd0xvY1swXSwgc3RvcFJvdywgd2lkdGgsIGZhbHNlLCBwYXR0ZXJuLCBjb3VudGVycyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgZm91bmQgcGF0dGVybiBpcyBvbmx5IGNvbnNpZGVyZWQgdG8gYmVsb25nIHRvIHRoZSBzYW1lIGJhcmNvZGUgaWYgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGRpZmZlciB0b28gbXVjaC4gUGF0dGVybiBkcmlmdCBzaG91bGQgYmUgbm90IGJpZ2dlciB0aGFuIHR3byBmb3IgY29uc2VjdXRpdmUgcm93cy4gV2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyBhIGhpZ2hlciBudW1iZXIgb2Ygc2tpcHBlZCByb3dzIGRyaWZ0IGNvdWxkIGJlIGxhcmdlci4gVG8ga2VlcCBpdCBzaW1wbGUgZm9yIG5vdywgd2UgYWxsb3cgYSBzbGlnaHRseVxuICAgICAgICAgICAgICAgICAgICAvLyBsYXJnZXIgZHJpZnQgYW5kIGRvbid0IGNoZWNrIGZvciBza2lwcGVkIHJvd3MuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2MgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocHJldmlvdXNSb3dMb2NbMF0gLSBsb2NbMF0pIDwgRGV0ZWN0b3IkMy5NQVhfUEFUVEVSTl9EUklGVCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocHJldmlvdXNSb3dMb2NbMV0gLSBsb2NbMV0pIDwgRGV0ZWN0b3IkMy5NQVhfUEFUVEVSTl9EUklGVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSb3dMb2MgPSBsb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkUm93Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBwZWRSb3dDb3VudCA+IERldGVjdG9yJDMuU0tJUFBFRF9ST1dfQ09VTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkUm93Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9wUm93IC09IHNraXBwZWRSb3dDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzJdID0gbmV3IFJlc3VsdFBvaW50KHByZXZpb3VzUm93TG9jWzBdLCBzdG9wUm93KTtcbiAgICAgICAgICAgICAgICByZXN1bHRbM10gPSBuZXcgUmVzdWx0UG9pbnQocHJldmlvdXNSb3dMb2NbMV0sIHN0b3BSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3BSb3cgLSBzdGFydFJvdyA8IERldGVjdG9yJDMuQkFSQ09ERV9NSU5fSEVJR0hUKSB7XG4gICAgICAgICAgICAgICAgQXJyYXlzLmZpbGwocmVzdWx0LCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBtYXRyaXggcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIGNvbHVtbiB4IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0gcm93IHkgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB3aWR0aCB0aGUgbnVtYmVyIG9mIHBpeGVscyB0byBzZWFyY2ggb24gdGhpcyByb3dcbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4gcGF0dGVybiBvZiBjb3VudHMgb2YgbnVtYmVyIG9mIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMgdGhhdCBhcmVcbiAgICAgICAgICogICAgICAgICAgICAgICAgIGJlaW5nIHNlYXJjaGVkIGZvciBhcyBhIHBhdHRlcm5cbiAgICAgICAgICogQHBhcmFtIGNvdW50ZXJzIGFycmF5IG9mIGNvdW50ZXJzLCBhcyBsb25nIGFzIHBhdHRlcm4sIHRvIHJlLXVzZVxuICAgICAgICAgKiBAcmV0dXJuIHN0YXJ0L2VuZCBob3Jpem9udGFsIG9mZnNldCBvZiBndWFyZCBwYXR0ZXJuLCBhcyBhbiBhcnJheSBvZiB0d28gaW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmaW5kR3VhcmRQYXR0ZXJuKG1hdHJpeCwgY29sdW1uLCByb3csIHdpZHRoLCB3aGl0ZUZpcnN0LCBwYXR0ZXJuLCBjb3VudGVycykge1xuICAgICAgICAgICAgQXJyYXlzLmZpbGxXaXRoaW4oY291bnRlcnMsIDAsIGNvdW50ZXJzLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gY29sdW1uO1xuICAgICAgICAgICAgbGV0IHBpeGVsRHJpZnQgPSAwO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGJsYWNrIHBpeGVscyBsZWZ0IG9mIHRoZSBjdXJyZW50IHBpeGVsIHNoaWZ0IHRvIHRoZSBsZWZ0LCBidXQgb25seSBmb3IgTUFYX1BJWEVMX0RSSUZUIHBpeGVsc1xuICAgICAgICAgICAgd2hpbGUgKG1hdHJpeC5nZXQocGF0dGVyblN0YXJ0LCByb3cpICYmIHBhdHRlcm5TdGFydCA+IDAgJiYgcGl4ZWxEcmlmdCsrIDwgRGV0ZWN0b3IkMy5NQVhfUElYRUxfRFJJRlQpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB4ID0gcGF0dGVyblN0YXJ0O1xuICAgICAgICAgICAgbGV0IGNvdW50ZXJQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaXNXaGl0ZSA9IHdoaXRlRmlyc3Q7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpeGVsID0gbWF0cml4LmdldCh4LCByb3cpO1xuICAgICAgICAgICAgICAgIGlmIChwaXhlbCAhPT0gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKERldGVjdG9yJDMucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIERldGVjdG9yJDMuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgRGV0ZWN0b3IkMy5NQVhfQVZHX1ZBUklBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtwYXR0ZXJuU3RhcnQsIHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb3VudGVycywgMiwgY291bnRlcnMsIDAsIGNvdW50ZXJQb3NpdGlvbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gcGF0dGVybkxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgICBEZXRlY3RvciQzLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBEZXRlY3RvciQzLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IERldGVjdG9yJDMuTUFYX0FWR19WQVJJQU5DRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbcGF0dGVyblN0YXJ0LCB4IC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaG93IGNsb3NlbHkgYSBzZXQgb2Ygb2JzZXJ2ZWQgY291bnRzIG9mIHJ1bnMgb2YgYmxhY2svd2hpdGVcbiAgICAgICAgICogdmFsdWVzIG1hdGNoZXMgYSBnaXZlbiB0YXJnZXQgcGF0dGVybi4gVGhpcyBpcyByZXBvcnRlZCBhcyB0aGUgcmF0aW8gb2ZcbiAgICAgICAgICogdGhlIHRvdGFsIHZhcmlhbmNlIGZyb20gdGhlIGV4cGVjdGVkIHBhdHRlcm4gcHJvcG9ydGlvbnMgYWNyb3NzIGFsbFxuICAgICAgICAgKiBwYXR0ZXJuIGVsZW1lbnRzLCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwYXR0ZXJuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY291bnRlcnMgb2JzZXJ2ZWQgY291bnRlcnNcbiAgICAgICAgICogQHBhcmFtIHBhdHRlcm4gZXhwZWN0ZWQgcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0gbWF4SW5kaXZpZHVhbFZhcmlhbmNlIFRoZSBtb3N0IGFueSBjb3VudGVyIGNhbiBkaWZmZXIgYmVmb3JlIHdlIGdpdmUgdXBcbiAgICAgICAgICogQHJldHVybiByYXRpbyBvZiB0b3RhbCB2YXJpYW5jZSBiZXR3ZWVuIGNvdW50ZXJzIGFuZCBwYXR0ZXJuIGNvbXBhcmVkIHRvIHRvdGFsIHBhdHRlcm4gc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBtYXhJbmRpdmlkdWFsVmFyaWFuY2UpIHtcbiAgICAgICAgICAgIGxldCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVybkxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuTGVuZ3RoICs9IHBhdHRlcm5baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG90YWwgPCBwYXR0ZXJuTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIG9uZSBwaXhlbCBwZXIgdW5pdCBvZiBiYXIgd2lkdGgsIGFzc3VtZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gaXMgdG9vIHNtYWxsIHRvIHJlbGlhYmx5IG1hdGNoLCBzbyBmYWlsOlxuICAgICAgICAgICAgICAgIHJldHVybiAvKkZsb2F0LlBPU0lUSVZFX0lORklOSVRZKi8gSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBmYWtlIGZsb2F0aW5nLXBvaW50IG1hdGggaW4gaW50ZWdlcnMuIFdlIGp1c3QgbmVlZCB0byB1c2UgbW9yZSBiaXRzLlxuICAgICAgICAgICAgLy8gU2NhbGUgdXAgcGF0dGVybkxlbmd0aCBzbyB0aGF0IGludGVybWVkaWF0ZSB2YWx1ZXMgYmVsb3cgbGlrZSBzY2FsZWRDb3VudGVyIHdpbGwgaGF2ZVxuICAgICAgICAgICAgLy8gbW9yZSBcInNpZ25pZmljYW50IGRpZ2l0c1wiLlxuICAgICAgICAgICAgbGV0IHVuaXRCYXJXaWR0aCA9IHRvdGFsIC8gcGF0dGVybkxlbmd0aDtcbiAgICAgICAgICAgIG1heEluZGl2aWR1YWxWYXJpYW5jZSAqPSB1bml0QmFyV2lkdGg7XG4gICAgICAgICAgICBsZXQgdG90YWxWYXJpYW5jZSA9IDAuMDtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbnVtQ291bnRlcnM7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBjb3VudGVyID0gY291bnRlcnNbeF07XG4gICAgICAgICAgICAgICAgbGV0IHNjYWxlZFBhdHRlcm4gPSBwYXR0ZXJuW3hdICogdW5pdEJhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCB2YXJpYW5jZSA9IGNvdW50ZXIgPiBzY2FsZWRQYXR0ZXJuID8gY291bnRlciAtIHNjYWxlZFBhdHRlcm4gOiBzY2FsZWRQYXR0ZXJuIC0gY291bnRlcjtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2UgPiBtYXhJbmRpdmlkdWFsVmFyaWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qRmxvYXQuUE9TSVRJVkVfSU5GSU5JVFkqLyBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG90YWxWYXJpYW5jZSArPSB2YXJpYW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbFZhcmlhbmNlIC8gdG90YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGV0ZWN0b3IkMy5JTkRFWEVTX1NUQVJUX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzAsIDQsIDEsIDVdKTtcbiAgICBEZXRlY3RvciQzLklOREVYRVNfU1RPUF9QQVRURVJOID0gSW50MzJBcnJheS5mcm9tKFs2LCAyLCA3LCAzXSk7XG4gICAgRGV0ZWN0b3IkMy5NQVhfQVZHX1ZBUklBTkNFID0gMC40MjtcbiAgICBEZXRlY3RvciQzLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC44O1xuICAgIC8vIEIgUyBCIFMgQiBTIEIgUyBCYXIvU3BhY2UgcGF0dGVyblxuICAgIC8vIDExMTExMTExIDAgMSAwIDEgMCAxIDAwMFxuICAgIERldGVjdG9yJDMuU1RBUlRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbOCwgMSwgMSwgMSwgMSwgMSwgMSwgM10pO1xuICAgIC8vIDExMTExMTEgMCAxIDAwMCAxIDAgMSAwMCAxXG4gICAgRGV0ZWN0b3IkMy5TVE9QX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzcsIDEsIDEsIDMsIDEsIDEsIDEsIDIsIDFdKTtcbiAgICBEZXRlY3RvciQzLk1BWF9QSVhFTF9EUklGVCA9IDM7XG4gICAgRGV0ZWN0b3IkMy5NQVhfUEFUVEVSTl9EUklGVCA9IDU7XG4gICAgLy8gaWYgd2Ugc2V0IHRoZSB2YWx1ZSB0b28gbG93LCB0aGVuIHdlIGRvbid0IGRldGVjdCB0aGUgY29ycmVjdCBoZWlnaHQgb2YgdGhlIGJhciBpZiB0aGUgc3RhcnQgcGF0dGVybnMgYXJlIGRhbWFnZWQuXG4gICAgLy8gaWYgd2Ugc2V0IHRoZSB2YWx1ZSB0b28gaGlnaCwgdGhlbiB3ZSBtaWdodCBkZXRlY3QgdGhlIHN0YXJ0IHBhdHRlcm4gZnJvbSBhIG5laWdoYm9yIGJhcmNvZGUuXG4gICAgRGV0ZWN0b3IkMy5TS0lQUEVEX1JPV19DT1VOVF9NQVggPSAyNTtcbiAgICAvLyBBIFBERjQ3MSBiYXJjb2RlIHNob3VsZCBoYXZlIGF0IGxlYXN0IDMgcm93cywgd2l0aCBlYWNoIHJvdyBiZWluZyA+PSAzIHRpbWVzIHRoZSBtb2R1bGUgd2lkdGguIFRoZXJlZm9yZSBpdCBzaG91bGQgYmUgYXQgbGVhc3RcbiAgICAvLyA5IHBpeGVscyB0YWxsLiBUbyBiZSBjb25zZXJ2YXRpdmUsIHdlIHVzZSBhYm91dCBoYWxmIHRoZSBzaXplIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGl0LlxuICAgIERldGVjdG9yJDMuUk9XX1NURVAgPSA1O1xuICAgIERldGVjdG9yJDMuQkFSQ09ERV9NSU5fSEVJR0hUID0gMTA7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTIgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uR2VuZXJpY0dGUG9seVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBNb2R1bHVzUG9seSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBjb2VmZmljaWVudHMpIHtcbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICAgICAgbGV0IGNvZWZmaWNpZW50c0xlbmd0aCA9IC8qaW50Ki8gY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjb2VmZmljaWVudHNMZW5ndGggPiAxICYmIGNvZWZmaWNpZW50c1swXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgdGVybSBtdXN0IGJlIG5vbi16ZXJvIGZvciBhbnl0aGluZyBleGNlcHQgdGhlIGNvbnN0YW50IHBvbHlub21pYWwgXCIwXCJcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3ROb25aZXJvID0gLyppbnQqLyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChmaXJzdE5vblplcm8gPCBjb2VmZmljaWVudHNMZW5ndGggJiYgY29lZmZpY2llbnRzW2ZpcnN0Tm9uWmVyb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vblplcm8gPT09IGNvZWZmaWNpZW50c0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZWZmaWNpZW50c0xlbmd0aCAtIGZpcnN0Tm9uWmVybyk7XG4gICAgICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoY29lZmZpY2llbnRzLCBmaXJzdE5vblplcm8sIHRoaXMuY29lZmZpY2llbnRzLCAwLCB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldENvZWZmaWNpZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBkZWdyZWUgb2YgdGhpcyBwb2x5bm9taWFsXG4gICAgICAgICAqL1xuICAgICAgICBnZXREZWdyZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmZiB0aGlzIHBvbHlub21pYWwgaXMgdGhlIG1vbm9taWFsIFwiMFwiXG4gICAgICAgICAqL1xuICAgICAgICBpc1plcm8oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbMF0gPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gY29lZmZpY2llbnQgb2YgeF5kZWdyZWUgdGVybSBpbiB0aGlzIHBvbHlub21pYWxcbiAgICAgICAgICovXG4gICAgICAgIGdldENvZWZmaWNpZW50KGRlZ3JlZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzW3RoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBkZWdyZWVdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGV2YWx1YXRpb24gb2YgdGhpcyBwb2x5bm9taWFsIGF0IGEgZ2l2ZW4gcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIGV2YWx1YXRlQXQoYSkge1xuICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHJldHVybiB0aGUgeF4wIGNvZWZmaWNpZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29lZmZpY2llbnQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgdGhlIHN1bSBvZiB0aGUgY29lZmZpY2llbnRzXG4gICAgICAgICAgICAgICAgbGV0IHN1bSA9IC8qaW50Ki8gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2VmZmljaWVudCAvKmludCovIG9mIHRoaXMuY29lZmZpY2llbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHRoaXMuZmllbGQuYWRkKHN1bSwgY29lZmZpY2llbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IC8qaW50Ki8gdGhpcy5jb2VmZmljaWVudHNbMF07XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IC8qaW50Ki8gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmllbGQuYWRkKHRoaXMuZmllbGQubXVsdGlwbHkoYSwgcmVzdWx0KSwgdGhpcy5jb2VmZmljaWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNtYWxsZXJDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGxldCBsYXJnZXJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XG4gICAgICAgICAgICBpZiAoc21hbGxlckNvZWZmaWNpZW50cy5sZW5ndGggPiBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBzbWFsbGVyQ29lZmZpY2llbnRzO1xuICAgICAgICAgICAgICAgIHNtYWxsZXJDb2VmZmljaWVudHMgPSBsYXJnZXJDb2VmZmljaWVudHM7XG4gICAgICAgICAgICAgICAgbGFyZ2VyQ29lZmZpY2llbnRzID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdW1EaWZmID0gbmV3IEludDMyQXJyYXkobGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoRGlmZiA9IC8qaW50Ki8gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCAtIHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gQ29weSBoaWdoLW9yZGVyIHRlcm1zIG9ubHkgZm91bmQgaW4gaGlnaGVyLWRlZ3JlZSBwb2x5bm9taWFsJ3MgY29lZmZpY2llbnRzXG4gICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KGxhcmdlckNvZWZmaWNpZW50cywgMCwgc3VtRGlmZiwgMCwgbGVuZ3RoRGlmZik7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSBsZW5ndGhEaWZmOyBpIDwgbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtRGlmZltpXSA9IHRoaXMuZmllbGQuYWRkKHNtYWxsZXJDb2VmZmljaWVudHNbaSAtIGxlbmd0aERpZmZdLCBsYXJnZXJDb2VmZmljaWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBzdW1EaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdNb2R1bHVzUG9seXMgZG8gbm90IGhhdmUgc2FtZSBNb2R1bHVzR0YgZmllbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0aXZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KG90aGVyKSB7XG4gICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBNb2R1bHVzUG9seSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5T3RoZXIob3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5T3RoZXIob3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1plcm8oKSB8fCBvdGhlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgICAgIGxldCBhTGVuZ3RoID0gLyppbnQqLyBhQ29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBiQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICAgICAgbGV0IGJMZW5ndGggPSAvKmludCovIGJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShhTGVuZ3RoICsgYkxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGFMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBhQ29lZmYgPSAvKmludCovIGFDb2VmZmljaWVudHNbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gMDsgaiA8IGJMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0W2kgKyBqXSA9IHRoaXMuZmllbGQuYWRkKHByb2R1Y3RbaSArIGpdLCB0aGlzLmZpZWxkLm11bHRpcGx5KGFDb2VmZiwgYkNvZWZmaWNpZW50c1tqXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgcHJvZHVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgbmVnYXRpdmUoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IC8qaW50Ki8gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG5lZ2F0aXZlQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVDb2VmZmljaWVudHNbaV0gPSB0aGlzLmZpZWxkLnN1YnRyYWN0KDAsIHRoaXMuY29lZmZpY2llbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmVnYXRpdmVDb2VmZmljaWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuICAgICAgICAgICAgaWYgKHNjYWxhciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IC8qaW50Ki8gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0W2ldID0gdGhpcy5maWVsZC5tdWx0aXBseSh0aGlzLmNvZWZmaWNpZW50c1tpXSwgc2NhbGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgcHJvZHVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZSwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZXcgSW50MzJBcnJheShbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUgKyBkZWdyZWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RbaV0gPSB0aGlzLmZpZWxkLm11bHRpcGx5KHRoaXMuY29lZmZpY2llbnRzW2ldLCBjb2VmZmljaWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIE1vZHVsdXNQb2x5W10gZGl2aWRlKG90aGVyOiBNb2R1bHVzUG9seSkge1xuICAgICAgICAgIGlmICghZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIk1vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiRGl2aWRlIGJ5IDBcIik7XG4gICAgICAgICAgfVxuICAgICAgXG4gICAgICAgICAgbGV0IHF1b3RpZW50OiBNb2R1bHVzUG9seSA9IGZpZWxkLmdldFplcm8oKTtcbiAgICAgICAgICBsZXQgcmVtYWluZGVyOiBNb2R1bHVzUG9seSA9IHRoaXM7XG4gICAgICBcbiAgICAgICAgICBsZXQgZGVub21pbmF0b3JMZWFkaW5nVGVybTogLyppbnQvIG51bWJlciA9IG90aGVyLmdldENvZWZmaWNpZW50KG90aGVyLmdldERlZ3JlZSgpKTtcbiAgICAgICAgICBsZXQgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm06IC8qaW50LyBudW1iZXIgPSBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgXG4gICAgICAgICAgd2hpbGUgKHJlbWFpbmRlci5nZXREZWdyZWUoKSA+PSBvdGhlci5nZXREZWdyZWUoKSAmJiAhcmVtYWluZGVyLmlzWmVybygpKSB7XG4gICAgICAgICAgICBsZXQgZGVncmVlRGlmZmVyZW5jZTogLyppbnQvIG51bWJlciA9IHJlbWFpbmRlci5nZXREZWdyZWUoKSAtIG90aGVyLmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgbGV0IHNjYWxlOiAvKmludC8gbnVtYmVyID0gZmllbGQubXVsdGlwbHkocmVtYWluZGVyLmdldENvZWZmaWNpZW50KHJlbWFpbmRlci5nZXREZWdyZWUoKSksIGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgICAgICAgIGxldCB0ZXJtOiBNb2R1bHVzUG9seSA9IG90aGVyLm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XG4gICAgICAgICAgICBsZXQgaXRlcmF0aW9uUXVvdGllbnQ6IE1vZHVsdXNQb2x5ID0gZmllbGQuYnVpbGRNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XG4gICAgICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZChpdGVyYXRpb25RdW90aWVudCk7XG4gICAgICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuc3VidHJhY3QodGVybSk7XG4gICAgICAgICAgfVxuICAgICAgXG4gICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seVtdIHsgcXVvdGllbnQsIHJlbWFpbmRlciB9O1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlciggLyo4ICogdGhpcy5nZXREZWdyZWUoKSovKTsgLy8gZHluYW1pYyBzdHJpbmcgc2l6ZSBpbiBKU1xuICAgICAgICAgICAgZm9yIChsZXQgZGVncmVlIC8qaW50Ki8gPSB0aGlzLmdldERlZ3JlZSgpOyBkZWdyZWUgPj0gMDsgZGVncmVlLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgY29lZmZpY2llbnQgPSAvKmludCovIHRoaXMuZ2V0Q29lZmZpY2llbnQoZGVncmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIC0gJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudCA9IC1jb2VmZmljaWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICsgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMCB8fCBjb2VmZmljaWVudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjb2VmZmljaWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ3gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ3heJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChkZWdyZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3MgTW9kdWx1c0Jhc2Uge1xuICAgICAgICBhZGQoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIChhICsgYikgJSB0aGlzLm1vZHVsdXM7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3QoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm1vZHVsdXMgKyBhIC0gYikgJSB0aGlzLm1vZHVsdXM7XG4gICAgICAgIH1cbiAgICAgICAgZXhwKGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cFRhYmxlW2FdO1xuICAgICAgICB9XG4gICAgICAgIGxvZyhhKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ1RhYmxlW2FdO1xuICAgICAgICB9XG4gICAgICAgIGludmVyc2UoYSkge1xuICAgICAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbdGhpcy5tb2R1bHVzIC0gdGhpcy5sb2dUYWJsZVthXSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSAwIHx8IGIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cFRhYmxlWyh0aGlzLmxvZ1RhYmxlW2FdICsgdGhpcy5sb2dUYWJsZVtiXSkgJSAodGhpcy5tb2R1bHVzIC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2R1bHVzO1xuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICByZXR1cm4gbyA9PT0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTIgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogPHA+QSBmaWVsZCBiYXNlZCBvbiBwb3dlcnMgb2YgYSBnZW5lcmF0b3IgaW50ZWdlciwgbW9kdWxvIHNvbWUgbW9kdWx1cy48L3A+XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIFNlYW4gT3dlblxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uR2VuZXJpY0dGXG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBNb2R1bHVzR0YgZXh0ZW5kcyBNb2R1bHVzQmFzZSB7XG4gICAgICAgIC8vIHByaXZhdGUgLypmaW5hbCovIG1vZHVsdXM6IC8qaW50Ki8gbnVtYmVyO1xuICAgICAgICBjb25zdHJ1Y3Rvcihtb2R1bHVzLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLm1vZHVsdXMgPSBtb2R1bHVzO1xuICAgICAgICAgICAgdGhpcy5leHBUYWJsZSA9IG5ldyBJbnQzMkFycmF5KG1vZHVsdXMpO1xuICAgICAgICAgICAgdGhpcy5sb2dUYWJsZSA9IG5ldyBJbnQzMkFycmF5KG1vZHVsdXMpO1xuICAgICAgICAgICAgbGV0IHggPSAvKmludCovIDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWx1czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBUYWJsZVtpXSA9IHg7XG4gICAgICAgICAgICAgICAgeCA9ICh4ICogZ2VuZXJhdG9yKSAlIG1vZHVsdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWx1cyAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nVGFibGVbdGhpcy5leHBUYWJsZVtpXV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbG9nVGFibGVbMF0gPT0gMCBidXQgdGhpcyBzaG91bGQgbmV2ZXIgYmUgdXNlZFxuICAgICAgICAgICAgdGhpcy56ZXJvID0gbmV3IE1vZHVsdXNQb2x5KHRoaXMsIG5ldyBJbnQzMkFycmF5KFswXSkpO1xuICAgICAgICAgICAgdGhpcy5vbmUgPSBuZXcgTW9kdWx1c1BvbHkodGhpcywgbmV3IEludDMyQXJyYXkoWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0WmVybygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgICAgIH1cbiAgICAgICAgZ2V0T25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25lO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTW9ub21pYWwoZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgICAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGRlZ3JlZSArIDEpO1xuICAgICAgICAgICAgY29lZmZpY2llbnRzWzBdID0gY29lZmZpY2llbnQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMsIGNvZWZmaWNpZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTW9kdWx1c0dGLlBERjQxN19HRiA9IG5ldyBNb2R1bHVzR0YoUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFMsIDMpO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEyIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogPHA+UERGNDE3IGVycm9yIGNvcnJlY3Rpb24gaW1wbGVtZW50YXRpb24uPC9wPlxuICAgICAqXG4gICAgICogPHA+VGhpcyA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SZWVkJUUyJTgwJTkzU29sb21vbl9lcnJvcl9jb3JyZWN0aW9uI0V4YW1wbGVcIj5leGFtcGxlPC9hPlxuICAgICAqIGlzIHF1aXRlIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBhbGdvcml0aG0uPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTZWFuIE93ZW5cbiAgICAgKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLlJlZWRTb2xvbW9uRGVjb2RlclxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgRXJyb3JDb3JyZWN0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gTW9kdWx1c0dGLlBERjQxN19HRjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHJlY2VpdmVkIHJlY2VpdmVkIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcGFyYW0gbnVtRUNDb2Rld29yZHMgbnVtYmVyIG9mIHRob3NlIGNvZGV3b3JkcyB1c2VkIGZvciBFQ1xuICAgICAgICAgKiBAcGFyYW0gZXJhc3VyZXMgbG9jYXRpb24gb2YgZXJhc3VyZXNcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgZXJyb3JzXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3JzIGNhbm5vdCBiZSBjb3JyZWN0ZWQsIG1heWJlIGJlY2F1c2Ugb2YgdG9vIG1hbnkgZXJyb3JzXG4gICAgICAgICAqL1xuICAgICAgICBkZWNvZGUocmVjZWl2ZWQsIG51bUVDQ29kZXdvcmRzLCBlcmFzdXJlcykge1xuICAgICAgICAgICAgbGV0IHBvbHkgPSBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgcmVjZWl2ZWQpO1xuICAgICAgICAgICAgbGV0IFMgPSBuZXcgSW50MzJBcnJheShudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IG51bUVDQ29kZXdvcmRzOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV2YWx1YXRpb24gPSBwb2x5LmV2YWx1YXRlQXQodGhpcy5maWVsZC5leHAoaSkpO1xuICAgICAgICAgICAgICAgIFNbbnVtRUNDb2Rld29yZHMgLSBpXSA9IGV2YWx1YXRpb247XG4gICAgICAgICAgICAgICAgaWYgKGV2YWx1YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBrbm93bkVycm9ycyA9IHRoaXMuZmllbGQuZ2V0T25lKCk7XG4gICAgICAgICAgICBpZiAoZXJhc3VyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXJhc3VyZSBvZiBlcmFzdXJlcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYiA9IHRoaXMuZmllbGQuZXhwKHJlY2VpdmVkLmxlbmd0aCAtIDEgLSBlcmFzdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkICgxIC0gYngpIHRlcm06XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFt0aGlzLmZpZWxkLnN1YnRyYWN0KDAsIGIpLCAxXSkpO1xuICAgICAgICAgICAgICAgICAgICBrbm93bkVycm9ycyA9IGtub3duRXJyb3JzLm11bHRpcGx5KHRlcm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzeW5kcm9tZSA9IG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBTKTtcbiAgICAgICAgICAgIC8vIHN5bmRyb21lID0gc3luZHJvbWUubXVsdGlwbHkoa25vd25FcnJvcnMpO1xuICAgICAgICAgICAgbGV0IHNpZ21hT21lZ2EgPSB0aGlzLnJ1bkV1Y2xpZGVhbkFsZ29yaXRobSh0aGlzLmZpZWxkLmJ1aWxkTW9ub21pYWwobnVtRUNDb2Rld29yZHMsIDEpLCBzeW5kcm9tZSwgbnVtRUNDb2Rld29yZHMpO1xuICAgICAgICAgICAgbGV0IHNpZ21hID0gc2lnbWFPbWVnYVswXTtcbiAgICAgICAgICAgIGxldCBvbWVnYSA9IHNpZ21hT21lZ2FbMV07XG4gICAgICAgICAgICAvLyBzaWdtYSA9IHNpZ21hLm11bHRpcGx5KGtub3duRXJyb3JzKTtcbiAgICAgICAgICAgIGxldCBlcnJvckxvY2F0aW9ucyA9IHRoaXMuZmluZEVycm9yTG9jYXRpb25zKHNpZ21hKTtcbiAgICAgICAgICAgIGxldCBlcnJvck1hZ25pdHVkZXMgPSB0aGlzLmZpbmRFcnJvck1hZ25pdHVkZXMob21lZ2EsIHNpZ21hLCBlcnJvckxvY2F0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgZXJyb3JMb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSByZWNlaXZlZC5sZW5ndGggLSAxIC0gdGhpcy5maWVsZC5sb2coZXJyb3JMb2NhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFtwb3NpdGlvbl0gPSB0aGlzLmZpZWxkLnN1YnRyYWN0KHJlY2VpdmVkW3Bvc2l0aW9uXSwgZXJyb3JNYWduaXR1ZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBNb2R1bHVzUG9seVxuICAgICAgICAgKiBAcGFyYW0gYVxuICAgICAgICAgKiBAcGFyYW0gTW9kdWx1c1BvbHlcbiAgICAgICAgICogQHBhcmFtIGJcbiAgICAgICAgICogQHBhcmFtIGludFxuICAgICAgICAgKiBAcGFyYW0gUlxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBydW5FdWNsaWRlYW5BbGdvcml0aG0oYSwgYiwgUikge1xuICAgICAgICAgICAgLy8gQXNzdW1lIGEncyBkZWdyZWUgaXMgPj0gYidzXG4gICAgICAgICAgICBpZiAoYS5nZXREZWdyZWUoKSA8IGIuZ2V0RGVncmVlKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGE7XG4gICAgICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICAgICAgYiA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgckxhc3QgPSBhO1xuICAgICAgICAgICAgbGV0IHIgPSBiO1xuICAgICAgICAgICAgbGV0IHRMYXN0ID0gdGhpcy5maWVsZC5nZXRaZXJvKCk7XG4gICAgICAgICAgICBsZXQgdCA9IHRoaXMuZmllbGQuZ2V0T25lKCk7XG4gICAgICAgICAgICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcbiAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IE1hdGgucm91bmQoUiAvIDIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJMYXN0TGFzdCA9IHJMYXN0O1xuICAgICAgICAgICAgICAgIGxldCB0TGFzdExhc3QgPSB0TGFzdDtcbiAgICAgICAgICAgICAgICByTGFzdCA9IHI7XG4gICAgICAgICAgICAgICAgdExhc3QgPSB0O1xuICAgICAgICAgICAgICAgIC8vIERpdmlkZSByTGFzdExhc3QgYnkgckxhc3QsIHdpdGggcXVvdGllbnQgaW4gcSBhbmQgcmVtYWluZGVyIGluIHJcbiAgICAgICAgICAgICAgICBpZiAockxhc3QuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT29wcywgRXVjbGlkZWFuIGFsZ29yaXRobSBhbHJlYWR5IHRlcm1pbmF0ZWQ/XG4gICAgICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgciA9IHJMYXN0TGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgcSA9IHRoaXMuZmllbGQuZ2V0WmVybygpO1xuICAgICAgICAgICAgICAgIGxldCBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gckxhc3QuZ2V0Q29lZmZpY2llbnQockxhc3QuZ2V0RGVncmVlKCkpO1xuICAgICAgICAgICAgICAgIGxldCBkbHRJbnZlcnNlID0gdGhpcy5maWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpICYmICFyLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWdyZWVEaWZmID0gci5nZXREZWdyZWUoKSAtIHJMYXN0LmdldERlZ3JlZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2NhbGUgPSB0aGlzLmZpZWxkLm11bHRpcGx5KHIuZ2V0Q29lZmZpY2llbnQoci5nZXREZWdyZWUoKSksIGRsdEludmVyc2UpO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5hZGQodGhpcy5maWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIHIgPSByLnN1YnRyYWN0KHJMYXN0Lm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ID0gcS5tdWx0aXBseSh0TGFzdCkuc3VidHJhY3QodExhc3RMYXN0KS5uZWdhdGl2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpZ21hVGlsZGVBdFplcm8gPSB0LmdldENvZWZmaWNpZW50KDApO1xuICAgICAgICAgICAgaWYgKHNpZ21hVGlsZGVBdFplcm8gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW52ZXJzZSA9IHRoaXMuZmllbGQuaW52ZXJzZShzaWdtYVRpbGRlQXRaZXJvKTtcbiAgICAgICAgICAgIGxldCBzaWdtYSA9IHQubXVsdGlwbHkoaW52ZXJzZSk7XG4gICAgICAgICAgICBsZXQgb21lZ2EgPSByLm11bHRpcGx5KGludmVyc2UpO1xuICAgICAgICAgICAgcmV0dXJuIFtzaWdtYSwgb21lZ2FdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXJyb3JMb2NhdG9yXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGZpbmRFcnJvckxvY2F0aW9ucyhlcnJvckxvY2F0b3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3QgYXBwbGljYXRpb24gb2YgQ2hpZW4ncyBzZWFyY2hcbiAgICAgICAgICAgIGxldCBudW1FcnJvcnMgPSBlcnJvckxvY2F0b3IuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkobnVtRXJyb3JzKTtcbiAgICAgICAgICAgIGxldCBlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDE7IGkgPCB0aGlzLmZpZWxkLmdldFNpemUoKSAmJiBlIDwgbnVtRXJyb3JzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JMb2NhdG9yLmV2YWx1YXRlQXQoaSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2VdID0gdGhpcy5maWVsZC5pbnZlcnNlKGkpO1xuICAgICAgICAgICAgICAgICAgICBlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgIT09IG51bUVycm9ycykge1xuICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZmluZEVycm9yTWFnbml0dWRlcyhlcnJvckV2YWx1YXRvciwgZXJyb3JMb2NhdG9yLCBlcnJvckxvY2F0aW9ucykge1xuICAgICAgICAgICAgbGV0IGVycm9yTG9jYXRvckRlZ3JlZSA9IGVycm9yTG9jYXRvci5nZXREZWdyZWUoKTtcbiAgICAgICAgICAgIGxldCBmb3JtYWxEZXJpdmF0aXZlQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoZXJyb3JMb2NhdG9yRGVncmVlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDE7IGkgPD0gZXJyb3JMb2NhdG9yRGVncmVlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3JtYWxEZXJpdmF0aXZlQ29lZmZpY2llbnRzW2Vycm9yTG9jYXRvckRlZ3JlZSAtIGldID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZC5tdWx0aXBseShpLCBlcnJvckxvY2F0b3IuZ2V0Q29lZmZpY2llbnQoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcm1hbERlcml2YXRpdmUgPSBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgZm9ybWFsRGVyaXZhdGl2ZUNvZWZmaWNpZW50cyk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRpcmVjdGx5IGFwcGx5aW5nIEZvcm5leSdzIEZvcm11bGFcbiAgICAgICAgICAgIGxldCBzID0gZXJyb3JMb2NhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB4aUludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2UoZXJyb3JMb2NhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIGxldCBudW1lcmF0b3IgPSB0aGlzLmZpZWxkLnN1YnRyYWN0KDAsIGVycm9yRXZhbHVhdG9yLmV2YWx1YXRlQXQoeGlJbnZlcnNlKSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gdGhpcy5maWVsZC5pbnZlcnNlKGZvcm1hbERlcml2YXRpdmUuZXZhbHVhdGVBdCh4aUludmVyc2UpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLmZpZWxkLm11bHRpcGx5KG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBCb3VuZGluZ0JveCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGltYWdlLCB0b3BMZWZ0LCBib3R0b21MZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChpbWFnZSBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvcl8yKGltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JfMShpbWFnZSwgdG9wTGVmdCwgYm90dG9tTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSB0b3BMZWZ0XG4gICAgICAgICAqIEBwYXJhbSBib3R0b21MZWZ0XG4gICAgICAgICAqIEBwYXJhbSB0b3BSaWdodFxuICAgICAgICAgKiBAcGFyYW0gYm90dG9tUmlnaHRcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3JfMShpbWFnZSwgdG9wTGVmdCwgYm90dG9tTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0VW5zcGVjaWZpZWQgPSB0b3BMZWZ0ID09IG51bGwgfHwgYm90dG9tTGVmdCA9PSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRVbnNwZWNpZmllZCA9IHRvcFJpZ2h0ID09IG51bGwgfHwgYm90dG9tUmlnaHQgPT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChsZWZ0VW5zcGVjaWZpZWQgJiYgcmlnaHRVbnNwZWNpZmllZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRVbnNwZWNpZmllZCkge1xuICAgICAgICAgICAgICAgIHRvcExlZnQgPSBuZXcgUmVzdWx0UG9pbnQoMCwgdG9wUmlnaHQuZ2V0WSgpKTtcbiAgICAgICAgICAgICAgICBib3R0b21MZWZ0ID0gbmV3IFJlc3VsdFBvaW50KDAsIGJvdHRvbVJpZ2h0LmdldFkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyaWdodFVuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgICAgdG9wUmlnaHQgPSBuZXcgUmVzdWx0UG9pbnQoaW1hZ2UuZ2V0V2lkdGgoKSAtIDEsIHRvcExlZnQuZ2V0WSgpKTtcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodCA9IG5ldyBSZXN1bHRQb2ludChpbWFnZS5nZXRXaWR0aCgpIC0gMSwgYm90dG9tTGVmdC5nZXRZKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy50b3BMZWZ0ID0gdG9wTGVmdDtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGVmdCA9IGJvdHRvbUxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcFJpZ2h0ID0gdG9wUmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVJpZ2h0ID0gYm90dG9tUmlnaHQ7XG4gICAgICAgICAgICB0aGlzLm1pblggPSBNYXRoLnRydW5jKE1hdGgubWluKHRvcExlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFgoKSkpO1xuICAgICAgICAgICAgdGhpcy5tYXhYID0gTWF0aC50cnVuYyhNYXRoLm1heCh0b3BSaWdodC5nZXRYKCksIGJvdHRvbVJpZ2h0LmdldFgoKSkpO1xuICAgICAgICAgICAgdGhpcy5taW5ZID0gTWF0aC50cnVuYyhNYXRoLm1pbih0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WSgpKSk7XG4gICAgICAgICAgICB0aGlzLm1heFkgPSBNYXRoLnRydW5jKE1hdGgubWF4KGJvdHRvbUxlZnQuZ2V0WSgpLCBib3R0b21SaWdodC5nZXRZKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvcl8yKGJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gYm91bmRpbmdCb3guaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnRvcExlZnQgPSBib3VuZGluZ0JveC5nZXRUb3BMZWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUxlZnQgPSBib3VuZGluZ0JveC5nZXRCb3R0b21MZWZ0KCk7XG4gICAgICAgICAgICB0aGlzLnRvcFJpZ2h0ID0gYm91bmRpbmdCb3guZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tUmlnaHQgPSBib3VuZGluZ0JveC5nZXRCb3R0b21SaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5taW5YID0gYm91bmRpbmdCb3guZ2V0TWluWCgpO1xuICAgICAgICAgICAgdGhpcy5tYXhYID0gYm91bmRpbmdCb3guZ2V0TWF4WCgpO1xuICAgICAgICAgICAgdGhpcy5taW5ZID0gYm91bmRpbmdCb3guZ2V0TWluWSgpO1xuICAgICAgICAgICAgdGhpcy5tYXhZID0gYm91bmRpbmdCb3guZ2V0TWF4WSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbWVyZ2UobGVmdEJveCwgcmlnaHRCb3gpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0Qm94ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRCb3g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRCb3ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0Qm94O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChsZWZ0Qm94LmltYWdlLCBsZWZ0Qm94LnRvcExlZnQsIGxlZnRCb3guYm90dG9tTGVmdCwgcmlnaHRCb3gudG9wUmlnaHQsIHJpZ2h0Qm94LmJvdHRvbVJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTWlzc2luZ1Jvd3MobWlzc2luZ1N0YXJ0Um93cywgbWlzc2luZ0VuZFJvd3MsIGlzTGVmdCkge1xuICAgICAgICAgICAgbGV0IG5ld1RvcExlZnQgPSB0aGlzLnRvcExlZnQ7XG4gICAgICAgICAgICBsZXQgbmV3Qm90dG9tTGVmdCA9IHRoaXMuYm90dG9tTGVmdDtcbiAgICAgICAgICAgIGxldCBuZXdUb3BSaWdodCA9IHRoaXMudG9wUmlnaHQ7XG4gICAgICAgICAgICBsZXQgbmV3Qm90dG9tUmlnaHQgPSB0aGlzLmJvdHRvbVJpZ2h0O1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdTdGFydFJvd3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IGlzTGVmdCA/IHRoaXMudG9wTGVmdCA6IHRoaXMudG9wUmlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IG5ld01pblkgPSBNYXRoLnRydW5jKHRvcC5nZXRZKCkgLSBtaXNzaW5nU3RhcnRSb3dzKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TWluWSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWluWSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXdUb3AgPSBuZXcgUmVzdWx0UG9pbnQodG9wLmdldFgoKSwgbmV3TWluWSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUb3BMZWZ0ID0gbmV3VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG9wUmlnaHQgPSBuZXdUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pc3NpbmdFbmRSb3dzID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBib3R0b20gPSBpc0xlZnQgPyB0aGlzLmJvdHRvbUxlZnQgOiB0aGlzLmJvdHRvbVJpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCBuZXdNYXhZID0gTWF0aC50cnVuYyhib3R0b20uZ2V0WSgpICsgbWlzc2luZ0VuZFJvd3MpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdNYXhZID49IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF4WSA9IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbmV3Qm90dG9tID0gbmV3IFJlc3VsdFBvaW50KGJvdHRvbS5nZXRYKCksIG5ld01heFkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Qm90dG9tTGVmdCA9IG5ld0JvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0JvdHRvbVJpZ2h0ID0gbmV3Qm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy5pbWFnZSwgbmV3VG9wTGVmdCwgbmV3Qm90dG9tTGVmdCwgbmV3VG9wUmlnaHQsIG5ld0JvdHRvbVJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRNaW5YKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluWDtcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXhYKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4WDtcbiAgICAgICAgfVxuICAgICAgICBnZXRNaW5ZKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluWTtcbiAgICAgICAgfVxuICAgICAgICBnZXRNYXhZKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4WTtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3BMZWZ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9wTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcFJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGdldEJvdHRvbUxlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGdldEJvdHRvbVJpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tUmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2RlcjtcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgQmFyY29kZU1ldGFkYXRhIHtcbiAgICAgICAgY29uc3RydWN0b3IoY29sdW1uQ291bnQsIHJvd0NvdW50VXBwZXJQYXJ0LCByb3dDb3VudExvd2VyUGFydCwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uQ291bnQgPSBjb2x1bW5Db3VudDtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBlcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgICAgICAgIHRoaXMucm93Q291bnRVcHBlclBhcnQgPSByb3dDb3VudFVwcGVyUGFydDtcbiAgICAgICAgICAgIHRoaXMucm93Q291bnRMb3dlclBhcnQgPSByb3dDb3VudExvd2VyUGFydDtcbiAgICAgICAgICAgIHRoaXMucm93Q291bnQgPSByb3dDb3VudFVwcGVyUGFydCArIHJvd0NvdW50TG93ZXJQYXJ0O1xuICAgICAgICB9XG4gICAgICAgIGdldENvbHVtbkNvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dDb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd0NvdW50VXBwZXJQYXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93Q291bnRVcHBlclBhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Um93Q291bnRMb3dlclBhcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dDb3VudExvd2VyUGFydDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEphdmEgRm9ybWF0dGVyIGNsYXNzIHBvbHlmaWxsIHRoYXQgd29ya3MgaW4gdGhlIEpTIHdheS5cbiAgICAgKi9cbiAgICBjbGFzcyBGb3JtYXR0ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEzNDM5NzExLzQzNjc2ODNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0clxuICAgICAgICAgKiBAcGFyYW0gYXJyXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZm9ybShzdHIsIGFycikge1xuICAgICAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGV4cCwgcDAsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cCA9PT0gJyUlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICclJztcbiAgICAgICAgICAgICAgICBpZiAoYXJyWysraV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBleHAgPSBwMiA/IHBhcnNlSW50KHAyLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBwMyA/IHBhcnNlSW50KHAzLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJyW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gYXJyW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcnJbaV0pLnRvRml4ZWQoZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoYXJyW2ldKS50b1ByZWNpc2lvbihleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcnJbaV0pLnRvRXhwb25lbnRpYWwoZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KGFycltpXSkudG9TdHJpbmcoYmFzZSA/IGJhc2UgOiAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHBhcnNlSW50KGFycltpXSwgYmFzZSA/IGJhc2UgOiAxMCkudG9QcmVjaXNpb24oZXhwKSkudG9GaXhlZCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbCkgOiAoK3ZhbCkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChwMSk7IC8qIHBhZGRpbmcgc2l6ZSAqL1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHAxICYmIChwMVswXSArICcnKSA9PT0gJzAnID8gJzAnIDogJyAnOyAvKiBpc251bGw/ICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKHZhbC5sZW5ndGggPCBzaXplKVxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwMCAhPT0gdW5kZWZpbmVkID8gdmFsICsgY2ggOiBjaCArIHZhbDsgLyogaXNtaW51cz8gKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gLyUoLSk/KDA/WzAtOV0rKT8oWy5dWzAtOV0rKT8oWyNdWzAtOV0rKT8oW3NjZnBleGQlXSkvZztcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdleCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYXBwZW5kIFRoZSBuZXcgc3RyaW5nIHRvIGFwcGVuZC5cbiAgICAgICAgICogQHBhcmFtIGFyZ3MgQXJndW1ldHMgdmFsdWVzIHRvIGJlIGZvcm1hdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybWF0KGFwcGVuZCwgLi4uYXJncykge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgKz0gRm9ybWF0dGVyLmZvcm0oYXBwZW5kLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgRm9ybWF0dGVyIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICBjbGFzcyBEZXRlY3Rpb25SZXN1bHRDb2x1bW4ge1xuICAgICAgICBjb25zdHJ1Y3Rvcihib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveChib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAvLyB0aGlzLmNvZGV3b3JkcyA9IG5ldyBDb2Rld29yZFtib3VuZGluZ0JveC5nZXRNYXhZKCkgLSBib3VuZGluZ0JveC5nZXRNaW5ZKCkgKyAxXTtcbiAgICAgICAgICAgIHRoaXMuY29kZXdvcmRzID0gbmV3IEFycmF5KGJvdW5kaW5nQm94LmdldE1heFkoKSAtIGJvdW5kaW5nQm94LmdldE1pblkoKSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwqLyBnZXRDb2Rld29yZE5lYXJieShpbWFnZVJvdykge1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gdGhpcy5nZXRDb2Rld29yZChpbWFnZVJvdyk7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLk1BWF9ORUFSQllfRElTVEFOQ0U7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZWFySW1hZ2VSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KSAtIGk7XG4gICAgICAgICAgICAgICAgaWYgKG5lYXJJbWFnZVJvdyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkID0gdGhpcy5jb2Rld29yZHNbbmVhckltYWdlUm93XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWFySW1hZ2VSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KSArIGk7XG4gICAgICAgICAgICAgICAgaWYgKG5lYXJJbWFnZVJvdyA8IHRoaXMuY29kZXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZCA9IHRoaXMuY29kZXdvcmRzW25lYXJJbWFnZVJvd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZXdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKmZpbmFsIGludCovIGltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KSB7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VSb3cgLSB0aGlzLmJvdW5kaW5nQm94LmdldE1pblkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKmZpbmFsIHZvaWQqLyBzZXRDb2Rld29yZChpbWFnZVJvdywgY29kZXdvcmQpIHtcbiAgICAgICAgICAgIHRoaXMuY29kZXdvcmRzW3RoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpXSA9IGNvZGV3b3JkO1xuICAgICAgICB9XG4gICAgICAgIC8qZmluYWwqLyBnZXRDb2Rld29yZChpbWFnZVJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzW3RoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpXTtcbiAgICAgICAgfVxuICAgICAgICAvKmZpbmFsKi8gZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ0JveDtcbiAgICAgICAgfVxuICAgICAgICAvKmZpbmFsKi8gZ2V0Q29kZXdvcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgICAgICAgICAgIGxldCByb3cgPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb2Rld29yZCBvZiB0aGlzLmNvZGV3b3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyUzZDogICAgfCAgICVuJywgcm93KyspO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTNkOiAlM2R8JTNkJW4nLCByb3crKywgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCksIGNvZGV3b3JkLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERldGVjdGlvblJlc3VsdENvbHVtbi5NQVhfTkVBUkJZX0RJU1RBTkNFID0gNTtcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uO1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuSGFzaE1hcDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLk1hcC5FbnRyeTtcbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgQmFyY29kZVZhbHVlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFuIG9jY3VycmVuY2Ugb2YgYSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSk7XG4gICAgICAgICAgICBsZXQgY29uZmlkZW5jZSA9IHRoaXMudmFsdWVzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY29uZmlkZW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWRlbmNlKys7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zZXQodmFsdWUsIGNvbmZpZGVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBtYXhpbXVtIG9jY3VycmVuY2Ugb2YgYSBzZXQgdmFsdWUgYW5kIHJldHVybnMgYWxsIHZhbHVlcyB3aGljaCB3ZXJlIHNldCB3aXRoIHRoaXMgb2NjdXJyZW5jZS5cbiAgICAgICAgICogQHJldHVybiBhbiBhcnJheSBvZiBpbnQsIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyB3aXRoIHRoZSBoaWdoZXN0IG9jY3VycmVuY2UsIG9yIG51bGwsIGlmIG5vIHZhbHVlIHdhcyBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlKCkge1xuICAgICAgICAgICAgbGV0IG1heENvbmZpZGVuY2UgPSAtMTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMudmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXRLZXk6ICgpID0+IGtleSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IHZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmdldFZhbHVlKCkgPiBtYXhDb25maWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heENvbmZpZGVuY2UgPSBlbnRyeS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5nZXRWYWx1ZSgpID09PSBtYXhDb25maWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5LmdldEtleSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3Q29tbW9uLnRvSW50QXJyYXkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRDb25maWRlbmNlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMuZ2V0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbiBleHRlbmRzIERldGVjdGlvblJlc3VsdENvbHVtbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJvdW5kaW5nQm94LCBpc0xlZnQpIHtcbiAgICAgICAgICAgIHN1cGVyKGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIHRoaXMuX2lzTGVmdCA9IGlzTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBzZXRSb3dOdW1iZXJzKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmQgLypDb2Rld29yZCovIG9mIHRoaXMuZ2V0Q29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXJBc1Jvd0luZGljYXRvckNvbHVtbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBwcm9wZXJseVxuICAgICAgICAvLyBUT0RPIG1heWJlIHdlIHNob3VsZCBhZGQgbWlzc2luZyBjb2Rld29yZHMgdG8gc3RvcmUgdGhlIGNvcnJlY3Qgcm93IG51bWJlciB0byBtYWtlXG4gICAgICAgIC8vIGZpbmRpbmcgcm93IG51bWJlcnMgZm9yIG90aGVyIGNvbHVtbnMgZWFzaWVyXG4gICAgICAgIC8vIHVzZSByb3cgaGVpZ2h0IGNvdW50IHRvIG1ha2UgZGV0ZWN0aW9uIG9mIGludmFsaWQgcm93IG51bWJlcnMgbW9yZSByZWxpYWJsZVxuICAgICAgICBhZGp1c3RDb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnMoYmFyY29kZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Um93TnVtYmVycygpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmNvcnJlY3RDb2Rld29yZHMoY29kZXdvcmRzLCBiYXJjb2RlTWV0YWRhdGEpO1xuICAgICAgICAgICAgbGV0IGJvdW5kaW5nQm94ID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKSA6IGJvdW5kaW5nQm94LmdldFRvcFJpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgYm90dG9tID0gdGhpcy5faXNMZWZ0ID8gYm91bmRpbmdCb3guZ2V0Qm90dG9tTGVmdCgpIDogYm91bmRpbmdCb3guZ2V0Qm90dG9tUmlnaHQoKTtcbiAgICAgICAgICAgIGxldCBmaXJzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyh0b3AuZ2V0WSgpKSk7XG4gICAgICAgICAgICBsZXQgbGFzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyhib3R0b20uZ2V0WSgpKSk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGJlIGNhcmVmdWwgdXNpbmcgdGhlIGF2ZXJhZ2Ugcm93IGhlaWdodC4gQmFyY29kZSBjb3VsZCBiZSBza2V3ZWQgc28gdGhhdCB3ZSBoYXZlIHNtYWxsZXIgYW5kXG4gICAgICAgICAgICAvLyB0YWxsZXIgcm93c1xuICAgICAgICAgICAgLy8gZmxvYXQgYXZlcmFnZVJvd0hlaWdodCA9IChsYXN0Um93IC0gZmlyc3RSb3cpIC8gLyooZmxvYXQpKi8gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZVJvdyA9IC0xO1xuICAgICAgICAgICAgbGV0IG1heFJvd0hlaWdodCA9IDE7XG4gICAgICAgICAgICBsZXQgY3VycmVudFJvd0hlaWdodCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IGZpcnN0Um93OyBjb2Rld29yZHNSb3cgPCBsYXN0Um93OyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICAvLyAgICAgIGZsb2F0IGV4cGVjdGVkUm93TnVtYmVyID0gKGNvZGV3b3Jkc1JvdyAtIGZpcnN0Um93KSAvIGF2ZXJhZ2VSb3dIZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gICAgICBpZiAoTWF0aC5hYnMoY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgLSBleHBlY3RlZFJvd051bWJlcikgPiAyKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIFNpbXBsZUxvZy5sb2coTEVWRUwuV0FSTklORyxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIFwiUmVtb3ZpbmcgY29kZXdvcmQsIHJvd051bWJlclNrZXcgdG9vIGhpZ2gsIGNvZGV3b3JkW1wiICsgY29kZXdvcmRzUm93ICsgXCJdOiBFeHBlY3RlZCBSb3c6IFwiICtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBleHBlY3RlZFJvd051bWJlciArIFwiLCBSZWFsUm93OiBcIiArIGNvZGV3b3JkLmdldFJvd051bWJlcigpICsgXCIsIHZhbHVlOiBcIiArIGNvZGV3b3JkLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJvd0RpZmZlcmVuY2UgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSAtIGJhcmNvZGVSb3c7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbXByb3ZlIGhhbmRsaW5nIHdpdGggY2FzZSB3aGVyZSBmaXJzdCByb3cgaW5kaWNhdG9yIGRvZXNuJ3Qgc3RhcnQgd2l0aCAwXG4gICAgICAgICAgICAgICAgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3dEaWZmZXJlbmNlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFJvd0hlaWdodCA9IE1hdGgubWF4KG1heFJvd0hlaWdodCwgY3VycmVudFJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3dIZWlnaHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93ID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvd0RpZmZlcmVuY2UgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLmdldFJvd051bWJlcigpID49IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIHJvd0RpZmZlcmVuY2UgPiBjb2Rld29yZHNSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoZWNrZWRSb3dzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4Um93SGVpZ2h0ID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZFJvd3MgPSAobWF4Um93SGVpZ2h0IC0gMikgKiByb3dEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZFJvd3MgPSByb3dEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZCA9IGNoZWNrZWRSb3dzID49IGNvZGV3b3Jkc1JvdztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMTsgaSA8PSBjaGVja2VkUm93cyAmJiAhY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgbXVzdCBiZSAoaGVpZ2h0ICogcm93RGlmZmVyZW5jZSkgbnVtYmVyIG9mIGNvZGV3b3JkcyBtaXNzaW5nLiBGb3Igbm93IHdlIGFzc3VtZSBoZWlnaHQgPSAxLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgaG9wZWZ1bGx5IGdldCByaWQgb2YgbW9zdCBwcm9ibGVtcyBhbHJlYWR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93IC0gaV0gIT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3dIZWlnaHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIChpbnQpIChhdmVyYWdlUm93SGVpZ2h0ICsgMC41KTtcbiAgICAgICAgfVxuICAgICAgICBnZXRSb3dIZWlnaHRzKCkge1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVNZXRhZGF0YSA9IHRoaXMuZ2V0QmFyY29kZU1ldGFkYXRhKCk7XG4gICAgICAgICAgICBpZiAoYmFyY29kZU1ldGFkYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0SW5jb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnMoYmFyY29kZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW50MzJBcnJheShiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZCAvKkNvZGV3b3JkKi8gb2YgdGhpcy5nZXRDb2Rld29yZHMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIG1vcmUgcm93cyB0aGFuIHRoZSBiYXJjb2RlIG1ldGFkYXRhIGFsbG93cyBmb3IsIGlnbm9yZSB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jvd051bWJlcl0rKztcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2UgdGhyb3cgZXhjZXB0aW9uP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1heWJlIHdlIHNob3VsZCBhZGQgbWlzc2luZyBjb2Rld29yZHMgdG8gc3RvcmUgdGhlIGNvcnJlY3Qgcm93IG51bWJlciB0byBtYWtlXG4gICAgICAgIC8vIGZpbmRpbmcgcm93IG51bWJlcnMgZm9yIG90aGVyIGNvbHVtbnMgZWFzaWVyXG4gICAgICAgIC8vIHVzZSByb3cgaGVpZ2h0IGNvdW50IHRvIG1ha2UgZGV0ZWN0aW9uIG9mIGludmFsaWQgcm93IG51bWJlcnMgbW9yZSByZWxpYWJsZVxuICAgICAgICBhZGp1c3RJbmNvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyhiYXJjb2RlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGxldCBib3VuZGluZ0JveCA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRUb3BMZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRUb3BSaWdodCgpO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldEJvdHRvbUxlZnQoKSA6IGJvdW5kaW5nQm94LmdldEJvdHRvbVJpZ2h0KCk7XG4gICAgICAgICAgICBsZXQgZmlyc3RSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KE1hdGgudHJ1bmModG9wLmdldFkoKSkpO1xuICAgICAgICAgICAgbGV0IGxhc3RSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KE1hdGgudHJ1bmMoYm90dG9tLmdldFkoKSkpO1xuICAgICAgICAgICAgLy8gZmxvYXQgYXZlcmFnZVJvd0hlaWdodCA9IChsYXN0Um93IC0gZmlyc3RSb3cpIC8gLyooZmxvYXQpKi8gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gdGhpcy5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlUm93ID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IGZpcnN0Um93OyBjb2Rld29yZHNSb3cgPCBsYXN0Um93OyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXJBc1Jvd0luZGljYXRvckNvbHVtbigpO1xuICAgICAgICAgICAgICAgIGxldCByb3dEaWZmZXJlbmNlID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgLSBiYXJjb2RlUm93O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gaW1wcm92ZSBoYW5kbGluZyB3aXRoIGNhc2Ugd2hlcmUgZmlyc3Qgcm93IGluZGljYXRvciBkb2Vzbid0IHN0YXJ0IHdpdGggMFxuICAgICAgICAgICAgICAgIGlmIChyb3dEaWZmZXJlbmNlID09PSAwKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93RGlmZmVyZW5jZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93ID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGV3b3JkLmdldFJvd051bWJlcigpID49IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gKGludCkgKGF2ZXJhZ2VSb3dIZWlnaHQgKyAwLjUpO1xuICAgICAgICB9XG4gICAgICAgIGdldEJhcmNvZGVNZXRhZGF0YSgpIHtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVDb2x1bW5Db3VudCA9IG5ldyBCYXJjb2RlVmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQgPSBuZXcgQmFyY29kZVZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0ID0gbmV3IEJhcmNvZGVWYWx1ZSgpO1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVFQ0xldmVsID0gbmV3IEJhcmNvZGVWYWx1ZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmQgLypDb2Rld29yZCovIG9mIGNvZGV3b3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXJBc1Jvd0luZGljYXRvckNvbHVtbigpO1xuICAgICAgICAgICAgICAgIGxldCByb3dJbmRpY2F0b3JWYWx1ZSA9IGNvZGV3b3JkLmdldFZhbHVlKCkgJSAzMDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmRSb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZFJvd051bWJlciArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3JkUm93TnVtYmVyICUgMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgKiAzICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZUVDTGV2ZWwuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgLyAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAlIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVDb2x1bW5Db3VudC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWF5YmUgd2Ugc2hvdWxkIGNoZWNrIGlmIHdlIGhhdmUgYW1iaWd1b3VzIHZhbHVlcz9cbiAgICAgICAgICAgIGlmICgoYmFyY29kZUNvbHVtbkNvdW50LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgIChiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgKGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAoYmFyY29kZUVDTGV2ZWwuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAgICAgYmFyY29kZUNvbHVtbkNvdW50LmdldFZhbHVlKClbMF0gPCAxIHx8XG4gICAgICAgICAgICAgICAgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LmdldFZhbHVlKClbMF0gKyBiYXJjb2RlUm93Q291bnRMb3dlclBhcnQuZ2V0VmFsdWUoKVswXSA8IFBERjQxN0NvbW1vbi5NSU5fUk9XU19JTl9CQVJDT0RFIHx8XG4gICAgICAgICAgICAgICAgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LmdldFZhbHVlKClbMF0gKyBiYXJjb2RlUm93Q291bnRMb3dlclBhcnQuZ2V0VmFsdWUoKVswXSA+IFBERjQxN0NvbW1vbi5NQVhfUk9XU19JTl9CQVJDT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmFyY29kZU1ldGFkYXRhID0gbmV3IEJhcmNvZGVNZXRhZGF0YShiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LmdldFZhbHVlKClbMF0sIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdLCBiYXJjb2RlRUNMZXZlbC5nZXRWYWx1ZSgpWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5jb3JyZWN0Q29kZXdvcmRzKGNvZGV3b3JkcywgYmFyY29kZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBiYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlSW5jb3JyZWN0Q29kZXdvcmRzKGNvZGV3b3JkcywgYmFyY29kZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgY29kZXdvcmRzIHdoaWNoIGRvIG5vdCBtYXRjaCB0aGUgbWV0YWRhdGFcbiAgICAgICAgICAgIC8vIFRPRE8gTWF5YmUgd2Ugc2hvdWxkIGtlZXAgdGhlIGluY29ycmVjdCBjb2Rld29yZHMgZm9yIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucz9cbiAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3JkUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZFJvdyA8IGNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3JkUm93KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBjb2Rld29yZHNbY29kZXdvcmRSb3ddO1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByb3dJbmRpY2F0b3JWYWx1ZSA9IGNvZGV3b3JkLmdldFZhbHVlKCkgJSAzMDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmRSb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRSb3dOdW1iZXIgPiBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkUm93TnVtYmVyICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRSb3dOdW1iZXIgJSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dJbmRpY2F0b3JWYWx1ZSAqIDMgKyAxICE9PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnRVcHBlclBhcnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLnRydW5jKHJvd0luZGljYXRvclZhbHVlIC8gMykgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93SW5kaWNhdG9yVmFsdWUgJSAzICE9PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnRMb3dlclBhcnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dJbmRpY2F0b3JWYWx1ZSArIDEgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRDb2x1bW5Db3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3JkUm93XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNMZWZ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTGVmdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0lzTGVmdDogJyArIHRoaXMuX2lzTGVmdCArICdcXG4nICsgc3VwZXIudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIERldGVjdGlvblJlc3VsdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJhcmNvZGVNZXRhZGF0YSwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIC8qZmluYWwqLyB0aGlzLkFESlVTVF9ST1dfTlVNQkVSX1NLSVAgPSAyO1xuICAgICAgICAgICAgdGhpcy5iYXJjb2RlTWV0YWRhdGEgPSBiYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgICAgICB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCA9IGJhcmNvZGVNZXRhZGF0YS5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgICAgICAgICAgLy8gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zID0gbmV3IERldGVjdGlvblJlc3VsdENvbHVtblt0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDJdO1xuICAgICAgICAgICAgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zID0gbmV3IEFycmF5KHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1ucygpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0SW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0pO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdKTtcbiAgICAgICAgICAgIGxldCB1bmFkanVzdGVkQ29kZXdvcmRDb3VudCA9IFBERjQxN0NvbW1vbi5NQVhfQ09ERVdPUkRTX0lOX0JBUkNPREU7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNVbmFkanVzdGVkQ291bnQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNVbmFkanVzdGVkQ291bnQgPSB1bmFkanVzdGVkQ29kZXdvcmRDb3VudDtcbiAgICAgICAgICAgICAgICB1bmFkanVzdGVkQ29kZXdvcmRDb3VudCA9IHRoaXMuYWRqdXN0Um93TnVtYmVyc0FuZEdldENvdW50KCk7XG4gICAgICAgICAgICB9IHdoaWxlICh1bmFkanVzdGVkQ29kZXdvcmRDb3VudCA+IDAgJiYgdW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPCBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zO1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdEluZGljYXRvckNvbHVtblJvd051bWJlcnMoZGV0ZWN0aW9uUmVzdWx0Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0Q29sdW1uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgLmFkanVzdENvbXBsZXRlSW5kaWNhdG9yQ29sdW1uUm93TnVtYmVycyh0aGlzLmJhcmNvZGVNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBlbnN1cmUgdGhhdCBubyBkZXRlY3RlZCBjb2Rld29yZHMgd2l0aCB1bmtub3duIHJvdyBudW1iZXIgYXJlIGxlZnRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gZXN0aW1hdGUgdGhlIHJvdyBoZWlnaHQgYW5kIHVzZSBpdCBhcyBhIGhpbnQgZm9yIHRoZSByb3cgbnVtYmVyXG4gICAgICAgIC8vIHdlIHNob3VsZCBhbHNvIGZpbGwgdGhlIHJvd3MgdG9wIHRvIGJvdHRvbSBhbmQgYm90dG9tIHRvIHRvcFxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgY29kZXdvcmRzIHdoaWNoIGRvbid0IGhhdmUgYSB2YWxpZCByb3cgbnVtYmVyLiBOb3RlIHRoYXQgdGhlIGNvdW50IGlzIG5vdCBhY2N1cmF0ZSBhcyBjb2Rld29yZHNcbiAgICAgICAgICogd2lsbCBiZSBjb3VudGVkIHNldmVyYWwgdGltZXMuIEl0IGp1c3Qgc2VydmVzIGFzIGFuIGluZGljYXRvciB0byBzZWUgd2hlbiB3ZSBjYW4gc3RvcCBhZGp1c3Rpbmcgcm93IG51bWJlcnNcbiAgICAgICAgICovXG4gICAgICAgIGFkanVzdFJvd051bWJlcnNBbmRHZXRDb3VudCgpIHtcbiAgICAgICAgICAgIGxldCB1bmFkanVzdGVkQ291bnQgPSB0aGlzLmFkanVzdFJvd051bWJlcnNCeVJvdygpO1xuICAgICAgICAgICAgaWYgKHVuYWRqdXN0ZWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgYmFyY29kZUNvbHVtbiAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbiA8IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMTsgYmFyY29kZUNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Um93TnVtYmVycyhiYXJjb2RlQ29sdW1uLCBjb2Rld29yZHNSb3csIGNvZGV3b3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5hZGp1c3RlZENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdFJvd051bWJlcnNCeVJvdygpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Um93TnVtYmVyc0Zyb21Cb3RoUkkoKTtcbiAgICAgICAgICAgIC8vIFRPRE8gd2Ugc2hvdWxkIG9ubHkgZG8gZnVsbCByb3cgYWRqdXN0bWVudHMgaWYgcm93IG51bWJlcnMgb2YgbGVmdCBhbmQgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW4gbWF0Y2guXG4gICAgICAgICAgICAvLyBNYXliZSBpdCdzIGV2ZW4gYmV0dGVyIHRvIGNhbGN1bGF0ZWQgdGhlIGhlaWdodCAocm93czogZCkgYW5kIGRpdmlkZSBpdCBieSB0aGUgbnVtYmVyIG9mIGJhcmNvZGVcbiAgICAgICAgICAgIC8vIHJvd3MuIFRoaXMsIHRvZ2V0aGVyIHdpdGggdGhlIExSSSBhbmQgUlJJIHJvdyBudW1iZXJzIHNob3VsZCBhbGxvdyB1cyB0byBnZXQgYSBnb29kIGVzdGltYXRlIHdoZXJlIGEgcm93XG4gICAgICAgICAgICAvLyBudW1iZXIgc3RhcnRzIGFuZCBlbmRzLlxuICAgICAgICAgICAgbGV0IHVuYWRqdXN0ZWRDb3VudCA9IHRoaXMuYWRqdXN0Um93TnVtYmVyc0Zyb21MUkkoKTtcbiAgICAgICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQgKyB0aGlzLmFkanVzdFJvd051bWJlcnNGcm9tUlJJKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRqdXN0Um93TnVtYmVyc0Zyb21Cb3RoUkkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdID09IG51bGwgfHwgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBMUkljb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBsZXQgUlJJY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IExSSWNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKExSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgUlJJY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBMUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSA9PT0gUlJJY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10uZ2V0Um93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYmFyY29kZUNvbHVtbiAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbiA8PSB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudDsgYmFyY29kZUNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXIoTFJJY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10uZ2V0Um93TnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkanVzdFJvd051bWJlcnNGcm9tUlJJKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB1bmFkanVzdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcm93SW5kaWNhdG9yUm93TnVtYmVyID0gY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10uZ2V0Um93TnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgbGV0IGludmFsaWRSb3dDb3VudHMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMTsgYmFyY29kZUNvbHVtbiA+IDAgJiYgaW52YWxpZFJvd0NvdW50cyA8IHRoaXMuQURKVVNUX1JPV19OVU1CRVJfU0tJUDsgYmFyY29kZUNvbHVtbi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZFJvd0NvdW50cyA9IERldGVjdGlvblJlc3VsdC5hZGp1c3RSb3dOdW1iZXJJZlZhbGlkKHJvd0luZGljYXRvclJvd051bWJlciwgaW52YWxpZFJvd0NvdW50cywgY29kZXdvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5hZGp1c3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5hZGp1c3RlZENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdFJvd051bWJlcnNGcm9tTFJJKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdW5hZGp1c3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBjb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByb3dJbmRpY2F0b3JSb3dOdW1iZXIgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBsZXQgaW52YWxpZFJvd0NvdW50cyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYmFyY29kZUNvbHVtbiAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbiA8IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMSAmJiBpbnZhbGlkUm93Q291bnRzIDwgdGhpcy5BREpVU1RfUk9XX05VTUJFUl9TS0lQOyBiYXJjb2RlQ29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkUm93Q291bnRzID0gRGV0ZWN0aW9uUmVzdWx0LmFkanVzdFJvd051bWJlcklmVmFsaWQocm93SW5kaWNhdG9yUm93TnVtYmVyLCBpbnZhbGlkUm93Q291bnRzLCBjb2Rld29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmFkanVzdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFkanVzdFJvd051bWJlcklmVmFsaWQocm93SW5kaWNhdG9yUm93TnVtYmVyLCBpbnZhbGlkUm93Q291bnRzLCBjb2Rld29yZCkge1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZFJvd0NvdW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZC5pc1ZhbGlkUm93TnVtYmVyKHJvd0luZGljYXRvclJvd051bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyKHJvd0luZGljYXRvclJvd051bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRSb3dDb3VudHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbnZhbGlkUm93Q291bnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnZhbGlkUm93Q291bnRzO1xuICAgICAgICB9XG4gICAgICAgIGFkanVzdFJvd051bWJlcnMoYmFyY29kZUNvbHVtbiwgY29kZXdvcmRzUm93LCBjb2Rld29yZHMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW4gLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW4gLSAxXS5nZXRDb2Rld29yZHMoKTtcbiAgICAgICAgICAgIGxldCBuZXh0Q29sdW1uQ29kZXdvcmRzID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHM7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW4gKyAxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV4dENvbHVtbkNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uICsgMV0uZ2V0Q29kZXdvcmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsZXQgb3RoZXJDb2Rld29yZHM6IENvZGV3b3JkW10gPSBuZXcgQ29kZXdvcmRbMTRdO1xuICAgICAgICAgICAgbGV0IG90aGVyQ29kZXdvcmRzID0gbmV3IEFycmF5KDE0KTtcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzJdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93XTtcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzNdID0gbmV4dENvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA+IDApIHtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1swXSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAxXTtcbiAgICAgICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s0XSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDFdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzVdID0gbmV4dENvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNSb3cgPiAxKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbOF0gPSBjb2Rld29yZHNbY29kZXdvcmRzUm93IC0gMl07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMTBdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMl07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMTFdID0gbmV4dENvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzFdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDFdO1xuICAgICAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzZdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMV07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbN10gPSBuZXh0Q29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbOV0gPSBjb2Rld29yZHNbY29kZXdvcmRzUm93ICsgMl07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMTJdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMl07XG4gICAgICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMTNdID0gbmV4dENvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IG90aGVyQ29kZXdvcmQgb2Ygb3RoZXJDb2Rld29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGV0ZWN0aW9uUmVzdWx0LmFkanVzdFJvd051bWJlcihjb2Rld29yZCwgb3RoZXJDb2Rld29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlLCBpZiByb3cgbnVtYmVyIHdhcyBhZGp1c3RlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYWRqdXN0Um93TnVtYmVyKGNvZGV3b3JkLCBvdGhlckNvZGV3b3JkKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJDb2Rld29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyQ29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSAmJiBvdGhlckNvZGV3b3JkLmdldEJ1Y2tldCgpID09PSBjb2Rld29yZC5nZXRCdWNrZXQoKSkge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihvdGhlckNvZGV3b3JkLmdldFJvd051bWJlcigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRCYXJjb2RlQ29sdW1uQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmFyY29kZVJvd0NvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QmFyY29kZUVDTGV2ZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXJjb2RlTWV0YWRhdGEuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRCb3VuZGluZ0JveChib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgICAgICB9XG4gICAgICAgIGdldEJvdW5kaW5nQm94KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3g7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4sIGRldGVjdGlvblJlc3VsdENvbHVtbikge1xuICAgICAgICAgICAgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dID0gZGV0ZWN0aW9uUmVzdWx0Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGxldCByb3dJbmRpY2F0b3JDb2x1bW4gPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF07XG4gICAgICAgICAgICBpZiAocm93SW5kaWNhdG9yQ29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByb3dJbmRpY2F0b3JDb2x1bW4gPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyeSAoXG4gICAgICAgICAgICBsZXQgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICAgICAgLy8gKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IHJvd0luZGljYXRvckNvbHVtbi5nZXRDb2Rld29yZHMoKS5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnQ1cgJTNkOicsIGNvZGV3b3Jkc1Jvdyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYmFyY29kZUNvbHVtbiAvKmludCovID0gMDsgYmFyY29kZUNvbHVtbiA8IHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMjsgYmFyY29kZUNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICAgIHwgICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2Rld29yZCA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICAgIHwgICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyAlM2R8JTNkJywgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCksIGNvZGV3b3JkLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXI7XG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIENvZGV3b3JkIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc3RhcnRYLCBlbmRYLCBidWNrZXQsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvd051bWJlciA9IENvZGV3b3JkLkJBUkNPREVfUk9XX1VOS05PV047XG4gICAgICAgICAgICB0aGlzLnN0YXJ0WCA9IE1hdGgudHJ1bmMoc3RhcnRYKTtcbiAgICAgICAgICAgIHRoaXMuZW5kWCA9IE1hdGgudHJ1bmMoZW5kWCk7XG4gICAgICAgICAgICB0aGlzLmJ1Y2tldCA9IE1hdGgudHJ1bmMoYnVja2V0KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNWYWxpZFJvd051bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWRSb3dOdW1iZXIodGhpcy5yb3dOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlzVmFsaWRSb3dOdW1iZXIocm93TnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcm93TnVtYmVyICE9PSBDb2Rld29yZC5CQVJDT0RFX1JPV19VTktOT1dOICYmIHRoaXMuYnVja2V0ID09PSAocm93TnVtYmVyICUgMykgKiAzO1xuICAgICAgICB9XG4gICAgICAgIHNldFJvd051bWJlckFzUm93SW5kaWNhdG9yQ29sdW1uKCkge1xuICAgICAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSBNYXRoLnRydW5jKChNYXRoLnRydW5jKHRoaXMudmFsdWUgLyAzMCkpICogMyArIE1hdGgudHJ1bmModGhpcy5idWNrZXQgLyAzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRYIC0gdGhpcy5zdGFydFg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0U3RhcnRYKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRYO1xuICAgICAgICB9XG4gICAgICAgIGdldEVuZFgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRYO1xuICAgICAgICB9XG4gICAgICAgIGdldEJ1Y2tldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldDtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGdldFJvd051bWJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBzZXRSb3dOdW1iZXIocm93TnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJvd051bWJlciA9IHJvd051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyAgIEBPdmVycmlkZVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd051bWJlciArICd8JyArIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29kZXdvcmQuQkFSQ09ERV9ST1dfVU5LTk9XTiA9IC0xO1xuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICogQGF1dGhvciBjcmVhdGFsZSBHbWJIIChjaHJpc3RvcGguc2NodWx6QGNyZWF0YWxlLmRlKVxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBQREY0MTdDb2Rld29yZERlY29kZXIge1xuICAgICAgICAvKiBAbm90ZVxuICAgICAgICAgKiB0aGlzIGFjdGlvbiBoYXZlIHRvIGJlIHBlcmZvcm1lZCBiZWZvcmUgZmlyc3QgdXNlIG9mIGNsYXNzXG4gICAgICAgICAqIC0gc3RhdGljIGNvbnN0cnVjdG9yXG4gICAgICAgICAqIHdvcmtpbmcgd2l0aCAzMmJpdCBmbG9hdCAoYmFzZWQgZnJvbSBKYXZhIGxvZ2ljKVxuICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIC8vIFByZS1jb21wdXRlcyB0aGUgc3ltYm9sIHJhdGlvIHRhYmxlLlxuICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBpID0gMDsgaSA8IFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFN5bWJvbCA9IFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEVbaV07XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRCaXQgPSBjdXJyZW50U3ltYm9sICYgMHgxO1xuICAgICAgICAgICAgICAgIGZvciAoIC8qaW50Ki9sZXQgaiA9IDA7IGogPCBQREY0MTdDb21tb24uQkFSU19JTl9NT0RVTEU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50U3ltYm9sICYgMHgxKSA9PT0gY3VycmVudEJpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3ltYm9sID4+PSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXQgPSBjdXJyZW50U3ltYm9sICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbaV0gPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2ldW1BERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRSAtIGogLSAxXSA9IE1hdGguZnJvdW5kKHNpemUgLyBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iU3ltYm9sVGFibGVSZWFkeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldERlY29kZWRWYWx1ZShtb2R1bGVCaXRDb3VudCkge1xuICAgICAgICAgICAgbGV0IGRlY29kZWRWYWx1ZSA9IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5nZXREZWNvZGVkQ29kZXdvcmRWYWx1ZShQREY0MTdDb2Rld29yZERlY29kZXIuc2FtcGxlQml0Q291bnRzKG1vZHVsZUJpdENvdW50KSk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZFZhbHVlICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldENsb3Nlc3REZWNvZGVkVmFsdWUobW9kdWxlQml0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzYW1wbGVCaXRDb3VudHMobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudFN1bSA9IE1hdGhVdGlscy5zdW0obW9kdWxlQml0Q291bnQpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRSk7XG4gICAgICAgICAgICBsZXQgYml0Q291bnRJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgc3VtUHJldmlvdXNCaXRzID0gMDtcbiAgICAgICAgICAgIGZvciAoIC8qaW50Ki9sZXQgaSA9IDA7IGkgPCBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNhbXBsZUluZGV4ID0gYml0Q291bnRTdW0gLyAoMiAqIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX0NPREVXT1JEKSArXG4gICAgICAgICAgICAgICAgICAgIChpICogYml0Q291bnRTdW0pIC8gUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQ7XG4gICAgICAgICAgICAgICAgaWYgKHN1bVByZXZpb3VzQml0cyArIG1vZHVsZUJpdENvdW50W2JpdENvdW50SW5kZXhdIDw9IHNhbXBsZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bVByZXZpb3VzQml0cyArPSBtb2R1bGVCaXRDb3VudFtiaXRDb3VudEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgYml0Q291bnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbYml0Q291bnRJbmRleF0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldERlY29kZWRDb2Rld29yZFZhbHVlKG1vZHVsZUJpdENvdW50KSB7XG4gICAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldEJpdFZhbHVlKG1vZHVsZUJpdENvdW50KTtcbiAgICAgICAgICAgIHJldHVybiBQREY0MTdDb21tb24uZ2V0Q29kZXdvcmQoZGVjb2RlZFZhbHVlKSA9PT0gLTEgPyAtMSA6IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0Qml0VmFsdWUobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAvKmxvbmcqLyAwO1xuICAgICAgICAgICAgZm9yIChsZXQgLyppbnQqLyBpID0gMDsgaSA8IG1vZHVsZUJpdENvdW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICggLyppbnQqL2xldCBiaXQgPSAwOyBiaXQgPCBtb2R1bGVCaXRDb3VudFtpXTsgYml0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCAxKSB8IChpICUgMiA9PT0gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdvcmtpbmcgd2l0aCAzMmJpdCBmbG9hdCAoYXMgaW4gSmF2YSlcbiAgICAgICAgc3RhdGljIGdldENsb3Nlc3REZWNvZGVkVmFsdWUobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIGxldCBiaXRDb3VudFN1bSA9IE1hdGhVdGlscy5zdW0obW9kdWxlQml0Q291bnQpO1xuICAgICAgICAgICAgbGV0IGJpdENvdW50UmF0aW9zID0gbmV3IEFycmF5KFBERjQxN0NvbW1vbi5CQVJTX0lOX01PRFVMRSk7XG4gICAgICAgICAgICBpZiAoYml0Q291bnRTdW0gPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgLyppbnQqLyBpID0gMDsgaSA8IGJpdENvdW50UmF0aW9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdENvdW50UmF0aW9zW2ldID0gTWF0aC5mcm91bmQobW9kdWxlQml0Q291bnRbaV0gLyBiaXRDb3VudFN1bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJlc3RNYXRjaEVycm9yID0gRmxvYXQuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJTeW1ib2xUYWJsZVJlYWR5KSB7XG4gICAgICAgICAgICAgICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoIC8qaW50Ki9sZXQgaiA9IDA7IGogPCBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gMC4wO1xuICAgICAgICAgICAgICAgIGxldCByYXRpb1RhYmxlUm93ID0gUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtqXTtcbiAgICAgICAgICAgICAgICBmb3IgKCAvKmludCovbGV0IGsgPSAwOyBrIDwgUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBNYXRoLmZyb3VuZChyYXRpb1RhYmxlUm93W2tdIC0gYml0Q291bnRSYXRpb3Nba10pO1xuICAgICAgICAgICAgICAgICAgICBlcnJvciArPSBNYXRoLmZyb3VuZChkaWZmICogZGlmZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA+PSBiZXN0TWF0Y2hFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZsYWcgdGhhdCB0aGUgdGFibGUgaXMgcmVhZHkgZm9yIHVzZVxuICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5iU3ltYm9sVGFibGVSZWFkeSA9IGZhbHNlO1xuICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEUgPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRS5sZW5ndGgpLm1hcCh4ID0+IHggPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFKSk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTc7XG4gICAgLyoqXG4gICAgICogQGF1dGhvciBHdWVudGhlciBHcmF1XG4gICAgICovXG4gICAgLypwdWJsaWMgZmluYWwqLyBjbGFzcyBQREY0MTdSZXN1bHRNZXRhZGF0YSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50Q291bnQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZmlsZVNpemUgPSAtMTtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gLTE7XG4gICAgICAgICAgICB0aGlzLmNoZWNrc3VtID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBTZWdtZW50IElEIHJlcHJlc2VudHMgdGhlIHNlZ21lbnQgb2YgdGhlIHdob2xlIGZpbGUgZGlzdHJpYnV0ZWQgb3ZlciBkaWZmZXJlbnQgc3ltYm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBGaWxlIHNlZ21lbnQgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIGdldFNlZ21lbnRJbmRleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWdtZW50SW5kZXgoc2VnbWVudEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgdGhlIHNhbWUgZm9yIGVhY2ggcmVsYXRlZCBQREY0MTcgc3ltYm9sXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gRmlsZSBJRFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZUlkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZUlkO1xuICAgICAgICB9XG4gICAgICAgIHNldEZpbGVJZChmaWxlSWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZUlkID0gZmlsZUlkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGFsd2F5cyBudWxsXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBkZWRpY2F0ZWQgYWxyZWFkeSBwYXJzZWQgZmllbGRzXG4gICAgICAgICAqL1xuICAgICAgICAvLyAgIEBEZXByZWNhdGVkXG4gICAgICAgIGdldE9wdGlvbmFsRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbmFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbmFsRGF0YSBvbGQgb3B0aW9uYWwgZGF0YSBmb3JtYXQgYXMgaW50IGFycmF5XG4gICAgICAgICAqIEBkZXByZWNhdGVkIHBhcnNlIGFuZCB1c2UgbmV3IGZpZWxkc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gICBARGVwcmVjYXRlZFxuICAgICAgICBzZXRPcHRpb25hbERhdGEob3B0aW9uYWxEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsRGF0YSA9IG9wdGlvbmFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIGl0IGlzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICAgICAgICovXG4gICAgICAgIGlzTGFzdFNlZ21lbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0U2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBzZXRMYXN0U2VnbWVudChsYXN0U2VnbWVudCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0U2VnbWVudCA9IGxhc3RTZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGNvdW50IG9mIHNlZ21lbnRzLCAtMSBpZiBub3Qgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWdtZW50Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VnbWVudENvdW50KHNlZ21lbnRDb3VudCAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRDb3VudCA9IHNlZ21lbnRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRTZW5kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kZXIgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZW5kZXIoc2VuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBnZXRBZGRyZXNzZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzZWUgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzZXRBZGRyZXNzZWUoYWRkcmVzc2VlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3NlZSA9IGFkZHJlc3NlZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlsZW5hbWUgb2YgdGhlIGVuY29kZWQgZmlsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGZpbGVuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZXRGaWxlTmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHNldEZpbGVOYW1lKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbGVzaXplIGluIGJ5dGVzIG9mIHRoZSBlbmNvZGVkIGZpbGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBmaWxlc2l6ZSBpbiBieXRlcywgLTEgaWYgbm90IHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZVNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRGaWxlU2l6ZShmaWxlU2l6ZSAvKmxvbmcqLykge1xuICAgICAgICAgICAgdGhpcy5maWxlU2l6ZSA9IGZpbGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxNi1iaXQgQ1JDIGNoZWNrc3VtIHVzaW5nIENDSVRULTE2XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gY3JjIGNoZWNrc3VtLCAtMSBpZiBub3Qgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGVja3N1bSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrc3VtO1xuICAgICAgICB9XG4gICAgICAgIHNldENoZWNrc3VtKGNoZWNrc3VtIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzdW0gPSBjaGVja3N1bTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogdW5peCBlcG9jayB0aW1lc3RhbXAsIGVsYXBzZWQgc2Vjb25kcyBzaW5jZSAxOTcwLTAxLTAxXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gZWxhcHNlZCBzZWNvbmRzLCAtMSBpZiBub3Qgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaW1lc3RhbXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZXN0YW1wKHRpbWVzdGFtcCAvKmxvbmcqLykge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb255ZmlsbCBmb3IgSmF2YSdzIExvbmcgY2xhc3MuXG4gICAgICovXG4gICAgY2xhc3MgTG9uZyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXJzZXMgYSBzdHJpbmcgdG8gYSBudW1iZXIsIHNpbmNlIEpTIGhhcyBubyByZWFsbHkgSW50NjQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW0gTnVtZXJpYyBzdHJpbmcuXG4gICAgICAgICAqIEBwYXJhbSByYWRpeCBEZXN0aW5hdGlvbiByYWRpeC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBwYXJzZUxvbmcobnVtLCByYWRpeCA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSwgcmFkaXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGNsYXNzIE51bGxQb2ludGVyRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgTnVsbFBvaW50ZXJFeGNlcHRpb24ua2luZCA9ICdOdWxsUG9pbnRlckV4Y2VwdGlvbic7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAoYykgMTk5NCwgMjAwNCwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgKiBETyBOT1QgQUxURVIgT1IgUkVNT1ZFIENPUFlSSUdIVCBOT1RJQ0VTIE9SIFRISVMgRklMRSBIRUFERVIuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgICAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyIG9ubHksIGFzXG4gICAgICogcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24uICBPcmFjbGUgZGVzaWduYXRlcyB0aGlzXG4gICAgICogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlIFwiQ2xhc3NwYXRoXCIgZXhjZXB0aW9uIGFzIHByb3ZpZGVkXG4gICAgICogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICAgKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICAgKiB2ZXJzaW9uIDIgZm9yIG1vcmUgZGV0YWlscyAoYSBjb3B5IGlzIGluY2x1ZGVkIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdFxuICAgICAqIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuXG4gICAgICpcbiAgICAgKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uXG4gICAgICogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLFxuICAgICAqIEluYy4sIDUxIEZyYW5rbGluIFN0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQS5cbiAgICAgKlxuICAgICAqIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBXG4gICAgICogb3IgdmlzaXQgd3d3Lm9yYWNsZS5jb20gaWYgeW91IG5lZWQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvciBoYXZlIGFueVxuICAgICAqIHF1ZXN0aW9ucy5cbiAgICAgKi9cbiAgICAvLyBwYWNrYWdlIGphdmEuaW87XG4gICAgLyoqXG4gICAgICogVGhpcyBhYnN0cmFjdCBjbGFzcyBpcyB0aGUgc3VwZXJjbGFzcyBvZiBhbGwgY2xhc3NlcyByZXByZXNlbnRpbmdcbiAgICAgKiBhbiBvdXRwdXQgc3RyZWFtIG9mIGJ5dGVzLiBBbiBvdXRwdXQgc3RyZWFtIGFjY2VwdHMgb3V0cHV0IGJ5dGVzXG4gICAgICogYW5kIHNlbmRzIHRoZW0gdG8gc29tZSBzaW5rLlxuICAgICAqIDxwPlxuICAgICAqIEFwcGxpY2F0aW9ucyB0aGF0IG5lZWQgdG8gZGVmaW5lIGEgc3ViY2xhc3Mgb2ZcbiAgICAgKiA8Y29kZT5PdXRwdXRTdHJlYW08L2NvZGU+IG11c3QgYWx3YXlzIHByb3ZpZGUgYXQgbGVhc3QgYSBtZXRob2RcbiAgICAgKiB0aGF0IHdyaXRlcyBvbmUgYnl0ZSBvZiBvdXRwdXQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yICBBcnRodXIgdmFuIEhvZmZcbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ1ZmZlcmVkT3V0cHV0U3RyZWFtXG4gICAgICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW1cbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkRhdGFPdXRwdXRTdHJlYW1cbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkZpbHRlck91dHB1dFN0cmVhbVxuICAgICAqIEBzZWUgICAgIGphdmEuaW8uSW5wdXRTdHJlYW1cbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLk91dHB1dFN0cmVhbSN3cml0ZShpbnQpXG4gICAgICogQHNpbmNlICAgSkRLMS4wXG4gICAgICovXG4gICAgLypwdWJsaWMqLyBjbGFzcyBPdXRwdXRTdHJlYW0gLyppbXBsZW1lbnRzIENsb3NlYWJsZSwgRmx1c2hhYmxlKi8ge1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIDxjb2RlPmIubGVuZ3RoPC9jb2RlPiBieXRlcyBmcm9tIHRoZSBzcGVjaWZpZWQgYnl0ZSBhcnJheVxuICAgICAgICAgKiB0byB0aGlzIG91dHB1dCBzdHJlYW0uIFRoZSBnZW5lcmFsIGNvbnRyYWN0IGZvciA8Y29kZT53cml0ZShiKTwvY29kZT5cbiAgICAgICAgICogaXMgdGhhdCBpdCBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVmZmVjdCBhcyB0aGUgY2FsbFxuICAgICAgICAgKiA8Y29kZT53cml0ZShiLCAwLCBiLmxlbmd0aCk8L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICAgICBiICAgdGhlIGRhdGEuXG4gICAgICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxuICAgICAgICAgKiBAc2VlICAgICAgICBqYXZhLmlvLk91dHB1dFN0cmVhbSN3cml0ZShieXRlW10sIGludCwgaW50KVxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVCeXRlcyhiKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlQnl0ZXNPZmZzZXQoYiwgMCwgYi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgPGNvZGU+bGVuPC9jb2RlPiBieXRlcyBmcm9tIHRoZSBzcGVjaWZpZWQgYnl0ZSBhcnJheVxuICAgICAgICAgKiBzdGFydGluZyBhdCBvZmZzZXQgPGNvZGU+b2ZmPC9jb2RlPiB0byB0aGlzIG91dHB1dCBzdHJlYW0uXG4gICAgICAgICAqIFRoZSBnZW5lcmFsIGNvbnRyYWN0IGZvciA8Y29kZT53cml0ZShiLCBvZmYsIGxlbik8L2NvZGU+IGlzIHRoYXRcbiAgICAgICAgICogc29tZSBvZiB0aGUgYnl0ZXMgaW4gdGhlIGFycmF5IDxjb2RlPmI8L2NvZGU+IGFyZSB3cml0dGVuIHRvIHRoZVxuICAgICAgICAgKiBvdXRwdXQgc3RyZWFtIGluIG9yZGVyOyBlbGVtZW50IDxjb2RlPmJbb2ZmXTwvY29kZT4gaXMgdGhlIGZpcnN0XG4gICAgICAgICAqIGJ5dGUgd3JpdHRlbiBhbmQgPGNvZGU+YltvZmYrbGVuLTFdPC9jb2RlPiBpcyB0aGUgbGFzdCBieXRlIHdyaXR0ZW5cbiAgICAgICAgICogYnkgdGhpcyBvcGVyYXRpb24uXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBUaGUgPGNvZGU+d3JpdGU8L2NvZGU+IG1ldGhvZCBvZiA8Y29kZT5PdXRwdXRTdHJlYW08L2NvZGU+IGNhbGxzXG4gICAgICAgICAqIHRoZSB3cml0ZSBtZXRob2Qgb2Ygb25lIGFyZ3VtZW50IG9uIGVhY2ggb2YgdGhlIGJ5dGVzIHRvIGJlXG4gICAgICAgICAqIHdyaXR0ZW4gb3V0LiBTdWJjbGFzc2VzIGFyZSBlbmNvdXJhZ2VkIHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFuZFxuICAgICAgICAgKiBwcm92aWRlIGEgbW9yZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBJZiA8Y29kZT5iPC9jb2RlPiBpcyA8Y29kZT5udWxsPC9jb2RlPiwgYVxuICAgICAgICAgKiA8Y29kZT5OdWxsUG9pbnRlckV4Y2VwdGlvbjwvY29kZT4gaXMgdGhyb3duLlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICogSWYgPGNvZGU+b2ZmPC9jb2RlPiBpcyBuZWdhdGl2ZSwgb3IgPGNvZGU+bGVuPC9jb2RlPiBpcyBuZWdhdGl2ZSwgb3JcbiAgICAgICAgICogPGNvZGU+b2ZmK2xlbjwvY29kZT4gaXMgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG4gICAgICAgICAqIDxjb2RlPmI8L2NvZGU+LCB0aGVuIGFuIDx0dD5JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uPC90dD4gaXMgdGhyb3duLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICAgICBiICAgICB0aGUgZGF0YS5cbiAgICAgICAgICogQHBhcmFtICAgICAgb2ZmICAgdGhlIHN0YXJ0IG9mZnNldCBpbiB0aGUgZGF0YS5cbiAgICAgICAgICogQHBhcmFtICAgICAgbGVuICAgdGhlIG51bWJlciBvZiBieXRlcyB0byB3cml0ZS5cbiAgICAgICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuIEluIHBhcnRpY3VsYXIsXG4gICAgICAgICAqICAgICAgICAgICAgIGFuIDxjb2RlPklPRXhjZXB0aW9uPC9jb2RlPiBpcyB0aHJvd24gaWYgdGhlIG91dHB1dFxuICAgICAgICAgKiAgICAgICAgICAgICBzdHJlYW0gaXMgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVCeXRlc09mZnNldChiLCBvZmYsIGxlbikge1xuICAgICAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOdWxsUG9pbnRlckV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9mZiA8IDApIHx8IChvZmYgPiBiLmxlbmd0aCkgfHwgKGxlbiA8IDApIHx8XG4gICAgICAgICAgICAgICAgKChvZmYgKyBsZW4pID4gYi5sZW5ndGgpIHx8ICgob2ZmICsgbGVuKSA8IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlKGJbb2ZmICsgaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbHVzaGVzIHRoaXMgb3V0cHV0IHN0cmVhbSBhbmQgZm9yY2VzIGFueSBidWZmZXJlZCBvdXRwdXQgYnl0ZXNcbiAgICAgICAgICogdG8gYmUgd3JpdHRlbiBvdXQuIFRoZSBnZW5lcmFsIGNvbnRyYWN0IG9mIDxjb2RlPmZsdXNoPC9jb2RlPiBpc1xuICAgICAgICAgKiB0aGF0IGNhbGxpbmcgaXQgaXMgYW4gaW5kaWNhdGlvbiB0aGF0LCBpZiBhbnkgYnl0ZXMgcHJldmlvdXNseVxuICAgICAgICAgKiB3cml0dGVuIGhhdmUgYmVlbiBidWZmZXJlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIG91dHB1dFxuICAgICAgICAgKiBzdHJlYW0sIHN1Y2ggYnl0ZXMgc2hvdWxkIGltbWVkaWF0ZWx5IGJlIHdyaXR0ZW4gdG8gdGhlaXJcbiAgICAgICAgICogaW50ZW5kZWQgZGVzdGluYXRpb24uXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBJZiB0aGUgaW50ZW5kZWQgZGVzdGluYXRpb24gb2YgdGhpcyBzdHJlYW0gaXMgYW4gYWJzdHJhY3Rpb24gcHJvdmlkZWQgYnlcbiAgICAgICAgICogdGhlIHVuZGVybHlpbmcgb3BlcmF0aW5nIHN5c3RlbSwgZm9yIGV4YW1wbGUgYSBmaWxlLCB0aGVuIGZsdXNoaW5nIHRoZVxuICAgICAgICAgKiBzdHJlYW0gZ3VhcmFudGVlcyBvbmx5IHRoYXQgYnl0ZXMgcHJldmlvdXNseSB3cml0dGVuIHRvIHRoZSBzdHJlYW0gYXJlXG4gICAgICAgICAqIHBhc3NlZCB0byB0aGUgb3BlcmF0aW5nIHN5c3RlbSBmb3Igd3JpdGluZzsgaXQgZG9lcyBub3QgZ3VhcmFudGVlIHRoYXRcbiAgICAgICAgICogdGhleSBhcmUgYWN0dWFsbHkgd3JpdHRlbiB0byBhIHBoeXNpY2FsIGRldmljZSBzdWNoIGFzIGEgZGlzayBkcml2ZS5cbiAgICAgICAgICogPHA+XG4gICAgICAgICAqIFRoZSA8Y29kZT5mbHVzaDwvY29kZT4gbWV0aG9kIG9mIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gZG9lcyBub3RoaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhpcyBvdXRwdXQgc3RyZWFtIGFuZCByZWxlYXNlcyBhbnkgc3lzdGVtIHJlc291cmNlc1xuICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdHJlYW0uIFRoZSBnZW5lcmFsIGNvbnRyYWN0IG9mIDxjb2RlPmNsb3NlPC9jb2RlPlxuICAgICAgICAgKiBpcyB0aGF0IGl0IGNsb3NlcyB0aGUgb3V0cHV0IHN0cmVhbS4gQSBjbG9zZWQgc3RyZWFtIGNhbm5vdCBwZXJmb3JtXG4gICAgICAgICAqIG91dHB1dCBvcGVyYXRpb25zIGFuZCBjYW5ub3QgYmUgcmVvcGVuZWQuXG4gICAgICAgICAqIDxwPlxuICAgICAgICAgKiBUaGUgPGNvZGU+Y2xvc2U8L2NvZGU+IG1ldGhvZCBvZiA8Y29kZT5PdXRwdXRTdHJlYW08L2NvZGU+IGRvZXMgbm90aGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBPdXRPZk1lbW9yeUVycm9yIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAoYykgMTk5NCwgMjAxMCwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAgKiBETyBOT1QgQUxURVIgT1IgUkVNT1ZFIENPUFlSSUdIVCBOT1RJQ0VTIE9SIFRISVMgRklMRSBIRUFERVIuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgICAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyIG9ubHksIGFzXG4gICAgICogcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24uICBPcmFjbGUgZGVzaWduYXRlcyB0aGlzXG4gICAgICogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlIFwiQ2xhc3NwYXRoXCIgZXhjZXB0aW9uIGFzIHByb3ZpZGVkXG4gICAgICogYnkgT3JhY2xlIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdCBhY2NvbXBhbmllZCB0aGlzIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICAgKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3JcbiAgICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICAgKiB2ZXJzaW9uIDIgZm9yIG1vcmUgZGV0YWlscyAoYSBjb3B5IGlzIGluY2x1ZGVkIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdFxuICAgICAqIGFjY29tcGFuaWVkIHRoaXMgY29kZSkuXG4gICAgICpcbiAgICAgKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uXG4gICAgICogMiBhbG9uZyB3aXRoIHRoaXMgd29yazsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLFxuICAgICAqIEluYy4sIDUxIEZyYW5rbGluIFN0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQS5cbiAgICAgKlxuICAgICAqIFBsZWFzZSBjb250YWN0IE9yYWNsZSwgNTAwIE9yYWNsZSBQYXJrd2F5LCBSZWR3b29kIFNob3JlcywgQ0EgOTQwNjUgVVNBXG4gICAgICogb3IgdmlzaXQgd3d3Lm9yYWNsZS5jb20gaWYgeW91IG5lZWQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvciBoYXZlIGFueVxuICAgICAqIHF1ZXN0aW9ucy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgYW4gb3V0cHV0IHN0cmVhbSBpbiB3aGljaCB0aGUgZGF0YSBpc1xuICAgICAqIHdyaXR0ZW4gaW50byBhIGJ5dGUgYXJyYXkuIFRoZSBidWZmZXIgYXV0b21hdGljYWxseSBncm93cyBhcyBkYXRhXG4gICAgICogaXMgd3JpdHRlbiB0byBpdC5cbiAgICAgKiBUaGUgZGF0YSBjYW4gYmUgcmV0cmlldmVkIHVzaW5nIDxjb2RlPnRvQnl0ZUFycmF5KCk8L2NvZGU+IGFuZFxuICAgICAqIDxjb2RlPnRvU3RyaW5nKCk8L2NvZGU+LlxuICAgICAqIDxwPlxuICAgICAqIENsb3NpbmcgYSA8dHQ+Qnl0ZUFycmF5T3V0cHV0U3RyZWFtPC90dD4gaGFzIG5vIGVmZmVjdC4gVGhlIG1ldGhvZHMgaW5cbiAgICAgKiB0aGlzIGNsYXNzIGNhbiBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHN0cmVhbSBoYXMgYmVlbiBjbG9zZWQgd2l0aG91dFxuICAgICAqIGdlbmVyYXRpbmcgYW4gPHR0PklPRXhjZXB0aW9uPC90dD4uXG4gICAgICpcbiAgICAgKiBAYXV0aG9yICBBcnRodXIgdmFuIEhvZmZcbiAgICAgKiBAc2luY2UgICBKREsxLjBcbiAgICAgKi9cbiAgICAvKnB1YmxpYyovIGNsYXNzIEJ5dGVBcnJheU91dHB1dFN0cmVhbSBleHRlbmRzIE91dHB1dFN0cmVhbSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbS4gVGhlIGJ1ZmZlciBjYXBhY2l0eSBpc1xuICAgICAgICAgKiBpbml0aWFsbHkgMzIgYnl0ZXMsIHRob3VnaCBpdHMgc2l6ZSBpbmNyZWFzZXMgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyAgICAgdGhpcygzMik7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgYnl0ZSBhcnJheSBvdXRwdXQgc3RyZWFtLCB3aXRoIGEgYnVmZmVyIGNhcGFjaXR5IG9mXG4gICAgICAgICAqIHRoZSBzcGVjaWZpZWQgc2l6ZSwgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIHNpemUgICB0aGUgaW5pdGlhbCBzaXplLlxuICAgICAgICAgKiBAZXhjZXB0aW9uICBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgc2l6ZSBpcyBuZWdhdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHNpemUgPSAzMikge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIG51bWJlciBvZiB2YWxpZCBieXRlcyBpbiB0aGUgYnVmZmVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ05lZ2F0aXZlIGluaXRpYWwgc2l6ZTogJ1xuICAgICAgICAgICAgICAgICAgICArIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5jcmVhc2VzIHRoZSBjYXBhY2l0eSBpZiBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgaXQgY2FuIGhvbGRcbiAgICAgICAgICogYXQgbGVhc3QgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIG1pbmltdW1cbiAgICAgICAgICogY2FwYWNpdHkgYXJndW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtaW5DYXBhY2l0eSB0aGUgZGVzaXJlZCBtaW5pbXVtIGNhcGFjaXR5XG4gICAgICAgICAqIEB0aHJvd3MgT3V0T2ZNZW1vcnlFcnJvciBpZiB7QGNvZGUgbWluQ2FwYWNpdHkgPCAwfS4gIFRoaXMgaXNcbiAgICAgICAgICogaW50ZXJwcmV0ZWQgYXMgYSByZXF1ZXN0IGZvciB0aGUgdW5zYXRpc2ZpYWJseSBsYXJnZSBjYXBhY2l0eVxuICAgICAgICAgKiB7QGNvZGUgKGxvbmcpIEludGVnZXIuTUFYX1ZBTFVFICsgKG1pbkNhcGFjaXR5IC0gSW50ZWdlci5NQVhfVkFMVUUpfS5cbiAgICAgICAgICovXG4gICAgICAgIGVuc3VyZUNhcGFjaXR5KG1pbkNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBvdmVyZmxvdy1jb25zY2lvdXMgY29kZVxuICAgICAgICAgICAgaWYgKG1pbkNhcGFjaXR5IC0gdGhpcy5idWYubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3cobWluQ2FwYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNyZWFzZXMgdGhlIGNhcGFjaXR5IHRvIGVuc3VyZSB0aGF0IGl0IGNhbiBob2xkIGF0IGxlYXN0IHRoZVxuICAgICAgICAgKiBudW1iZXIgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBtaW5pbXVtIGNhcGFjaXR5IGFyZ3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWluQ2FwYWNpdHkgdGhlIGRlc2lyZWQgbWluaW11bSBjYXBhY2l0eVxuICAgICAgICAgKi9cbiAgICAgICAgZ3JvdyhtaW5DYXBhY2l0eSkge1xuICAgICAgICAgICAgLy8gb3ZlcmZsb3ctY29uc2Npb3VzIGNvZGVcbiAgICAgICAgICAgIGxldCBvbGRDYXBhY2l0eSA9IHRoaXMuYnVmLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBuZXdDYXBhY2l0eSA9IG9sZENhcGFjaXR5IDw8IDE7XG4gICAgICAgICAgICBpZiAobmV3Q2FwYWNpdHkgLSBtaW5DYXBhY2l0eSA8IDApXG4gICAgICAgICAgICAgICAgbmV3Q2FwYWNpdHkgPSBtaW5DYXBhY2l0eTtcbiAgICAgICAgICAgIGlmIChuZXdDYXBhY2l0eSA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobWluQ2FwYWNpdHkgPCAwKSAvLyBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZNZW1vcnlFcnJvcigpO1xuICAgICAgICAgICAgICAgIG5ld0NhcGFjaXR5ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IEFycmF5cy5jb3B5T2ZVaW50OEFycmF5KHRoaXMuYnVmLCBuZXdDYXBhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyB0aGUgc3BlY2lmaWVkIGJ5dGUgdG8gdGhpcyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIGIgICB0aGUgYnl0ZSB0byBiZSB3cml0dGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGUoYikge1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLmNvdW50ICsgMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLmNvdW50XSA9IC8qKGJ5dGUpKi8gYjtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIDxjb2RlPmxlbjwvY29kZT4gYnl0ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGJ5dGUgYXJyYXlcbiAgICAgICAgICogc3RhcnRpbmcgYXQgb2Zmc2V0IDxjb2RlPm9mZjwvY29kZT4gdG8gdGhpcyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgIGIgICAgIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gICBvZmYgICB0aGUgc3RhcnQgb2Zmc2V0IGluIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gICBsZW4gICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVCeXRlc09mZnNldChiLCBvZmYsIGxlbikge1xuICAgICAgICAgICAgaWYgKChvZmYgPCAwKSB8fCAob2ZmID4gYi5sZW5ndGgpIHx8IChsZW4gPCAwKSB8fFxuICAgICAgICAgICAgICAgICgob2ZmICsgbGVuKSAtIGIubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLmNvdW50ICsgbGVuKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkoYiwgb2ZmLCB0aGlzLmJ1ZiwgdGhpcy5jb3VudCwgbGVuKTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgdGhlIGNvbXBsZXRlIGNvbnRlbnRzIG9mIHRoaXMgYnl0ZSBhcnJheSBvdXRwdXQgc3RyZWFtIHRvXG4gICAgICAgICAqIHRoZSBzcGVjaWZpZWQgb3V0cHV0IHN0cmVhbSBhcmd1bWVudCwgYXMgaWYgYnkgY2FsbGluZyB0aGUgb3V0cHV0XG4gICAgICAgICAqIHN0cmVhbSdzIHdyaXRlIG1ldGhvZCB1c2luZyA8Y29kZT5vdXQud3JpdGUoYnVmLCAwLCBjb3VudCk8L2NvZGU+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gICAgICBvdXQgICB0aGUgb3V0cHV0IHN0cmVhbSB0byB3aGljaCB0byB3cml0ZSB0aGUgZGF0YS5cbiAgICAgICAgICogQGV4Y2VwdGlvbiAgSU9FeGNlcHRpb24gIGlmIGFuIEkvTyBlcnJvciBvY2N1cnMuXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZVRvKG91dCkge1xuICAgICAgICAgICAgb3V0LndyaXRlQnl0ZXNPZmZzZXQodGhpcy5idWYsIDAsIHRoaXMuY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIDxjb2RlPmNvdW50PC9jb2RlPiBmaWVsZCBvZiB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0XG4gICAgICAgICAqIHN0cmVhbSB0byB6ZXJvLCBzbyB0aGF0IGFsbCBjdXJyZW50bHkgYWNjdW11bGF0ZWQgb3V0cHV0IGluIHRoZVxuICAgICAgICAgKiBvdXRwdXQgc3RyZWFtIGlzIGRpc2NhcmRlZC4gVGhlIG91dHB1dCBzdHJlYW0gY2FuIGJlIHVzZWQgYWdhaW4sXG4gICAgICAgICAqIHJldXNpbmcgdGhlIGFscmVhZHkgYWxsb2NhdGVkIGJ1ZmZlciBzcGFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlJbnB1dFN0cmVhbSNjb3VudFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ld2x5IGFsbG9jYXRlZCBieXRlIGFycmF5LiBJdHMgc2l6ZSBpcyB0aGUgY3VycmVudFxuICAgICAgICAgKiBzaXplIG9mIHRoaXMgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIHZhbGlkIGNvbnRlbnRzIG9mIHRoZSBidWZmZXJcbiAgICAgICAgICogaGF2ZSBiZWVuIGNvcGllZCBpbnRvIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuICB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGlzIG91dHB1dCBzdHJlYW0sIGFzIGEgYnl0ZSBhcnJheS5cbiAgICAgICAgICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jc2l6ZSgpXG4gICAgICAgICAqL1xuICAgICAgICB0b0J5dGVBcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheXMuY29weU9mVWludDhBcnJheSh0aGlzLmJ1ZiwgdGhpcy5jb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgYnVmZmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuICB0aGUgdmFsdWUgb2YgdGhlIDxjb2RlPmNvdW50PC9jb2RlPiBmaWVsZCwgd2hpY2ggaXMgdGhlIG51bWJlclxuICAgICAgICAgKiAgICAgICAgICBvZiB2YWxpZCBieXRlcyBpbiB0aGlzIG91dHB1dCBzdHJlYW0uXG4gICAgICAgICAqIEBzZWUgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI2NvdW50XG4gICAgICAgICAqL1xuICAgICAgICBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcocGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZ192b2lkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nX3N0cmluZyhwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZ19udW1iZXIocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGUgYnVmZmVyJ3MgY29udGVudHMgaW50byBhIHN0cmluZyBkZWNvZGluZyBieXRlcyB1c2luZyB0aGVcbiAgICAgICAgICogcGxhdGZvcm0ncyBkZWZhdWx0IGNoYXJhY3RlciBzZXQuIFRoZSBsZW5ndGggb2YgdGhlIG5ldyA8dHQ+U3RyaW5nPC90dD5cbiAgICAgICAgICogaXMgYSBmdW5jdGlvbiBvZiB0aGUgY2hhcmFjdGVyIHNldCwgYW5kIGhlbmNlIG1heSBub3QgYmUgZXF1YWwgdG8gdGhlXG4gICAgICAgICAqIHNpemUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogPHA+IFRoaXMgbWV0aG9kIGFsd2F5cyByZXBsYWNlcyBtYWxmb3JtZWQtaW5wdXQgYW5kIHVubWFwcGFibGUtY2hhcmFjdGVyXG4gICAgICAgICAqIHNlcXVlbmNlcyB3aXRoIHRoZSBkZWZhdWx0IHJlcGxhY2VtZW50IHN0cmluZyBmb3IgdGhlIHBsYXRmb3JtJ3NcbiAgICAgICAgICogZGVmYXVsdCBjaGFyYWN0ZXIgc2V0LiBUaGUge0BsaW5rcGxhaW4gamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0RGVjb2Rlcn1cbiAgICAgICAgICogY2xhc3Mgc2hvdWxkIGJlIHVzZWQgd2hlbiBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgZGVjb2RpbmcgcHJvY2VzcyBpc1xuICAgICAgICAgKiByZXF1aXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiBTdHJpbmcgZGVjb2RlZCBmcm9tIHRoZSBidWZmZXIncyBjb250ZW50cy5cbiAgICAgICAgICogQHNpbmNlICBKREsxLjFcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nX3ZvaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgMCwgdGhpcy5jb3VudCovKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGUgYnVmZmVyJ3MgY29udGVudHMgaW50byBhIHN0cmluZyBieSBkZWNvZGluZyB0aGUgYnl0ZXMgdXNpbmdcbiAgICAgICAgICogdGhlIHNwZWNpZmllZCB7QGxpbmsgamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0IGNoYXJzZXROYW1lfS4gVGhlIGxlbmd0aCBvZlxuICAgICAgICAgKiB0aGUgbmV3IDx0dD5TdHJpbmc8L3R0PiBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBjaGFyc2V0LCBhbmQgaGVuY2UgbWF5IG5vdCBiZVxuICAgICAgICAgKiBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBieXRlIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA8cD4gVGhpcyBtZXRob2QgYWx3YXlzIHJlcGxhY2VzIG1hbGZvcm1lZC1pbnB1dCBhbmQgdW5tYXBwYWJsZS1jaGFyYWN0ZXJcbiAgICAgICAgICogc2VxdWVuY2VzIHdpdGggdGhpcyBjaGFyc2V0J3MgZGVmYXVsdCByZXBsYWNlbWVudCBzdHJpbmcuIFRoZSB7QGxpbmtcbiAgICAgICAgICogamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0RGVjb2Rlcn0gY2xhc3Mgc2hvdWxkIGJlIHVzZWQgd2hlbiBtb3JlIGNvbnRyb2xcbiAgICAgICAgICogb3ZlciB0aGUgZGVjb2RpbmcgcHJvY2VzcyBpcyByZXF1aXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtICBjaGFyc2V0TmFtZSAgdGhlIG5hbWUgb2YgYSBzdXBwb3J0ZWRcbiAgICAgICAgICogICAgICAgICAgICAgIHtAbGlua3BsYWluIGphdmEubmlvLmNoYXJzZXQuQ2hhcnNldCA8L2NvZGU+Y2hhcnNldDxjb2RlPn1cbiAgICAgICAgICogQHJldHVybiBTdHJpbmcgZGVjb2RlZCBmcm9tIHRoZSBidWZmZXIncyBjb250ZW50cy5cbiAgICAgICAgICogQGV4Y2VwdGlvbiAgVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICBJZiB0aGUgbmFtZWQgY2hhcnNldCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAqIEBzaW5jZSAgIEpESzEuMVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmdfc3RyaW5nKGNoYXJzZXROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgMCwgdGhpcy5jb3VudCwgY2hhcnNldE5hbWUqLykudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ld2x5IGFsbG9jYXRlZCBzdHJpbmcuIEl0cyBzaXplIGlzIHRoZSBjdXJyZW50IHNpemUgb2ZcbiAgICAgICAgICogdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSB2YWxpZCBjb250ZW50cyBvZiB0aGUgYnVmZmVyIGhhdmUgYmVlblxuICAgICAgICAgKiBjb3BpZWQgaW50byBpdC4gRWFjaCBjaGFyYWN0ZXIgPGk+YzwvaT4gaW4gdGhlIHJlc3VsdGluZyBzdHJpbmcgaXNcbiAgICAgICAgICogY29uc3RydWN0ZWQgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IDxpPmI8L2k+IGluIHRoZSBieXRlXG4gICAgICAgICAqIGFycmF5IHN1Y2ggdGhhdDpcbiAgICAgICAgICogPGJsb2NrcXVvdGU+PHByZT5cbiAgICAgICAgICogICAgIGMgPT0gKGNoYXIpKCgoaGlieXRlICZhbXA7IDB4ZmYpICZsdDsmbHQ7IDgpIHwgKGIgJmFtcDsgMHhmZikpXG4gICAgICAgICAqIDwvcHJlPjwvYmxvY2txdW90ZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgZG9lcyBub3QgcHJvcGVybHkgY29udmVydCBieXRlcyBpbnRvIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEFzIG9mIEpESyZuYnNwOzEuMSwgdGhlIHByZWZlcnJlZCB3YXkgdG8gZG8gdGhpcyBpcyB2aWEgdGhlXG4gICAgICAgICAqIDxjb2RlPnRvU3RyaW5nKFN0cmluZyBlbmMpPC9jb2RlPiBtZXRob2QsIHdoaWNoIHRha2VzIGFuIGVuY29kaW5nLW5hbWVcbiAgICAgICAgICogYXJndW1lbnQsIG9yIHRoZSA8Y29kZT50b1N0cmluZygpPC9jb2RlPiBtZXRob2QsIHdoaWNoIHVzZXMgdGhlXG4gICAgICAgICAqIHBsYXRmb3JtJ3MgZGVmYXVsdCBjaGFyYWN0ZXIgZW5jb2RpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAgICAgIGhpYnl0ZSAgICB0aGUgaGlnaCBieXRlIG9mIGVhY2ggcmVzdWx0aW5nIFVuaWNvZGUgY2hhcmFjdGVyLlxuICAgICAgICAgKiBAcmV0dXJuICAgICB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgb3V0cHV0IHN0cmVhbSwgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3NpemUoKVxuICAgICAgICAgKiBAc2VlICAgICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSN0b1N0cmluZyhTdHJpbmcpXG4gICAgICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3RvU3RyaW5nKClcbiAgICAgICAgICovXG4gICAgICAgIC8vIEBEZXByZWNhdGVkXG4gICAgICAgIHRvU3RyaW5nX251bWJlcihoaWJ5dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nKHRoaXMuYnVmIC8qLCBoaWJ5dGUsIDAsIHRoaXMuY291bnQqLykudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2luZyBhIDx0dD5CeXRlQXJyYXlPdXRwdXRTdHJlYW08L3R0PiBoYXMgbm8gZWZmZWN0LiBUaGUgbWV0aG9kcyBpblxuICAgICAgICAgKiB0aGlzIGNsYXNzIGNhbiBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHN0cmVhbSBoYXMgYmVlbiBjbG9zZWQgd2l0aG91dFxuICAgICAgICAgKiBnZW5lcmF0aW5nIGFuIDx0dD5JT0V4Y2VwdGlvbjwvdHQ+LlxuICAgICAgICAgKiA8cD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBJT0V4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qcHJpdmF0ZSovIHZhciBNb2RlJDI7XG4gICAgKGZ1bmN0aW9uIChNb2RlKSB7XG4gICAgICAgIE1vZGVbTW9kZVtcIkFMUEhBXCJdID0gMF0gPSBcIkFMUEhBXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkxPV0VSXCJdID0gMV0gPSBcIkxPV0VSXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIk1JWEVEXCJdID0gMl0gPSBcIk1JWEVEXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIlBVTkNUXCJdID0gM10gPSBcIlBVTkNUXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIkFMUEhBX1NISUZUXCJdID0gNF0gPSBcIkFMUEhBX1NISUZUXCI7XG4gICAgICAgIE1vZGVbTW9kZVtcIlBVTkNUX1NISUZUXCJdID0gNV0gPSBcIlBVTkNUX1NISUZUXCI7XG4gICAgfSkoTW9kZSQyIHx8IChNb2RlJDIgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIEluZGlyZWN0bHkgYWNjZXNzIHRoZSBnbG9iYWwgQmlnSW50IGNvbnN0cnVjdG9yLCBpdFxuICAgICAqIGFsbG93cyBicm93c2VycyB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBCaWdJbnQgdG8gcnVuXG4gICAgICogdGhlIGxpYnJhcnkgd2l0aG91dCBicmVha2luZyBkdWUgdG8gXCJ1bmRlZmluZWQgQmlnSW50XCJcbiAgICAgKiBlcnJvcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QmlnSW50Q29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1snQmlnSW50J10gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxbJ0JpZ0ludCddIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGZbJ0JpZ0ludCddIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHNlYXJjaCBnbG9iYWxzIGZvciBCaWdJbnQhJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3RvcmUgdGhlIEJpZ0ludCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBsZXQgQmlnSW50ZWdlcjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBiaWdpbnQgdmFsdWUuIEl0IGFsbG93cyBicm93c2Vyc1xuICAgICAqIHRoYXQgZG9lc24ndCBzdXBwb3J0IEJpZ0ludCB0byBydW4gdGhlIHJlc3Qgb2YgdGhlIGxpYnJhcnlcbiAgICAgKiBieSBub3QgZGlyZWN0bHkgYWNjZXNzaW5nIHRoZSBCaWdJbnQgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmlnSW50KG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIEJpZ0ludGVnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBCaWdJbnRlZ2VyID0gZ2V0QmlnSW50Q29uc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQmlnSW50ZWdlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgaXMgbm90IHN1cHBvcnRlZCEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50ZWdlcihudW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRFWFA5MDAoKSB7XG4gICAgICAgIC8vIGluIEphdmEgLSBhcnJheSB3aXRoIGxlbmd0aCA9IDE2XG4gICAgICAgIGxldCBFWFA5MDAgPSBbXTtcbiAgICAgICAgRVhQOTAwWzBdID0gY3JlYXRlQmlnSW50KDEpO1xuICAgICAgICBsZXQgbmluZUh1bmRyZWQgPSBjcmVhdGVCaWdJbnQoOTAwKTtcbiAgICAgICAgRVhQOTAwWzFdID0gbmluZUh1bmRyZWQ7XG4gICAgICAgIC8vIGluIEphdmEgLSBhcnJheSB3aXRoIGxlbmd0aCA9IDE2XG4gICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBFWFA5MDBbaV0gPSBFWFA5MDBbaSAtIDFdICogbmluZUh1bmRyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVYUDkwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogPHA+VGhpcyBjbGFzcyBjb250YWlucyB0aGUgbWV0aG9kcyBmb3IgZGVjb2RpbmcgdGhlIFBERjQxNyBjb2Rld29yZHMuPC9wPlxuICAgICAqXG4gICAgICogQGF1dGhvciBTSVRBIExhYiAoa2V2aW4ub3N1bGxpdmFuQHNpdGEuYWVybylcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKmZpbmFsKi8gY2xhc3MgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyIHtcbiAgICAgICAgLy8gICBwcml2YXRlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIoKSB7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIGVjTGV2ZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGUoY29kZXdvcmRzLCBlY0xldmVsKSB7XG4gICAgICAgICAgICAvLyBwYXNzIGVuY29kaW5nIHRvIHJlc3VsdCAod2lsbCBiZSB1c2VkIGZvciBkZWNvZGUgc3ltYm9scyBpbiBieXRlIG1vZGUpXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoJycpO1xuICAgICAgICAgICAgLy8gbGV0IGVuY29kaW5nOiBDaGFyc2V0ID0gU3RhbmRhcmRDaGFyc2V0cy5JU09fODg1OV8xO1xuICAgICAgICAgICAgbGV0IGVuY29kaW5nID0gQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5vdGUgdGhlIG5leHQgY29tbWFuZCBpcyBzcGVjaWZpYyBmcm9tIHRoaXMgVHlwZVNjcmlwdCBsaWJyYXJ5XG4gICAgICAgICAgICAgKiBiZWNhdXNlIFRTIGNhbid0IHByb3Blcmx5IGNhc3Qgc29tZSB2YWx1ZXMgdG8gY2hhciBhbmRcbiAgICAgICAgICAgICAqIGNvbnZlcnQgaXQgdG8gc3RyaW5nIGxhdGVyIGNvcnJlY3RseSBkdWUgdG8gZW5jb2RpbmdcbiAgICAgICAgICAgICAqIGRpZmZlcmVuY2VzIGZyb20gSmF2YSB2ZXJzaW9uLiBBcyByZXBvcnRlZCBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3p4aW5nLWpzL2xpYnJhcnkvcHVsbC8yNjQvZmlsZXMjcjM4MjgzMTU5M1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXN1bHQuZW5hYmxlRGVjb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgICAgLy8gR2V0IGNvbXBhY3Rpb24gbW9kZVxuICAgICAgICAgICAgbGV0IGNvZGVJbmRleCA9IDE7XG4gICAgICAgICAgICBsZXQgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICBsZXQgcmVzdWx0TWV0YWRhdGEgPSBuZXcgUERGNDE3UmVzdWx0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgIHdoaWxlIChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuYnl0ZUNvbXBhY3Rpb24oY29kZSwgY29kZXdvcmRzLCBlbmNvZGluZywgY29kZUluZGV4LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gY29kZXdvcmRzW2NvZGVJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuRUNJX0NIQVJTRVQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hhcnNldEVDSSA9IENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlKGNvZGV3b3Jkc1tjb2RlSW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RpbmcgPSBDaGFyc2V0LmZvck5hbWUoY2hhcnNldEVDSS5nZXROYW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9HRU5FUkFMX1BVUlBPU0U6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCBkbyBhbnl0aGluZyB3aXRoIGdlbmVyaWMgRUNJOyBza2lwIGl0cyAyIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVDSV9VU0VSX0RFRklORUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCBkbyBhbnl0aGluZyB3aXRoIHVzZXIgRUNJOyBza2lwIGl0cyAxIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuZGVjb2RlTWFjcm9CbG9jayhjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgbm90IHNlZSB0aGVzZSBvdXRzaWRlIGEgbWFjcm8gYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGV4dCBjb21wYWN0aW9uLiBEdXJpbmcgdGVzdGluZyBudW1lcm91cyBiYXJjb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXBwZWFyZWQgdG8gYmUgbWlzc2luZyB0aGUgc3RhcnRpbmcgbW9kZS4gSW4gdGhlc2UgY2FzZXMgZGVmYXVsdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGV4dCBjb21wYWN0aW9uIHNlZW1zIHRvIHdvcmsuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZUluZGV4IDwgY29kZXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXJSZXN1bHQobnVsbCwgcmVzdWx0LnRvU3RyaW5nKCksIG51bGwsIGVjTGV2ZWwpO1xuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRPdGhlcihyZXN1bHRNZXRhZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlclJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGludFxuICAgICAgICAgKiBAcGFyYW0gcGFyYW0xXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIGludFxuICAgICAgICAgKiBAcGFyYW0gY29kZUluZGV4XG4gICAgICAgICAqIEBwYXJhbSBQREY0MTdSZXN1bHRNZXRhZGF0YVxuICAgICAgICAgKiBAcGFyYW0gcmVzdWx0TWV0YWRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIC8vIEBTdXBwcmVzc1dhcm5pbmdzKFwiZGVwcmVjYXRpb25cIilcbiAgICAgICAgc3RhdGljIGRlY29kZU1hY3JvQmxvY2soY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoY29kZUluZGV4ICsgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUJFUl9PRl9TRVFVRU5DRV9DT0RFV09SRFMgPiBjb2Rld29yZHNbMF0pIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGJ5dGVzIGxlZnQgZm9yIHRoZSBzZWdtZW50IGluZGV4XG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2VnbWVudEluZGV4QXJyYXkgPSBuZXcgSW50MzJBcnJheShEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUJFUl9PRl9TRVFVRU5DRV9DT0RFV09SRFM7IGkrKywgY29kZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50SW5kZXhBcnJheVtpXSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0U2VnbWVudEluZGV4KEludGVnZXIucGFyc2VJbnQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLmRlY29kZUJhc2U5MDB0b0Jhc2UxMChzZWdtZW50SW5kZXhBcnJheSwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUJFUl9PRl9TRVFVRU5DRV9DT0RFV09SRFMpKSk7XG4gICAgICAgICAgICBsZXQgZmlsZUlkID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgZmlsZUlkKTtcbiAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldEZpbGVJZChmaWxlSWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBsZXQgb3B0aW9uYWxGaWVsZHNTdGFydCA9IC0xO1xuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2RlSW5kZXhdID09PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxGaWVsZHNTdGFydCA9IGNvZGVJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rld29yZHNbY29kZUluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRzW2NvZGVJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9OQU1FOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldEZpbGVOYW1lKGZpbGVOYW1lLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VOREVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VuZGVyID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgc2VuZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0U2VuZGVyKHNlbmRlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0FERFJFU1NFRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFkZHJlc3NlZSA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCArIDEsIGFkZHJlc3NlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldEFkZHJlc3NlZShhZGRyZXNzZWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9TRUdNRU5UX0NPVU5UOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VnbWVudENvdW50ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgc2VnbWVudENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0U2VnbWVudENvdW50KEludGVnZXIucGFyc2VJbnQoc2VnbWVudENvdW50LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1RJTUVfU1RBTVA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aW1lc3RhbXAgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRUaW1lc3RhbXAoTG9uZy5wYXJzZUxvbmcodGltZXN0YW1wLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0NIRUNLU1VNOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tzdW0gPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBjaGVja3N1bSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldENoZWNrc3VtKEludGVnZXIucGFyc2VJbnQoY2hlY2tzdW0udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9TSVpFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZVNpemUgPSBuZXcgU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBmaWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldEZpbGVTaXplKExvbmcucGFyc2VMb25nKGZpbGVTaXplLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldExhc3RTZWdtZW50KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IG9wdGlvbmFsIGZpZWxkcyB0byBhZGRpdGlvbmFsIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChvcHRpb25hbEZpZWxkc1N0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb25hbEZpZWxkc0xlbmd0aCA9IGNvZGVJbmRleCAtIG9wdGlvbmFsRmllbGRzU3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdE1ldGFkYXRhLmlzTGFzdFNlZ21lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgaW5jbHVkZSB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsRmllbGRzTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldE9wdGlvbmFsRGF0YShBcnJheXMuY29weU9mUmFuZ2UoY29kZXdvcmRzLCBvcHRpb25hbEZpZWxkc1N0YXJ0LCBvcHRpb25hbEZpZWxkc1N0YXJ0ICsgb3B0aW9uYWxGaWVsZHNMZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgQ29tcGFjdGlvbiBtb2RlIChzZWUgNS40LjEuNSkgcGVybWl0cyBhbGwgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnMgdG8gYmVcbiAgICAgICAgICogZW5jb2RlZCwgaS5lLiB2YWx1ZXMgMzIgLSAxMjYgaW5jbHVzaXZlIGluIGFjY29yZGFuY2Ugd2l0aCBJU08vSUVDIDY0NiAoSVJWKSwgYXNcbiAgICAgICAgICogd2VsbCBhcyBzZWxlY3RlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHMgVGhlIGFycmF5IG9mIGNvZGV3b3JkcyAoZGF0YSArIGVycm9yKVxuICAgICAgICAgKiBAcGFyYW0gY29kZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gcmVzdWx0ICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgbmV4dCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyB0ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAvLyAyIGNoYXJhY3RlciBwZXIgY29kZXdvcmRcbiAgICAgICAgICAgIGxldCB0ZXh0Q29tcGFjdGlvbkRhdGEgPSBuZXcgSW50MzJBcnJheSgoY29kZXdvcmRzWzBdIC0gY29kZUluZGV4KSAqIDIpO1xuICAgICAgICAgICAgLy8gVXNlZCB0byBob2xkIHRoZSBieXRlIGNvbXBhY3Rpb24gdmFsdWUgaWYgdGhlcmUgaXMgYSBtb2RlIHNoaWZ0XG4gICAgICAgICAgICBsZXQgYnl0ZUNvbXBhY3Rpb25EYXRhID0gbmV3IEludDMyQXJyYXkoKGNvZGV3b3Jkc1swXSAtIGNvZGVJbmRleCkgKiAyKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkgJiYgIWVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29tcGFjdGlvbkRhdGFbaW5kZXhdID0gY29kZSAvIDMwO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29tcGFjdGlvbkRhdGFbaW5kZXggKyAxXSA9IGNvZGUgJSAzMDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVpbml0aWFsaXplIHRleHQgY29tcGFjdGlvbiBtb2RlIHRvIGFscGhhIHN1YiBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4KytdID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBNb2RlIFNoaWZ0IGNvZGV3b3JkIDkxMyBzaGFsbCBjYXVzZSBhIHRlbXBvcmFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBmcm9tIFRleHQgQ29tcGFjdGlvbiBtb2RlIHRvIEJ5dGUgQ29tcGFjdGlvbiBtb2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc3dpdGNoIHNoYWxsIGJlIGluIGVmZmVjdCBmb3Igb25seSB0aGUgbmV4dCBjb2Rld29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB3aGljaCB0aGUgbW9kZSBzaGFsbCByZXZlcnQgdG8gdGhlIHByZXZhaWxpbmcgc3ViLW1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgVGV4dCBDb21wYWN0aW9uIG1vZGUuIENvZGV3b3JkIDkxMyBpcyBvbmx5IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIFRleHQgQ29tcGFjdGlvbiBtb2RlOyBpdHMgdXNlIGlzIGRlc2NyaWJlZCBpbiA1LjQuMi40LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb21wYWN0aW9uRGF0YVtpbmRleF0gPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQ29tcGFjdGlvbkRhdGFbaW5kZXhdID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLmRlY29kZVRleHRDb21wYWN0aW9uKHRleHRDb21wYWN0aW9uRGF0YSwgYnl0ZUNvbXBhY3Rpb25EYXRhLCBpbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBjb2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBUZXh0IENvbXBhY3Rpb24gbW9kZSBpbmNsdWRlcyBhbGwgdGhlIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXJzXG4gICAgICAgICAqIChpLmUuIHZhbHVlcyBmcm9tIDMyIHRvIDEyNikgYW5kIHRocmVlIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyczogSFQgb3IgdGFiXG4gICAgICAgICAqICg5OiBlKSwgTEYgb3IgbGluZSBmZWVkICgxMDogZSksIGFuZCBDUiBvciBjYXJyaWFnZVxuICAgICAgICAgKiByZXR1cm4gKDEzOiBlKS4gVGhlIFRleHQgQ29tcGFjdGlvbiBtb2RlIGFsc28gaW5jbHVkZXMgdmFyaW91cyBsYXRjaFxuICAgICAgICAgKiBhbmQgc2hpZnQgY2hhcmFjdGVycyB3aGljaCBhcmUgdXNlZCBleGNsdXNpdmVseSB3aXRoaW4gdGhlIG1vZGUuIFRoZSBUZXh0XG4gICAgICAgICAqIENvbXBhY3Rpb24gbW9kZSBlbmNvZGVzIHVwIHRvIDIgY2hhcmFjdGVycyBwZXIgY29kZXdvcmQuIFRoZSBjb21wYWN0aW9uIHJ1bGVzXG4gICAgICAgICAqIGZvciBjb252ZXJ0aW5nIGRhdGEgaW50byBQREY0MTcgY29kZXdvcmRzIGFyZSBkZWZpbmVkIGluIDUuNC4yLjIuIFRoZSBzdWItbW9kZVxuICAgICAgICAgKiBzd2l0Y2hlcyBhcmUgZGVmaW5lZCBpbiA1LjQuMi4zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGV4dENvbXBhY3Rpb25EYXRhIFRoZSB0ZXh0IGNvbXBhY3Rpb24gZGF0YS5cbiAgICAgICAgICogQHBhcmFtIGJ5dGVDb21wYWN0aW9uRGF0YSBUaGUgYnl0ZSBjb21wYWN0aW9uIGRhdGEgaWYgdGhlcmVcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgYSBtb2RlIHNoaWZ0LlxuICAgICAgICAgKiBAcGFyYW0gbGVuZ3RoICAgICAgICAgICAgIFRoZSBzaXplIG9mIHRoZSB0ZXh0IGNvbXBhY3Rpb24gYW5kIGJ5dGUgY29tcGFjdGlvbiBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gcmVzdWx0ICAgICAgICAgICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGVUZXh0Q29tcGFjdGlvbih0ZXh0Q29tcGFjdGlvbkRhdGEsIGJ5dGVDb21wYWN0aW9uRGF0YSwgbGVuZ3RoLCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIEJlZ2lubmluZyBmcm9tIGFuIGluaXRpYWwgc3RhdGUgb2YgdGhlIEFscGhhIHN1Yi1tb2RlXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBjb21wYWN0aW9uIG1vZGUgZm9yIFBERjQxNyBpbiBlZmZlY3QgYXQgdGhlIHN0YXJ0IG9mIGVhY2ggc3ltYm9sIHNoYWxsIGFsd2F5cyBiZSBUZXh0XG4gICAgICAgICAgICAvLyBDb21wYWN0aW9uIG1vZGUgQWxwaGEgc3ViLW1vZGUgKGFscGhhYmV0aWM6IHVwcGVyY2FzZSkuIEEgbGF0Y2ggY29kZXdvcmQgZnJvbSBhbm90aGVyIG1vZGUgdG8gdGhlIFRleHRcbiAgICAgICAgICAgIC8vIENvbXBhY3Rpb24gbW9kZSBzaGFsbCBhbHdheXMgc3dpdGNoIHRvIHRoZSBUZXh0IENvbXBhY3Rpb24gQWxwaGEgc3ViLW1vZGUuXG4gICAgICAgICAgICBsZXQgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgIGxldCBwcmlvclRvU2hpZnRNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3ViTW9kZUNoID0gdGV4dENvbXBhY3Rpb25EYXRhW2ldO1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IC8qY2hhciovICcnO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMi5BTFBIQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscGhhIChhbHBoYWJldGljOiB1cHBlcmNhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcHBlciBjYXNlIEFscGhhIENoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IDY1ID0gJ0EnIEFTQ0lJIC0+IHRoZXJlIGlzIGJ5dGUgY29kZSBvZiBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IC8qKGNoYXIpKCdBJyArIHN1Yk1vZGVDaCkgKi8gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIHN1Yk1vZGVDaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTEw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkxPV0VSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5NSVhFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRvIHB1bmN0dWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuUFVOQ1RfU0hJRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMi5MT1dFUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvd2VyIChhbHBoYWJldGljOiBsb3dlcmNhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IC8qKGNoYXIpKCdhJyArIHN1Yk1vZGVDaCkqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgc3ViTW9kZUNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5BUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRvIGFscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEFfU0hJRlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLk1JWEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gcHVuY3R1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yVG9TaGlmdE1vZGUgPSBzdWJNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5QVU5DVF9TSElGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBEb2VzIHRoaXMgbmVlZCB0byB1c2UgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGVuY29kaW5nPyBTZWUgb3RoZXIgb2NjdXJyZW5jZXMgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMi5NSVhFRDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peGVkIChwdW5jdHVhdGlvbjogZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NSVhFRF9DSEFSU1tzdWJNb2RlQ2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLlBVTkNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5MTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuTE9XRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gcHVuY3R1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yVG9TaGlmdE1vZGUgPSBzdWJNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5QVU5DVF9TSElGVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLlBVTkNUOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVuY3R1YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUEFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuUFVOQ1RfQ0hBUlNbc3ViTW9kZUNoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBBTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlJDIuQUxQSEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUkMi5BTFBIQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMi5BTFBIQV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgc3ViLW1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBwcmlvclRvU2hpZnRNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAvKihjaGFyKSgnQScgKyBzdWJNb2RlQ2gpKi8gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIHN1Yk1vZGVDaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQyLlBVTkNUX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBzdWItbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IHByaW9yVG9TaGlmdE1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViTW9kZUNoIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBVTkNUX0NIQVJTW3N1Yk1vZGVDaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGVDaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QQUw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUyBiZWZvcmUgU2hpZnQtdG8tQnl0ZSBpcyB1c2VkIGFzIGEgcGFkZGluZyBjaGFyYWN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgNS40LjIuNCBvZiB0aGUgc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZSQyLkFMUEhBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIChjaCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjaCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGRlY29kZWQgY2hhcmFjdGVyIHRvIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCeXRlIENvbXBhY3Rpb24gbW9kZSAoc2VlIDUuNC4zKSBwZXJtaXRzIGFsbCAyNTYgcG9zc2libGUgOC1iaXQgYnl0ZSB2YWx1ZXMgdG8gYmUgZW5jb2RlZC5cbiAgICAgICAgICogVGhpcyBpbmNsdWRlcyBhbGwgQVNDSUkgY2hhcmFjdGVycyB2YWx1ZSAwIHRvIDEyNyBpbmNsdXNpdmUgYW5kIHByb3ZpZGVzIGZvciBpbnRlcm5hdGlvbmFsXG4gICAgICAgICAqIGNoYXJhY3RlciBzZXQgc3VwcG9ydC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG1vZGUgICAgICBUaGUgYnl0ZSBjb21wYWN0aW9uIG1vZGUgaS5lLiA5MDEgb3IgOTI0XG4gICAgICAgICAqIEBwYXJhbSBjb2Rld29yZHMgVGhlIGFycmF5IG9mIGNvZGV3b3JkcyAoZGF0YSArIGVycm9yKVxuICAgICAgICAgKiBAcGFyYW0gZW5jb2RpbmcgIEN1cnJlbnRseSBhY3RpdmUgY2hhcmFjdGVyIGVuY29kaW5nXG4gICAgICAgICAqIEBwYXJhbSBjb2RlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSByZXN1bHQgICAgVGhlIGRlY29kZWQgZGF0YSBpcyBhcHBlbmRlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIC8qaW50Ki8gYnl0ZUNvbXBhY3Rpb24obW9kZSwgY29kZXdvcmRzLCBlbmNvZGluZywgY29kZUluZGV4LCByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkQnl0ZXMgPSBuZXcgQnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gLypsb25nKi8gMDtcbiAgICAgICAgICAgIGxldCBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgQnl0ZSBDb21wYWN0aW9uIGNoYXJhY3RlcnMgdG8gYmUgZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBub3QgYSBtdWx0aXBsZSBvZiA2XG4gICAgICAgICAgICAgICAgICAgIGxldCBieXRlQ29tcGFjdGVkQ29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoNik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0Q29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdKSAmJiAhZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlQ29tcGFjdGVkQ29kZXdvcmRzW2NvdW50KytdID0gbmV4dENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlIDkwMFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSA5MDAgKiB2YWx1ZSArIG5leHRDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dENvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyaGFwcyBpdCBzaG91bGQgYmUgb2sgdG8gY2hlY2sgb25seSBuZXh0Q29kZSA+PSBURVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSFxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuZXh0Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudCAlIDUgPT09IDApICYmIChjb3VudCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWNvZGUgZXZlcnkgNSBjb2Rld29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gQmFzZSAyNTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCA2OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBAbm90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEphdmFTY3JpcHQgc3RvcmVzIG51bWJlcnMgYXMgNjQgYml0cyBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBidXQgYWxsIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIG9uIDMyIGJpdHMgYmluYXJ5IG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU28gdGhlIG5leHQgYml0d2lzZSBvcGVyYXRpb24gY291bGQgbm90IGJlIGRvbmUgd2l0aCBzaW1wbGUgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCeXRlcy53cml0ZSgvKihieXRlKSovIE51bWJlcihjcmVhdGVCaWdJbnQodmFsdWUpID4+IGNyZWF0ZUJpZ0ludCg4ICogKDUgLSBqKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZW5kIG9mIGFsbCBjb2Rld29yZHMgaXMgcmVhY2hlZCB0aGUgbGFzdCBjb2Rld29yZCBuZWVkcyB0byBiZSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZUluZGV4ID09PSBjb2Rld29yZHNbMF0gJiYgbmV4dENvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVDb21wYWN0ZWRDb2Rld29yZHNbY291bnQrK10gPSBuZXh0Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBCeXRlIENvbXBhY3Rpb24gbW9kZSBpcyBpbnZva2VkIHdpdGggY29kZXdvcmQgOTAxLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBncm91cCBvZiBjb2Rld29yZHMgaXMgaW50ZXJwcmV0ZWQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgb25lIGJ5dGUgcGVyIGNvZGV3b3JkLCB3aXRob3V0IGNvbXBhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQnl0ZXMud3JpdGUoLyooYnl0ZSkqLyBieXRlQ29tcGFjdGVkQ29kZXdvcmRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgQnl0ZSBDb21wYWN0aW9uIGNoYXJhY3RlcnMgdG8gYmUgZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBhbiBpbnRlZ2VyIG11bHRpcGxlIG9mIDZcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSAmJiAhZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFzZSA5MDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDkwMCAqIHZhbHVlICsgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnQgJSA1ID09PSAwKSAmJiAoY291bnQgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY29kZSBldmVyeSA1IGNvZGV3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gQmFzZSAyNTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBAbm90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEphdmFTY3JpcHQgc3RvcmVzIG51bWJlcnMgYXMgNjQgYml0cyBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBidXQgYWxsIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIG9uIDMyIGJpdHMgYmluYXJ5IG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU28gdGhlIG5leHQgYml0d2lzZSBvcGVyYXRpb24gY291bGQgbm90IGJlIGRvbmUgd2l0aCBzaW1wbGUgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiAvKmludCovID0gMDsgaiA8IDY7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQnl0ZXMud3JpdGUoLyooYnl0ZSkqLyBOdW1iZXIoY3JlYXRlQmlnSW50KHZhbHVlKSA+PiBjcmVhdGVCaWdJbnQoOCAqICg1IC0gaikpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nLmRlY29kZShkZWNvZGVkQnl0ZXMudG9CeXRlQXJyYXkoKSwgZW5jb2RpbmcpKTtcbiAgICAgICAgICAgIHJldHVybiBjb2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlIChzZWUgNS40LjQpIHBlcm1pdHMgZWZmaWNpZW50IGVuY29kaW5nIG9mIG51bWVyaWMgZGF0YSBzdHJpbmdzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzIFRoZSBhcnJheSBvZiBjb2Rld29yZHMgKGRhdGEgKyBlcnJvcilcbiAgICAgICAgICogQHBhcmFtIGNvZGVJbmRleCBUaGUgY3VycmVudCBpbmRleCBpbnRvIHRoZSBjb2Rld29yZCBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdCAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIG5leHQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggLyppbnQqLywgcmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG51bWVyaWNDb2Rld29yZHMgPSBuZXcgSW50MzJBcnJheShEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFYX05VTUVSSUNfQ09ERVdPUkRTKTtcbiAgICAgICAgICAgIHdoaWxlIChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0gJiYgIWVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZUluZGV4ID09PSBjb2Rld29yZHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJpY0NvZGV3b3Jkc1tjb3VudF0gPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGNvdW50ICUgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BWF9OVU1FUklDX0NPREVXT1JEUyA9PT0gMCB8fCBjb2RlID09PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0ggfHwgZW5kKSAmJiBjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtaW52b2tpbmcgTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUgKGJ5IHVzaW5nIGNvZGV3b3JkIDkwMlxuICAgICAgICAgICAgICAgICAgICAvLyB3aGlsZSBpbiBOdW1lcmljIENvbXBhY3Rpb24gbW9kZSkgc2VydmVzICB0byB0ZXJtaW5hdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUgZ3JvdXBpbmcgYXMgZGVzY3JpYmVkIGluIDUuNC40LjIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIHRvIHN0YXJ0IGEgbmV3IG9uZSBncm91cGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuZGVjb2RlQmFzZTkwMHRvQmFzZTEwKG51bWVyaWNDb2Rld29yZHMsIGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29kZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGEgbGlzdCBvZiBOdW1lcmljIENvbXBhY3RlZCBjb2Rld29yZHMgZnJvbSBCYXNlIDkwMCB0byBCYXNlIDEwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29kZXdvcmRzIFRoZSBhcnJheSBvZiBjb2Rld29yZHNcbiAgICAgICAgICogQHBhcmFtIGNvdW50ICAgICBUaGUgbnVtYmVyIG9mIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAcmV0dXJuIFRoZSBkZWNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIE51bWVyaWMgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogRVhBTVBMRVxuICAgICAgICAgKiBFbmNvZGUgdGhlIGZpZnRlZW4gZGlnaXQgbnVtZXJpYyBzdHJpbmcgMDAwMjEzMjk4MTc0MDAwXG4gICAgICAgICAqIFByZWZpeCB0aGUgbnVtZXJpYyBzdHJpbmcgd2l0aCBhIDEgYW5kIHNldCB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICAgICAgICAgKiB0ID0gMSAwMDAgMjEzIDI5OCAxNzQgMDAwXG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAwXG4gICAgICAgICAqIGQwID0gMSAwMDAgMjEzIDI5OCAxNzQgMDAwIG1vZCA5MDAgPSAyMDBcbiAgICAgICAgICpcbiAgICAgICAgICogdCA9IDEgMDAwIDIxMyAyOTggMTc0IDAwMCBkaXYgOTAwID0gMSAxMTEgMzQ4IDEwOSAwODJcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDFcbiAgICAgICAgICogZDEgPSAxIDExMSAzNDggMTA5IDA4MiBtb2QgOTAwID0gMjgyXG4gICAgICAgICAqXG4gICAgICAgICAqIHQgPSAxIDExMSAzNDggMTA5IDA4MiBkaXYgOTAwID0gMSAyMzQgODMxIDIzMlxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgMlxuICAgICAgICAgKiBkMiA9IDEgMjM0IDgzMSAyMzIgbW9kIDkwMCA9IDYzMlxuICAgICAgICAgKlxuICAgICAgICAgKiB0ID0gMSAyMzQgODMxIDIzMiBkaXYgOTAwID0gMSAzNzIgMDM0XG4gICAgICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAzXG4gICAgICAgICAqIGQzID0gMSAzNzIgMDM0IG1vZCA5MDAgPSA0MzRcbiAgICAgICAgICpcbiAgICAgICAgICogdCA9IDEgMzcyIDAzNCBkaXYgOTAwID0gMSA1MjRcbiAgICAgICAgICogQ2FsY3VsYXRlIGNvZGV3b3JkIDRcbiAgICAgICAgICogZDQgPSAxIDUyNCBtb2QgOTAwID0gNjI0XG4gICAgICAgICAqXG4gICAgICAgICAqIHQgPSAxIDUyNCBkaXYgOTAwID0gMVxuICAgICAgICAgKiBDYWxjdWxhdGUgY29kZXdvcmQgNVxuICAgICAgICAgKiBkNSA9IDEgbW9kIDkwMCA9IDFcbiAgICAgICAgICogdCA9IDEgZGl2IDkwMCA9IDBcbiAgICAgICAgICogQ29kZXdvcmQgc2VxdWVuY2UgaXM6IDEsIDYyNCwgNDM0LCA2MzIsIDI4MiwgMjAwXG4gICAgICAgICAqXG4gICAgICAgICAqIERlY29kZSB0aGUgYWJvdmUgY29kZXdvcmRzIGludm9sdmVzXG4gICAgICAgICAqICAgMSB4IDkwMCBwb3dlciBvZiA1ICsgNjI0IHggOTAwIHBvd2VyIG9mIDQgKyA0MzQgeCA5MDAgcG93ZXIgb2YgMyArXG4gICAgICAgICAqIDYzMiB4IDkwMCBwb3dlciBvZiAyICsgMjgyIHggOTAwIHBvd2VyIG9mIDEgKyAyMDAgeCA5MDAgcG93ZXIgb2YgMCA9IDEwMDAyMTMyOTgxNzQwMDBcbiAgICAgICAgICpcbiAgICAgICAgICogUmVtb3ZlIGxlYWRpbmcgMSA9PiAgUmVzdWx0IGlzIDAwMDIxMzI5ODE3NDAwMFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUJhc2U5MDB0b0Jhc2UxMChjb2Rld29yZHMsIGNvdW50KSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gY3JlYXRlQmlnSW50KDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkVYUDkwMFtjb3VudCAtIGkgLSAxXSAqIGNyZWF0ZUJpZ0ludChjb2Rld29yZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5jaGFyQXQoMCkgIT09ICcxJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRTdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCA9IDkwMDtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0ggPSA5MDE7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk5VTUVSSUNfQ09NUEFDVElPTl9NT0RFX0xBVENIID0gOTAyO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82ID0gOTI0O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FQ0lfVVNFUl9ERUZJTkVEID0gOTI1O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FQ0lfR0VORVJBTF9QVVJQT1NFID0gOTI2O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FQ0lfQ0hBUlNFVCA9IDkyNztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0sgPSA5Mjg7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRCA9IDkyMztcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1IgPSA5MjI7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREUgPSA5MTM7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BWF9OVU1FUklDX0NPREVXT1JEUyA9IDE1O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfRklMRV9OQU1FID0gMDtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFR01FTlRfQ09VTlQgPSAxO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfVElNRV9TVEFNUCA9IDI7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9TRU5ERVIgPSAzO1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQUREUkVTU0VFID0gNDtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfU0laRSA9IDU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9DSEVDS1NVTSA9IDY7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBMID0gMjU7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkxMID0gMjc7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkFTID0gMjc7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1MID0gMjg7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLkFMID0gMjg7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBTID0gMjk7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLlBBTCA9IDI5O1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5QVU5DVF9DSEFSUyA9ICc7PD5AW1xcXFxdX2B+IVxcclxcdCw6XFxuLS4kL1wifCooKT97fVxcJyc7XG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQyLk1JWEVEX0NIQVJTID0gJzAxMjM0NTY3ODkmXFxyXFx0LDojLS4kLyslKj1eJztcbiAgICAvKipcbiAgICAgKiBUYWJsZSBjb250YWluaW5nIHZhbHVlcyBmb3IgdGhlIGV4cG9uZW50IG9mIDkwMC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIG51bWVyaWMgY29tcGFjdGlvbiBkZWNvZGUgYWxnb3JpdGhtLlxuICAgICAqL1xuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIkMi5FWFA5MDAgPSBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpID8gZ2V0RVhQOTAwKCkgOiBbXTtcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUyA9IDI7XG5cbiAgICAvKlxuICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICpcbiAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAqXG4gICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICpcbiAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5Gb3JtYXR0ZXI7XG4gICAgLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xuICAgIC8qKlxuICAgICAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgUERGNDE3U2Nhbm5pbmdEZWNvZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBUT0RPIGRvbid0IHBhc3MgaW4gbWluQ29kZXdvcmRXaWR0aCBhbmQgbWF4Q29kZXdvcmRXaWR0aCwgcGFzcyBpbiBiYXJjb2RlIGNvbHVtbnMgZm9yIHN0YXJ0IGFuZCBzdG9wIHBhdHRlcm5cbiAgICAgICAgICpcbiAgICAgICAgICogY29sdW1ucy4gVGhhdCB3YXkgd2lkdGggY2FuIGJlIGRlZHVjdGVkIGZyb20gdGhlIHBhdHRlcm4gY29sdW1uLlxuICAgICAgICAgKiBUaGlzIGFwcHJvYWNoIGFsc28gYWxsb3dzIHRvIGRldGVjdCBtb3JlIGRldGFpbHMgYWJvdXQgdGhlIGJhcmNvZGUsIGUuZy4gaWYgYSBiYXIgdHlwZSAod2hpdGUgb3IgYmxhY2spIGlzIHdpZGVyXG4gICAgICAgICAqIHRoYW4gaXQgc2hvdWxkIGJlLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHNjYW5uZXIgdXNlZCBhIGJhZCBibGFja3BvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gQml0TWF0cml4XG4gICAgICAgICAqIEBwYXJhbSBpbWFnZVxuICAgICAgICAgKiBAcGFyYW0gUmVzdWx0UG9pbnRcbiAgICAgICAgICogQHBhcmFtIGltYWdlVG9wTGVmdFxuICAgICAgICAgKiBAcGFyYW0gUmVzdWx0UG9pbnRcbiAgICAgICAgICogQHBhcmFtIGltYWdlQm90dG9tTGVmdFxuICAgICAgICAgKiBAcGFyYW0gUmVzdWx0UG9pbnRcbiAgICAgICAgICogQHBhcmFtIGltYWdlVG9wUmlnaHRcbiAgICAgICAgICogQHBhcmFtIFJlc3VsdFBvaW50XG4gICAgICAgICAqIEBwYXJhbSBpbWFnZUJvdHRvbVJpZ2h0XG4gICAgICAgICAqIEBwYXJhbSBpbnRcbiAgICAgICAgICogQHBhcmFtIG1pbkNvZGV3b3JkV2lkdGhcbiAgICAgICAgICogQHBhcmFtIGludFxuICAgICAgICAgKiBAcGFyYW0gbWF4Q29kZXdvcmRXaWR0aFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBkZWNvZGUoaW1hZ2UsIGltYWdlVG9wTGVmdCwgaW1hZ2VCb3R0b21MZWZ0LCBpbWFnZVRvcFJpZ2h0LCBpbWFnZUJvdHRvbVJpZ2h0LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goaW1hZ2UsIGltYWdlVG9wTGVmdCwgaW1hZ2VCb3R0b21MZWZ0LCBpbWFnZVRvcFJpZ2h0LCBpbWFnZUJvdHRvbVJpZ2h0KTtcbiAgICAgICAgICAgIGxldCBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCByaWdodFJvd0luZGljYXRvckNvbHVtbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGV0ZWN0aW9uUmVzdWx0O1xuICAgICAgICAgICAgZm9yIChsZXQgZmlyc3RQYXNzIC8qYm9vbGVhbiovID0gdHJ1ZTs7IGZpcnN0UGFzcyA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlVG9wTGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Um93SW5kaWNhdG9yQ29sdW1uKGltYWdlLCBib3VuZGluZ0JveCwgaW1hZ2VUb3BMZWZ0LCB0cnVlLCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlVG9wUmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFJvd0luZGljYXRvckNvbHVtbiA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRSb3dJbmRpY2F0b3JDb2x1bW4oaW1hZ2UsIGJvdW5kaW5nQm94LCBpbWFnZVRvcFJpZ2h0LCBmYWxzZSwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5tZXJnZShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGlvblJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uLmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdEJveCA9IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhc3MgJiYgcmVzdWx0Qm94ICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdEJveC5nZXRNaW5ZKCkgPCBib3VuZGluZ0JveC5nZXRNaW5ZKCkgfHwgcmVzdWx0Qm94LmdldE1heFkoKSA+IGJvdW5kaW5nQm94LmdldE1heFkoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdCb3ggPSByZXN1bHRCb3g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQuc2V0Qm91bmRpbmdCb3goYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgbGV0IG1heEJhcmNvZGVDb2x1bW4gPSBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAxO1xuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldERldGVjdGlvblJlc3VsdENvbHVtbigwLCBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uKTtcbiAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4obWF4QmFyY29kZUNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pO1xuICAgICAgICAgICAgbGV0IGxlZnRUb1JpZ2h0ID0gbGVmdFJvd0luZGljYXRvckNvbHVtbiAhPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgYmFyY29kZUNvbHVtbkNvdW50IC8qaW50Ki8gPSAxOyBiYXJjb2RlQ29sdW1uQ291bnQgPD0gbWF4QmFyY29kZUNvbHVtbjsgYmFyY29kZUNvbHVtbkNvdW50KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFyY29kZUNvbHVtbiA9IGxlZnRUb1JpZ2h0ID8gYmFyY29kZUNvbHVtbkNvdW50IDogbWF4QmFyY29kZUNvbHVtbiAtIGJhcmNvZGVDb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKSAhPT0gLyogbnVsbCAqLyB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBjYXNlIGZvciB0aGUgb3Bwb3NpdGUgcm93IGluZGljYXRvciBjb2x1bW4sIHdoaWNoIGRvZXNuJ3QgbmVlZCB0byBiZSBkZWNvZGVkIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRldGVjdGlvblJlc3VsdENvbHVtbjtcbiAgICAgICAgICAgICAgICBpZiAoYmFyY29kZUNvbHVtbiA9PT0gMCB8fCBiYXJjb2RlQ29sdW1uID09PSBtYXhCYXJjb2RlQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtbiA9IG5ldyBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4oYm91bmRpbmdCb3gsIGJhcmNvZGVDb2x1bW4gPT09IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gbmV3IERldGVjdGlvblJlc3VsdENvbHVtbihib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiwgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRDb2x1bW4gPSAtMTtcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNTdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gc3RhcnQgYXQgYSByb3cgZm9yIHdoaWNoIHdlIGtub3cgdGhlIHN0YXJ0IHBvc2l0aW9uLCB0aGVuIGRldGVjdCB1cHdhcmRzIGFuZCBkb3dud2FyZHMgZnJvbSB0aGVyZS5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbWFnZVJvdyAvKmludCovID0gYm91bmRpbmdCb3guZ2V0TWluWSgpOyBpbWFnZVJvdyA8PSBib3VuZGluZ0JveC5nZXRNYXhZKCk7IGltYWdlUm93KyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0U3RhcnRDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uLCBpbWFnZVJvdywgbGVmdFRvUmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPCAwIHx8IHN0YXJ0Q29sdW1uID4gYm91bmRpbmdCb3guZ2V0TWF4WCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTdGFydENvbHVtbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gcHJldmlvdXNTdGFydENvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZGV0ZWN0Q29kZXdvcmQoaW1hZ2UsIGJvdW5kaW5nQm94LmdldE1pblgoKSwgYm91bmRpbmdCb3guZ2V0TWF4WCgpLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtbi5zZXRDb2Rld29yZChpbWFnZVJvdywgY29kZXdvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29kZXdvcmRXaWR0aCA9IE1hdGgubWluKG1pbkNvZGV3b3JkV2lkdGgsIGNvZGV3b3JkLmdldFdpZHRoKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q29kZXdvcmRXaWR0aCA9IE1hdGgubWF4KG1heENvZGV3b3JkV2lkdGgsIGNvZGV3b3JkLmdldFdpZHRoKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jcmVhdGVEZWNvZGVyUmVzdWx0KGRldGVjdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uXG4gICAgICAgICAqIEBwYXJhbSByaWdodFJvd0luZGljYXRvckNvbHVtblxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbWVyZ2UobGVmdFJvd0luZGljYXRvckNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmIChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwgJiYgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJhcmNvZGVNZXRhZGF0YSA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRCYXJjb2RlTWV0YWRhdGEobGVmdFJvd0luZGljYXRvckNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGJhcmNvZGVNZXRhZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveC5tZXJnZShQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Qm91bmRpbmdCb3gobGVmdFJvd0luZGljYXRvckNvbHVtbiksIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RCb3VuZGluZ0JveChyaWdodFJvd0luZGljYXRvckNvbHVtbikpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXRlY3Rpb25SZXN1bHQoYmFyY29kZU1ldGFkYXRhLCBib3VuZGluZ0JveCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByb3dJbmRpY2F0b3JDb2x1bW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFkanVzdEJvdW5kaW5nQm94KHJvd0luZGljYXRvckNvbHVtbikge1xuICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcm93SGVpZ2h0cyA9IHJvd0luZGljYXRvckNvbHVtbi5nZXRSb3dIZWlnaHRzKCk7XG4gICAgICAgICAgICBpZiAocm93SGVpZ2h0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWF4Um93SGVpZ2h0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE1heChyb3dIZWlnaHRzKTtcbiAgICAgICAgICAgIGxldCBtaXNzaW5nU3RhcnRSb3dzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHJvd0hlaWdodCAvKmludCovIG9mIHJvd0hlaWdodHMpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nU3RhcnRSb3dzICs9IG1heFJvd0hlaWdodCAtIHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAocm93SGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRzID0gcm93SW5kaWNhdG9yQ29sdW1uLmdldENvZGV3b3JkcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgcm93IC8qaW50Ki8gPSAwOyBtaXNzaW5nU3RhcnRSb3dzID4gMCAmJiBjb2Rld29yZHNbcm93XSA9PSBudWxsOyByb3crKykge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdTdGFydFJvd3MtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtaXNzaW5nRW5kUm93cyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgLyppbnQqLyA9IHJvd0hlaWdodHMubGVuZ3RoIC0gMTsgcm93ID49IDA7IHJvdy0tKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ0VuZFJvd3MgKz0gbWF4Um93SGVpZ2h0IC0gcm93SGVpZ2h0c1tyb3ddO1xuICAgICAgICAgICAgICAgIGlmIChyb3dIZWlnaHRzW3Jvd10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gY29kZXdvcmRzLmxlbmd0aCAtIDE7IG1pc3NpbmdFbmRSb3dzID4gMCAmJiBjb2Rld29yZHNbcm93XSA9PSBudWxsOyByb3ctLSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdFbmRSb3dzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93SW5kaWNhdG9yQ29sdW1uLmdldEJvdW5kaW5nQm94KCkuYWRkTWlzc2luZ1Jvd3MobWlzc2luZ1N0YXJ0Um93cywgbWlzc2luZ0VuZFJvd3MsIHJvd0luZGljYXRvckNvbHVtbi5pc0xlZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE1heCh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCBtYXhWYWx1ZSA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgLyppbnQqLyBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF4VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldEJhcmNvZGVNZXRhZGF0YShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGxlZnRCYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAobGVmdFJvd0luZGljYXRvckNvbHVtbiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGxlZnRCYXJjb2RlTWV0YWRhdGEgPSBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLmdldEJhcmNvZGVNZXRhZGF0YSgpKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwgPyBudWxsIDogcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4uZ2V0QmFyY29kZU1ldGFkYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmlnaHRCYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAocmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChyaWdodEJhcmNvZGVNZXRhZGF0YSA9IHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uLmdldEJhcmNvZGVNZXRhZGF0YSgpKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRCYXJjb2RlTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdEJhcmNvZGVNZXRhZGF0YS5nZXRDb2x1bW5Db3VudCgpICE9PSByaWdodEJhcmNvZGVNZXRhZGF0YS5nZXRDb2x1bW5Db3VudCgpICYmXG4gICAgICAgICAgICAgICAgbGVmdEJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpICE9PSByaWdodEJhcmNvZGVNZXRhZGF0YS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCgpICYmXG4gICAgICAgICAgICAgICAgbGVmdEJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpICE9PSByaWdodEJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVmdEJhcmNvZGVNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0Um93SW5kaWNhdG9yQ29sdW1uKGltYWdlLCBib3VuZGluZ0JveCwgc3RhcnRQb2ludCwgbGVmdFRvUmlnaHQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcbiAgICAgICAgICAgIGxldCByb3dJbmRpY2F0b3JDb2x1bW4gPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uKGJvdW5kaW5nQm94LCBsZWZ0VG9SaWdodCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluY3JlbWVudCA9IGkgPT09IDAgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0Q29sdW1uID0gTWF0aC50cnVuYyhNYXRoLnRydW5jKHN0YXJ0UG9pbnQuZ2V0WCgpKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW1hZ2VSb3cgLyppbnQqLyA9IE1hdGgudHJ1bmMoTWF0aC50cnVuYyhzdGFydFBvaW50LmdldFkoKSkpOyBpbWFnZVJvdyA8PSBib3VuZGluZ0JveC5nZXRNYXhZKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VSb3cgPj0gYm91bmRpbmdCb3guZ2V0TWluWSgpOyBpbWFnZVJvdyArPSBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGV3b3JkID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRldGVjdENvZGV3b3JkKGltYWdlLCAwLCBpbWFnZS5nZXRXaWR0aCgpLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGljYXRvckNvbHVtbi5zZXRDb2Rld29yZChpbWFnZVJvdywgY29kZXdvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRUb1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBjb2Rld29yZC5nZXRTdGFydFgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gY29kZXdvcmQuZ2V0RW5kWCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd0luZGljYXRvckNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRldGVjdGlvblJlc3VsdFxuICAgICAgICAgKiBAcGFyYW0gQmFyY29kZVZhbHVlXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbTJcbiAgICAgICAgICogQHBhcmFtIHBhcmFtM1xuICAgICAgICAgKiBAcGFyYW0gYmFyY29kZU1hdHJpeFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYWRqdXN0Q29kZXdvcmRDb3VudChkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVNYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlTWF0cml4MDEgPSBiYXJjb2RlTWF0cml4WzBdWzFdO1xuICAgICAgICAgICAgbGV0IG51bWJlck9mQ29kZXdvcmRzID0gYmFyY29kZU1hdHJpeDAxLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBsZXQgY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzID0gZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICpcbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZVJvd0NvdW50KCkgLVxuICAgICAgICAgICAgICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXROdW1iZXJPZkVDQ29kZVdvcmRzKGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlRUNMZXZlbCgpKTtcbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvZGV3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzIDwgMSB8fCBjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMgPiBQREY0MTdDb21tb24uTUFYX0NPREVXT1JEU19JTl9CQVJDT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uLmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmFyY29kZU1hdHJpeDAxLnNldFZhbHVlKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChudW1iZXJPZkNvZGV3b3Jkc1swXSAhPT0gY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNhbGN1bGF0ZWQgb25lIGlzIG1vcmUgcmVsaWFibGUgYXMgaXQgaXMgZGVyaXZlZCBmcm9tIHRoZSByb3cgaW5kaWNhdG9yIGNvbHVtbnNcbiAgICAgICAgICAgICAgICBiYXJjb2RlTWF0cml4MDEuc2V0VmFsdWUoY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRldGVjdGlvblJlc3VsdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjcmVhdGVEZWNvZGVyUmVzdWx0KGRldGVjdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IGJhcmNvZGVNYXRyaXggPSBQREY0MTdTY2FubmluZ0RlY29kZXIuY3JlYXRlQmFyY29kZU1hdHJpeChkZXRlY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdENvZGV3b3JkQ291bnQoZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlTWF0cml4KTtcbiAgICAgICAgICAgIGxldCBlcmFzdXJlcyAvKkNvbGxlY3Rpb248SW50ZWdlcj4qLyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgbGV0IGNvZGV3b3JkcyA9IG5ldyBJbnQzMkFycmF5KGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKSAqIGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSk7XG4gICAgICAgICAgICBsZXQgYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0ID0gLypMaXN0PGludFtdPiovIFtdO1xuICAgICAgICAgICAgbGV0IGFtYmlndW91c0luZGV4ZXNMaXN0ID0gLypDb2xsZWN0aW9uPEludGVnZXI+Ki8gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgLyppbnQqLyA9IDA7IHJvdyA8IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKTsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gLyppbnQqLyA9IDA7IGNvbHVtbiA8IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKTsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IGJhcmNvZGVNYXRyaXhbcm93XVtjb2x1bW4gKyAxXS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZXdvcmRJbmRleCA9IHJvdyAqIGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIGNvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyYXN1cmVzLnB1c2goY29kZXdvcmRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3JkSW5kZXhdID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhlc0xpc3QucHVzaChjb2Rld29yZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4VmFsdWVzTGlzdC5wdXNoKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYW1iaWd1b3VzSW5kZXhWYWx1ZXMgPSBuZXcgQXJyYXkoYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgYW1iaWd1b3VzSW5kZXhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleFZhbHVlc1tpXSA9IGFtYmlndW91c0luZGV4VmFsdWVzTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuY3JlYXRlRGVjb2RlclJlc3VsdEZyb21BbWJpZ3VvdXNWYWx1ZXMoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVFQ0xldmVsKCksIGNvZGV3b3JkcywgUERGNDE3Q29tbW9uLnRvSW50QXJyYXkoZXJhc3VyZXMpLCBQREY0MTdDb21tb24udG9JbnRBcnJheShhbWJpZ3VvdXNJbmRleGVzTGlzdCksIGFtYmlndW91c0luZGV4VmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgZGVhbHMgd2l0aCB0aGUgZmFjdCwgdGhhdCB0aGUgZGVjb2RpbmcgcHJvY2VzcyBkb2Vzbid0IGFsd2F5cyB5aWVsZCBhIHNpbmdsZSBtb3N0IGxpa2VseSB2YWx1ZS4gVGhlXG4gICAgICAgICAqIGN1cnJlbnQgZXJyb3IgY29ycmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IGRlYWwgd2l0aCBlcmFzdXJlcyB2ZXJ5IHdlbGwsIHNvIGl0J3MgYmV0dGVyIHRvIHByb3ZpZGUgYSB2YWx1ZVxuICAgICAgICAgKiBmb3IgdGhlc2UgYW1iaWd1b3VzIGNvZGV3b3JkcyBpbnN0ZWFkIG9mIHRyZWF0aW5nIGl0IGFzIGFuIGVyYXN1cmUuIFRoZSBwcm9ibGVtIGlzIHRoYXQgd2UgZG9uJ3Qga25vdyB3aGljaCBvZlxuICAgICAgICAgKiB0aGUgYW1iaWd1b3VzIHZhbHVlcyB0byBjaG9vc2UuIFdlIHRyeSBkZWNvZGUgdXNpbmcgdGhlIGZpcnN0IHZhbHVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgdXNlIGFub3RoZXIgb2YgdGhlXG4gICAgICAgICAqIGFtYmlndW91cyB2YWx1ZXMgYW5kIHRyeSB0byBkZWNvZGUgYWdhaW4uIFRoaXMgdXN1YWxseSBvbmx5IGhhcHBlbnMgb24gdmVyeSBoYXJkIHRvIHJlYWQgYW5kIGRlY29kZSBiYXJjb2RlcyxcbiAgICAgICAgICogc28gZGVjb2RpbmcgdGhlIG5vcm1hbCBiYXJjb2RlcyBpcyBub3QgYWZmZWN0ZWQgYnkgdGhpcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVyYXN1cmVBcnJheSBjb250YWlucyB0aGUgaW5kZXhlcyBvZiBlcmFzdXJlc1xuICAgICAgICAgKiBAcGFyYW0gYW1iaWd1b3VzSW5kZXhlcyBhcnJheSB3aXRoIHRoZSBpbmRleGVzIHRoYXQgaGF2ZSBtb3JlIHRoYW4gb25lIG1vc3QgbGlrZWx5IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSBhbWJpZ3VvdXNJbmRleFZhbHVlcyB0d28gZGltZW5zaW9uYWwgYXJyYXkgdGhhdCBjb250YWlucyB0aGUgYW1iaWd1b3VzIHZhbHVlcy4gVGhlIGZpcnN0IGRpbWVuc2lvbiBtdXN0XG4gICAgICAgICAqIGJlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgYW1iaWd1b3VzSW5kZXhlcyBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY3JlYXRlRGVjb2RlclJlc3VsdEZyb21BbWJpZ3VvdXNWYWx1ZXMoZWNMZXZlbCwgY29kZXdvcmRzLCBlcmFzdXJlQXJyYXksIGFtYmlndW91c0luZGV4ZXMsIGFtYmlndW91c0luZGV4VmFsdWVzKSB7XG4gICAgICAgICAgICBsZXQgYW1iaWd1b3VzSW5kZXhDb3VudCA9IG5ldyBJbnQzMkFycmF5KGFtYmlndW91c0luZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCB0cmllcyA9IDEwMDtcbiAgICAgICAgICAgIHdoaWxlICh0cmllcy0tID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1thbWJpZ3VvdXNJbmRleGVzW2ldXSA9IGFtYmlndW91c0luZGV4VmFsdWVzW2ldW2FtYmlndW91c0luZGV4Q291bnRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZUNvZGV3b3Jkcyhjb2Rld29yZHMsIGVjTGV2ZWwsIGVyYXN1cmVBcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlnbm9yZWQgPSBlcnIgaW5zdGFuY2VvZiBDaGVja3N1bUV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFtYmlndW91c0luZGV4Q291bnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IGFtYmlndW91c0luZGV4Q291bnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFtYmlndW91c0luZGV4Q291bnRbaV0gPCBhbWJpZ3VvdXNJbmRleFZhbHVlc1tpXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleENvdW50W2ldKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4Q291bnRbaV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGFtYmlndW91c0luZGV4Q291bnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uLmdldENoZWNrc3VtSW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY3JlYXRlQmFyY29kZU1hdHJpeChkZXRlY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGxldCBiYXJjb2RlTWF0cml4OiBCYXJjb2RlVmFsdWVbXVtdID1cbiAgICAgICAgICAgIC8vIG5ldyBCYXJjb2RlVmFsdWVbZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpXVtkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAyXTtcbiAgICAgICAgICAgIGxldCBiYXJjb2RlTWF0cml4ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpIH0sICgpID0+IG5ldyBBcnJheShkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAyKSk7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgLyppbnQqLyA9IDA7IHJvdyA8IGJhcmNvZGVNYXRyaXgubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiAvKmludCovID0gMDsgY29sdW1uIDwgYmFyY29kZU1hdHJpeFtyb3ddLmxlbmd0aDsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyY29kZU1hdHJpeFtyb3ddW2NvbHVtbl0gPSBuZXcgQmFyY29kZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbHVtbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBkZXRlY3Rpb25SZXN1bHRDb2x1bW4gLypEZXRlY3Rpb25SZXN1bHRDb2x1bW4qLyBvZiBkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1ucygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGlvblJlc3VsdENvbHVtbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGV3b3JkIC8qQ29kZXdvcmQqLyBvZiBkZXRlY3Rpb25SZXN1bHRDb2x1bW4uZ2V0Q29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dOdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyID49IGJhcmNvZGVNYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIG1vcmUgcm93cyB0aGFuIHRoZSBiYXJjb2RlIG1ldGFkYXRhIGFsbG93cyBmb3IsIGlnbm9yZSB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZU1hdHJpeFtyb3dOdW1iZXJdW2NvbHVtbl0uc2V0VmFsdWUoY29kZXdvcmQuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbHVtbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhcmNvZGVNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzVmFsaWRCYXJjb2RlQ29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGJhcmNvZGVDb2x1bW4gPj0gMCAmJiBiYXJjb2RlQ29sdW1uIDw9IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldFN0YXJ0Q29sdW1uKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbiwgaW1hZ2VSb3csIGxlZnRUb1JpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbGVmdFRvUmlnaHQgPyAxIDogLTE7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpLmdldENvZGV3b3JkKGltYWdlUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRUb1JpZ2h0ID8gY29kZXdvcmQuZ2V0RW5kWCgpIDogY29kZXdvcmQuZ2V0U3RhcnRYKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbikuZ2V0Q29kZXdvcmROZWFyYnkoaW1hZ2VSb3cpO1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRTdGFydFgoKSA6IGNvZGV3b3JkLmdldEVuZFgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChQREY0MTdTY2FubmluZ0RlY29kZXIuaXNWYWxpZEJhcmNvZGVDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGNvZGV3b3JkID0gZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KS5nZXRDb2Rld29yZE5lYXJieShpbWFnZVJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGNvZGV3b3JkLmdldEVuZFgoKSA6IGNvZGV3b3JkLmdldFN0YXJ0WCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNraXBwZWRDb2x1bW5zID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChQREY0MTdTY2FubmluZ0RlY29kZXIuaXNWYWxpZEJhcmNvZGVDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGJhcmNvZGVDb2x1bW4gLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHByZXZpb3VzUm93Q29kZXdvcmQgLypDb2Rld29yZCovIG9mIGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbikuZ2V0Q29kZXdvcmRzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUm93Q29kZXdvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChsZWZ0VG9SaWdodCA/IHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0RW5kWCgpIDogcHJldmlvdXNSb3dDb2Rld29yZC5nZXRTdGFydFgoKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRDb2x1bW5zICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0RW5kWCgpIC0gcHJldmlvdXNSb3dDb2Rld29yZC5nZXRTdGFydFgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcHBlZENvbHVtbnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpLmdldE1pblgoKSA6IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpLmdldE1heFgoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZGV0ZWN0Q29kZXdvcmQoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKSB7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RDb2Rld29yZFN0YXJ0Q29sdW1uKGltYWdlLCBtaW5Db2x1bW4sIG1heENvbHVtbiwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdyk7XG4gICAgICAgICAgICAvLyB3ZSB1c3VhbGx5IGtub3cgZmFpcmx5IGV4YWN0IG5vdyBob3cgbG9uZyBhIGNvZGV3b3JkIGlzLiBXZSBzaG91bGQgcHJvdmlkZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGV4cGVjdGVkIGxlbmd0aFxuICAgICAgICAgICAgLy8gYW5kIHRyeSB0byBhZGp1c3QgdGhlIHJlYWQgcGl4ZWxzLCBlLmcuIHJlbW92ZSBzaW5nbGUgcGl4ZWwgZXJyb3JzIG9yIHRyeSB0byBjdXQgb2ZmIGV4Y2VlZGluZyBwaXhlbHMuXG4gICAgICAgICAgICAvLyBtaW4gYW5kIG1heENvZGV3b3JkV2lkdGggc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHRoZXkgYXJlIGNhbGN1bGF0ZWQgZm9yIHRoZSB3aG9sZSBiYXJjb2RlIGFuIGNhbiBiZSBpbmFjY3VyYXRlXG4gICAgICAgICAgICAvLyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIGxldCBtb2R1bGVCaXRDb3VudCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRNb2R1bGVCaXRDb3VudChpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3cpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZUJpdENvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmRDb2x1bW47XG4gICAgICAgICAgICBsZXQgY29kZXdvcmRCaXRDb3VudCA9IE1hdGhVdGlscy5zdW0obW9kdWxlQml0Q291bnQpO1xuICAgICAgICAgICAgaWYgKGxlZnRUb1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gc3RhcnRDb2x1bW4gKyBjb2Rld29yZEJpdENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IG1vZHVsZUJpdENvdW50Lmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG1wQ291bnQgPSBtb2R1bGVCaXRDb3VudFtpXTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbaV0gPSBtb2R1bGVCaXRDb3VudFttb2R1bGVCaXRDb3VudC5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUJpdENvdW50W21vZHVsZUJpdENvdW50Lmxlbmd0aCAtIDEgLSBpXSA9IHRtcENvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgICAgICBzdGFydENvbHVtbiA9IGVuZENvbHVtbiAtIGNvZGV3b3JkQml0Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBjaGVjayBmb3Igd2lkdGggYW5kIGNvcnJlY3Rpb24gb2YgYmxhY2sgYW5kIHdoaXRlIGJhcnNcbiAgICAgICAgICAgIC8vIHVzZSBzdGFydCAoYW5kIG1heWJlIHN0b3AgcGF0dGVybikgdG8gZGV0ZXJtaW5lIGlmIGJsYWNrIGJhcnMgYXJlIHdpZGVyIHRoYW4gd2hpdGUgYmFycy4gSWYgc28sIGFkanVzdC5cbiAgICAgICAgICAgIC8vIHNob3VsZCBwcm9iYWJseSBkb25lIG9ubHkgZm9yIGNvZGV3b3JkcyB3aXRoIGEgbG90IG1vcmUgdGhhbiAxNyBiaXRzLlxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBmaXhlcyAxMC0xLnBuZywgd2hpY2ggaGFzIHdpZGUgYmxhY2sgYmFycyBhbmQgc21hbGwgd2hpdGUgYmFyc1xuICAgICAgICAgICAgLy8gICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IG1vZHVsZUJpdENvdW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgLy8gICAgICAgIG1vZHVsZUJpdENvdW50W2ldLS07XG4gICAgICAgICAgICAvLyAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgICAgbW9kdWxlQml0Q291bnRbaV0rKztcbiAgICAgICAgICAgIC8vICAgICAgfVxuICAgICAgICAgICAgLy8gICAgfVxuICAgICAgICAgICAgLy8gV2UgY291bGQgYWxzbyB1c2UgdGhlIHdpZHRoIG9mIHN1cnJvdW5kaW5nIGNvZGV3b3JkcyBmb3IgbW9yZSBhY2N1cmF0ZSByZXN1bHRzLCBidXQgdGhpcyBzZWVtc1xuICAgICAgICAgICAgLy8gc3VmZmljaWVudCBmb3Igbm93XG4gICAgICAgICAgICBpZiAoIVBERjQxN1NjYW5uaW5nRGVjb2Rlci5jaGVja0NvZGV3b3JkU2tldyhjb2Rld29yZEJpdENvdW50LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHRyeSB0byB1c2UgdGhlIHN0YXJ0WCBhbmQgZW5kWCBwb3NpdGlvbiBvZiB0aGUgY29kZXdvcmQgaW4gdGhlIHNhbWUgY29sdW1uIGluIHRoZSBwcmV2aW91cyByb3csXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBiaXQgY291bnQgZnJvbSBpdCBhbmQgbm9ybWFsaXplIGl0IHRvIDguIFRoaXMgd291bGQgaGVscCB3aXRoIHNpbmdsZSBwaXhlbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldERlY29kZWRWYWx1ZShtb2R1bGVCaXRDb3VudCk7XG4gICAgICAgICAgICBsZXQgY29kZXdvcmQgPSBQREY0MTdDb21tb24uZ2V0Q29kZXdvcmQoZGVjb2RlZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZXdvcmQoc3RhcnRDb2x1bW4sIGVuZENvbHVtbiwgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldENvZGV3b3JkQnVja2V0TnVtYmVyKGRlY29kZWRWYWx1ZSksIGNvZGV3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TW9kdWxlQml0Q291bnQoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93KSB7XG4gICAgICAgICAgICBsZXQgaW1hZ2VDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgIGxldCBtb2R1bGVCaXRDb3VudCA9IG5ldyBJbnQzMkFycmF5KDgpO1xuICAgICAgICAgICAgbGV0IG1vZHVsZU51bWJlciA9IDA7XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50ID0gbGVmdFRvUmlnaHQgPyAxIDogLTE7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNQaXhlbFZhbHVlID0gbGVmdFRvUmlnaHQ7XG4gICAgICAgICAgICB3aGlsZSAoKGxlZnRUb1JpZ2h0ID8gaW1hZ2VDb2x1bW4gPCBtYXhDb2x1bW4gOiBpbWFnZUNvbHVtbiA+PSBtaW5Db2x1bW4pICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlTnVtYmVyIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChpbWFnZUNvbHVtbiwgaW1hZ2VSb3cpID09PSBwcmV2aW91c1BpeGVsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbbW9kdWxlTnVtYmVyXSsrO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUNvbHVtbiArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOdW1iZXIrKztcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNQaXhlbFZhbHVlID0gIXByZXZpb3VzUGl4ZWxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kdWxlTnVtYmVyID09PSBtb2R1bGVCaXRDb3VudC5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAoKGltYWdlQ29sdW1uID09PSAobGVmdFRvUmlnaHQgPyBtYXhDb2x1bW4gOiBtaW5Db2x1bW4pKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOdW1iZXIgPT09IG1vZHVsZUJpdENvdW50Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUJpdENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE51bWJlck9mRUNDb2RlV29yZHMoYmFyY29kZUVDTGV2ZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAyIDw8IGJhcmNvZGVFQ0xldmVsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhZGp1c3RDb2Rld29yZFN0YXJ0Q29sdW1uKGltYWdlLCBtaW5Db2x1bW4sIG1heENvbHVtbiwgbGVmdFRvUmlnaHQsIGNvZGV3b3JkU3RhcnRDb2x1bW4sIGltYWdlUm93KSB7XG4gICAgICAgICAgICBsZXQgY29ycmVjdGVkU3RhcnRDb2x1bW4gPSBjb2Rld29yZFN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgbGV0IGluY3JlbWVudCA9IGxlZnRUb1JpZ2h0ID8gLTEgOiAxO1xuICAgICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIG5vIGJsYWNrIHBpeGVscyBiZWZvcmUgdGhlIHN0YXJ0IGNvbHVtbi4gSWYgdGhlcmUgYXJlLCB0aGVuIHdlIG5lZWQgdG8gc3RhcnQgZWFybGllci5cbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGxlZnRUb1JpZ2h0ID8gY29ycmVjdGVkU3RhcnRDb2x1bW4gPj0gbWluQ29sdW1uIDogY29ycmVjdGVkU3RhcnRDb2x1bW4gPCBtYXhDb2x1bW4pICYmXG4gICAgICAgICAgICAgICAgICAgIGxlZnRUb1JpZ2h0ID09PSBpbWFnZS5nZXQoY29ycmVjdGVkU3RhcnRDb2x1bW4sIGltYWdlUm93KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29kZXdvcmRTdGFydENvbHVtbiAtIGNvcnJlY3RlZFN0YXJ0Q29sdW1uKSA+IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZFN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZFN0YXJ0Q29sdW1uICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gLWluY3JlbWVudDtcbiAgICAgICAgICAgICAgICBsZWZ0VG9SaWdodCA9ICFsZWZ0VG9SaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3JyZWN0ZWRTdGFydENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hlY2tDb2Rld29yZFNrZXcoY29kZXdvcmRTaXplLCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluQ29kZXdvcmRXaWR0aCAtIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkUgPD0gY29kZXdvcmRTaXplICYmXG4gICAgICAgICAgICAgICAgY29kZXdvcmRTaXplIDw9IG1heENvZGV3b3JkV2lkdGggKyBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbixcbiAgICAgICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGRlY29kZUNvZGV3b3Jkcyhjb2Rld29yZHMsIGVjTGV2ZWwsIGVyYXN1cmVzKSB7XG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG51bUVDQ29kZXdvcmRzID0gMSA8PCAoZWNMZXZlbCArIDEpO1xuICAgICAgICAgICAgbGV0IGNvcnJlY3RlZEVycm9yc0NvdW50ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNvcnJlY3RFcnJvcnMoY29kZXdvcmRzLCBlcmFzdXJlcywgbnVtRUNDb2Rld29yZHMpO1xuICAgICAgICAgICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLnZlcmlmeUNvZGV3b3JkQ291bnQoY29kZXdvcmRzLCBudW1FQ0NvZGV3b3Jkcyk7XG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGNvZGV3b3Jkc1xuICAgICAgICAgICAgbGV0IGRlY29kZXJSZXN1bHQgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDIuZGVjb2RlKGNvZGV3b3JkcywgJycgKyBlY0xldmVsKTtcbiAgICAgICAgICAgIGRlY29kZXJSZXN1bHQuc2V0RXJyb3JzQ29ycmVjdGVkKGNvcnJlY3RlZEVycm9yc0NvdW50KTtcbiAgICAgICAgICAgIGRlY29kZXJSZXN1bHQuc2V0RXJhc3VyZXMoZXJhc3VyZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8cD5HaXZlbiBkYXRhIGFuZCBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyByZWNlaXZlZCwgcG9zc2libHkgY29ycnVwdGVkIGJ5IGVycm9ycywgYXR0ZW1wdHMgdG9cbiAgICAgICAgICogY29ycmVjdCB0aGUgZXJyb3JzIGluLXBsYWNlLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvZGV3b3JkcyAgIGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzXG4gICAgICAgICAqIEBwYXJhbSBlcmFzdXJlcyBwb3NpdGlvbnMgb2YgYW55IGtub3duIGVyYXN1cmVzXG4gICAgICAgICAqIEBwYXJhbSBudW1FQ0NvZGV3b3JkcyBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMgdGhhdCBhcmUgYXZhaWxhYmxlIGluIGNvZGV3b3Jkc1xuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBjb3JyZWN0RXJyb3JzKGNvZGV3b3JkcywgZXJhc3VyZXMsIG51bUVDQ29kZXdvcmRzKSB7XG4gICAgICAgICAgICBpZiAoZXJhc3VyZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGVyYXN1cmVzLmxlbmd0aCA+IG51bUVDQ29kZXdvcmRzIC8gMiArIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRVJST1JTIHx8XG4gICAgICAgICAgICAgICAgbnVtRUNDb2Rld29yZHMgPCAwIHx8XG4gICAgICAgICAgICAgICAgbnVtRUNDb2Rld29yZHMgPiBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VDX0NPREVXT1JEUykge1xuICAgICAgICAgICAgICAgIC8vIFRvbyBtYW55IGVycm9ycyBvciBFQyBDb2Rld29yZHMgaXMgY29ycnVwdGVkXG4gICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb24uZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5lcnJvckNvcnJlY3Rpb24uZGVjb2RlKGNvZGV3b3JkcywgbnVtRUNDb2Rld29yZHMsIGVyYXN1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZ5IHRoYXQgYWxsIGlzIE9LIHdpdGggdGhlIGNvZGV3b3JkIGFycmF5LlxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHZlcmlmeUNvZGV3b3JkQ291bnQoY29kZXdvcmRzLCBudW1FQ0NvZGV3b3Jkcykge1xuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkcy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ29kZXdvcmQgYXJyYXkgc2l6ZSBzaG91bGQgYmUgYXQgbGVhc3QgNCBhbGxvd2luZyBmb3JcbiAgICAgICAgICAgICAgICAvLyBDb3VudCBDVywgQXQgbGVhc3Qgb25lIERhdGEgQ1csIEVycm9yIENvcnJlY3Rpb24gQ1csIEVycm9yIENvcnJlY3Rpb24gQ1dcbiAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb24uZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjb2Rld29yZCwgdGhlIFN5bWJvbCBMZW5ndGggRGVzY3JpcHRvciwgc2hhbGwgYWx3YXlzIGVuY29kZSB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGFcbiAgICAgICAgICAgIC8vIGNvZGV3b3JkcyBpbiB0aGUgc3ltYm9sLCBpbmNsdWRpbmcgdGhlIFN5bWJvbCBMZW5ndGggRGVzY3JpcHRvciBpdHNlbGYsIGRhdGEgY29kZXdvcmRzIGFuZCBwYWRcbiAgICAgICAgICAgIC8vIGNvZGV3b3JkcywgYnV0IGV4Y2x1ZGluZyB0aGUgbnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzLlxuICAgICAgICAgICAgbGV0IG51bWJlck9mQ29kZXdvcmRzID0gY29kZXdvcmRzWzBdO1xuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29kZXdvcmRzID4gY29kZXdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29kZXdvcmRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgLSA4IChBbGxvdyBmb3IgYXQgbGVhc3QgbGV2ZWwgMyBFcnJvciBDb3JyZWN0aW9uICg4IEVycm9yIENvZGV3b3JkcylcbiAgICAgICAgICAgICAgICBpZiAobnVtRUNDb2Rld29yZHMgPCBjb2Rld29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1swXSA9IGNvZGV3b3Jkcy5sZW5ndGggLSBudW1FQ0NvZGV3b3JkcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbi5nZXRGb3JtYXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0Qml0Q291bnRGb3JDb2Rld29yZChjb2Rld29yZCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KDgpO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzVmFsdWUgPSAwO1xuICAgICAgICAgICAgbGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjb2Rld29yZCAmIDB4MSkgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGNvZGV3b3JkICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldKys7XG4gICAgICAgICAgICAgICAgY29kZXdvcmQgPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRDb2Rld29yZEJ1Y2tldE51bWJlcihjb2Rld29yZCkge1xuICAgICAgICAgICAgaWYgKGNvZGV3b3JkIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvZGV3b3JkQnVja2V0TnVtYmVyX0ludDMyQXJyYXkoY29kZXdvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfbnVtYmVyKGNvZGV3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfbnVtYmVyKGNvZGV3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldENvZGV3b3JkQnVja2V0TnVtYmVyKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRCaXRDb3VudEZvckNvZGV3b3JkKGNvZGV3b3JkKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldENvZGV3b3JkQnVja2V0TnVtYmVyX0ludDMyQXJyYXkobW9kdWxlQml0Q291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiAobW9kdWxlQml0Q291bnRbMF0gLSBtb2R1bGVCaXRDb3VudFsyXSArIG1vZHVsZUJpdENvdW50WzRdIC0gbW9kdWxlQml0Q291bnRbNl0gKyA5KSAlIDk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHRvU3RyaW5nKGJhcmNvZGVNYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCk7XG4gICAgICAgICAgICAvLyB0cnkgKGxldCBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyAvKmludCovID0gMDsgcm93IDwgYmFyY29kZU1hdHJpeC5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnUm93ICUyZDogJywgcm93KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gLyppbnQqLyA9IDA7IGNvbHVtbiA8IGJhcmNvZGVNYXRyaXhbcm93XS5sZW5ndGg7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiYXJjb2RlVmFsdWUgPSBiYXJjb2RlTWF0cml4W3Jvd11bY29sdW1uXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVWYWx1ZS5nZXRWYWx1ZSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICAgICAgICAnLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyU0ZCglMmQpJywgYmFyY29kZVZhbHVlLmdldFZhbHVlKClbMF0sIGJhcmNvZGVWYWx1ZS5nZXRDb25maWRlbmNlKGJhcmNvZGVWYWx1ZS5nZXRWYWx1ZSgpWzBdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLkNPREVXT1JEX1NLRVdfU0laRSA9IDI7XG4gICAgLypmaW5hbCovIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRVJST1JTID0gMztcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FQ19DT0RFV09SRFMgPSA1MTI7XG4gICAgLypmaW5hbCovIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5lcnJvckNvcnJlY3Rpb24gPSBuZXcgRXJyb3JDb3JyZWN0aW9uKCk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xuICAgIC8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcbiAgICAvLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcbiAgICAvKipcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBkZXRlY3QgYW5kIGRlY29kZSBQREY0MTcgY29kZXMgaW4gYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIFBERjQxN1JlYWRlciB7XG4gICAgICAgIC8vIHByaXZhdGUgc3RhdGljIC8qZmluYWwgUmVzdWx0W10qLyBFTVBUWV9SRVNVTFRfQVJSQVk6IFJlc3VsdFtdID0gbmV3IFJlc3VsdChbMF0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIFBERjQxNyBjb2RlIGluIGFuIGltYWdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIGEgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29udGVudCBlbmNvZGVkIGJ5IHRoZSBQREY0MTcgY29kZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgUERGNDE3IGNvZGUgY2Fubm90IGJlIGZvdW5kLFxuICAgICAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFBERjQxNyBjYW5ub3QgYmUgZGVjb2RlZFxuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZGVjb2RlKGltYWdlLCBoaW50cyA9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBQREY0MTdSZWFkZXIuZGVjb2RlKGltYWdlLCBoaW50cywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdC5sZW5ndGggPT09IDAgfHwgcmVzdWx0WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gQmluYXJ5Qml0bWFwXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZVxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvLyAgIEBPdmVycmlkZVxuICAgICAgICBkZWNvZGVNdWx0aXBsZShpbWFnZSwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQREY0MTdSZWFkZXIuZGVjb2RlKGltYWdlLCBoaW50cywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgRm9ybWF0RXhjZXB0aW9uIHx8IGlnbm9yZWQgaW5zdGFuY2VvZiBDaGVja3N1bUV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGlnbm9yZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZVxuICAgICAgICAgKiBAcGFyYW0gaGludHNcbiAgICAgICAgICogQHBhcmFtIG11bHRpcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb27Dn1xuICAgICAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZGVjb2RlKGltYWdlLCBoaW50cywgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGRldGVjdG9yUmVzdWx0ID0gRGV0ZWN0b3IkMy5kZXRlY3RNdWx0aXBsZShpbWFnZSwgaGludHMsIG11bHRpcGxlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIGRldGVjdG9yUmVzdWx0LmdldFBvaW50cygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb2RlclJlc3VsdCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5kZWNvZGUoZGV0ZWN0b3JSZXN1bHQuZ2V0Qml0cygpLCBwb2ludHNbNF0sIHBvaW50c1s1XSwgcG9pbnRzWzZdLCBwb2ludHNbN10sIFBERjQxN1JlYWRlci5nZXRNaW5Db2Rld29yZFdpZHRoKHBvaW50cyksIFBERjQxN1JlYWRlci5nZXRNYXhDb2Rld29yZFdpZHRoKHBvaW50cykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSZXN1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKSwgdW5kZWZpbmVkLCBwb2ludHMsIEJhcmNvZGVGb3JtYXQkMS5QREZfNDE3KTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlJDEuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBkZjQxN1Jlc3VsdE1ldGFkYXRhID0gZGVjb2RlclJlc3VsdC5nZXRPdGhlcigpO1xuICAgICAgICAgICAgICAgIGlmIChwZGY0MTdSZXN1bHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGUkMS5QREY0MTdfRVhUUkFfTUVUQURBVEEsIHBkZjQxN1Jlc3VsdE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5tYXAoeCA9PiB4KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TWF4V2lkdGgocDEsIHAyKSB7XG4gICAgICAgICAgICBpZiAocDEgPT0gbnVsbCB8fCBwMiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0TWluV2lkdGgocDEsIHAyKSB7XG4gICAgICAgICAgICBpZiAocDEgPT0gbnVsbCB8fCBwMiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMoTWF0aC5hYnMocDEuZ2V0WCgpIC0gcDIuZ2V0WCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldE1heENvZGV3b3JkV2lkdGgocCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoTWF0aC5tYXgoUERGNDE3UmVhZGVyLmdldE1heFdpZHRoKHBbMF0sIHBbNF0pLCBQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFs2XSwgcFsyXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSwgTWF0aC5tYXgoUERGNDE3UmVhZGVyLmdldE1heFdpZHRoKHBbMV0sIHBbNV0pLCBQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFs3XSwgcFszXSkgKiBQREY0MTdDb21tb24uTU9EVUxFU19JTl9DT0RFV09SRCAvXG4gICAgICAgICAgICAgICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXRNaW5Db2Rld29yZFdpZHRoKHApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKE1hdGgubWluKFBERjQxN1JlYWRlci5nZXRNaW5XaWR0aChwWzBdLCBwWzRdKSwgUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbNl0sIHBbMl0pICogUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQgL1xuICAgICAgICAgICAgICAgIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX1NUT1BfUEFUVEVSTiksIE1hdGgubWluKFBERjQxN1JlYWRlci5nZXRNaW5XaWR0aChwWzFdLCBwWzVdKSwgUERGNDE3UmVhZGVyLmdldE1pbldpZHRoKHBbN10sIHBbM10pICogUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQgL1xuICAgICAgICAgICAgICAgIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX1NUT1BfUEFUVEVSTikpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlc2V0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGVyRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICB9XG4gICAgUmVhZGVyRXhjZXB0aW9uLmtpbmQgPSAnUmVhZGVyRXhjZXB0aW9uJztcblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cbiAgICAvKipcbiAgICAgKiBNdWx0aUZvcm1hdFJlYWRlciBpcyBhIGNvbnZlbmllbmNlIGNsYXNzIGFuZCB0aGUgbWFpbiBlbnRyeSBwb2ludCBpbnRvIHRoZSBsaWJyYXJ5IGZvciBtb3N0IHVzZXMuXG4gICAgICogQnkgZGVmYXVsdCBpdCBhdHRlbXB0cyB0byBkZWNvZGUgYWxsIGJhcmNvZGUgZm9ybWF0cyB0aGF0IHRoZSBsaWJyYXJ5IHN1cHBvcnRzLiBPcHRpb25hbGx5LCB5b3VcbiAgICAgKiBjYW4gcHJvdmlkZSBhIGhpbnRzIG9iamVjdCB0byByZXF1ZXN0IGRpZmZlcmVudCBiZWhhdmlvciwgZm9yIGV4YW1wbGUgb25seSBkZWNvZGluZyBRUiBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBNdWx0aUZvcm1hdFJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmVyYm9zZSBpZiAndHJ1ZScgbG9ncyB3aWxsIGJlIGR1bXBlZCB0byBjb25zb2xlLCBvdGhlcndpc2UgaGlkZGVuLlxuICAgICAgICAgKiBAcGFyYW0gaGludHMgVGhlIGhpbnRzIHRvIHVzZSwgY2xlYXJpbmcgdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodmVyYm9zZSwgaGludHMpIHtcbiAgICAgICAgICAgIHRoaXMudmVyYm9zZSA9ICh2ZXJib3NlID09PSB0cnVlKTtcbiAgICAgICAgICAgIGlmIChoaW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGludHMoaGludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHZlcnNpb24gb2YgZGVjb2RlIGhvbm9ycyB0aGUgaW50ZW50IG9mIFJlYWRlci5kZWNvZGUoQmluYXJ5Qml0bWFwKSBpbiB0aGF0IGl0XG4gICAgICAgICAqIHBhc3NlcyBudWxsIGFzIGEgaGludCB0byB0aGUgZGVjb2RlcnMuIEhvd2V2ZXIsIHRoYXQgbWFrZXMgaXQgaW5lZmZpY2llbnQgdG8gY2FsbCByZXBlYXRlZGx5LlxuICAgICAgICAgKiBVc2Ugc2V0SGludHMoKSBmb2xsb3dlZCBieSBkZWNvZGVXaXRoU3RhdGUoKSBmb3IgY29udGludW91cyBzY2FuIGFwcGxpY2F0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGltYWdlIFRoZSBwaXhlbCBkYXRhIHRvIGRlY29kZVxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBBbnkgZXJyb3JzIHdoaWNoIG9jY3VycmVkXG4gICAgICAgICAqL1xuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIC8vIHB1YmxpYyBkZWNvZGUoaW1hZ2U6IEJpbmFyeUJpdG1hcCk6IFJlc3VsdCB7XG4gICAgICAgIC8vICAgc2V0SGludHMobnVsbClcbiAgICAgICAgLy8gICByZXR1cm4gZGVjb2RlSW50ZXJuYWwoaW1hZ2UpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZSBhbiBpbWFnZSB1c2luZyB0aGUgaGludHMgcHJvdmlkZWQuIERvZXMgbm90IGhvbm9yIGV4aXN0aW5nIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIHBpeGVsIGRhdGEgdG8gZGVjb2RlXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBUaGUgaGludHMgdG8gdXNlLCBjbGVhcmluZyB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBlcnJvcnMgd2hpY2ggb2NjdXJyZWRcbiAgICAgICAgICovXG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZGVjb2RlKGltYWdlLCBoaW50cykge1xuICAgICAgICAgICAgaWYgKGhpbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaW50cyhoaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbnRlcm5hbChpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZSBhbiBpbWFnZSB1c2luZyB0aGUgc3RhdGUgc2V0IHVwIGJ5IGNhbGxpbmcgc2V0SGludHMoKSBwcmV2aW91c2x5LiBDb250aW51b3VzIHNjYW5cbiAgICAgICAgICogY2xpZW50cyB3aWxsIGdldCBhIDxiPmxhcmdlPC9iPiBzcGVlZCBpbmNyZWFzZSBieSB1c2luZyB0aGlzIGluc3RlYWQgb2YgZGVjb2RlKCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgcGl4ZWwgZGF0YSB0byBkZWNvZGVcbiAgICAgICAgICogQHJldHVybiBUaGUgY29udGVudHMgb2YgdGhlIGltYWdlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IGVycm9ycyB3aGljaCBvY2N1cnJlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVjb2RlV2l0aFN0YXRlKGltYWdlKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gc2V0IHVwIHRoZSBkZWZhdWx0IHN0YXRlIHNvIHdlIGRvbid0IGNyYXNoXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkZXJzID09PSBudWxsIHx8IHRoaXMucmVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaW50cyhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUludGVybmFsKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgYWRkcyBzdGF0ZSB0byB0aGUgTXVsdGlGb3JtYXRSZWFkZXIuIEJ5IHNldHRpbmcgdGhlIGhpbnRzIG9uY2UsIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgICAgICogdG8gZGVjb2RlV2l0aFN0YXRlKGltYWdlKSBjYW4gcmV1c2UgdGhlIHNhbWUgc2V0IG9mIHJlYWRlcnMgd2l0aG91dCByZWFsbG9jYXRpbmcgbWVtb3J5LiBUaGlzXG4gICAgICAgICAqIGlzIGltcG9ydGFudCBmb3IgcGVyZm9ybWFuY2UgaW4gY29udGludW91cyBzY2FuIGNsaWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBoaW50cyBUaGUgc2V0IG9mIGhpbnRzIHRvIHVzZSBmb3Igc3Vic2VxdWVudCBjYWxscyB0byBkZWNvZGUoaW1hZ2UpXG4gICAgICAgICAqL1xuICAgICAgICBzZXRIaW50cyhoaW50cykge1xuICAgICAgICAgICAgdGhpcy5oaW50cyA9IGhpbnRzO1xuICAgICAgICAgICAgY29uc3QgdHJ5SGFyZGVyID0gIWlzTnVsbE9yVW5kZWZpbmVkKGhpbnRzKVxuICAgICAgICAgICAgICAgICYmIGhpbnRzLmdldChEZWNvZGVIaW50VHlwZSQxLlRSWV9IQVJERVIpID09PSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0cyA9IGlzTnVsbE9yVW5kZWZpbmVkKGhpbnRzKSA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGUkMS5QT1NTSUJMRV9GT1JNQVRTKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlcnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoZm9ybWF0cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRPbmVEUmVhZGVyID0gZm9ybWF0cy5zb21lKGYgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLlVQQ19BIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuVVBDX0UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5FQU5fMTMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5FQU5fOCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkNPREFCQVIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXQkMS5DT0RFXzM5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuQ09ERV85MyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdCQxLkNPREVfMTI4IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuSVRGIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuUlNTXzE0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0JDEuUlNTX0VYUEFOREVEKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBQdXQgMUQgcmVhZGVycyB1cGZyb250IGluIFwibm9ybWFsXCIgbW9kZVxuICAgICAgICAgICAgICAgIGlmIChhZGRPbmVEUmVhZGVyICYmICF0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMsIHRoaXMudmVyYm9zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuUVJfQ09ERSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBRUkNvZGVSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5EQVRBX01BVFJJWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBEYXRhTWF0cml4UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0JDEuQVpURUMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgQXp0ZWNSZWFkZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQkMS5QREZfNDE3KSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IFBERjQxN1JlYWRlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdC5NQVhJQ09ERSkpIHtcbiAgICAgICAgICAgICAgICAvLyAgICByZWFkZXJzLnB1c2gobmV3IE1heGlDb2RlUmVhZGVyKCkpXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIEF0IGVuZCBpbiBcInRyeSBoYXJkZXJcIiBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKGFkZE9uZURSZWFkZXIgJiYgdHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyKGhpbnRzLCB0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0T25lRFJlYWRlcihoaW50cywgdGhpcy52ZXJib3NlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgUVJDb2RlUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRGF0YU1hdHJpeFJlYWRlcigpKTtcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEF6dGVjUmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgUERGNDE3UmVhZGVyKCkpO1xuICAgICAgICAgICAgICAgIC8vIHJlYWRlcnMucHVzaChuZXcgTWF4aUNvZGVSZWFkZXIoKSlcbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyKGhpbnRzLCB0aGlzLnZlcmJvc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlcnMgPSByZWFkZXJzOyAvLyAudG9BcnJheShuZXcgUmVhZGVyW3JlYWRlcnMuc2l6ZSgpXSlcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMucmVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUludGVybmFsKGltYWdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlYWRlckV4Y2VwdGlvbignTm8gcmVhZGVycyB3aGVyZSBzZWxlY3RlZCwgbm90aGluZyBjYW4gYmUgcmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMucmVhZGVycykge1xuICAgICAgICAgICAgICAgIC8vIFRyeWluZyB0byBkZWNvZGUgd2l0aCAke3JlYWRlcn0gcmVhZGVyLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIuZGVjb2RlKGltYWdlLCB0aGlzLmhpbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIFJlYWRlckV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQmFkIEV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oJ05vIE11bHRpRm9ybWF0IFJlYWRlcnMgd2VyZSBhYmxlIHRvIGRldGVjdCB0aGUgY29kZS4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzIEJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlciBleHRlbmRzIEJyb3dzZXJDb2RlUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoaGludHMgPSBudWxsLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgTXVsdGlGb3JtYXRSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5zZXRIaW50cyhoaW50cyk7XG4gICAgICAgICAgICBzdXBlcihyZWFkZXIsIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdGUgZGVjb2RlQml0bWFwIHRvIGNhbGwgZGVjb2RlV2l0aFN0YXRlLCB3aGljaCB3aWxsIHBheVxuICAgICAgICAgKiBhdHRlbnRpb24gdG8gdGhlIGhpbnRzIHNldCBpbiB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGRlY29kZUJpdG1hcChiaW5hcnlCaXRtYXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRlci5kZWNvZGVXaXRoU3RhdGUoYmluYXJ5Qml0bWFwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqXG4gICAgICogUVIgQ29kZSByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBjbGFzcyBCcm93c2VyUERGNDE3UmVhZGVyIGV4dGVuZHMgQnJvd3NlckNvZGVSZWFkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyUERGNDE3UmVhZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwKSB7XG4gICAgICAgICAgICBzdXBlcihuZXcgUERGNDE3UmVhZGVyKCksIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTW92aW5nIHRvIEB6eGluZy9icm93c2VyXG4gICAgICpcbiAgICAgKiBRUiBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJRUkNvZGVSZWFkZXIgZXh0ZW5kcyBCcm93c2VyQ29kZVJlYWRlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJRUkNvZGVSZWFkZXIuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDApIHtcbiAgICAgICAgICAgIHN1cGVyKG5ldyBRUkNvZGVSZWFkZXIoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXG4gICAgLyoqXG4gICAgICogVGhlc2UgYXJlIGEgc2V0IG9mIGhpbnRzIHRoYXQgeW91IG1heSBwYXNzIHRvIFdyaXRlcnMgdG8gc3BlY2lmeSB0aGVpciBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgdmFyIEVuY29kZUhpbnRUeXBlO1xuICAgIChmdW5jdGlvbiAoRW5jb2RlSGludFR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGF0IGRlZ3JlZSBvZiBlcnJvciBjb3JyZWN0aW9uIHRvIHVzZSwgZm9yIGV4YW1wbGUgaW4gUVIgQ29kZXMuXG4gICAgICAgICAqIFR5cGUgZGVwZW5kcyBvbiB0aGUgZW5jb2Rlci4gRm9yIGV4YW1wbGUgZm9yIFFSIGNvZGVzIGl0J3MgdHlwZVxuICAgICAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2Rlci5FcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvckNvcnJlY3Rpb25MZXZlbH0uXG4gICAgICAgICAqIEZvciBBenRlYyBpdCBpcyBvZiB0eXBlIHtAbGluayBJbnRlZ2VyfSwgcmVwcmVzZW50aW5nIHRoZSBtaW5pbWFsIHBlcmNlbnRhZ2Ugb2YgZXJyb3IgY29ycmVjdGlvbiB3b3Jkcy5cbiAgICAgICAgICogRm9yIFBERjQxNyBpdCBpcyBvZiB0eXBlIHtAbGluayBJbnRlZ2VyfSwgdmFsaWQgdmFsdWVzIGJlaW5nIDAgdG8gOC5cbiAgICAgICAgICogSW4gYWxsIGNhc2VzLCBpdCBjYW4gYWxzbyBiZSBhIHtAbGluayBTdHJpbmd9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkZXNpcmVkIHZhbHVlIGFzIHdlbGwuXG4gICAgICAgICAqIE5vdGU6IGFuIEF6dGVjIHN5bWJvbCBzaG91bGQgaGF2ZSBhIG1pbmltdW0gb2YgMjUlIEVDIHdvcmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJFUlJPUl9DT1JSRUNUSU9OXCJdID0gMF0gPSBcIkVSUk9SX0NPUlJFQ1RJT05cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGF0IGNoYXJhY3RlciBlbmNvZGluZyB0byB1c2Ugd2hlcmUgYXBwbGljYWJsZSAodHlwZSB7QGxpbmsgU3RyaW5nfSlcbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiQ0hBUkFDVEVSX1NFVFwiXSA9IDFdID0gXCJDSEFSQUNURVJfU0VUXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIG1hdHJpeCBzaGFwZSBmb3IgRGF0YSBNYXRyaXggKHR5cGUge0BsaW5rIGNvbS5nb29nbGUuenhpbmcuZGF0YW1hdHJpeC5lbmNvZGVyLlN5bWJvbFNoYXBlSGludH0pXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkRBVEFfTUFUUklYX1NIQVBFXCJdID0gMl0gPSBcIkRBVEFfTUFUUklYX1NIQVBFXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgYSBtaW5pbXVtIGJhcmNvZGUgc2l6ZSAodHlwZSB7QGxpbmsgRGltZW5zaW9ufSkuIE9ubHkgYXBwbGljYWJsZSB0byBEYXRhIE1hdHJpeCBub3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSB3aWR0aC9oZWlnaHQgcGFyYW1zIGluXG4gICAgICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLmRhdGFtYXRyaXguRGF0YU1hdHJpeFdyaXRlciNlbmNvZGUoU3RyaW5nLCBCYXJjb2RlRm9ybWF0LCBpbnQsIGludCl9XG4gICAgICAgICAqL1xuICAgICAgICAvKkBEZXByZWNhdGVkKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNSU5fU0laRVwiXSA9IDNdID0gXCJNSU5fU0laRVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGEgbWF4aW11bSBiYXJjb2RlIHNpemUgKHR5cGUge0BsaW5rIERpbWVuc2lvbn0pLiBPbmx5IGFwcGxpY2FibGUgdG8gRGF0YSBNYXRyaXggbm93LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB3aXRob3V0IHJlcGxhY2VtZW50XG4gICAgICAgICAqL1xuICAgICAgICAvKkBEZXByZWNhdGVkKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNQVhfU0laRVwiXSA9IDRdID0gXCJNQVhfU0laRVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIG1hcmdpbiwgaW4gcGl4ZWxzLCB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHRoZSBiYXJjb2RlLiBUaGUgbWVhbmluZyBjYW4gdmFyeVxuICAgICAgICAgKiBieSBmb3JtYXQ7IGZvciBleGFtcGxlIGl0IGNvbnRyb2xzIG1hcmdpbiBiZWZvcmUgYW5kIGFmdGVyIHRoZSBiYXJjb2RlIGhvcml6b250YWxseSBmb3JcbiAgICAgICAgICogbW9zdCAxRCBmb3JtYXRzLiAoVHlwZSB7QGxpbmsgSW50ZWdlcn0sIG9yIHtAbGluayBTdHJpbmd9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnRlZ2VyIHZhbHVlKS5cbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiTUFSR0lOXCJdID0gNV0gPSBcIk1BUkdJTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdG8gdXNlIGNvbXBhY3QgbW9kZSBmb3IgUERGNDE3ICh0eXBlIHtAbGluayBCb29sZWFufSwgb3IgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXG4gICAgICAgICAqIHtAbGluayBTdHJpbmd9IHZhbHVlKS5cbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUERGNDE3X0NPTVBBQ1RcIl0gPSA2XSA9IFwiUERGNDE3X0NPTVBBQ1RcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGF0IGNvbXBhY3Rpb24gbW9kZSB0byB1c2UgZm9yIFBERjQxNyAodHlwZVxuICAgICAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZW5jb2Rlci5Db21wYWN0aW9uIENvbXBhY3Rpb259IG9yIHtAbGluayBTdHJpbmd9IHZhbHVlIG9mIG9uZSBvZiBpdHNcbiAgICAgICAgICogZW51bSB2YWx1ZXMpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJQREY0MTdfQ09NUEFDVElPTlwiXSA9IDddID0gXCJQREY0MTdfQ09NUEFDVElPTlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIGZvciBQREY0MTcgKHR5cGVcbiAgICAgICAgICoge0BsaW5rIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmVuY29kZXIuRGltZW5zaW9ucyBEaW1lbnNpb25zfSkuXG4gICAgICAgICAqL1xuICAgICAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIlBERjQxN19ESU1FTlNJT05TXCJdID0gOF0gPSBcIlBERjQxN19ESU1FTlNJT05TXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBsYXllcnMgZm9yIGFuIEF6dGVjIGNvZGUuXG4gICAgICAgICAqIEEgbmVnYXRpdmUgbnVtYmVyICgtMSwgLTIsIC0zLCAtNCkgc3BlY2lmaWVzIGEgY29tcGFjdCBBenRlYyBjb2RlLlxuICAgICAgICAgKiAwIGluZGljYXRlcyB0byB1c2UgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGxheWVycyAodGhlIGRlZmF1bHQpLlxuICAgICAgICAgKiBBIHBvc2l0aXZlIG51bWJlciAoMSwgMiwgLi4gMzIpIHNwZWNpZmllcyBhIG5vcm1hbCAobm9uLWNvbXBhY3QpIEF6dGVjIGNvZGUuXG4gICAgICAgICAqIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJBWlRFQ19MQVlFUlNcIl0gPSA5XSA9IFwiQVpURUNfTEFZRVJTXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIGV4YWN0IHZlcnNpb24gb2YgUVIgY29kZSB0byBiZSBlbmNvZGVkLlxuICAgICAgICAgKiAoVHlwZSB7QGxpbmsgSW50ZWdlcn0sIG9yIHtAbGluayBTdHJpbmd9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnRlZ2VyIHZhbHVlKS5cbiAgICAgICAgICovXG4gICAgICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUVJfVkVSU0lPTlwiXSA9IDEwXSA9IFwiUVJfVkVSU0lPTlwiO1xuICAgIH0pKEVuY29kZUhpbnRUeXBlIHx8IChFbmNvZGVIaW50VHlwZSA9IHt9KSk7XG4gICAgdmFyIEVuY29kZUhpbnRUeXBlJDEgPSBFbmNvZGVIaW50VHlwZTtcblxuICAgIC8qKlxuICAgICAqIDxwPkltcGxlbWVudHMgUmVlZC1Tb2xvbW9uIGVuY29kaW5nLCBhcyB0aGUgbmFtZSBpbXBsaWVzLjwvcD5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICogQGF1dGhvciBXaWxsaWFtIFJ1Y2tsaWRnZVxuICAgICAqL1xuICAgIGNsYXNzIFJlZWRTb2xvbW9uRW5jb2RlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZWQgc29sb21vbiBlcnJvci1jb3JyZWN0aW5nIGVuY29kaW5nIGNvbnN0cnVjdG9yIGlzIGNyZWF0ZWQgYnlcbiAgICAgICAgICogcGFzc2luZyBhcyBHYWxvaXMgRmllbGQgd2l0aCBvZiBzaXplIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY29kZVxuICAgICAgICAgKiB3b3JkcyAoc3ltYm9scykgaW4gdGhlIGFscGhhYmV0ICh0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbiBlYWNoXG4gICAgICAgICAqIGVsZW1lbnQgb2YgYXJyYXlzIHRoYXQgYXJlIGVuY29kZWQvZGVjb2RlZCkuXG4gICAgICAgICAqIEBwYXJhbSBmaWVsZCBBIGdhbG9pcyBmaWVsZCB3aXRoIGEgbnVtYmVyIG9mIGVsZW1lbnRzIGVxdWFsIHRvIHRoZSBzaXplXG4gICAgICAgICAqIG9mIHRoZSBhbHBoYWJldCBvZiBzeW1ib2xzIHRvIGVuY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGZpZWxkKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZEdlbmVyYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkR2VuZXJhdG9ycy5wdXNoKG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBJbnQzMkFycmF5LmZyb20oWzFdKSkpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkR2VuZXJhdG9yKGRlZ3JlZSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRHZW5lcmF0b3JzID0gdGhpcy5jYWNoZWRHZW5lcmF0b3JzO1xuICAgICAgICAgICAgaWYgKGRlZ3JlZSA+PSBjYWNoZWRHZW5lcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBsYXN0R2VuZXJhdG9yID0gY2FjaGVkR2VuZXJhdG9yc1tjYWNoZWRHZW5lcmF0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5maWVsZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gY2FjaGVkR2VuZXJhdG9ycy5sZW5ndGg7IGQgPD0gZGVncmVlOyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEdlbmVyYXRvciA9IGxhc3RHZW5lcmF0b3IubXVsdGlwbHkobmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIEludDMyQXJyYXkuZnJvbShbMSwgZmllbGQuZXhwKGQgLSAxICsgZmllbGQuZ2V0R2VuZXJhdG9yQmFzZSgpKV0pKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZEdlbmVyYXRvcnMucHVzaChuZXh0R2VuZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRvciA9IG5leHRHZW5lcmF0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEdlbmVyYXRvcnNbZGVncmVlXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogPHA+RW5jb2RlIGEgc2VxdWVuY2Ugb2YgY29kZSB3b3JkcyAoc3ltYm9scykgdXNpbmcgUmVlZC1Tb2xvbW9uIHRvIGFsbG93IGRlY29kZXJzXG4gICAgICAgICAqIHRvIGRldGVjdCBhbmQgY29ycmVjdCBlcnJvcnMgdGhhdCBtYXkgaGF2ZSBiZWVuIGludHJvZHVjZWQgd2hlbiB0aGUgcmVzdWx0aW5nXG4gICAgICAgICAqIGRhdGEgaXMgc3RvcmVkIG9yIHRyYW5zbWl0dGVkLjwvcD5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRvRW5jb2RlIGFycmF5IHVzZWQgZm9yIGJvdGggYW5kIG91dHB1dC4gQ2FsbGVyIGluaXRpYWxpemVzIHRoZSBhcnJheSB3aXRoXG4gICAgICAgICAqIHRoZSBjb2RlIHdvcmRzIChzeW1ib2xzKSB0byBiZSBlbmNvZGVkIGZvbGxvd2VkIGJ5IGVtcHR5IGVsZW1lbnRzIGFsbG9jYXRlZCB0byBtYWtlXG4gICAgICAgICAqIHNwYWNlIGZvciBlcnJvci1jb3JyZWN0aW9uIGNvZGUgd29yZHMgaW4gdGhlIGVuY29kZWQgb3V0cHV0LiBUaGUgYXJyYXkgY29udGFpbnNcbiAgICAgICAgICogdGhlIGVuY2RvZGVkIG91dHB1dCB3aGVuIGVuY29kZSByZXR1cm5zLiBDb2RlIHdvcmRzIGFyZSBlbmNvZGVkIGFzIG51bWJlcnMgZnJvbVxuICAgICAgICAgKiAwIHRvIG4tMSwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIHBvc3NpYmxlIGNvZGUgd29yZHMgKHN5bWJvbHMpLCBhcyBkZXRlcm1pbmVkXG4gICAgICAgICAqIGJ5IHRoZSBzaXplIG9mIHRoZSBHYWxvaXMgRmllbGQgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIGVjQnl0ZXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyByZXNlcnZlZCBpbiB0aGUgYXJyYXkgKGZpcnN0IHBhcmFtZXRlcilcbiAgICAgICAgICogdG8gc3RvcmUgZXJyb3ItY29ycmVjdGlvbiBjb2RlIHdvcmRzLiBUaHVzLCB0aGUgbnVtYmVyIG9mIGNvZGUgd29yZHMgKHN5bWJvbHMpXG4gICAgICAgICAqIHRvIGVuY29kZSBpbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRodXMgdG9FbmNvZGUubGVuZ3RoIC0gZWNCeXRlcy5cbiAgICAgICAgICogTm90ZSwgdGhlIHVzZSBvZiBcImJ5dGVzXCIgaW4gdGhlIG5hbWUgb2YgdGhpcyBwYXJhbWV0ZXIgaXMgbWlzbGVhZGluZywgYXMgdGhlcmUgbWF5XG4gICAgICAgICAqIGJlIG1vcmUgb3IgZmV3ZXIgdGhhbiAyNTYgc3ltYm9scyBiZWluZyBlbmNvZGVkLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICogZWxlbWVudHMgaW4gdGhlIEdhbG9pcyBGaWVsZCBwYXNzZWQgYXMgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG9iamVjdC5cbiAgICAgICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gdGhyb3duIGluIHJlc3BvbnNlIHRvIHZhbGlkYXRpb24gZXJycm9zLlxuICAgICAgICAgKi9cbiAgICAgICAgZW5jb2RlKHRvRW5jb2RlLCBlY0J5dGVzIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChlY0J5dGVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTm8gZXJyb3IgY29ycmVjdGlvbiBieXRlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUJ5dGVzID0gdG9FbmNvZGUubGVuZ3RoIC0gZWNCeXRlcztcbiAgICAgICAgICAgIGlmIChkYXRhQnl0ZXMgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ05vIGRhdGEgYnl0ZXMgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IHRoaXMuYnVpbGRHZW5lcmF0b3IoZWNCeXRlcyk7XG4gICAgICAgICAgICBjb25zdCBpbmZvQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoZGF0YUJ5dGVzKTtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkodG9FbmNvZGUsIDAsIGluZm9Db2VmZmljaWVudHMsIDAsIGRhdGFCeXRlcyk7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IG5ldyBHZW5lcmljR0ZQb2x5KHRoaXMuZmllbGQsIGluZm9Db2VmZmljaWVudHMpO1xuICAgICAgICAgICAgaW5mbyA9IGluZm8ubXVsdGlwbHlCeU1vbm9taWFsKGVjQnl0ZXMsIDEpO1xuICAgICAgICAgICAgY29uc3QgcmVtYWluZGVyID0gaW5mby5kaXZpZGUoZ2VuZXJhdG9yKVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IHJlbWFpbmRlci5nZXRDb2VmZmljaWVudHMoKTtcbiAgICAgICAgICAgIGNvbnN0IG51bVplcm9Db2VmZmljaWVudHMgPSBlY0J5dGVzIC0gY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtWmVyb0NvZWZmaWNpZW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG9FbmNvZGVbZGF0YUJ5dGVzICsgaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weShjb2VmZmljaWVudHMsIDAsIHRvRW5jb2RlLCBkYXRhQnl0ZXMgKyBudW1aZXJvQ29lZmZpY2llbnRzLCBjb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgU2F0b3J1IFRha2FiYXlhc2hpXG4gICAgICogQGF1dGhvciBEYW5pZWwgU3dpdGtpblxuICAgICAqIEBhdXRob3IgU2VhbiBPd2VuXG4gICAgICovXG4gICAgY2xhc3MgTWFza1V0aWwge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgMSBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBGaW5kIHJlcGV0aXRpdmUgY2VsbHMgd2l0aCB0aGUgc2FtZSBjb2xvciBhbmRcbiAgICAgICAgICogZ2l2ZSBwZW5hbHR5IHRvIHRoZW0uIEV4YW1wbGU6IDAwMDAwIG9yIDExMTExLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFwcGx5TWFza1BlbmFsdHlSdWxlMShtYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIHRydWUpICsgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUxSW50ZXJuYWwobWF0cml4LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IG1hc2sgcGVuYWx0eSBydWxlIDIgYW5kIHJldHVybiB0aGUgcGVuYWx0eS4gRmluZCAyeDIgYmxvY2tzIHdpdGggdGhlIHNhbWUgY29sb3IgYW5kIGdpdmVcbiAgICAgICAgICogcGVuYWx0eSB0byB0aGVtLiBUaGlzIGlzIGFjdHVhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIHNwZWMncyBydWxlLCB3aGljaCBpcyB0byBmaW5kIE14TiBibG9ja3MgYW5kIGdpdmUgYVxuICAgICAgICAgKiBwZW5hbHR5IHByb3BvcnRpb25hbCB0byAoTS0xKXgoTi0xKSwgYmVjYXVzZSB0aGlzIGlzIHRoZSBudW1iZXIgb2YgMngyIGJsb2NrcyBpbnNpZGUgc3VjaCBhIGJsb2NrLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFwcGx5TWFza1BlbmFsdHlSdWxlMihtYXRyaXgpIHtcbiAgICAgICAgICAgIGxldCBwZW5hbHR5ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQgLSAxOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheVkgPSBhcnJheVt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoIC0gMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXlZW3hdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGFycmF5WVt4ICsgMV0gJiYgdmFsdWUgPT09IGFycmF5W3kgKyAxXVt4XSAmJiB2YWx1ZSA9PT0gYXJyYXlbeSArIDFdW3ggKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hc2tVdGlsLk4yICogcGVuYWx0eTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgMyBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBGaW5kIGNvbnNlY3V0aXZlIHJ1bnMgb2YgMToxOjM6MToxOjRcbiAgICAgICAgICogc3RhcnRpbmcgd2l0aCBibGFjaywgb3IgNDoxOjE6MzoxOjEgc3RhcnRpbmcgd2l0aCB3aGl0ZSwgYW5kIGdpdmUgcGVuYWx0eSB0byB0aGVtLiAgSWYgd2VcbiAgICAgICAgICogZmluZCBwYXR0ZXJucyBsaWtlIDAwMDAxMDExMTAxMDAwMCwgd2UgZ2l2ZSBwZW5hbHR5IG9uY2UuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUzKG1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IG51bVBlbmFsdGllcyA9IDA7XG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IG1hdHJpeC5nZXRBcnJheSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlZID0gYXJyYXlbeV07IC8vIFdlIGNhbiBhdCBsZWFzdCBvcHRpbWl6ZSB0aGlzIGFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCArIDYgPCB3aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlZW3hdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDFdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDJdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDNdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDRdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDZdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoTWFza1V0aWwuaXNXaGl0ZUhvcml6b250YWwoYXJyYXlZLCB4IC0gNCwgeCkgfHwgTWFza1V0aWwuaXNXaGl0ZUhvcml6b250YWwoYXJyYXlZLCB4ICsgNywgeCArIDExKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVBlbmFsdGllcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ICsgNiA8IGhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeV1beF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAxXVt4XSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDJdW3hdID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgM11beF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA0XVt4XSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbeSArIDVdW3hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVt5ICsgNl1beF0gPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChNYXNrVXRpbC5pc1doaXRlVmVydGljYWwoYXJyYXksIHgsIHkgLSA0LCB5KSB8fCBNYXNrVXRpbC5pc1doaXRlVmVydGljYWwoYXJyYXksIHgsIHkgKyA3LCB5ICsgMTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGVuYWx0aWVzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtUGVuYWx0aWVzICogTWFza1V0aWwuTjM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGlzV2hpdGVIb3Jpem9udGFsKHJvd0FycmF5LCBmcm9tIC8qaW50Ki8sIHRvIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCAwKTtcbiAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJvd0FycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocm93QXJyYXlbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBpc1doaXRlVmVydGljYWwoYXJyYXksIGNvbCAvKmludCovLCBmcm9tIC8qaW50Ki8sIHRvIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCAwKTtcbiAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIGFycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV1bY29sXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IG1hc2sgcGVuYWx0eSBydWxlIDQgYW5kIHJldHVybiB0aGUgcGVuYWx0eS4gQ2FsY3VsYXRlIHRoZSByYXRpbyBvZiBkYXJrIGNlbGxzIGFuZCBnaXZlXG4gICAgICAgICAqIHBlbmFsdHkgaWYgdGhlIHJhdGlvIGlzIGZhciBmcm9tIDUwJS4gSXQgZ2l2ZXMgMTAgcGVuYWx0eSBmb3IgNSUgZGlzdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGU0KG1hdHJpeCkge1xuICAgICAgICAgICAgbGV0IG51bURhcmtDZWxscyA9IDA7XG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IG1hdHJpeC5nZXRBcnJheSgpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtYXRyaXguZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheVkgPSBhcnJheVt5XTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5WVt4XSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtRGFya0NlbGxzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBudW1Ub3RhbENlbGxzID0gbWF0cml4LmdldEhlaWdodCgpICogbWF0cml4LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBmaXZlUGVyY2VudFZhcmlhbmNlcyA9IE1hdGguZmxvb3IoTWF0aC5hYnMobnVtRGFya0NlbGxzICogMiAtIG51bVRvdGFsQ2VsbHMpICogMTAgLyBudW1Ub3RhbENlbGxzKTtcbiAgICAgICAgICAgIHJldHVybiBmaXZlUGVyY2VudFZhcmlhbmNlcyAqIE1hc2tVdGlsLk40O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIG1hc2sgYml0IGZvciBcImdldE1hc2tQYXR0ZXJuXCIgYXQgXCJ4XCIgYW5kIFwieVwiLiBTZWUgOC44IG9mIEpJU1gwNTEwOjIwMDQgZm9yIG1hc2tcbiAgICAgICAgICogcGF0dGVybiBjb25kaXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldERhdGFNYXNrQml0KG1hc2tQYXR0ZXJuIC8qaW50Ki8sIHggLyppbnQqLywgeSAvKmludCovKSB7XG4gICAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlOyAvKmludCovXG4gICAgICAgICAgICBsZXQgdGVtcDsgLyppbnQqL1xuICAgICAgICAgICAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHkgKyB4KSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSB5ICYgMHgxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IHggJSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICh5ICsgeCkgJSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IChNYXRoLmZsb29yKHkgLyAyKSArIE1hdGguZmxvb3IoeCAvIDMpKSAmIDB4MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICh0ZW1wICYgMHgxKSArICh0ZW1wICUgMyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHkgKiB4O1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoKHRlbXAgJiAweDEpICsgKHRlbXAgJSAzKSkgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHkgKiB4O1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoKHRlbXAgJSAzKSArICgoeSArIHgpICYgMHgxKSkgJiAweDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ludmFsaWQgbWFzayBwYXR0ZXJuOiAnICsgbWFza1BhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludGVybWVkaWF0ZSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBhcHBseU1hc2tQZW5hbHR5UnVsZTEuIFdlIG5lZWQgdGhpcyBmb3IgZG9pbmcgdGhpcyBjYWxjdWxhdGlvbiBpbiBib3RoXG4gICAgICAgICAqIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIG9yZGVycyByZXNwZWN0aXZlbHkuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwbHlNYXNrUGVuYWx0eVJ1bGUxSW50ZXJuYWwobWF0cml4LCBpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGxldCBwZW5hbHR5ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGlMaW1pdCA9IGlzSG9yaXpvbnRhbCA/IG1hdHJpeC5nZXRIZWlnaHQoKSA6IG1hdHJpeC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgakxpbWl0ID0gaXNIb3Jpem9udGFsID8gbWF0cml4LmdldFdpZHRoKCkgOiBtYXRyaXguZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IG1hdHJpeC5nZXRBcnJheSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpTGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBudW1TYW1lQml0Q2VsbHMgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwcmV2Qml0ID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqTGltaXQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaXQgPSBpc0hvcml6b250YWwgPyBhcnJheVtpXVtqXSA6IGFycmF5W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYml0ID09PSBwcmV2Qml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1TYW1lQml0Q2VsbHMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1TYW1lQml0Q2VsbHMgPj0gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmFsdHkgKz0gTWFza1V0aWwuTjEgKyAobnVtU2FtZUJpdENlbGxzIC0gNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1TYW1lQml0Q2VsbHMgPSAxOyAvLyBJbmNsdWRlIHRoZSBjZWxsIGl0c2VsZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZCaXQgPSBiaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bVNhbWVCaXRDZWxscyA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmFsdHkgKz0gTWFza1V0aWwuTjEgKyAobnVtU2FtZUJpdENlbGxzIC0gNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBlbmFsdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUGVuYWx0eSB3ZWlnaHRzIGZyb20gc2VjdGlvbiA2LjguMi4xXG4gICAgTWFza1V0aWwuTjEgPSAzO1xuICAgIE1hc2tVdGlsLk4yID0gMztcbiAgICBNYXNrVXRpbC5OMyA9IDQwO1xuICAgIE1hc2tVdGlsLk40ID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBKQVZBUE9SVDogVGhlIG9yaWdpbmFsIGNvZGUgd2FzIGEgMkQgYXJyYXkgb2YgaW50cywgYnV0IHNpbmNlIGl0IG9ubHkgZXZlciBnZXRzIGFzc2lnbmVkXG4gICAgICogLTEsIDAsIGFuZCAxLCBJJ20gZ29pbmcgdG8gdXNlIGxlc3MgbWVtb3J5IGFuZCBnbyB3aXRoIGJ5dGVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBCeXRlTWF0cml4IHtcbiAgICAgICAgY29uc3RydWN0b3Iod2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoaGVpZ2h0KTsgLy8gW2hlaWdodF1bd2lkdGhdXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlc1tpXSA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICAgICAgfVxuICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBnZXQoeCAvKmludCovLCB5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3ldW3hdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIGFuIGludGVybmFsIHJlcHJlc2VudGF0aW9uIGFzIGJ5dGVzLCBpbiByb3ctbWFqb3Igb3JkZXIuIGFycmF5W3ldW3hdIHJlcHJlc2VudHMgcG9pbnQgKHgseSlcbiAgICAgICAgICovXG4gICAgICAgIGdldEFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IHByZWZmZXIgdG8gbGV0IHR3byBtZXRob2RzIGluc3RlYWQgb2Ygb3ZlcnJpZGUgdG8gYXZvaWQgdHlwZSBjb21wYXJpc29uIGluc2lkZVxuICAgICAgICBzZXROdW1iZXIoeCAvKmludCovLCB5IC8qaW50Ki8sIHZhbHVlIC8qYnl0ZXxpbnQqLykge1xuICAgICAgICAgICAgdGhpcy5ieXRlc1t5XVt4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1YmxpYyBzZXQoeDogbnVtYmVyIC8qaW50Ki8sIHk6IG51bWJlciAvKmludCovLCB2YWx1ZTogbnVtYmVyIC8qaW50Ki8pOiB2b2lkIHtcbiAgICAgICAgLy8gICBieXRlc1t5XVt4XSA9IChieXRlKSB2YWx1ZVxuICAgICAgICAvLyB9XG4gICAgICAgIHNldEJvb2xlYW4oeCAvKmludCovLCB5IC8qaW50Ki8sIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVzW3ldW3hdID0gLyooYnl0ZSkgKi8gKHZhbHVlID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKHZhbHVlIC8qYnl0ZSovKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFCeXRlIG9mIHRoaXMuYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBBcnJheXMuZmlsbChhQnl0ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVxdWFscyhvKSB7XG4gICAgICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQnl0ZU1hdHJpeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IG87XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gb3RoZXIud2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IG90aGVyLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNZID0gdGhpcy5ieXRlc1t5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckJ5dGVzWSA9IG90aGVyLmJ5dGVzW3ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwLCB3aWR0aCA9IHRoaXMud2lkdGg7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlc1lbeF0gIT09IG90aGVyQnl0ZXNZW3hdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXIoKTsgLy8gKDIgKiB3aWR0aCAqIGhlaWdodCArIDIpXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzWSA9IHRoaXMuYnl0ZXNbeV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChieXRlc1lbeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAxJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xuICAgICAqL1xuICAgIGNsYXNzIFFSQ29kZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5tYXNrUGF0dGVybiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGdldE1vZGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGdldEVDTGV2ZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY0xldmVsO1xuICAgICAgICB9XG4gICAgICAgIGdldFZlcnNpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldE1hc2tQYXR0ZXJuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFza1BhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TWF0cml4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcigpOyAvLyAoMjAwKVxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnPDxcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyBtb2RlOiAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5tb2RlID8gdGhpcy5tb2RlLnRvU3RyaW5nKCkgOiAnbnVsbCcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIGVjTGV2ZWw6ICcpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLmVjTGV2ZWwgPyB0aGlzLmVjTGV2ZWwudG9TdHJpbmcoKSA6ICdudWxsJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4gdmVyc2lvbjogJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMudmVyc2lvbiA/IHRoaXMudmVyc2lvbi50b1N0cmluZygpIDogJ251bGwnKTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXNrUGF0dGVybjogJyk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMubWFza1BhdHRlcm4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4gbWF0cml4OlxcbicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5tYXRyaXgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4gbWF0cml4OiBudWxsXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKCc+PlxcbicpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHNldE1vZGUodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNldEVDTGV2ZWwodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWNMZXZlbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNldFZlcnNpb24odmVyc2lvbikge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBzZXRNYXNrUGF0dGVybih2YWx1ZSAvKmludCovKSB7XG4gICAgICAgICAgICB0aGlzLm1hc2tQYXR0ZXJuID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TWF0cml4KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIFwibWFza19wYXR0ZXJuXCIgaXMgdmFsaWQuXG4gICAgICAgIHN0YXRpYyBpc1ZhbGlkTWFza1BhdHRlcm4obWFza1BhdHRlcm4gLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIG1hc2tQYXR0ZXJuID49IDAgJiYgbWFza1BhdHRlcm4gPCBRUkNvZGUuTlVNX01BU0tfUEFUVEVSTlM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUVJDb2RlLk5VTV9NQVNLX1BBVFRFUk5TID0gODtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBXcml0ZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIH1cbiAgICBXcml0ZXJFeGNlcHRpb24ua2luZCA9ICdXcml0ZXJFeGNlcHRpb24nO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBzYXRvcnV4QGdvb2dsZS5jb20gKFNhdG9ydSBUYWthYmF5YXNoaSkgLSBjcmVhdG9yXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikgLSBwb3J0ZWQgZnJvbSBDKytcbiAgICAgKi9cbiAgICBjbGFzcyBNYXRyaXhVdGlsIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGFsbCBjZWxscyB0byAtMSAoVFlQRVNDUklQVFBPUlQ6IDI1NSkuICAtMSAoVFlQRVNDUklQVFBPUlQ6IDI1NSkgbWVhbnMgdGhhdCB0aGUgY2VsbCBpcyBlbXB0eSAobm90IHNldCB5ZXQpLlxuICAgICAgICAvL1xuICAgICAgICAvLyBKQVZBUE9SVDogV2Ugc2hvdWxkbid0IG5lZWQgdG8gZG8gdGhpcyBhdCBhbGwuIFRoZSBjb2RlIHNob3VsZCBiZSByZXdyaXR0ZW4gdG8gYmVnaW4gZW5jb2RpbmdcbiAgICAgICAgLy8gd2l0aCB0aGUgQnl0ZU1hdHJpeCBpbml0aWFsaXplZCBhbGwgdG8gemVyby5cbiAgICAgICAgc3RhdGljIGNsZWFyTWF0cml4KG1hdHJpeCkge1xuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IHdlIHVzZSBVaW50QXJyYXkgc2UgY2hhbmdlZCBoZXJlIGZyb20gLTEgdG8gMjU1XG4gICAgICAgICAgICBtYXRyaXguY2xlYXIoLyooYnl0ZSkgKi8gLyotMSovIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbGQgMkQgbWF0cml4IG9mIFFSIENvZGUgZnJvbSBcImRhdGFCaXRzXCIgd2l0aCBcImVjTGV2ZWxcIiwgXCJ2ZXJzaW9uXCIgYW5kIFwiZ2V0TWFza1BhdHRlcm5cIi4gT25cbiAgICAgICAgLy8gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcIm1hdHJpeFwiIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgc3RhdGljIGJ1aWxkTWF0cml4KGRhdGFCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIE1hdHJpeFV0aWwuY2xlYXJNYXRyaXgobWF0cml4KTtcbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRCYXNpY1BhdHRlcm5zKHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBUeXBlIGluZm9ybWF0aW9uIGFwcGVhciB3aXRoIGFueSB2ZXJzaW9uLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFR5cGVJbmZvKGVjTGV2ZWwsIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gVmVyc2lvbiBpbmZvIGFwcGVhciBpZiB2ZXJzaW9uID49IDcuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLm1heWJlRW1iZWRWZXJzaW9uSW5mbyh2ZXJzaW9uLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gRGF0YSBzaG91bGQgYmUgZW1iZWRkZWQgYXQgZW5kLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZERhdGFCaXRzKGRhdGFCaXRzLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCBiYXNpYyBwYXR0ZXJucy4gT24gc3VjY2VzcywgbW9kaWZ5IHRoZSBtYXRyaXggYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAvLyBUaGUgYmFzaWMgcGF0dGVybnMgYXJlOlxuICAgICAgICAvLyAtIFBvc2l0aW9uIGRldGVjdGlvbiBwYXR0ZXJuc1xuICAgICAgICAvLyAtIFRpbWluZyBwYXR0ZXJuc1xuICAgICAgICAvLyAtIERhcmsgZG90IGF0IHRoZSBsZWZ0IGJvdHRvbSBjb3JuZXJcbiAgICAgICAgLy8gLSBQb3NpdGlvbiBhZGp1c3RtZW50IHBhdHRlcm5zLCBpZiBuZWVkIGJlXG4gICAgICAgIHN0YXRpYyBlbWJlZEJhc2ljUGF0dGVybnModmVyc2lvbiwgbWF0cml4KSB7XG4gICAgICAgICAgICAvLyBMZXQncyBnZXQgc3RhcnRlZCB3aXRoIGVtYmVkZGluZyBiaWcgc3F1YXJlcyBhdCBjb3JuZXJzLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybnNBbmRTZXBhcmF0b3JzKG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBUaGVuLCBlbWJlZCB0aGUgZGFyayBkb3QgYXQgdGhlIGxlZnQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWREYXJrRG90QXRMZWZ0Qm90dG9tQ29ybmVyKG1hdHJpeCk7XG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBhZGp1c3RtZW50IHBhdHRlcm5zIGFwcGVhciBpZiB2ZXJzaW9uID49IDIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLm1heWJlRW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gVGltaW5nIHBhdHRlcm5zIHNob3VsZCBiZSBlbWJlZGRlZCBhZnRlciBwb3NpdGlvbiBhZGouIHBhdHRlcm5zLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFRpbWluZ1BhdHRlcm5zKG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgdHlwZSBpbmZvcm1hdGlvbi4gT24gc3VjY2VzcywgbW9kaWZ5IHRoZSBtYXRyaXguXG4gICAgICAgIHN0YXRpYyBlbWJlZFR5cGVJbmZvKGVjTGV2ZWwsIG1hc2tQYXR0ZXJuIC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZUluZm9CaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgICAgICAgICBNYXRyaXhVdGlsLm1ha2VUeXBlSW5mb0JpdHMoZWNMZXZlbCwgbWFza1BhdHRlcm4sIHR5cGVJbmZvQml0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc2l6ZSA9IHR5cGVJbmZvQml0cy5nZXRTaXplKCk7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBQbGFjZSBiaXRzIGluIExTQiB0byBNU0Igb3JkZXIuICBMU0IgKGxlYXN0IHNpZ25pZmljYW50IGJpdCkgaXMgdGhlIGxhc3QgdmFsdWUgaW5cbiAgICAgICAgICAgICAgICAvLyBcInR5cGVJbmZvQml0c1wiLlxuICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IHR5cGVJbmZvQml0cy5nZXQodHlwZUluZm9CaXRzLmdldFNpemUoKSAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAvLyBUeXBlIGluZm8gYml0cyBhdCB0aGUgbGVmdCB0b3AgY29ybmVyLiBTZWUgOC45IG9mIEpJU1gwNTEwOjIwMDQgKHAuNDYpLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gTWF0cml4VXRpbC5UWVBFX0lORk9fQ09PUkRJTkFURVNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeDEgPSBjb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHgxLCB5MSwgYml0KTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDIgPSBtYXRyaXguZ2V0V2lkdGgoKSAtIGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MiA9IDg7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHgyLCB5MiwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDIgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MiA9IG1hdHJpeC5nZXRIZWlnaHQoKSAtIDcgKyAoaSAtIDgpO1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbih4MiwgeTIsIGJpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIHZlcnNpb24gaW5mb3JtYXRpb24gaWYgbmVlZCBiZS4gT24gc3VjY2VzcywgbW9kaWZ5IHRoZSBtYXRyaXggYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAvLyBTZWUgOC4xMCBvZiBKSVNYMDUxMDoyMDA0IChwLjQ3KSBmb3IgaG93IHRvIGVtYmVkIHZlcnNpb24gaW5mb3JtYXRpb24uXG4gICAgICAgIHN0YXRpYyBtYXliZUVtYmVkVmVyc2lvbkluZm8odmVyc2lvbiwgbWF0cml4KSB7XG4gICAgICAgICAgICBpZiAodmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCkgPCA3KSB7IC8vIFZlcnNpb24gaW5mbyBpcyBuZWNlc3NhcnkgaWYgdmVyc2lvbiA+PSA3LlxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgbmVlZCB2ZXJzaW9uIGluZm8uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uSW5mb0JpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIE1hdHJpeFV0aWwubWFrZVZlcnNpb25JbmZvQml0cyh2ZXJzaW9uLCB2ZXJzaW9uSW5mb0JpdHMpO1xuICAgICAgICAgICAgbGV0IGJpdEluZGV4ID0gNiAqIDMgLSAxOyAvLyBJdCB3aWxsIGRlY3JlYXNlIGZyb20gMTcgdG8gMC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgYml0cyBpbiBMU0IgKGxlYXN0IHNpZ25pZmljYW50IGJpdCkgdG8gTVNCIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaXQgPSB2ZXJzaW9uSW5mb0JpdHMuZ2V0KGJpdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYml0SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbihpLCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSAxMSArIGosIGJpdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGJvdHRvbSBjb3JuZXIuXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKG1hdHJpeC5nZXRIZWlnaHQoKSAtIDExICsgaiwgaSwgYml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1iZWQgXCJkYXRhQml0c1wiIHVzaW5nIFwiZ2V0TWFza1BhdHRlcm5cIi4gT24gc3VjY2VzcywgbW9kaWZ5IHRoZSBtYXRyaXggYW5kIHJldHVybiB0cnVlLlxuICAgICAgICAvLyBGb3IgZGVidWdnaW5nIHB1cnBvc2VzLCBpdCBza2lwcyBtYXNraW5nIHByb2Nlc3MgaWYgXCJnZXRNYXNrUGF0dGVyblwiIGlzIC0xKFRZUEVTQ1JJUFRQT1JUOiAyNTUpLlxuICAgICAgICAvLyBTZWUgOC43IG9mIEpJU1gwNTEwOjIwMDQgKHAuMzgpIGZvciBob3cgdG8gZW1iZWQgZGF0YSBiaXRzLlxuICAgICAgICBzdGF0aWMgZW1iZWREYXRhQml0cyhkYXRhQml0cywgbWFza1BhdHRlcm4gLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgYml0SW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgcmlnaHQgYm90dG9tIGNlbGwuXG4gICAgICAgICAgICBsZXQgeCA9IG1hdHJpeC5nZXRXaWR0aCgpIC0gMTtcbiAgICAgICAgICAgIGxldCB5ID0gbWF0cml4LmdldEhlaWdodCgpIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICh4ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIHZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuLlxuICAgICAgICAgICAgICAgIGlmICh4ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHggLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHkgPj0gMCAmJiB5IDwgbWF0cml4LmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4eCA9IHggLSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgY2VsbCBpZiBpdCdzIG5vdCBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoeHgsIHkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRJbmRleCA8IGRhdGFCaXRzLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9IGRhdGFCaXRzLmdldChiaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytiaXRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZGRpbmcgYml0LiBJZiB0aGVyZSBpcyBubyBiaXQgbGVmdCwgd2UnbGwgZmlsbCB0aGUgbGVmdCBjZWxscyB3aXRoIDAsIGFzIGRlc2NyaWJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIDguNC45IG9mIEpJU1gwNTEwOjIwMDQgKHAuIDI0KS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgbWFza2luZyBpZiBtYXNrX3BhdHRlcm4gaXMgLTEgKFRZUEVTQ1JJUFRQT1JUOiAyNTUpLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQYXR0ZXJuICE9PSAyNTUgJiYgTWFza1V0aWwuZ2V0RGF0YU1hc2tCaXQobWFza1BhdHRlcm4sIHh4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9ICFiaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbih4eCwgeSwgYml0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5ICs9IGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gLWRpcmVjdGlvbjsgLy8gUmV2ZXJzZSB0aGUgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIHkgKz0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIHggLT0gMjsgLy8gTW92ZSB0byB0aGUgbGVmdC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFsbCBiaXRzIHNob3VsZCBiZSBjb25zdW1lZC5cbiAgICAgICAgICAgIGlmIChiaXRJbmRleCAhPT0gZGF0YUJpdHMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignTm90IGFsbCBiaXRzIGNvbnN1bWVkOiAnICsgYml0SW5kZXggKyAnLycgKyBkYXRhQml0cy5nZXRTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IHNldCAob25lOiB0bykgaW4gdGhlIFwidmFsdWVcIi4gVGhlIG1vc3RcbiAgICAgICAgLy8gc2lnbmlmaWNhbnQgYml0IGlzIHBvc2l0aW9uIDMyLiBJZiB0aGVyZSBpcyBubyBiaXQgc2V0LCByZXR1cm4gMC4gRXhhbXBsZXM6XG4gICAgICAgIC8vIC0gZmluZE1TQlNldCgwKSA9PiAwXG4gICAgICAgIC8vIC0gZmluZE1TQlNldCgxKSA9PiAxXG4gICAgICAgIC8vIC0gZmluZE1TQlNldCgyNTUpID0+IDhcbiAgICAgICAgc3RhdGljIGZpbmRNU0JTZXQodmFsdWUgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIDMyIC0gSW50ZWdlci5udW1iZXJPZkxlYWRpbmdaZXJvcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIEJDSCAoQm9zZS1DaGF1ZGh1cmktSG9jcXVlbmdoZW0pIGNvZGUgZm9yIFwidmFsdWVcIiB1c2luZyBwb2x5bm9taWFsIFwicG9seVwiLiBUaGUgQkNIXG4gICAgICAgIC8vIGNvZGUgaXMgdXNlZCBmb3IgZW5jb2RpbmcgdHlwZSBpbmZvcm1hdGlvbiBhbmQgdmVyc2lvbiBpbmZvcm1hdGlvbi5cbiAgICAgICAgLy8gRXhhbXBsZTogQ2FsY3VsYXRpb24gb2YgdmVyc2lvbiBpbmZvcm1hdGlvbiBvZiA3LlxuICAgICAgICAvLyBmKHgpIGlzIGNyZWF0ZWQgZnJvbSA3LlxuICAgICAgICAvLyAgIC0gNyA9IDAwMDExMSBpbiA2IGJpdHNcbiAgICAgICAgLy8gICAtIGYoeCkgPSB4XjIgKyB4XjEgKyB4XjBcbiAgICAgICAgLy8gZyh4KSBpcyBnaXZlbiBieSB0aGUgc3RhbmRhcmQgKHAuIDY3KVxuICAgICAgICAvLyAgIC0gZyh4KSA9IHheMTIgKyB4XjExICsgeF4xMCArIHheOSArIHheOCArIHheNSArIHheMiArIDFcbiAgICAgICAgLy8gTXVsdGlwbHkgZih4KSBieSB4XigxOCAtIDYpXG4gICAgICAgIC8vICAgLSBmJyh4KSA9IGYoeCkgKiB4XigxOCAtIDYpXG4gICAgICAgIC8vICAgLSBmJyh4KSA9IHheMTQgKyB4XjEzICsgeF4xMlxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHJlbWFpbmRlciBvZiBmJyh4KSAvIGcoeClcbiAgICAgICAgLy8gICAgICAgICB4XjJcbiAgICAgICAgLy8gICAgICAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICAgICAgICAvLyAgIGcoeCkgKXheMTQgKyB4XjEzICsgeF4xMlxuICAgICAgICAvLyAgICAgICAgIHheMTQgKyB4XjEzICsgeF4xMiArIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAgICAgIC8vICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XjExICsgeF4xMCArIHheNyArIHheNCArIHheMlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcmVtYWluZGVyIGlzIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXG4gICAgICAgIC8vIEVuY29kZSBpdCBpbiBiaW5hcnk6IDExMDAxMDAxMDEwMFxuICAgICAgICAvLyBUaGUgcmV0dXJuIHZhbHVlIGlzIDB4Yzk0ICgxMTAwIDEwMDEgMDEwMClcbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2luY2UgYWxsIGNvZWZmaWNpZW50cyBpbiB0aGUgcG9seW5vbWlhbHMgYXJlIDEgb3IgMCwgd2UgY2FuIGRvIHRoZSBjYWxjdWxhdGlvbiBieSBiaXRcbiAgICAgICAgLy8gb3BlcmF0aW9ucy4gV2UgZG9uJ3QgY2FyZSBpZiBjb2VmZmljaWVudHMgYXJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxuICAgICAgICBzdGF0aWMgY2FsY3VsYXRlQkNIQ29kZSh2YWx1ZSAvKmludCovLCBwb2x5IC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGlmIChwb2x5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignMCBwb2x5bm9taWFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBwb2x5IGlzIFwiMSAxMTExIDAwMTAgMDEwMVwiICh2ZXJzaW9uIGluZm8gcG9seSksIG1zYlNldEluUG9seSBpcyAxMy4gV2UnbGwgc3VidHJhY3QgMVxuICAgICAgICAgICAgLy8gZnJvbSAxMyB0byBtYWtlIGl0IDEyLlxuICAgICAgICAgICAgY29uc3QgbXNiU2V0SW5Qb2x5ID0gTWF0cml4VXRpbC5maW5kTVNCU2V0KHBvbHkpO1xuICAgICAgICAgICAgdmFsdWUgPDw9IG1zYlNldEluUG9seSAtIDE7XG4gICAgICAgICAgICAvLyBEbyB0aGUgZGl2aXNpb24gYnVzaW5lc3MgdXNpbmcgZXhjbHVzaXZlLW9yIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICB3aGlsZSAoTWF0cml4VXRpbC5maW5kTVNCU2V0KHZhbHVlKSA+PSBtc2JTZXRJblBvbHkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSBePSBwb2x5IDw8IChNYXRyaXhVdGlsLmZpbmRNU0JTZXQodmFsdWUpIC0gbXNiU2V0SW5Qb2x5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyB0aGUgXCJ2YWx1ZVwiIGlzIHRoZSByZW1haW5kZXIgKGkuZS4gdGhlIEJDSCBjb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgYml0IHZlY3RvciBvZiB0eXBlIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgLy8gRW5jb2RlIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgYW5kIG1hc2sgcGF0dGVybi4gU2VlIDguOSBvZlxuICAgICAgICAvLyBKSVNYMDUxMDoyMDA0IChwLjQ1KSBmb3IgZGV0YWlscy5cbiAgICAgICAgc3RhdGljIG1ha2VUeXBlSW5mb0JpdHMoZWNMZXZlbCwgbWFza1BhdHRlcm4gLyppbnQqLywgYml0cykge1xuICAgICAgICAgICAgaWYgKCFRUkNvZGUuaXNWYWxpZE1hc2tQYXR0ZXJuKG1hc2tQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludmFsaWQgbWFzayBwYXR0ZXJuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlSW5mbyA9IChlY0xldmVsLmdldEJpdHMoKSA8PCAzKSB8IG1hc2tQYXR0ZXJuO1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKHR5cGVJbmZvLCA1KTtcbiAgICAgICAgICAgIGNvbnN0IGJjaENvZGUgPSBNYXRyaXhVdGlsLmNhbGN1bGF0ZUJDSENvZGUodHlwZUluZm8sIE1hdHJpeFV0aWwuVFlQRV9JTkZPX1BPTFkpO1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGJjaENvZGUsIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2tCaXRzID0gbmV3IEJpdEFycmF5KCk7XG4gICAgICAgICAgICBtYXNrQml0cy5hcHBlbmRCaXRzKE1hdHJpeFV0aWwuVFlQRV9JTkZPX01BU0tfUEFUVEVSTiwgMTUpO1xuICAgICAgICAgICAgYml0cy54b3IobWFza0JpdHMpO1xuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9PSAxNSkgeyAvLyBKdXN0IGluIGNhc2UuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignc2hvdWxkIG5vdCBoYXBwZW4gYnV0IHdlIGdvdDogJyArIGJpdHMuZ2V0U2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIGJpdCB2ZWN0b3Igb2YgdmVyc2lvbiBpbmZvcm1hdGlvbi4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIiBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgIC8vIFNlZSA4LjEwIG9mIEpJU1gwNTEwOjIwMDQgKHAuNDUpIGZvciBkZXRhaWxzLlxuICAgICAgICBzdGF0aWMgbWFrZVZlcnNpb25JbmZvQml0cyh2ZXJzaW9uLCBiaXRzKSB7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHModmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCksIDYpO1xuICAgICAgICAgICAgY29uc3QgYmNoQ29kZSA9IE1hdHJpeFV0aWwuY2FsY3VsYXRlQkNIQ29kZSh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSwgTWF0cml4VXRpbC5WRVJTSU9OX0lORk9fUE9MWSk7XG4gICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoYmNoQ29kZSwgMTIpO1xuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9PSAxOCkgeyAvLyBKdXN0IGluIGNhc2UuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignc2hvdWxkIG5vdCBoYXBwZW4gYnV0IHdlIGdvdDogJyArIGJpdHMuZ2V0U2l6ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBcInZhbHVlXCIgaXMgZW1wdHkuXG4gICAgICAgIHN0YXRpYyBpc0VtcHR5KHZhbHVlIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMjU1OyAvLyAtMVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlbWJlZFRpbWluZ1BhdHRlcm5zKG1hdHJpeCkge1xuICAgICAgICAgICAgLy8gLTggaXMgZm9yIHNraXBwaW5nIHBvc2l0aW9uIGRldGVjdGlvbiBwYXR0ZXJucyAoNzogc2l6ZSksIGFuZCB0d28gaG9yaXpvbnRhbC92ZXJ0aWNhbFxuICAgICAgICAgICAgLy8gc2VwYXJhdGlvbiBwYXR0ZXJucyAoMTogc2l6ZSkuIFRodXMsIDggPSA3ICsgMS5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgbWF0cml4LmdldFdpZHRoKCkgLSA4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXQgPSAoaSArIDEpICUgMjtcbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmUuXG4gICAgICAgICAgICAgICAgaWYgKE1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KGksIDYpKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKGksIDYsIGJpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUuXG4gICAgICAgICAgICAgICAgaWYgKE1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KDYsIGkpKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKDYsIGksIGJpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIHRoZSBsb25lbHkgZGFyayBkb3QgYXQgbGVmdCBib3R0b20gY29ybmVyLiBKSVNYMDUxMDoyMDA0IChwLjQ2KVxuICAgICAgICBzdGF0aWMgZW1iZWREYXJrRG90QXRMZWZ0Qm90dG9tQ29ybmVyKG1hdHJpeCkge1xuICAgICAgICAgICAgaWYgKG1hdHJpeC5nZXQoOCwgbWF0cml4LmdldEhlaWdodCgpIC0gOCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKDgsIG1hdHJpeC5nZXRIZWlnaHQoKSAtIDgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybih4U3RhcnQgLyppbnQqLywgeVN0YXJ0IC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA4OyArK3gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KHhTdGFydCArIHgsIHlTdGFydCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQgKyB4LCB5U3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4oeFN0YXJ0IC8qaW50Ki8sIHlTdGFydCAvKmludCovLCBtYXRyaXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNzsgKyt5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4U3RhcnQsIHlTdGFydCArIHkpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoeFN0YXJ0LCB5U3RhcnQgKyB5LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJuKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDU7ICsreSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5ZID0gTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5beV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA1OyArK3gpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQgKyB4LCB5U3RhcnQgKyB5LCBwYXR0ZXJuWVt4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBlbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybih4U3RhcnQgLyppbnQqLywgeVN0YXJ0IC8qaW50Ki8sIG1hdHJpeCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA3OyArK3kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuWSA9IE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk5beV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA3OyArK3gpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcih4U3RhcnQgKyB4LCB5U3RhcnQgKyB5LCBwYXR0ZXJuWVt4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVtYmVkIHBvc2l0aW9uIGRldGVjdGlvbiBwYXR0ZXJucyBhbmQgc3Vycm91bmRpbmcgdmVydGljYWwvaG9yaXpvbnRhbCBzZXBhcmF0b3JzLlxuICAgICAgICBzdGF0aWMgZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm5zQW5kU2VwYXJhdG9ycyhtYXRyaXgpIHtcbiAgICAgICAgICAgIC8vIEVtYmVkIHRocmVlIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXG4gICAgICAgICAgICBjb25zdCBwZHBXaWR0aCA9IE1hdHJpeFV0aWwuUE9TSVRJT05fREVURUNUSU9OX1BBVFRFUk5bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgLy8gTGVmdCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybigwLCAwLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4obWF0cml4LmdldFdpZHRoKCkgLSBwZHBXaWR0aCwgMCwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIExlZnQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4oMCwgbWF0cml4LmdldFdpZHRoKCkgLSBwZHBXaWR0aCwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIEVtYmVkIGhvcml6b250YWwgc2VwYXJhdGlvbiBwYXR0ZXJucyBhcm91bmQgdGhlIHNxdWFyZXMuXG4gICAgICAgICAgICBjb25zdCBoc3BXaWR0aCA9IDg7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKDAsIGhzcFdpZHRoIC0gMSwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIFJpZ2h0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKG1hdHJpeC5nZXRXaWR0aCgpIC0gaHNwV2lkdGgsIGhzcFdpZHRoIC0gMSwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIExlZnQgYm90dG9tIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRIb3Jpem9udGFsU2VwYXJhdGlvblBhdHRlcm4oMCwgbWF0cml4LmdldFdpZHRoKCkgLSBoc3BXaWR0aCwgbWF0cml4KTtcbiAgICAgICAgICAgIC8vIEVtYmVkIHZlcnRpY2FsIHNlcGFyYXRpb24gcGF0dGVybnMgYXJvdW5kIHRoZSBzcXVhcmVzLlxuICAgICAgICAgICAgY29uc3QgdnNwU2l6ZSA9IDc7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih2c3BTaXplLCAwLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cbiAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKG1hdHJpeC5nZXRIZWlnaHQoKSAtIHZzcFNpemUgLSAxLCAwLCBtYXRyaXgpO1xuICAgICAgICAgICAgLy8gTGVmdCBib3R0b20gY29ybmVyLlxuICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4odnNwU2l6ZSwgbWF0cml4LmdldEhlaWdodCgpIC0gdnNwU2l6ZSwgbWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWJlZCBwb3NpdGlvbiBhZGp1c3RtZW50IHBhdHRlcm5zIGlmIG5lZWQgYmUuXG4gICAgICAgIHN0YXRpYyBtYXliZUVtYmVkUG9zaXRpb25BZGp1c3RtZW50UGF0dGVybnModmVyc2lvbiwgbWF0cml4KSB7XG4gICAgICAgICAgICBpZiAodmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCkgPCAyKSB7IC8vIFRoZSBwYXR0ZXJucyBhcHBlYXIgaWYgdmVyc2lvbiA+PSAyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSAtIDE7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IE1hdHJpeFV0aWwuUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOX0NPT1JESU5BVEVfVEFCTEVbaW5kZXhdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSAhPT0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiAhPT0gbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID49IDAgJiYgTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoeCwgeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNlbGwgaXMgdW5zZXQsIHdlIGVtYmVkIHRoZSBwb3NpdGlvbiBhZGp1c3RtZW50IHBhdHRlcm4gaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMiBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIHgveSBjb29yZGluYXRlcyBwb2ludCB0byB0aGUgY2VudGVyIG9mIHRoZSBwYXR0ZXJuLCBub3QgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVmdCB0b3AgY29ybmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJuKHggLSAyLCB5IC0gMiwgbWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBNYXRyaXhVdGlsLlBPU0lUSU9OX0RFVEVDVElPTl9QQVRURVJOID0gQXJyYXkuZnJvbShbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMSwgMSwgMSwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDEsIDEsIDEsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMSwgMSwgMV0pLFxuICAgIF0pO1xuICAgIE1hdHJpeFV0aWwuUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOID0gQXJyYXkuZnJvbShbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMSwgMSwgMSwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAwLCAxXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMSwgMCwgMCwgMCwgMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDEsIDEsIDEsIDFdKSxcbiAgICBdKTtcbiAgICAvLyBGcm9tIEFwcGVuZGl4IEUuIFRhYmxlIDEsIEpJUzA1MTBYOjIwMDQgKDcxOiBwKS4gVGhlIHRhYmxlIHdhcyBkb3VibGUtY2hlY2tlZCBieSBrb21hdHN1LlxuICAgIE1hdHJpeFV0aWwuUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOX0NPT1JESU5BVEVfVEFCTEUgPSBBcnJheS5mcm9tKFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFstMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDE4LCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyMiwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCAtMSwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgLTEsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjIsIDM4LCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA0MiwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDYsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgLTEsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIC0xLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCAtMSwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0NiwgNjYsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNDgsIDcwLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NCwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTYsIDgyLCAtMSwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgLTEsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIC0xLCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTAsIDcyLCA5NCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NCwgOTgsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTAsIC0xLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODYsIDExNCwgLTEsIC0xXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAtMSwgLTFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MiwgNzgsIDEwNCwgMTMwLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0LCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MCwgODYsIDExMiwgMTM4LCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyLCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2LCAtMV0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAxNTBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgMTM2LCAxNjJdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF0pLFxuICAgIF0pO1xuICAgIC8vIFR5cGUgaW5mbyBjZWxscyBhdCB0aGUgbGVmdCB0b3AgY29ybmVyLlxuICAgIE1hdHJpeFV0aWwuVFlQRV9JTkZPX0NPT1JESU5BVEVTID0gQXJyYXkuZnJvbShbXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgMF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDFdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAyXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgM10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDRdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA1XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbOCwgN10pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzgsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs3LCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNSwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzQsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA4XSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMiwgOF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzEsIDhdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFswLCA4XSksXG4gICAgXSk7XG4gICAgLy8gRnJvbSBBcHBlbmRpeCBEIGluIEpJU1gwNTEwOjIwMDQgKHAuIDY3KVxuICAgIE1hdHJpeFV0aWwuVkVSU0lPTl9JTkZPX1BPTFkgPSAweDFmMjU7IC8vIDEgMTExMSAwMDEwIDAxMDFcbiAgICAvLyBGcm9tIEFwcGVuZGl4IEMgaW4gSklTWDA1MTA6MjAwNCAocC42NSkuXG4gICAgTWF0cml4VXRpbC5UWVBFX0lORk9fUE9MWSA9IDB4NTM3O1xuICAgIE1hdHJpeFV0aWwuVFlQRV9JTkZPX01BU0tfUEFUVEVSTiA9IDB4NTQxMjtcblxuICAgIC8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLmVuY29kZXIgeyovXG4gICAgY2xhc3MgQmxvY2tQYWlyIHtcbiAgICAgICAgY29uc3RydWN0b3IoZGF0YUJ5dGVzLCBlcnJvckNvcnJlY3Rpb25CeXRlcykge1xuICAgICAgICAgICAgdGhpcy5kYXRhQnl0ZXMgPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkJ5dGVzID0gZXJyb3JDb3JyZWN0aW9uQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RGF0YUJ5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGdldEVycm9yQ29ycmVjdGlvbkJ5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uQnl0ZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKmltcG9ydCBqYXZhLmlvLlVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb247Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0OyovXG4gICAgLyppbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247Ki9cbiAgICAvKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBzYXRvcnV4QGdvb2dsZS5jb20gKFNhdG9ydSBUYWthYmF5YXNoaSkgLSBjcmVhdG9yXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikgLSBwb3J0ZWQgZnJvbSBDKytcbiAgICAgKi9cbiAgICBjbGFzcyBFbmNvZGVyIHtcbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoYW5nZWQgdG8gVVRGOCwgdGhlIGRlZmF1bHQgZm9yIGpzXG4gICAgICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgICAgIC8vIFRoZSBtYXNrIHBlbmFsdHkgY2FsY3VsYXRpb24gaXMgY29tcGxpY2F0ZWQuICBTZWUgVGFibGUgMjEgb2YgSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuXG4gICAgICAgIC8vIEJhc2ljYWxseSBpdCBhcHBsaWVzIGZvdXIgcnVsZXMgYW5kIHN1bW1hdGUgYWxsIHBlbmFsdGllcy5cbiAgICAgICAgc3RhdGljIGNhbGN1bGF0ZU1hc2tQZW5hbHR5KG1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMShtYXRyaXgpXG4gICAgICAgICAgICAgICAgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTIobWF0cml4KVxuICAgICAgICAgICAgICAgICsgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUzKG1hdHJpeClcbiAgICAgICAgICAgICAgICArIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlNChtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gY29udGVudCB0ZXh0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0gZWNMZXZlbCBlcnJvciBjb3JyZWN0aW9uIGxldmVsIHRvIHVzZVxuICAgICAgICAgKiBAcmV0dXJuIHtAbGluayBRUkNvZGV9IHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCBRUiBjb2RlXG4gICAgICAgICAqIEB0aHJvd3MgV3JpdGVyRXhjZXB0aW9uIGlmIGVuY29kaW5nIGNhbid0IHN1Y2NlZWQsIGJlY2F1c2Ugb2YgZm9yIGV4YW1wbGUgaW52YWxpZCBjb250ZW50XG4gICAgICAgICAqICAgb3IgY29uZmlndXJhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gcHVibGljIHN0YXRpYyBlbmNvZGUoY29udGVudDogc3RyaW5nLCBlY0xldmVsOiBFcnJvckNvcnJlY3Rpb25MZXZlbCk6IFFSQ29kZSAvKnRocm93cyBXcml0ZXJFeGNlcHRpb24qLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGVuY29kZShjb250ZW50LCBlY0xldmVsLCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIHN0YXRpYyBlbmNvZGUoY29udGVudCwgZWNMZXZlbCwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgaGFzIGJlZW4gc3BlY2lmaWVkIGJ5IHRoZSBjYWxsZXIsIGlmIGFueVxuICAgICAgICAgICAgbGV0IGVuY29kaW5nID0gRW5jb2Rlci5ERUZBVUxUX0JZVEVfTU9ERV9FTkNPRElORztcbiAgICAgICAgICAgIGNvbnN0IGhhc0VuY29kaW5nSGludCA9IGhpbnRzICE9PSBudWxsICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuQ0hBUkFDVEVSX1NFVCk7XG4gICAgICAgICAgICBpZiAoaGFzRW5jb2RpbmdIaW50KSB7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGljayBhbiBlbmNvZGluZyBtb2RlIGFwcHJvcHJpYXRlIGZvciB0aGUgY29udGVudC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgYXR0ZW1wdCB0byB1c2VcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIG1vZGVzIC8gc2VnbWVudHMgZXZlbiBpZiB0aGF0IHdlcmUgbW9yZSBlZmZpY2llbnQuIFR3b3VsZCBiZSBuaWNlLlxuICAgICAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMuY2hvb3NlTW9kZShjb250ZW50LCBlbmNvZGluZyk7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgc3RvcmUgdGhlIGhlYWRlciBpbmZvcm1hdGlvbiwgbGlrZSBtb2RlIGFuZFxuICAgICAgICAgICAgLy8gbGVuZ3RoLCBhcyB3ZWxsIGFzIFwiaGVhZGVyXCIgc2VnbWVudHMgbGlrZSBhbiBFQ0kgc2VnbWVudC5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlckJpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIC8vIEFwcGVuZCBFQ0kgc2VnbWVudCBpZiBhcHBsaWNhYmxlXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gTW9kZSQxLkJZVEUgJiYgKGhhc0VuY29kaW5nSGludCB8fCBFbmNvZGVyLkRFRkFVTFRfQllURV9NT0RFX0VOQ09ESU5HICE9PSBlbmNvZGluZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlY2kgPSBDaGFyYWN0ZXJTZXRFQ0kuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlOYW1lKGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoZWNpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFQ0koZWNpLCBoZWFkZXJCaXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAoV2l0aCBFQ0kgaW4gcGxhY2UsKSBXcml0ZSB0aGUgbW9kZSBtYXJrZXJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTW9kZUluZm8obW9kZSwgaGVhZGVyQml0cyk7XG4gICAgICAgICAgICAvLyBDb2xsZWN0IGRhdGEgd2l0aGluIHRoZSBtYWluIHNlZ21lbnQsIHNlcGFyYXRlbHksIHRvIGNvdW50IGl0cyBzaXplIGlmIG5lZWRlZC4gRG9uJ3QgYWRkIGl0IHRvXG4gICAgICAgICAgICAvLyBtYWluIHBheWxvYWQgeWV0LlxuICAgICAgICAgICAgY29uc3QgZGF0YUJpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQnl0ZXMoY29udGVudCwgbW9kZSwgZGF0YUJpdHMsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uO1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuUVJfVkVSU0lPTikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLlFSX1ZFUlNJT04pLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bWJlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0c05lZWRlZCA9IHRoaXMuY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLndpbGxGaXQoYml0c05lZWRlZCwgdmVyc2lvbiwgZWNMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignRGF0YSB0b28gYmlnIGZvciByZXF1ZXN0ZWQgdmVyc2lvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSB0aGlzLnJlY29tbWVuZFZlcnNpb24oZWNMZXZlbCwgbW9kZSwgaGVhZGVyQml0cywgZGF0YUJpdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyQW5kRGF0YUJpdHMgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIGhlYWRlckFuZERhdGFCaXRzLmFwcGVuZEJpdEFycmF5KGhlYWRlckJpdHMpO1xuICAgICAgICAgICAgLy8gRmluZCBcImxlbmd0aFwiIG9mIG1haW4gc2VnbWVudCBhbmQgd3JpdGUgaXRcbiAgICAgICAgICAgIGNvbnN0IG51bUxldHRlcnMgPSBtb2RlID09PSBNb2RlJDEuQllURSA/IGRhdGFCaXRzLmdldFNpemVJbkJ5dGVzKCkgOiBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTGVuZ3RoSW5mbyhudW1MZXR0ZXJzLCB2ZXJzaW9uLCBtb2RlLCBoZWFkZXJBbmREYXRhQml0cyk7XG4gICAgICAgICAgICAvLyBQdXQgZGF0YSB0b2dldGhlciBpbnRvIHRoZSBvdmVyYWxsIHBheWxvYWRcbiAgICAgICAgICAgIGhlYWRlckFuZERhdGFCaXRzLmFwcGVuZEJpdEFycmF5KGRhdGFCaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzID0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpIC0gZWNCbG9ja3MuZ2V0VG90YWxFQ0NvZGV3b3JkcygpO1xuICAgICAgICAgICAgLy8gVGVybWluYXRlIHRoZSBiaXRzIHByb3Blcmx5LlxuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVCaXRzKG51bURhdGFCeXRlcywgaGVhZGVyQW5kRGF0YUJpdHMpO1xuICAgICAgICAgICAgLy8gSW50ZXJsZWF2ZSBkYXRhIGJpdHMgd2l0aCBlcnJvciBjb3JyZWN0aW9uIGNvZGUuXG4gICAgICAgICAgICBjb25zdCBmaW5hbEJpdHMgPSB0aGlzLmludGVybGVhdmVXaXRoRUNCeXRlcyhoZWFkZXJBbmREYXRhQml0cywgdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpLCBudW1EYXRhQnl0ZXMsIGVjQmxvY2tzLmdldE51bUJsb2NrcygpKTtcbiAgICAgICAgICAgIGNvbnN0IHFyQ29kZSA9IG5ldyBRUkNvZGUoKTtcbiAgICAgICAgICAgIHFyQ29kZS5zZXRFQ0xldmVsKGVjTGV2ZWwpO1xuICAgICAgICAgICAgcXJDb2RlLnNldE1vZGUobW9kZSk7XG4gICAgICAgICAgICBxckNvZGUuc2V0VmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgICAgICAgIC8vICBDaG9vc2UgdGhlIG1hc2sgcGF0dGVybiBhbmQgc2V0IHRvIFwicXJDb2RlXCIuXG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB2ZXJzaW9uLmdldERpbWVuc2lvbkZvclZlcnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBCeXRlTWF0cml4KGRpbWVuc2lvbiwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2tQYXR0ZXJuID0gdGhpcy5jaG9vc2VNYXNrUGF0dGVybihmaW5hbEJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hdHJpeCk7XG4gICAgICAgICAgICBxckNvZGUuc2V0TWFza1BhdHRlcm4obWFza1BhdHRlcm4pO1xuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIG1hdHJpeCBhbmQgc2V0IGl0IHRvIFwicXJDb2RlXCIuXG4gICAgICAgICAgICBNYXRyaXhVdGlsLmJ1aWxkTWF0cml4KGZpbmFsQml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICAgICAgICBxckNvZGUuc2V0TWF0cml4KG1hdHJpeCk7XG4gICAgICAgICAgICByZXR1cm4gcXJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNpZGVzIHRoZSBzbWFsbGVzdCB2ZXJzaW9uIG9mIFFSIGNvZGUgdGhhdCB3aWxsIGNvbnRhaW4gYWxsIG9mIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiBpZiB0aGUgZGF0YSBjYW5ub3QgZml0IGluIGFueSB2ZXJzaW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgcmVjb21tZW5kVmVyc2lvbihlY0xldmVsLCBtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cykge1xuICAgICAgICAgICAgLy8gSGFyZCBwYXJ0OiBuZWVkIHRvIGtub3cgdmVyc2lvbiB0byBrbm93IGhvdyBtYW55IGJpdHMgbGVuZ3RoIHRha2VzLiBCdXQgbmVlZCB0byBrbm93IGhvdyBtYW55XG4gICAgICAgICAgICAvLyBiaXRzIGl0IHRha2VzIHRvIGtub3cgdmVyc2lvbi4gRmlyc3Qgd2UgdGFrZSBhIGd1ZXNzIGF0IHZlcnNpb24gYnkgYXNzdW1pbmcgdmVyc2lvbiB3aWxsIGJlXG4gICAgICAgICAgICAvLyB0aGUgbWluaW11bSwgMTpcbiAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmFsQml0c05lZWRlZCA9IHRoaXMuY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgVmVyc2lvbiQxLmdldFZlcnNpb25Gb3JOdW1iZXIoMSkpO1xuICAgICAgICAgICAgY29uc3QgcHJvdmlzaW9uYWxWZXJzaW9uID0gdGhpcy5jaG9vc2VWZXJzaW9uKHByb3Zpc2lvbmFsQml0c05lZWRlZCwgZWNMZXZlbCk7XG4gICAgICAgICAgICAvLyBVc2UgdGhhdCBndWVzcyB0byBjYWxjdWxhdGUgdGhlIHJpZ2h0IHZlcnNpb24uIEkgYW0gc3RpbGwgbm90IHN1cmUgdGhpcyB3b3JrcyBpbiAxMDAlIG9mIGNhc2VzLlxuICAgICAgICAgICAgY29uc3QgYml0c05lZWRlZCA9IHRoaXMuY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgcHJvdmlzaW9uYWxWZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNob29zZVZlcnNpb24oYml0c05lZWRlZCwgZWNMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNhbGN1bGF0ZUJpdHNOZWVkZWQobW9kZSwgaGVhZGVyQml0cywgZGF0YUJpdHMsIHZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJCaXRzLmdldFNpemUoKSArIG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pICsgZGF0YUJpdHMuZ2V0U2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSBjb2RlIHBvaW50IG9mIHRoZSB0YWJsZSB1c2VkIGluIGFscGhhbnVtZXJpYyBtb2RlIG9yXG4gICAgICAgICAqICAtMSBpZiB0aGVyZSBpcyBubyBjb3JyZXNwb25kaW5nIGNvZGUgaW4gdGhlIHRhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldEFscGhhbnVtZXJpY0NvZGUoY29kZSAvKmludCovKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA8IEVuY29kZXIuQUxQSEFOVU1FUklDX1RBQkxFLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFbmNvZGVyLkFMUEhBTlVNRVJJQ19UQUJMRVtjb2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwdWJsaWMgc3RhdGljIGNob29zZU1vZGUoY29udGVudDogc3RyaW5nKTogTW9kZSB7XG4gICAgICAgIC8vICAgcmV0dXJuIGNob29zZU1vZGUoY29udGVudCwgbnVsbCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENob29zZSB0aGUgYmVzdCBtb2RlIGJ5IGV4YW1pbmluZyB0aGUgY29udGVudC4gTm90ZSB0aGF0ICdlbmNvZGluZycgaXMgdXNlZCBhcyBhIGhpbnQ7XG4gICAgICAgICAqIGlmIGl0IGlzIFNoaWZ0X0pJUywgYW5kIHRoZSBpbnB1dCBpcyBvbmx5IGRvdWJsZS1ieXRlIEthbmppLCB0aGVuIHdlIHJldHVybiB7QGxpbmsgTW9kZSNLQU5KSX0uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgY2hvb3NlTW9kZShjb250ZW50LCBlbmNvZGluZyA9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChDaGFyYWN0ZXJTZXRFQ0kuU0pJUy5nZXROYW1lKCkgPT09IGVuY29kaW5nICYmIHRoaXMuaXNPbmx5RG91YmxlQnl0ZUthbmppKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hvb3NlIEthbmppIG1vZGUgaWYgYWxsIGlucHV0IGFyZSBkb3VibGUtYnl0ZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5LQU5KSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBoYXNOdW1lcmljID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaGFzQWxwaGFudW1lcmljID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBjb250ZW50LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoRW5jb2Rlci5pc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc051bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmdldEFscGhhbnVtZXJpY0NvZGUoYy5jaGFyQ29kZUF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQWxwaGFudW1lcmljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlJDEuQllURTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQWxwaGFudW1lcmljKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUkMS5BTFBIQU5VTUVSSUM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTnVtZXJpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBNb2RlJDEuTlVNRVJJQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNb2RlJDEuQllURTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNPbmx5RG91YmxlQnl0ZUthbmppKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBTdHJpbmdFbmNvZGluZy5lbmNvZGUoY29udGVudCwgQ2hhcmFjdGVyU2V0RUNJLlNKSVMpOyAvLyBjb250ZW50LmdldEJ5dGVzKFwiU2hpZnRfSklTXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gYnl0ZXNbaV0gJiAweEZGO1xuICAgICAgICAgICAgICAgIGlmICgoYnl0ZTEgPCAweDgxIHx8IGJ5dGUxID4gMHg5RikgJiYgKGJ5dGUxIDwgMHhFMCB8fCBieXRlMSA+IDB4RUIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgY2hvb3NlTWFza1BhdHRlcm4oYml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWF0cml4KSB7XG4gICAgICAgICAgICBsZXQgbWluUGVuYWx0eSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOyAvLyBMb3dlciBwZW5hbHR5IGlzIGJldHRlci5cbiAgICAgICAgICAgIGxldCBiZXN0TWFza1BhdHRlcm4gPSAtMTtcbiAgICAgICAgICAgIC8vIFdlIHRyeSBhbGwgbWFzayBwYXR0ZXJucyB0byBjaG9vc2UgdGhlIGJlc3Qgb25lLlxuICAgICAgICAgICAgZm9yIChsZXQgbWFza1BhdHRlcm4gPSAwOyBtYXNrUGF0dGVybiA8IFFSQ29kZS5OVU1fTUFTS19QQVRURVJOUzsgbWFza1BhdHRlcm4rKykge1xuICAgICAgICAgICAgICAgIE1hdHJpeFV0aWwuYnVpbGRNYXRyaXgoYml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWFza1BhdHRlcm4sIG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgbGV0IHBlbmFsdHkgPSB0aGlzLmNhbGN1bGF0ZU1hc2tQZW5hbHR5KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmFsdHkgPCBtaW5QZW5hbHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblBlbmFsdHkgPSBwZW5hbHR5O1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWFza1BhdHRlcm4gPSBtYXNrUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hc2tQYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBjaG9vc2VWZXJzaW9uKG51bUlucHV0Qml0cyAvKmludCovLCBlY0xldmVsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB2ZXJzaW9uTnVtID0gMTsgdmVyc2lvbk51bSA8PSA0MDsgdmVyc2lvbk51bSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb24kMS5nZXRWZXJzaW9uRm9yTnVtYmVyKHZlcnNpb25OdW0pO1xuICAgICAgICAgICAgICAgIGlmIChFbmNvZGVyLndpbGxGaXQobnVtSW5wdXRCaXRzLCB2ZXJzaW9uLCBlY0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdEYXRhIHRvbyBiaWcnKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBudW1iZXIgb2YgaW5wdXQgYml0cyB3aWxsIGZpdCBpbiBhIGNvZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHZlcnNpb24gYW5kXG4gICAgICAgICAqIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgd2lsbEZpdChudW1JbnB1dEJpdHMgLyppbnQqLywgdmVyc2lvbiwgZWNMZXZlbCkge1xuICAgICAgICAgICAgLy8gSW4gdGhlIGZvbGxvd2luZyBjb21tZW50cywgd2UgdXNlIG51bWJlcnMgb2YgVmVyc2lvbiA3LUguXG4gICAgICAgICAgICAvLyBudW1CeXRlcyA9IDE5NlxuICAgICAgICAgICAgY29uc3QgbnVtQnl0ZXMgPSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBnZXROdW1FQ0J5dGVzID0gMTMwXG4gICAgICAgICAgICBjb25zdCBlY0Jsb2NrcyA9IHZlcnNpb24uZ2V0RUNCbG9ja3NGb3JMZXZlbChlY0xldmVsKTtcbiAgICAgICAgICAgIGNvbnN0IG51bUVjQnl0ZXMgPSBlY0Jsb2Nrcy5nZXRUb3RhbEVDQ29kZXdvcmRzKCk7XG4gICAgICAgICAgICAvLyBnZXROdW1EYXRhQnl0ZXMgPSAxOTYgLSAxMzAgPSA2NlxuICAgICAgICAgICAgY29uc3QgbnVtRGF0YUJ5dGVzID0gbnVtQnl0ZXMgLSBudW1FY0J5dGVzO1xuICAgICAgICAgICAgY29uc3QgdG90YWxJbnB1dEJ5dGVzID0gKG51bUlucHV0Qml0cyArIDcpIC8gODtcbiAgICAgICAgICAgIHJldHVybiBudW1EYXRhQnl0ZXMgPj0gdG90YWxJbnB1dEJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXJtaW5hdGUgYml0cyBhcyBkZXNjcmliZWQgaW4gOC40LjggYW5kIDguNC45IG9mIEpJU1gwNTEwOjIwMDQgKHAuMjQpLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHRlcm1pbmF0ZUJpdHMobnVtRGF0YUJ5dGVzIC8qaW50Ki8sIGJpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGFjaXR5ID0gbnVtRGF0YUJ5dGVzICogODtcbiAgICAgICAgICAgIGlmIChiaXRzLmdldFNpemUoKSA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignZGF0YSBiaXRzIGNhbm5vdCBmaXQgaW4gdGhlIFFSIENvZGUnICsgYml0cy5nZXRTaXplKCkgKyAnID4gJyArXG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNCAmJiBiaXRzLmdldFNpemUoKSA8IGNhcGFjaXR5OyArK2kpIHtcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBlbmQgdGVybWluYXRpb24gYml0cy4gU2VlIDguNC44IG9mIEpJU1gwNTEwOjIwMDQgKHAuMjQpIGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgYnl0ZSBpc24ndCA4LWJpdCBhbGlnbmVkLCB3ZSdsbCBhZGQgcGFkZGluZyBiaXRzLlxuICAgICAgICAgICAgY29uc3QgbnVtQml0c0luTGFzdEJ5dGUgPSBiaXRzLmdldFNpemUoKSAmIDB4MDc7XG4gICAgICAgICAgICBpZiAobnVtQml0c0luTGFzdEJ5dGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG51bUJpdHNJbkxhc3RCeXRlOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgc3BhY2UsIHdlJ2xsIGZpbGwgdGhlIHNwYWNlIHdpdGggcGFkZGluZyBwYXR0ZXJucyBkZWZpbmVkIGluIDguNC45IChwLjI0KS5cbiAgICAgICAgICAgIGNvbnN0IG51bVBhZGRpbmdCeXRlcyA9IG51bURhdGFCeXRlcyAtIGJpdHMuZ2V0U2l6ZUluQnl0ZXMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGFkZGluZ0J5dGVzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoKGkgJiAweDAxKSA9PT0gMCA/IDB4RUMgOiAweDExLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzLmdldFNpemUoKSAhPT0gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdCaXRzIHNpemUgZG9lcyBub3QgZXF1YWwgY2FwYWNpdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG51bWJlciBvZiBkYXRhIGJ5dGVzIGFuZCBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBieXRlcyBmb3IgYmxvY2sgaWQgXCJibG9ja0lEXCIuIFN0b3JlXG4gICAgICAgICAqIHRoZSByZXN1bHQgaW4gXCJudW1EYXRhQnl0ZXNJbkJsb2NrXCIsIGFuZCBcIm51bUVDQnl0ZXNJbkJsb2NrXCIuIFNlZSB0YWJsZSAxMiBpbiA4LjUuMSBvZlxuICAgICAgICAgKiBKSVNYMDUxMDoyMDA0IChwLjMwKVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGdldE51bURhdGFCeXRlc0FuZE51bUVDQnl0ZXNGb3JCbG9ja0lEKG51bVRvdGFsQnl0ZXMgLyppbnQqLywgbnVtRGF0YUJ5dGVzIC8qaW50Ki8sIG51bVJTQmxvY2tzIC8qaW50Ki8sIGJsb2NrSUQgLyppbnQqLywgbnVtRGF0YUJ5dGVzSW5CbG9jaywgbnVtRUNCeXRlc0luQmxvY2spIHtcbiAgICAgICAgICAgIGlmIChibG9ja0lEID49IG51bVJTQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignQmxvY2sgSUQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBudW1Sc0Jsb2Nrc0luR3JvdXAyID0gMTk2ICUgNSA9IDFcbiAgICAgICAgICAgIGNvbnN0IG51bVJzQmxvY2tzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzICUgbnVtUlNCbG9ja3M7XG4gICAgICAgICAgICAvLyBudW1Sc0Jsb2Nrc0luR3JvdXAxID0gNSAtIDEgPSA0XG4gICAgICAgICAgICBjb25zdCBudW1Sc0Jsb2Nrc0luR3JvdXAxID0gbnVtUlNCbG9ja3MgLSBudW1Sc0Jsb2Nrc0luR3JvdXAyO1xuICAgICAgICAgICAgLy8gbnVtVG90YWxCeXRlc0luR3JvdXAxID0gMTk2IC8gNSA9IDM5XG4gICAgICAgICAgICBjb25zdCBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgPSBNYXRoLmZsb29yKG51bVRvdGFsQnl0ZXMgLyBudW1SU0Jsb2Nrcyk7XG4gICAgICAgICAgICAvLyBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSAzOSArIDEgPSA0MFxuICAgICAgICAgICAgY29uc3QgbnVtVG90YWxCeXRlc0luR3JvdXAyID0gbnVtVG90YWxCeXRlc0luR3JvdXAxICsgMTtcbiAgICAgICAgICAgIC8vIG51bURhdGFCeXRlc0luR3JvdXAxID0gNjYgLyA1ID0gMTNcbiAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlc0luR3JvdXAxID0gTWF0aC5mbG9vcihudW1EYXRhQnl0ZXMgLyBudW1SU0Jsb2Nrcyk7XG4gICAgICAgICAgICAvLyBudW1EYXRhQnl0ZXNJbkdyb3VwMiA9IDEzICsgMSA9IDE0XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXNJbkdyb3VwMiA9IG51bURhdGFCeXRlc0luR3JvdXAxICsgMTtcbiAgICAgICAgICAgIC8vIG51bUVjQnl0ZXNJbkdyb3VwMSA9IDM5IC0gMTMgPSAyNlxuICAgICAgICAgICAgY29uc3QgbnVtRWNCeXRlc0luR3JvdXAxID0gbnVtVG90YWxCeXRlc0luR3JvdXAxIC0gbnVtRGF0YUJ5dGVzSW5Hcm91cDE7XG4gICAgICAgICAgICAvLyBudW1FY0J5dGVzSW5Hcm91cDIgPSA0MCAtIDE0ID0gMjZcbiAgICAgICAgICAgIGNvbnN0IG51bUVjQnl0ZXNJbkdyb3VwMiA9IG51bVRvdGFsQnl0ZXNJbkdyb3VwMiAtIG51bURhdGFCeXRlc0luR3JvdXAyO1xuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrcy5cbiAgICAgICAgICAgIC8vIDI2ID0gMjZcbiAgICAgICAgICAgIGlmIChudW1FY0J5dGVzSW5Hcm91cDEgIT09IG51bUVjQnl0ZXNJbkdyb3VwMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0VDIGJ5dGVzIG1pc21hdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1ID0gNCArIDEuXG4gICAgICAgICAgICBpZiAobnVtUlNCbG9ja3MgIT09IG51bVJzQmxvY2tzSW5Hcm91cDEgKyBudW1Sc0Jsb2Nrc0luR3JvdXAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignUlMgYmxvY2tzIG1pc21hdGNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAxOTYgPSAoMTMgKyAyNikgKiA0ICsgKDE0ICsgMjYpICogMVxuICAgICAgICAgICAgaWYgKG51bVRvdGFsQnl0ZXMgIT09XG4gICAgICAgICAgICAgICAgKChudW1EYXRhQnl0ZXNJbkdyb3VwMSArIG51bUVjQnl0ZXNJbkdyb3VwMSkgKlxuICAgICAgICAgICAgICAgICAgICBudW1Sc0Jsb2Nrc0luR3JvdXAxKSArXG4gICAgICAgICAgICAgICAgICAgICgobnVtRGF0YUJ5dGVzSW5Hcm91cDIgKyBudW1FY0J5dGVzSW5Hcm91cDIpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVJzQmxvY2tzSW5Hcm91cDIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignVG90YWwgYnl0ZXMgbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0lEIDwgbnVtUnNCbG9ja3NJbkdyb3VwMSkge1xuICAgICAgICAgICAgICAgIG51bURhdGFCeXRlc0luQmxvY2tbMF0gPSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcbiAgICAgICAgICAgICAgICBudW1FQ0J5dGVzSW5CbG9ja1swXSA9IG51bUVjQnl0ZXNJbkdyb3VwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG51bURhdGFCeXRlc0luQmxvY2tbMF0gPSBudW1EYXRhQnl0ZXNJbkdyb3VwMjtcbiAgICAgICAgICAgICAgICBudW1FQ0J5dGVzSW5CbG9ja1swXSA9IG51bUVjQnl0ZXNJbkdyb3VwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJsZWF2ZSBcImJpdHNcIiB3aXRoIGNvcnJlc3BvbmRpbmcgZXJyb3IgY29ycmVjdGlvbiBieXRlcy4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpblxuICAgICAgICAgKiBcInJlc3VsdFwiLiBUaGUgaW50ZXJsZWF2ZSBydWxlIGlzIGNvbXBsaWNhdGVkLiBTZWUgOC42IG9mIEpJU1gwNTEwOjIwMDQgKHAuMzcpIGZvciBkZXRhaWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGludGVybGVhdmVXaXRoRUNCeXRlcyhiaXRzLCBudW1Ub3RhbEJ5dGVzIC8qaW50Ki8sIG51bURhdGFCeXRlcyAvKmludCovLCBudW1SU0Jsb2NrcyAvKmludCovKSB7XG4gICAgICAgICAgICAvLyBcImJpdHNcIiBtdXN0IGhhdmUgXCJnZXROdW1EYXRhQnl0ZXNcIiBieXRlcyBvZiBkYXRhLlxuICAgICAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZUluQnl0ZXMoKSAhPT0gbnVtRGF0YUJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbignTnVtYmVyIG9mIGJpdHMgYW5kIGRhdGEgYnl0ZXMgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMS4gIERpdmlkZSBkYXRhIGJ5dGVzIGludG8gYmxvY2tzIGFuZCBnZW5lcmF0ZSBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzIGZvciB0aGVtLiBXZSdsbFxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGRpdmlkZWQgZGF0YSBieXRlcyBibG9ja3MgYW5kIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMgYmxvY2tzIGludG8gXCJibG9ja3NcIi5cbiAgICAgICAgICAgIGxldCBkYXRhQnl0ZXNPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IG1heE51bURhdGFCeXRlcyA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4TnVtRWNCeXRlcyA9IDA7XG4gICAgICAgICAgICAvLyBTaW5jZSwgd2Uga25vdyB0aGUgbnVtYmVyIG9mIHJlZWRzb2xtb24gYmxvY2tzLCB3ZSBjYW4gaW5pdGlhbGl6ZSB0aGUgdmVjdG9yIHdpdGggdGhlIG51bWJlci5cbiAgICAgICAgICAgIGNvbnN0IGJsb2NrcyA9IG5ldyBBcnJheSgpOyAvLyBuZXcgQXJyYXk8QmxvY2tQYWlyPihudW1SU0Jsb2NrcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUlNCbG9ja3M7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bURhdGFCeXRlc0luQmxvY2sgPSBuZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1FY0J5dGVzSW5CbG9jayA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICAgICAgICAgIEVuY29kZXIuZ2V0TnVtRGF0YUJ5dGVzQW5kTnVtRUNCeXRlc0ZvckJsb2NrSUQobnVtVG90YWxCeXRlcywgbnVtRGF0YUJ5dGVzLCBudW1SU0Jsb2NrcywgaSwgbnVtRGF0YUJ5dGVzSW5CbG9jaywgbnVtRWNCeXRlc0luQmxvY2spO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBudW1EYXRhQnl0ZXNJbkJsb2NrWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAgICAgICAgIGJpdHMudG9CeXRlcyg4ICogZGF0YUJ5dGVzT2Zmc2V0LCBkYXRhQnl0ZXMsIDAsIHNpemUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVjQnl0ZXMgPSBFbmNvZGVyLmdlbmVyYXRlRUNCeXRlcyhkYXRhQnl0ZXMsIG51bUVjQnl0ZXNJbkJsb2NrWzBdKTtcbiAgICAgICAgICAgICAgICBibG9ja3MucHVzaChuZXcgQmxvY2tQYWlyKGRhdGFCeXRlcywgZWNCeXRlcykpO1xuICAgICAgICAgICAgICAgIG1heE51bURhdGFCeXRlcyA9IE1hdGgubWF4KG1heE51bURhdGFCeXRlcywgc2l6ZSk7XG4gICAgICAgICAgICAgICAgbWF4TnVtRWNCeXRlcyA9IE1hdGgubWF4KG1heE51bUVjQnl0ZXMsIGVjQnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBkYXRhQnl0ZXNPZmZzZXQgKz0gbnVtRGF0YUJ5dGVzSW5CbG9ja1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1EYXRhQnl0ZXMgIT09IGRhdGFCeXRlc09mZnNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0RhdGEgYnl0ZXMgZG9lcyBub3QgbWF0Y2ggb2Zmc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBwbGFjZSBkYXRhIGJsb2Nrcy5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TnVtRGF0YUJ5dGVzOyArK2kpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJsb2Nrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhQnl0ZXMgPSBibG9jay5nZXREYXRhQnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBkYXRhQnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQml0cyhkYXRhQnl0ZXNbaV0sIDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlbiwgcGxhY2UgZXJyb3IgY29ycmVjdGlvbiBibG9ja3MuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heE51bUVjQnl0ZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVjQnl0ZXMgPSBibG9jay5nZXRFcnJvckNvcnJlY3Rpb25CeXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGVjQnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQml0cyhlY0J5dGVzW2ldLCA4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudW1Ub3RhbEJ5dGVzICE9PSByZXN1bHQuZ2V0U2l6ZUluQnl0ZXMoKSkgeyAvLyBTaG91bGQgYmUgc2FtZS5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdJbnRlcmxlYXZpbmcgZXJyb3I6ICcgKyBudW1Ub3RhbEJ5dGVzICsgJyBhbmQgJyArXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRTaXplSW5CeXRlcygpICsgJyBkaWZmZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZW5lcmF0ZUVDQnl0ZXMoZGF0YUJ5dGVzLCBudW1FY0J5dGVzSW5CbG9jayAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBudW1EYXRhQnl0ZXMgPSBkYXRhQnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdG9FbmNvZGUgPSBuZXcgSW50MzJBcnJheShudW1EYXRhQnl0ZXMgKyBudW1FY0J5dGVzSW5CbG9jayk7IC8vIGludFtudW1EYXRhQnl0ZXMgKyBudW1FY0J5dGVzSW5CbG9ja11cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRGF0YUJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b0VuY29kZVtpXSA9IGRhdGFCeXRlc1tpXSAmIDB4RkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXcgUmVlZFNvbG9tb25FbmNvZGVyKEdlbmVyaWNHRi5RUl9DT0RFX0ZJRUxEXzI1NikuZW5jb2RlKHRvRW5jb2RlLCBudW1FY0J5dGVzSW5CbG9jayk7XG4gICAgICAgICAgICBjb25zdCBlY0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkobnVtRWNCeXRlc0luQmxvY2spO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FY0J5dGVzSW5CbG9jazsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWNCeXRlc1tpXSA9IC8qKGJ5dGUpICovIHRvRW5jb2RlW251bURhdGFCeXRlcyArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVjQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGVuZCBtb2RlIGluZm8uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwZW5kTW9kZUluZm8obW9kZSwgYml0cykge1xuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKG1vZGUuZ2V0Qml0cygpLCA0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIGxlbmd0aCBpbmZvLiBPbiBzdWNjZXNzLCBzdG9yZSB0aGUgcmVzdWx0IGluIFwiYml0c1wiLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFwcGVuZExlbmd0aEluZm8obnVtTGV0dGVycyAvKmludCovLCB2ZXJzaW9uLCBtb2RlLCBiaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBudW1CaXRzID0gbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbik7XG4gICAgICAgICAgICBpZiAobnVtTGV0dGVycyA+PSAoMSA8PCBudW1CaXRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24obnVtTGV0dGVycyArICcgaXMgYmlnZ2VyIHRoYW4gJyArICgoMSA8PCBudW1CaXRzKSAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW1MZXR0ZXJzLCBudW1CaXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIFwiYnl0ZXNcIiBpbiBcIm1vZGVcIiBtb2RlIChlbmNvZGluZykgaW50byBcImJpdHNcIi4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhcHBlbmRCeXRlcyhjb250ZW50LCBtb2RlLCBiaXRzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgRW5jb2Rlci5hcHBlbmROdW1lcmljQnl0ZXMoY29udGVudCwgYml0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW9kZSQxLkFMUEhBTlVNRVJJQzpcbiAgICAgICAgICAgICAgICAgICAgRW5jb2Rlci5hcHBlbmRBbHBoYW51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlJDEuQllURTpcbiAgICAgICAgICAgICAgICAgICAgRW5jb2Rlci5hcHBlbmQ4Qml0Qnl0ZXMoY29udGVudCwgYml0cywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUkMS5LQU5KSTpcbiAgICAgICAgICAgICAgICAgICAgRW5jb2Rlci5hcHBlbmRLYW5qaUJ5dGVzKGNvbnRlbnQsIGJpdHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCdJbnZhbGlkIG1vZGU6ICcgKyBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0RGlnaXQoc2luZ2xlQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlQ2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgLSA0ODtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaXNEaWdpdChzaW5nbGVDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNuID0gRW5jb2Rlci5nZXREaWdpdChzaW5nbGVDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGNuID49IDAgJiYgY24gPD0gOTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kTnVtZXJpY0J5dGVzKGNvbnRlbnQsIGJpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW0xID0gRW5jb2Rlci5nZXREaWdpdChjb250ZW50LmNoYXJBdChpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSB0aHJlZSBudW1lcmljIGxldHRlcnMgaW4gdGVuIGJpdHMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bTIgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bTMgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW0xICogMTAwICsgbnVtMiAqIDEwICsgbnVtMywgMTApO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSB0d28gbnVtZXJpYyBsZXR0ZXJzIGluIHNldmVuIGJpdHMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bTIgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW0xICogMTAgKyBudW0yLCA3KTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5jb2RlIG9uZSBudW1lcmljIGxldHRlciBpbiBmb3VyIGJpdHMuXG4gICAgICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW0xLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYXBwZW5kQWxwaGFudW1lcmljQnl0ZXMoY29udGVudCwgYml0cykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUxID0gRW5jb2Rlci5nZXRBbHBoYW51bWVyaWNDb2RlKGNvbnRlbnQuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUxID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlMiA9IEVuY29kZXIuZ2V0QWxwaGFudW1lcmljQ29kZShjb250ZW50LmNoYXJDb2RlQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUyID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSB0d28gYWxwaGFudW1lcmljIGxldHRlcnMgaW4gMTEgYml0cy5cbiAgICAgICAgICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGNvZGUxICogNDUgKyBjb2RlMiwgMTEpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgb25lIGFscGhhbnVtZXJpYyBsZXR0ZXIgaW4gc2l4IGJpdHMuXG4gICAgICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhjb2RlMSwgNik7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFwcGVuZDhCaXRCeXRlcyhjb250ZW50LCBiaXRzLCBlbmNvZGluZykge1xuICAgICAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IFN0cmluZ0VuY29kaW5nLmVuY29kZShjb250ZW50LCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAodWVlIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uKHVlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoYiwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aHJvd3MgV3JpdGVyRXhjZXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgYXBwZW5kS2FuamlCeXRlcyhjb250ZW50LCBiaXRzKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmcuZW5jb2RlKGNvbnRlbnQsIENoYXJhY3RlclNldEVDSS5TSklTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh1ZWUgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24odWVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlMSA9IGJ5dGVzW2ldICYgMHhGRjtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlMiA9IGJ5dGVzW2kgKyAxXSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9ICgoYnl0ZTEgPDwgOCkgJiAweEZGRkZGRkZGKSB8IGJ5dGUyO1xuICAgICAgICAgICAgICAgIGxldCBzdWJ0cmFjdGVkID0gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHg4MTQwICYmIGNvZGUgPD0gMHg5ZmZjKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0ZWQgPSBjb2RlIC0gMHg4MTQwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlID49IDB4ZTA0MCAmJiBjb2RlIDw9IDB4ZWJiZikge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdGVkID0gY29kZSAtIDB4YzE0MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YnRyYWN0ZWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb24oJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gKChzdWJ0cmFjdGVkID4+IDgpICogMHhjMCkgKyAoc3VidHJhY3RlZCAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhlbmNvZGVkLCAxMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFwcGVuZEVDSShlY2ksIGJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhNb2RlJDEuRUNJLmdldEJpdHMoKSwgNCk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGNvcnJlY3QgZm9yIHZhbHVlcyB1cCB0byAxMjcsIHdoaWNoIGlzIGFsbCB3ZSBuZWVkIG5vdy5cbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhlY2kuZ2V0VmFsdWUoKSwgOCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlIG9yaWdpbmFsIHRhYmxlIGlzIGRlZmluZWQgaW4gdGhlIHRhYmxlIDUgb2YgSklTWDA1MTA6MjAwNCAocC4xOSkuXG4gICAgRW5jb2Rlci5BTFBIQU5VTUVSSUNfVEFCTEUgPSBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAgICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgICAgIDM2LCAtMSwgLTEsIC0xLCAzNywgMzgsIC0xLCAtMSwgLTEsIC0xLCAzOSwgNDAsIC0xLCA0MSwgNDIsIDQzLFxuICAgICAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCA0NCwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCxcbiAgICAgICAgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgXSk7XG4gICAgRW5jb2Rlci5ERUZBVUxUX0JZVEVfTU9ERV9FTkNPRElORyA9IENoYXJhY3RlclNldEVDSS5VVEY4LmdldE5hbWUoKTsgLy8gXCJJU08tODg1OS0xXCJcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxuICAgICAqL1xuICAgIGNsYXNzIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGFuZCByZW5kZXJzIGEgUVJDb2RlIFNWRyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29udGVudHNcbiAgICAgICAgICogQHBhcmFtIHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSBoZWlnaHRcbiAgICAgICAgICogQHBhcmFtIGhpbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3cml0ZShjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMgPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRm91bmQgZW1wdHkgY29udGVudHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIChmb3JtYXQgIT0gQmFyY29kZUZvcm1hdC5RUl9DT0RFKSB7XG4gICAgICAgICAgICAvLyAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJDYW4gb25seSBlbmNvZGUgUVJfQ09ERSwgYnV0IGdvdCBcIiArIGZvcm1hdClcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDAgfHwgaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1JlcXVlc3RlZCBkaW1lbnNpb25zIGFyZSB0b28gc21hbGw6ICcgKyB3aWR0aCArICd4JyArIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbC5MO1xuICAgICAgICAgICAgbGV0IHF1aWV0Wm9uZSA9IEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIuUVVJRVRfWk9ORV9TSVpFO1xuICAgICAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuRVJST1JfQ09SUkVDVElPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbC5mcm9tU3RyaW5nKGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkVSUk9SX0NPUlJFQ1RJT04pLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5NQVJHSU4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1aWV0Wm9uZSA9IE51bWJlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5NQVJHSU4pLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gRW5jb2Rlci5lbmNvZGUoY29udGVudHMsIGVycm9yQ29ycmVjdGlvbkxldmVsLCBoaW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSZXN1bHQoY29kZSwgd2lkdGgsIGhlaWdodCwgcXVpZXRab25lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVycyB0aGUgcmVzdWx0IGFuZCB0aGVuIGFwcGVuZHMgaXQgdG8gdGhlIERPTS5cbiAgICAgICAgICovXG4gICAgICAgIHdyaXRlVG9Eb20oY29udGFpbmVyRWxlbWVudCwgY29udGVudHMsIHdpZHRoLCBoZWlnaHQsIGhpbnRzID0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250YWluZXJFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMud3JpdGUoY29udGVudHMsIHdpZHRoLCBoZWlnaHQsIGhpbnRzKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJFbGVtZW50KVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgaW5wdXQgbWF0cml4IHVzZXMgMCA9PSB3aGl0ZSwgMSA9PSBibGFjay5cbiAgICAgICAgICogVGhlIG91dHB1dCBtYXRyaXggdXNlcyAwID09IGJsYWNrLCAyNTUgPT0gd2hpdGUgKGkuZS4gYW4gOCBiaXQgZ3JleXNjYWxlIGJpdG1hcCkuXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJSZXN1bHQoY29kZSwgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIHF1aWV0Wm9uZSAvKmludCovKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNvZGUuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnB1dFdpZHRoID0gaW5wdXQuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0SGVpZ2h0ID0gaW5wdXQuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICBjb25zdCBxcldpZHRoID0gaW5wdXRXaWR0aCArIChxdWlldFpvbmUgKiAyKTtcbiAgICAgICAgICAgIGNvbnN0IHFySGVpZ2h0ID0gaW5wdXRIZWlnaHQgKyAocXVpZXRab25lICogMik7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRXaWR0aCA9IE1hdGgubWF4KHdpZHRoLCBxcldpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgcXJIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlwbGUgPSBNYXRoLm1pbihNYXRoLmZsb29yKG91dHB1dFdpZHRoIC8gcXJXaWR0aCksIE1hdGguZmxvb3Iob3V0cHV0SGVpZ2h0IC8gcXJIZWlnaHQpKTtcbiAgICAgICAgICAgIC8vIFBhZGRpbmcgaW5jbHVkZXMgYm90aCB0aGUgcXVpZXQgem9uZSBhbmQgdGhlIGV4dHJhIHdoaXRlIHBpeGVscyB0byBhY2NvbW1vZGF0ZSB0aGUgcmVxdWVzdGVkXG4gICAgICAgICAgICAvLyBkaW1lbnNpb25zLiBGb3IgZXhhbXBsZSwgaWYgaW5wdXQgaXMgMjV4MjUgdGhlIFFSIHdpbGwgYmUgMzN4MzMgaW5jbHVkaW5nIHRoZSBxdWlldCB6b25lLlxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3RlZCBzaXplIGlzIDIwMHgxNjAsIHRoZSBtdWx0aXBsZSB3aWxsIGJlIDQsIGZvciBhIFFSIG9mIDEzMngxMzIuIFRoZXNlIHdpbGxcbiAgICAgICAgICAgIC8vIGhhbmRsZSBhbGwgdGhlIHBhZGRpbmcgZnJvbSAxMDB4MTAwICh0aGUgYWN0dWFsIFFSKSB1cCB0byAyMDB4MTYwLlxuICAgICAgICAgICAgY29uc3QgbGVmdFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRXaWR0aCAtIChpbnB1dFdpZHRoICogbXVsdGlwbGUpKSAvIDIpO1xuICAgICAgICAgICAgY29uc3QgdG9wUGFkZGluZyA9IE1hdGguZmxvb3IoKG91dHB1dEhlaWdodCAtIChpbnB1dEhlaWdodCAqIG11bHRpcGxlKSkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSB0aGlzLmNyZWF0ZVNWR0VsZW1lbnQob3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbnB1dFkgPSAwLCBvdXRwdXRZID0gdG9wUGFkZGluZzsgaW5wdXRZIDwgaW5wdXRIZWlnaHQ7IGlucHV0WSsrLCBvdXRwdXRZICs9IG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGNvbnRlbnRzIG9mIHRoaXMgcm93IG9mIHRoZSBiYXJjb2RlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5wdXRYID0gMCwgb3V0cHV0WCA9IGxlZnRQYWRkaW5nOyBpbnB1dFggPCBpbnB1dFdpZHRoOyBpbnB1dFgrKywgb3V0cHV0WCArPSBtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZ2V0KGlucHV0WCwgaW5wdXRZKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUmVjdEVsZW1lbnQgPSB0aGlzLmNyZWF0ZVN2Z1JlY3RFbGVtZW50KG91dHB1dFgsIG91dHB1dFksIG11bHRpcGxlLCBtdWx0aXBsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmdFbGVtZW50LmFwcGVuZENoaWxkKHN2Z1JlY3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgU1ZHIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB3IFNWRydzIHdpZHRoIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcGFyYW0gaCBTVkcncyBoZWlnaHQgYXR0cmlidXRlXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTVkdFbGVtZW50KHcsIGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMsICdzdmcnKTtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIHcudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gc3ZnRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFNWRyByZWN0IGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB4IEVsZW1lbnQncyB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIHkgRWxlbWVudCdzIHkgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gdyBFbGVtZW50J3Mgd2lkdGggYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSBoIEVsZW1lbnQncyBoZWlnaHQgYXR0cmlidXRlXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTdmdSZWN0RWxlbWVudCh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIuU1ZHX05TLCAncmVjdCcpO1xuICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd5JywgeS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIHcudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyMwMDAwMDAnKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIuUVVJRVRfWk9ORV9TSVpFID0gNDtcbiAgICAvKipcbiAgICAgKiBTVkcgbWFya3VwIE5hbWVTcGFjZVxuICAgICAqL1xuICAgIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIuU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuICAgIC8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cbiAgICAvKipcbiAgICAgKiBUaGlzIG9iamVjdCByZW5kZXJzIGEgUVIgQ29kZSBhcyBhIEJpdE1hdHJpeCAyRCBhcnJheSBvZiBncmV5c2NhbGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBRUkNvZGVXcml0ZXIge1xuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIC8vIHB1YmxpYyBlbmNvZGUoY29udGVudHM6IHN0cmluZywgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LCB3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pOiBCaXRNYXRyaXhcbiAgICAgICAgLy8gICAgIC8qdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiAqLyB7XG4gICAgICAgIC8vICAgcmV0dXJuIGVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBudWxsKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBoaW50cykge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ZvdW5kIGVtcHR5IGNvbnRlbnRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSBCYXJjb2RlRm9ybWF0JDEuUVJfQ09ERSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0NhbiBvbmx5IGVuY29kZSBRUl9DT0RFLCBidXQgZ290ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihgUmVxdWVzdGVkIGRpbWVuc2lvbnMgYXJlIHRvbyBzbWFsbDogJHt3aWR0aH14JHtoZWlnaHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbC5MO1xuICAgICAgICAgICAgbGV0IHF1aWV0Wm9uZSA9IFFSQ29kZVdyaXRlci5RVUlFVF9aT05FX1NJWkU7XG4gICAgICAgICAgICBpZiAoaGludHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGUkMS5FUlJPUl9DT1JSRUNUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsLmZyb21TdHJpbmcoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuRVJST1JfQ09SUkVDVElPTikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVpZXRab25lID0gTnVtYmVyLnBhcnNlSW50KGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLk1BUkdJTikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBFbmNvZGVyLmVuY29kZShjb250ZW50cywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGhpbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBRUkNvZGVXcml0ZXIucmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoLCBoZWlnaHQsIHF1aWV0Wm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBpbnB1dCBtYXRyaXggdXNlcyAwID09IHdoaXRlLCAxID09IGJsYWNrLCB3aGlsZSB0aGUgb3V0cHV0IG1hdHJpeCB1c2VzXG4gICAgICAgIC8vIDAgPT0gYmxhY2ssIDI1NSA9PSB3aGl0ZSAoaS5lLiBhbiA4IGJpdCBncmV5c2NhbGUgYml0bWFwKS5cbiAgICAgICAgc3RhdGljIHJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcXVpZXRab25lIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY29kZS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHFyV2lkdGggPSBpbnB1dFdpZHRoICsgKHF1aWV0Wm9uZSAqIDIpO1xuICAgICAgICAgICAgY29uc3QgcXJIZWlnaHQgPSBpbnB1dEhlaWdodCArIChxdWlldFpvbmUgKiAyKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHFyV2lkdGgpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBxckhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBtdWx0aXBsZSA9IE1hdGgubWluKE1hdGguZmxvb3Iob3V0cHV0V2lkdGggLyBxcldpZHRoKSwgTWF0aC5mbG9vcihvdXRwdXRIZWlnaHQgLyBxckhlaWdodCkpO1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpbmNsdWRlcyBib3RoIHRoZSBxdWlldCB6b25lIGFuZCB0aGUgZXh0cmEgd2hpdGUgcGl4ZWxzIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1ZXN0ZWRcbiAgICAgICAgICAgIC8vIGRpbWVuc2lvbnMuIEZvciBleGFtcGxlLCBpZiBpbnB1dCBpcyAyNXgyNSB0aGUgUVIgd2lsbCBiZSAzM3gzMyBpbmNsdWRpbmcgdGhlIHF1aWV0IHpvbmUuXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdGVkIHNpemUgaXMgMjAweDE2MCwgdGhlIG11bHRpcGxlIHdpbGwgYmUgNCwgZm9yIGEgUVIgb2YgMTMyeDEzMi4gVGhlc2Ugd2lsbFxuICAgICAgICAgICAgLy8gaGFuZGxlIGFsbCB0aGUgcGFkZGluZyBmcm9tIDEwMHgxMDAgKHRoZSBhY3R1YWwgUVIpIHVwIHRvIDIwMHgxNjAuXG4gICAgICAgICAgICBjb25zdCBsZWZ0UGFkZGluZyA9IE1hdGguZmxvb3IoKG91dHB1dFdpZHRoIC0gKGlucHV0V2lkdGggKiBtdWx0aXBsZSkpIC8gMik7XG4gICAgICAgICAgICBjb25zdCB0b3BQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDIpO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gbmV3IEJpdE1hdHJpeChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0WSA9IDAsIG91dHB1dFkgPSB0b3BQYWRkaW5nOyBpbnB1dFkgPCBpbnB1dEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgY29udGVudHMgb2YgdGhpcyByb3cgb2YgdGhlIGJhcmNvZGVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnB1dFggPSAwLCBvdXRwdXRYID0gbGVmdFBhZGRpbmc7IGlucHV0WCA8IGlucHV0V2lkdGg7IGlucHV0WCsrLCBvdXRwdXRYICs9IG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXQoaW5wdXRYLCBpbnB1dFkpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0UmVnaW9uKG91dHB1dFgsIG91dHB1dFksIG11bHRpcGxlLCBtdWx0aXBsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFFSQ29kZVdyaXRlci5RVUlFVF9aT05FX1NJWkUgPSA0O1xuXG4gICAgLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3J5IGNsYXNzIHdoaWNoIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSBXcml0ZXIgc3ViY2xhc3MgZm9yIHRoZSBCYXJjb2RlRm9ybWF0XG4gICAgICogcmVxdWVzdGVkIGFuZCBlbmNvZGVzIHRoZSBiYXJjb2RlIHdpdGggdGhlIHN1cHBsaWVkIGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcbiAgICAgKi9cbiAgICBjbGFzcyBNdWx0aUZvcm1hdFdyaXRlciB7XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgLy8gcHVibGljIGVuY29kZShjb250ZW50czogc3RyaW5nLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBudW1iZXIgLyppbnQqLyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBudW1iZXIgLyppbnQqLyk6IEJpdE1hdHJpeCAvKnRocm93cyBXcml0ZXJFeGNlcHRpb24gKi8ge1xuICAgICAgICAvLyAgIHJldHVybiBlbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgbnVsbClcbiAgICAgICAgLy8gfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGVuY29kZShjb250ZW50cywgZm9ybWF0LCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgaGludHMpIHtcbiAgICAgICAgICAgIGxldCB3cml0ZXI7XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5FQU5fODpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBFQU44V3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LlVQQ19FOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IFVQQ0VXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuRUFOXzEzOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IEVBTjEzV3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LlVQQ19BOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IFVQQ0FXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIEJhcmNvZGVGb3JtYXQkMS5RUl9DT0RFOlxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIgPSBuZXcgUVJDb2RlV3JpdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RFXzM5OlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGUzOVdyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RFXzkzOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGU5M1dyaXRlcigpXG4gICAgICAgICAgICAgICAgLy8gICBicmVha1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RFXzEyODpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBDb2RlMTI4V3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LklURjpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBJVEZXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuUERGXzQxNzpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBQREY0MTdXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuQ09EQUJBUjpcbiAgICAgICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBDb2RhQmFyV3JpdGVyKClcbiAgICAgICAgICAgICAgICAvLyAgIGJyZWFrXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkRBVEFfTUFUUklYOlxuICAgICAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IERhdGFNYXRyaXhXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuQVpURUM6XG4gICAgICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQXp0ZWNXcml0ZXIoKVxuICAgICAgICAgICAgICAgIC8vICAgYnJlYWtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdObyBlbmNvZGVyIGF2YWlsYWJsZSBmb3IgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5lbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgaGludHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIG9iamVjdCBleHRlbmRzIEx1bWluYW5jZVNvdXJjZSBhcm91bmQgYW4gYXJyYXkgb2YgWVVWIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgY2FtZXJhIGRyaXZlcixcbiAgICAgKiB3aXRoIHRoZSBvcHRpb24gdG8gY3JvcCB0byBhIHJlY3RhbmdsZSB3aXRoaW4gdGhlIGZ1bGwgZGF0YS4gVGhpcyBjYW4gYmUgdXNlZCB0byBleGNsdWRlXG4gICAgICogc3VwZXJmbHVvdXMgcGl4ZWxzIGFyb3VuZCB0aGUgcGVyaW1ldGVyIGFuZCBzcGVlZCB1cCBkZWNvZGluZy5cbiAgICAgKlxuICAgICAqIEl0IHdvcmtzIGZvciBhbnkgcGl4ZWwgZm9ybWF0IHdoZXJlIHRoZSBZIGNoYW5uZWwgaXMgcGxhbmFyIGFuZCBhcHBlYXJzIGZpcnN0LCBpbmNsdWRpbmdcbiAgICAgKiBZQ2JDcl80MjBfU1AgYW5kIFlDYkNyXzQyMl9TUC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXG4gICAgICovXG4gICAgY2xhc3MgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlIGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoeXV2RGF0YSwgZGF0YVdpZHRoIC8qaW50Ki8sIGRhdGFIZWlnaHQgLyppbnQqLywgbGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIHJldmVyc2VIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMueXV2RGF0YSA9IHl1dkRhdGE7XG4gICAgICAgICAgICB0aGlzLmRhdGFXaWR0aCA9IGRhdGFXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZGF0YUhlaWdodCA9IGRhdGFIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gZGF0YVdpZHRoIHx8IHRvcCArIGhlaWdodCA+IGRhdGFIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdDcm9wIHJlY3RhbmdsZSBkb2VzIG5vdCBmaXQgd2l0aGluIGltYWdlIGRhdGEuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2ZXJzZUhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVyc2VIb3Jpem9udGFsKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0Um93KHkgLyppbnQqLywgcm93KSB7XG4gICAgICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBpZiAocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdy5sZW5ndGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoeSArIHRoaXMudG9wKSAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xuICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLnl1dkRhdGEsIG9mZnNldCwgcm93LCAwLCB3aWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgZ2V0TWF0cml4KCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBhc2tzIGZvciB0aGUgZW50aXJlIHVuZGVybHlpbmcgaW1hZ2UsIHNhdmUgdGhlIGNvcHkgYW5kIGdpdmUgdGhlbSB0aGVcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsIGRhdGEuIFRoZSBkb2NzIHNwZWNpZmljYWxseSB3YXJuIHRoYXQgcmVzdWx0Lmxlbmd0aCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5kYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueXV2RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBVaW50OENsYW1wZWRBcnJheShhcmVhKTtcbiAgICAgICAgICAgIGxldCBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgd2lkdGggbWF0Y2hlcyB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgdW5kZXJseWluZyBkYXRhLCBwZXJmb3JtIGEgc2luZ2xlIGNvcHkuXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IHRoaXMuZGF0YVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLnl1dkRhdGEsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIDAsIGFyZWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY29weSBvbmUgY3JvcHBlZCByb3cgYXQgYSB0aW1lLlxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgICAgICAgICAgICBTeXN0ZW0uYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgaW5wdXRPZmZzZXQsIG1hdHJpeCwgb3V0cHV0T2Zmc2V0LCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgaXNDcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLypAT3ZlcnJpZGUqL1xuICAgICAgICBjcm9wKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSh0aGlzLnl1dkRhdGEsIHRoaXMuZGF0YVdpZHRoLCB0aGlzLmRhdGFIZWlnaHQsIHRoaXMubGVmdCArIGxlZnQsIHRoaXMudG9wICsgdG9wLCB3aWR0aCwgaGVpZ2h0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyVGh1bWJuYWlsKCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVscyA9IG5ldyBJbnQzMkFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IHl1diA9IHRoaXMueXV2RGF0YTtcbiAgICAgICAgICAgIGxldCBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0T2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmV5ID0geXV2W2lucHV0T2Zmc2V0ICsgeCAqIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SXSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1tvdXRwdXRPZmZzZXQgKyB4XSA9IDB4RkYwMDAwMDAgfCAoZ3JleSAqIDB4MDAwMTAxMDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dE9mZnNldCArPSB0aGlzLmRhdGFXaWR0aCAqIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBpeGVscztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB3aWR0aCBvZiBpbWFnZSBmcm9tIHtAbGluayAjcmVuZGVyVGh1bWJuYWlsKCl9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaHVtYm5haWxXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBoZWlnaHQgb2YgaW1hZ2UgZnJvbSB7QGxpbmsgI3JlbmRlclRodW1ibmFpbCgpfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGh1bWJuYWlsSGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcbiAgICAgICAgfVxuICAgICAgICByZXZlcnNlSG9yaXpvbnRhbCh3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgY29uc3QgeXV2RGF0YSA9IHRoaXMueXV2RGF0YTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwLCByb3dTdGFydCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7IHkgPCBoZWlnaHQ7IHkrKywgcm93U3RhcnQgKz0gdGhpcy5kYXRhV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGUgPSByb3dTdGFydCArIHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4MSA9IHJvd1N0YXJ0LCB4MiA9IHJvd1N0YXJ0ICsgd2lkdGggLSAxOyB4MSA8IG1pZGRsZTsgeDErKywgeDItLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0geXV2RGF0YVt4MV07XG4gICAgICAgICAgICAgICAgICAgIHl1dkRhdGFbeDFdID0geXV2RGF0YVt4Ml07XG4gICAgICAgICAgICAgICAgICAgIHl1dkRhdGFbeDJdID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52ZXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUiA9IDI7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBoZWxwIGRlY29kZSBpbWFnZXMgZnJvbSBmaWxlcyB3aGljaCBhcnJpdmUgYXMgUkdCIGRhdGEgZnJvbVxuICAgICAqIGFuIEFSR0IgcGl4ZWwgYXJyYXkuIEl0IGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24uXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxuICAgICAqIEBhdXRob3IgQmV0YW1pbm9zXG4gICAgICovXG4gICAgY2xhc3MgUkdCTHVtaW5hbmNlU291cmNlIGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIHtcbiAgICAgICAgY29uc3RydWN0b3IobHVtaW5hbmNlcywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIGRhdGFXaWR0aCAvKmludCovLCBkYXRhSGVpZ2h0IC8qaW50Ki8sIGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8pIHtcbiAgICAgICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5kYXRhV2lkdGggPSBkYXRhV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmRhdGFIZWlnaHQgPSBkYXRhSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICAgICAgaWYgKGx1bWluYW5jZXMuQllURVNfUEVSX0VMRU1FTlQgPT09IDQpIHsgLy8gSW50MzJBcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBsdW1pbmFuY2VzVWludDhBcnJheSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShzaXplKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBzaXplOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IGx1bWluYW5jZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IChwaXhlbCA+PiAxNikgJiAweGZmOyAvLyByZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZzIgPSAocGl4ZWwgPj4gNykgJiAweDFmZTsgLy8gMiAqIGdyZWVuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBwaXhlbCAmIDB4ZmY7IC8vIGJsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGdyZWVuLWZhdm91cmluZyBhdmVyYWdlIGNoZWFwbHlcbiAgICAgICAgICAgICAgICAgICAgbHVtaW5hbmNlc1VpbnQ4QXJyYXlbb2Zmc2V0XSA9IC8qKGJ5dGUpICovICgociArIGcyICsgYikgLyA0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubHVtaW5hbmNlcyA9IGx1bWluYW5jZXNVaW50OEFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sdW1pbmFuY2VzID0gbHVtaW5hbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRhdGFXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkYXRhSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICsgd2lkdGggPiB0aGlzLmRhdGFXaWR0aCB8fCB0aGlzLnRvcCArIGhlaWdodCA+IHRoaXMuZGF0YUhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nyb3AgcmVjdGFuZ2xlIGRvZXMgbm90IGZpdCB3aXRoaW4gaW1hZ2UgZGF0YS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldFJvdyh5IC8qaW50Ki8sIHJvdykge1xuICAgICAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1JlcXVlc3RlZCByb3cgaXMgb3V0c2lkZSB0aGUgaW1hZ2U6ICcgKyB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gbnVsbCB8fCByb3cgPT09IHVuZGVmaW5lZCB8fCByb3cubGVuZ3RoIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHkgKyB0aGlzLnRvcCkgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcbiAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy5sdW1pbmFuY2VzLCBvZmZzZXQsIHJvdywgMCwgd2lkdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGdldE1hdHJpeCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjYWxsZXIgYXNrcyBmb3IgdGhlIGVudGlyZSB1bmRlcmx5aW5nIGltYWdlLCBzYXZlIHRoZSBjb3B5IGFuZCBnaXZlIHRoZW0gdGhlXG4gICAgICAgICAgICAvLyBvcmlnaW5hbCBkYXRhLiBUaGUgZG9jcyBzcGVjaWZpY2FsbHkgd2FybiB0aGF0IHJlc3VsdC5sZW5ndGggbXVzdCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLmRhdGFXaWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuZGF0YUhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmx1bWluYW5jZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYXJlYSk7XG4gICAgICAgICAgICBsZXQgaW5wdXRPZmZzZXQgPSB0aGlzLnRvcCAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xuICAgICAgICAgICAgLy8gSWYgdGhlIHdpZHRoIG1hdGNoZXMgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIHVuZGVybHlpbmcgZGF0YSwgcGVyZm9ybSBhIHNpbmdsZSBjb3B5LlxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLmRhdGFXaWR0aCkge1xuICAgICAgICAgICAgICAgIFN5c3RlbS5hcnJheWNvcHkodGhpcy5sdW1pbmFuY2VzLCBpbnB1dE9mZnNldCwgbWF0cml4LCAwLCBhcmVhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNvcHkgb25lIGNyb3BwZWQgcm93IGF0IGEgdGltZS5cbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRPZmZzZXQgPSB5ICogd2lkdGg7XG4gICAgICAgICAgICAgICAgU3lzdGVtLmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIG91dHB1dE9mZnNldCwgd2lkdGgpO1xuICAgICAgICAgICAgICAgIGlucHV0T2Zmc2V0ICs9IHRoaXMuZGF0YVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgICAgfVxuICAgICAgICAvKkBPdmVycmlkZSovXG4gICAgICAgIGlzQ3JvcFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qQE92ZXJyaWRlKi9cbiAgICAgICAgY3JvcChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSR0JMdW1pbmFuY2VTb3VyY2UodGhpcy5sdW1pbmFuY2VzLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLmRhdGFXaWR0aCwgdGhpcy5kYXRhSGVpZ2h0LCB0aGlzLmxlZnQgKyBsZWZ0LCB0aGlzLnRvcCArIHRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaW52ZXJ0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1c3QgdG8gbWFrZSBhIHNob3J0Y3V0IGJldHdlZW4gSmF2YSBjb2RlIGFuZCBUUyBjb2RlLlxuICAgICAqL1xuICAgIGNsYXNzIENoYXJzZXQgZXh0ZW5kcyBDaGFyYWN0ZXJTZXRFQ0kge1xuICAgICAgICBzdGF0aWMgZm9yTmFtZShuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGFyYWN0ZXJTZXRFQ0lCeU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKdXN0IHRvIG1ha2UgYSBzaG9ydGN1dCBiZXR3ZWVuIEphdmEgY29kZSBhbmQgVFMgY29kZS5cbiAgICAgKi9cbiAgICBjbGFzcyBTdGFuZGFyZENoYXJzZXRzIHtcbiAgICB9XG4gICAgU3RhbmRhcmRDaGFyc2V0cy5JU09fODg1OV8xID0gQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMTtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEF6dGVjIDJEIGNvZGUgcmVwcmVzZW50YXRpb25cbiAgICAgKlxuICAgICAqIEBhdXRob3IgUnVzdGFtIEFiZHVsbGFldlxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgQXp0ZWNDb2RlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIGNvbXBhY3QgaW5zdGVhZCBvZiBmdWxsIG1vZGVcbiAgICAgICAgICovXG4gICAgICAgIGlzQ29tcGFjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q29tcGFjdChjb21wYWN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHNpemUgaW4gcGl4ZWxzICh3aWR0aCBhbmQgaGVpZ2h0KVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2l6ZShzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIG51bWJlciBvZiBsZXZlbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVycygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVycztcbiAgICAgICAgfVxuICAgICAgICBzZXRMYXllcnMobGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmxheWVycyA9IGxheWVycztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHNcbiAgICAgICAgICovXG4gICAgICAgIGdldENvZGVXb3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGVXb3JkcztcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2RlV29yZHMoY29kZVdvcmRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVXb3JkcyA9IGNvZGVXb3JkcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB0aGUgc3ltYm9sIGltYWdlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXRyaXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TWF0cml4KG1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzcyBDb2xsZWN0aW9ucyB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2luZ2xldG9uTGlzdChUKSBtZXRob2QgaXMgdXNlZCB0byByZXR1cm4gYW4gaW1tdXRhYmxlIGxpc3QgY29udGFpbmluZyBvbmx5IHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIHNpbmdsZXRvbkxpc3QoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFtpdGVtXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbihDb2xsZWN0aW9uPD8gZXh0ZW5kcyBUPiwgQ29tcGFyYXRvcjw/IHN1cGVyIFQ+KSBtZXRob2QgaXMgdXNlZCB0byByZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCBvZiB0aGUgZ2l2ZW4gY29sbGVjdGlvbiwgYWNjb3JkaW5nIHRvIHRoZSBvcmRlciBpbmR1Y2VkIGJ5IHRoZSBzcGVjaWZpZWQgY29tcGFyYXRvci5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBtaW4oY29sbGVjdGlvbiwgY29tcGFyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc29ydChjb21wYXJhdG9yKVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIGNsYXNzIFRva2VuIHtcbiAgICAgICAgY29uc3RydWN0b3IocHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICBnZXRQcmV2aW91cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAqXG4gICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgKlxuICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAqXG4gICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICovXG4gICAgLypmaW5hbCovIGNsYXNzIFNpbXBsZVRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICAgICAgICBjb25zdHJ1Y3RvcihwcmV2aW91cywgdmFsdWUsIGJpdENvdW50KSB7XG4gICAgICAgICAgICBzdXBlcihwcmV2aW91cyk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmJpdENvdW50ID0gYml0Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBPdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kVG8oYml0QXJyYXksIHRleHQpIHtcbiAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHModGhpcy52YWx1ZSwgdGhpcy5iaXRDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKHZhbHVlLCBiaXRDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVUb2tlbih0aGlzLCB2YWx1ZSwgYml0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEJpbmFyeVNoaWZ0KHN0YXJ0LCBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIG5vLW9wIGNhbid0IGJpbmFyeSBzaGlmdCBhIHNpbXBsZSB0b2tlblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZGRCaW5hcnlTaGlmdCBvbiBTaW1wbGVUb2tlbiwgdGhpcyBzaW1wbHkgcmV0dXJucyBhIGNvcHkgb2YgdGhpcyB0b2tlbicpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVUb2tlbih0aGlzLCBzdGFydCwgYnl0ZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgJiAoKDEgPDwgdGhpcy5iaXRDb3VudCkgLSAxKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDEgPDwgdGhpcy5iaXRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiAnPCcgKyBJbnRlZ2VyLnRvQmluYXJ5U3RyaW5nKHZhbHVlIHwgKDEgPDwgdGhpcy5iaXRDb3VudCkpLnN1YnN0cmluZygxKSArICc+JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBCaW5hcnlTaGlmdFRva2VuIGV4dGVuZHMgU2ltcGxlVG9rZW4ge1xuICAgICAgICBjb25zdHJ1Y3RvcihwcmV2aW91cywgYmluYXJ5U2hpZnRTdGFydCwgYmluYXJ5U2hpZnRCeXRlQ291bnQpIHtcbiAgICAgICAgICAgIHN1cGVyKHByZXZpb3VzLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5U2hpZnRTdGFydCA9IGJpbmFyeVNoaWZ0U3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID0gYmluYXJ5U2hpZnRCeXRlQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBPdmVycmlkZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kVG8oYml0QXJyYXksIHRleHQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgKGkgPT09IDMxICYmIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPD0gNjIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgYSBoZWFkZXIgYmVmb3JlIHRoZSBmaXJzdCBjaGFyYWN0ZXIsIGFuZCBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyIDMxIHdoZW4gdGhlIHRvdGFsIGJ5dGUgY29kZSBpcyA8PSA2MlxuICAgICAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKDMxLCA1KTsgLy8gQklOQVJZX1NISUZUXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gNjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdEFycmF5LmFwcGVuZEJpdHModGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCAtIDMxLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSA8PSBiaW5hcnlTaGlmdEJ5dGVDb2RlIDw9IDYyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKE1hdGgubWluKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQsIDMxKSwgNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzMiA8PSBiaW5hcnlTaGlmdENvdW50IDw9IDYyIGFuZCBpID09IDMxXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRBcnJheS5hcHBlbmRCaXRzKHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgLSAzMSwgNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYml0QXJyYXkuYXBwZW5kQml0cyh0ZXh0W3RoaXMuYmluYXJ5U2hpZnRTdGFydCArIGldLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRCaW5hcnlTaGlmdChzdGFydCwgYnl0ZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBpbnQgYml0Q291bnQgPSAoYnl0ZUNvdW50ICogOCkgKyAoYnl0ZUNvdW50IDw9IDMxID8gMTAgOiBieXRlQ291bnQgPD0gNjIgPyAyMCA6IDIxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5U2hpZnRUb2tlbih0aGlzLCBzdGFydCwgYnl0ZUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQE92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAnPCcgKyB0aGlzLmJpbmFyeVNoaWZ0U3RhcnQgKyAnOjonICsgKHRoaXMuYmluYXJ5U2hpZnRTdGFydCArIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgLSAxKSArICc+JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEJpbmFyeVNoaWZ0KHRva2VuLCBzdGFydCwgYnl0ZUNvdW50KSB7XG4gICAgICAgIC8vIGludCBiaXRDb3VudCA9IChieXRlQ291bnQgKiA4KSArIChieXRlQ291bnQgPD0gMzEgPyAxMCA6IGJ5dGVDb3VudCA8PSA2MiA/IDIwIDogMjEpO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeVNoaWZ0VG9rZW4odG9rZW4sIHN0YXJ0LCBieXRlQ291bnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGQodG9rZW4sIHZhbHVlLCBiaXRDb3VudCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVRva2VuKHRva2VuLCB2YWx1ZSwgYml0Q291bnQpO1xuICAgIH1cblxuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX05BTUVTID0gW1xuICAgICAgICAnVVBQRVInLFxuICAgICAgICAnTE9XRVInLFxuICAgICAgICAnRElHSVQnLFxuICAgICAgICAnTUlYRUQnLFxuICAgICAgICAnUFVOQ1QnXG4gICAgXTtcbiAgICBjb25zdCAvKmZpbmFsKi8gTU9ERV9VUFBFUiA9IDA7IC8vIDUgYml0c1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX0xPV0VSID0gMTsgLy8gNSBiaXRzXG4gICAgY29uc3QgLypmaW5hbCovIE1PREVfRElHSVQgPSAyOyAvLyA0IGJpdHNcbiAgICBjb25zdCAvKmZpbmFsKi8gTU9ERV9NSVhFRCA9IDM7IC8vIDUgYml0c1xuICAgIGNvbnN0IC8qZmluYWwqLyBNT0RFX1BVTkNUID0gNDsgLy8gNSBiaXRzXG4gICAgY29uc3QgRU1QVFlfVE9LRU4gPSBuZXcgU2ltcGxlVG9rZW4obnVsbCwgMCwgMCk7XG5cbiAgICAvLyBUaGUgTGF0Y2ggVGFibGUgc2hvd3MsIGZvciBlYWNoIHBhaXIgb2YgTW9kZXMsIHRoZSBvcHRpbWFsIG1ldGhvZCBmb3JcbiAgICAvLyBnZXR0aW5nIGZyb20gb25lIG1vZGUgdG8gYW5vdGhlci4gIEluIHRoZSB3b3JzdCBwb3NzaWJsZSBjYXNlLCB0aGlzIGNhblxuICAgIC8vIGJlIHVwIHRvIDE0IGJpdHMuICBJbiB0aGUgYmVzdCBwb3NzaWJsZSBjYXNlLCB3ZSBhcmUgYWxyZWFkeSB0aGVyZSFcbiAgICAvLyBUaGUgaGlnaCBoYWxmLXdvcmQgb2YgZWFjaCBlbnRyeSBnaXZlcyB0aGUgbnVtYmVyIG9mIGJpdHMuXG4gICAgLy8gVGhlIGxvdyBoYWxmLXdvcmQgb2YgZWFjaCBlbnRyeSBhcmUgdGhlIGFjdHVhbCBiaXRzIG5lY2Vzc2FyeSB0byBjaGFuZ2VcbiAgICBjb25zdCBMQVRDSF9UQUJMRSA9IFtcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMwLFxuICAgICAgICAgICAgKDUgPDwgMTYpICsgMjksXG4gICAgICAgICAgICAoMTAgPDwgMTYpICsgKDI5IDw8IDUpICsgMzAgLy8gVVBQRVIgLT4gTUlYRUQgLT4gUFVOQ1RcbiAgICAgICAgXSksXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgICAgICAoOSA8PCAxNikgKyAoMzAgPDwgNCkgKyAxNCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAzMCxcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDI5LFxuICAgICAgICAgICAgKDEwIDw8IDE2KSArICgyOSA8PCA1KSArIDMwIC8vIExPV0VSIC0+IE1JWEVEIC0+IFBVTkNUXG4gICAgICAgIF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgKDQgPDwgMTYpICsgMTQsXG4gICAgICAgICAgICAoOSA8PCAxNikgKyAoMTQgPDwgNSkgKyAyOCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAoOSA8PCAxNikgKyAoMTQgPDwgNSkgKyAyOSxcbiAgICAgICAgICAgICgxNCA8PCAxNikgKyAoMTQgPDwgMTApICsgKDI5IDw8IDUpICsgMzBcbiAgICAgICAgICAgIC8vIERJR0lUIC0+IFVQUEVSIC0+IE1JWEVEIC0+IFBVTkNUXG4gICAgICAgIF0pLFxuICAgICAgICBJbnQzMkFycmF5LmZyb20oW1xuICAgICAgICAgICAgKDUgPDwgMTYpICsgMjksXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAyOCxcbiAgICAgICAgICAgICgxMCA8PCAxNikgKyAoMjkgPDwgNSkgKyAzMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAoNSA8PCAxNikgKyAzMCAvLyBNSVhFRCAtPiBQVU5DVFxuICAgICAgICBdKSxcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgICAgICg1IDw8IDE2KSArIDMxLFxuICAgICAgICAgICAgKDEwIDw8IDE2KSArICgzMSA8PCA1KSArIDI4LFxuICAgICAgICAgICAgKDEwIDw8IDE2KSArICgzMSA8PCA1KSArIDMwLFxuICAgICAgICAgICAgKDEwIDw8IDE2KSArICgzMSA8PCA1KSArIDI5LFxuICAgICAgICAgICAgMFxuICAgICAgICBdKVxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBzdGF0aWNfU0hJRlRfVEFCTEUoU0hJRlRfVEFCTEUpIHtcbiAgICAgICAgZm9yIChsZXQgdGFibGUgLypJbnQzMkFycmF5Ki8gb2YgU0hJRlRfVEFCTEUpIHtcbiAgICAgICAgICAgIEFycmF5cy5maWxsKHRhYmxlLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9VUFBFUl1bTU9ERV9QVU5DVF0gPSAwO1xuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX0xPV0VSXVtNT0RFX1BVTkNUXSA9IDA7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfTE9XRVJdW01PREVfVVBQRVJdID0gMjg7XG4gICAgICAgIFNISUZUX1RBQkxFW01PREVfTUlYRURdW01PREVfUFVOQ1RdID0gMDtcbiAgICAgICAgU0hJRlRfVEFCTEVbTU9ERV9ESUdJVF1bTU9ERV9QVU5DVF0gPSAwO1xuICAgICAgICBTSElGVF9UQUJMRVtNT0RFX0RJR0lUXVtNT0RFX1VQUEVSXSA9IDE1O1xuICAgICAgICByZXR1cm4gU0hJRlRfVEFCTEU7XG4gICAgfVxuICAgIGNvbnN0IC8qZmluYWwqLyBTSElGVF9UQUJMRSA9IHN0YXRpY19TSElGVF9UQUJMRShBcnJheXMuY3JlYXRlSW50MzJBcnJheSg2LCA2KSk7IC8vIG1vZGUgc2hpZnQgY29kZXMsIHBlciB0YWJsZVxuXG4gICAgLypcbiAgICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTdGF0ZSByZXByZXNlbnRzIGFsbCBpbmZvcm1hdGlvbiBhYm91dCBhIHNlcXVlbmNlIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aGUgY3VycmVudCBvdXRwdXQuXG4gICAgICogTm90ZSB0aGF0IGEgc3RhdGUgaXMgaW1tdXRhYmxlLlxuICAgICAqL1xuICAgIC8qZmluYWwqLyBjbGFzcyBTdGF0ZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRva2VuLCBtb2RlLCBiaW5hcnlCeXRlcywgYml0Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID0gYmluYXJ5Qnl0ZXM7XG4gICAgICAgICAgICB0aGlzLmJpdENvdW50ID0gYml0Q291bnQ7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgbWF0Y2ggdGhlIHRva2VuXG4gICAgICAgICAgICAvLyBpbnQgYmluYXJ5U2hpZnRCaXRDb3VudCA9IChiaW5hcnlTaGlmdEJ5dGVDb3VudCAqIDgpICtcbiAgICAgICAgICAgIC8vICAgIChiaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMCA/IDAgOlxuICAgICAgICAgICAgLy8gICAgIGJpbmFyeVNoaWZ0Qnl0ZUNvdW50IDw9IDMxID8gMTAgOlxuICAgICAgICAgICAgLy8gICAgIGJpbmFyeVNoaWZ0Qnl0ZUNvdW50IDw9IDYyID8gMjAgOiAyMSk7XG4gICAgICAgICAgICAvLyBhc3NlcnQgdGhpcy5iaXRDb3VudCA9PT0gdG9rZW4uZ2V0VG90YWxCaXRDb3VudCgpICsgYmluYXJ5U2hpZnRCaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBnZXRNb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRUb2tlbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGdldEJpbmFyeVNoaWZ0Qnl0ZUNvdW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Qml0Q291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RhdGUgcmVwcmVzZW50aW5nIHRoaXMgc3RhdGUgd2l0aCBhIGxhdGNoIHRvIGEgKG5vdFxuICAgICAgICAvLyBuZWNlc3NhcnkgZGlmZmVyZW50KSBtb2RlLCBhbmQgdGhlbiBhIGNvZGUuXG4gICAgICAgIGxhdGNoQW5kQXBwZW5kKG1vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQgYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDA7XG4gICAgICAgICAgICBsZXQgYml0Q291bnQgPSB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgbGV0IHRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIGlmIChtb2RlICE9PSB0aGlzLm1vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF0Y2ggPSBMQVRDSF9UQUJMRVt0aGlzLm1vZGVdW21vZGVdO1xuICAgICAgICAgICAgICAgIHRva2VuID0gYWRkKHRva2VuLCBsYXRjaCAmIDB4ZmZmZiwgbGF0Y2ggPj4gMTYpO1xuICAgICAgICAgICAgICAgIGJpdENvdW50ICs9IGxhdGNoID4+IDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxhdGNoTW9kZUJpdENvdW50ID0gbW9kZSA9PT0gTU9ERV9ESUdJVCA/IDQgOiA1O1xuICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIHZhbHVlLCBsYXRjaE1vZGVCaXRDb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YXRlKHRva2VuLCBtb2RlLCAwLCBiaXRDb3VudCArIGxhdGNoTW9kZUJpdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RhdGUgcmVwcmVzZW50aW5nIHRoaXMgc3RhdGUsIHdpdGggYSB0ZW1wb3Jhcnkgc2hpZnRcbiAgICAgICAgLy8gdG8gYSBkaWZmZXJlbnQgbW9kZSB0byBvdXRwdXQgYSBzaW5nbGUgdmFsdWUuXG4gICAgICAgIHNoaWZ0QW5kQXBwZW5kKG1vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQgYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDAgJiYgdGhpcy5tb2RlICE9PSBtb2RlO1xuICAgICAgICAgICAgbGV0IHRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIGxldCB0aGlzTW9kZUJpdENvdW50ID0gdGhpcy5tb2RlID09PSBNT0RFX0RJR0lUID8gNCA6IDU7XG4gICAgICAgICAgICAvLyBTaGlmdHMgZXhpc3Qgb25seSB0byBVUFBFUiBhbmQgUFVOQ1QsIGJvdGggd2l0aCB0b2tlbnMgc2l6ZSA1LlxuICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIFNISUZUX1RBQkxFW3RoaXMubW9kZV1bbW9kZV0sIHRoaXNNb2RlQml0Q291bnQpO1xuICAgICAgICAgICAgdG9rZW4gPSBhZGQodG9rZW4sIHZhbHVlLCA1KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGUodG9rZW4sIHRoaXMubW9kZSwgMCwgdGhpcy5iaXRDb3VudCArIHRoaXNNb2RlQml0Q291bnQgKyA1KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RhdGUgcmVwcmVzZW50aW5nIHRoaXMgc3RhdGUsIGJ1dCBhbiBhZGRpdGlvbmFsIGNoYXJhY3RlclxuICAgICAgICAvLyBvdXRwdXQgaW4gQmluYXJ5IFNoaWZ0IG1vZGUuXG4gICAgICAgIGFkZEJpbmFyeVNoaWZ0Q2hhcihpbmRleCkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIGxldCBtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgICAgICAgbGV0IGJpdENvdW50ID0gdGhpcy5iaXRDb3VudDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09IE1PREVfUFVOQ1QgfHwgdGhpcy5tb2RlID09PSBNT0RFX0RJR0lUKSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IGJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwO1xuICAgICAgICAgICAgICAgIGxldCBsYXRjaCA9IExBVENIX1RBQkxFW21vZGVdW01PREVfVVBQRVJdO1xuICAgICAgICAgICAgICAgIHRva2VuID0gYWRkKHRva2VuLCBsYXRjaCAmIDB4ZmZmZiwgbGF0Y2ggPj4gMTYpO1xuICAgICAgICAgICAgICAgIGJpdENvdW50ICs9IGxhdGNoID4+IDE2O1xuICAgICAgICAgICAgICAgIG1vZGUgPSBNT0RFX1VQUEVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlbHRhQml0Q291bnQgPSB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwIHx8IHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgPT09IDMxXG4gICAgICAgICAgICAgICAgPyAxOFxuICAgICAgICAgICAgICAgIDogdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gNjJcbiAgICAgICAgICAgICAgICAgICAgPyA5XG4gICAgICAgICAgICAgICAgICAgIDogODtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgU3RhdGUodG9rZW4sIG1vZGUsIHRoaXMuYmluYXJ5U2hpZnRCeXRlQ291bnQgKyAxLCBiaXRDb3VudCArIGRlbHRhQml0Q291bnQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5iaW5hcnlTaGlmdEJ5dGVDb3VudCA9PT0gMjA0NyArIDMxKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHN0cmluZyBpcyBhcyBsb25nIGFzIGl0J3MgYWxsb3dlZCB0byBiZS4gIFdlIHNob3VsZCBlbmQgaXQuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmVuZEJpbmFyeVNoaWZ0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgc3RhdGUgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2UgYXJlIG5vIGxvbmdlciBpblxuICAgICAgICAvLyBCaW5hcnkgU2hpZnQgbW9kZS5cbiAgICAgICAgZW5kQmluYXJ5U2hpZnQoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgdG9rZW4gPSBhZGRCaW5hcnlTaGlmdCh0b2tlbiwgaW5kZXggLSB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50LCB0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50KTtcbiAgICAgICAgICAgIC8vIGFzc2VydCB0b2tlbi5nZXRUb3RhbEJpdENvdW50KCkgPT09IHRoaXMuYml0Q291bnQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YXRlKHRva2VuLCB0aGlzLm1vZGUsIDAsIHRoaXMuYml0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBcInRoaXNcIiBzdGF0ZSBpcyBiZXR0ZXIgKGVxdWFsOiBvcikgdG8gYmUgaW4gdGhhbiBcInRoYXRcIlxuICAgICAgICAvLyBzdGF0ZSB1bmRlciBhbGwgcG9zc2libGUgY2lyY3Vtc3RhbmNlcy5cbiAgICAgICAgaXNCZXR0ZXJUaGFuT3JFcXVhbFRvKG90aGVyKSB7XG4gICAgICAgICAgICBsZXQgbmV3TW9kZUJpdENvdW50ID0gdGhpcy5iaXRDb3VudCArIChMQVRDSF9UQUJMRVt0aGlzLm1vZGVdW290aGVyLm1vZGVdID4+IDE2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50IDwgb3RoZXIuYmluYXJ5U2hpZnRCeXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYWRkaXRpb25hbCBCL1MgZW5jb2RpbmcgY29zdCBvZiBvdGhlciwgaWYgYW55XG4gICAgICAgICAgICAgICAgbmV3TW9kZUJpdENvdW50ICs9XG4gICAgICAgICAgICAgICAgICAgIFN0YXRlLmNhbGN1bGF0ZUJpbmFyeVNoaWZ0Q29zdChvdGhlcikgLVxuICAgICAgICAgICAgICAgICAgICAgICAgU3RhdGUuY2FsY3VsYXRlQmluYXJ5U2hpZnRDb3N0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCA+IG90aGVyLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ICYmXG4gICAgICAgICAgICAgICAgb3RoZXIuYmluYXJ5U2hpZnRCeXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbWF4aW11bSBwb3NzaWJsZSBhZGRpdGlvbmFsIGNvc3QgKGl0OiBoKVxuICAgICAgICAgICAgICAgIG5ld01vZGVCaXRDb3VudCArPSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdNb2RlQml0Q291bnQgPD0gb3RoZXIuYml0Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9CaXRBcnJheSh0ZXh0KSB7XG4gICAgICAgICAgICAvLyBSZXZlcnNlIHRoZSB0b2tlbnMsIHNvIHRoYXQgdGhleSBhcmUgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIG91dHB1dFxuICAgICAgICAgICAgbGV0IHN5bWJvbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuID0gdGhpcy5lbmRCaW5hcnlTaGlmdCh0ZXh0Lmxlbmd0aCkudG9rZW47IHRva2VuICE9PSBudWxsOyB0b2tlbiA9IHRva2VuLmdldFByZXZpb3VzKCkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLnVuc2hpZnQodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJpdEFycmF5ID0gbmV3IEJpdEFycmF5KCk7XG4gICAgICAgICAgICAvLyBBZGQgZWFjaCB0b2tlbiB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgZm9yIChjb25zdCBzeW1ib2wgb2Ygc3ltYm9scykge1xuICAgICAgICAgICAgICAgIHN5bWJvbC5hcHBlbmRUbyhiaXRBcnJheSwgdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhc3NlcnQgYml0QXJyYXkuZ2V0U2l6ZSgpID09PSB0aGlzLmJpdENvdW50O1xuICAgICAgICAgICAgcmV0dXJuIGJpdEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAT3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLmZvcm1hdCgnJXMgYml0cz0lZCBieXRlcz0lZCcsIE1PREVfTkFNRVNbdGhpcy5tb2RlXSwgdGhpcy5iaXRDb3VudCwgdGhpcy5iaW5hcnlTaGlmdEJ5dGVDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGNhbGN1bGF0ZUJpbmFyeVNoaWZ0Q29zdChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gNjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjE7IC8vIEIvUyB3aXRoIGV4dGVuZGVkIGxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmJpbmFyeVNoaWZ0Qnl0ZUNvdW50ID4gMzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjA7IC8vIHR3byBCL1NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5iaW5hcnlTaGlmdEJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTA7IC8vIG9uZSBCL1NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN0YXRlLklOSVRJQUxfU1RBVEUgPSBuZXcgU3RhdGUoRU1QVFlfVE9LRU4sIE1PREVfVVBQRVIsIDAsIDApO1xuXG4gICAgZnVuY3Rpb24gc3RhdGljX0NIQVJfTUFQKENIQVJfTUFQKSB7XG4gICAgICAgIGNvbnN0IHNwYWNlQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnICcpO1xuICAgICAgICBjb25zdCBwb2ludENoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJy4nKTtcbiAgICAgICAgY29uc3QgY29tbWFDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcsJyk7XG4gICAgICAgIENIQVJfTUFQW01PREVfVVBQRVJdW3NwYWNlQ2hhckNvZGVdID0gMTtcbiAgICAgICAgY29uc3QgelVwcGVyQ2hhckNvZGUgPSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnWicpO1xuICAgICAgICBjb25zdCBhVXBwZXJDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCdBJyk7XG4gICAgICAgIGZvciAobGV0IGMgPSBhVXBwZXJDaGFyQ29kZTsgYyA8PSB6VXBwZXJDaGFyQ29kZTsgYysrKSB7XG4gICAgICAgICAgICBDSEFSX01BUFtNT0RFX1VQUEVSXVtjXSA9IGMgLSBhVXBwZXJDaGFyQ29kZSArIDI7XG4gICAgICAgIH1cbiAgICAgICAgQ0hBUl9NQVBbTU9ERV9MT1dFUl1bc3BhY2VDaGFyQ29kZV0gPSAxO1xuICAgICAgICBjb25zdCB6TG93ZXJDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCd6Jyk7XG4gICAgICAgIGNvbnN0IGFMb3dlckNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ2EnKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IGFMb3dlckNoYXJDb2RlOyBjIDw9IHpMb3dlckNoYXJDb2RlOyBjKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfTE9XRVJdW2NdID0gYyAtIGFMb3dlckNoYXJDb2RlICsgMjtcbiAgICAgICAgfVxuICAgICAgICBDSEFSX01BUFtNT0RFX0RJR0lUXVtzcGFjZUNoYXJDb2RlXSA9IDE7XG4gICAgICAgIGNvbnN0IG5pbmVDaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCc5Jyk7XG4gICAgICAgIGNvbnN0IHplcm9DaGFyQ29kZSA9IFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCcwJyk7XG4gICAgICAgIGZvciAobGV0IGMgPSB6ZXJvQ2hhckNvZGU7IGMgPD0gbmluZUNoYXJDb2RlOyBjKyspIHtcbiAgICAgICAgICAgIENIQVJfTUFQW01PREVfRElHSVRdW2NdID0gYyAtIHplcm9DaGFyQ29kZSArIDI7XG4gICAgICAgIH1cbiAgICAgICAgQ0hBUl9NQVBbTU9ERV9ESUdJVF1bY29tbWFDaGFyQ29kZV0gPSAxMjtcbiAgICAgICAgQ0hBUl9NQVBbTU9ERV9ESUdJVF1bcG9pbnRDaGFyQ29kZV0gPSAxMztcbiAgICAgICAgY29uc3QgbWl4ZWRUYWJsZSA9IFtcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnICcsXG4gICAgICAgICAgICAnXFx4MDEnLFxuICAgICAgICAgICAgJ1xceDAyJyxcbiAgICAgICAgICAgICdcXHgwMycsXG4gICAgICAgICAgICAnXFx4MDQnLFxuICAgICAgICAgICAgJ1xceDA1JyxcbiAgICAgICAgICAgICdcXHgwNicsXG4gICAgICAgICAgICAnXFx4MDcnLFxuICAgICAgICAgICAgJ1xcYicsXG4gICAgICAgICAgICAnXFx0JyxcbiAgICAgICAgICAgICdcXG4nLFxuICAgICAgICAgICAgJ1xceDBiJyxcbiAgICAgICAgICAgICdcXGYnLFxuICAgICAgICAgICAgJ1xccicsXG4gICAgICAgICAgICAnXFx4MWInLFxuICAgICAgICAgICAgJ1xceDFjJyxcbiAgICAgICAgICAgICdcXHgxZCcsXG4gICAgICAgICAgICAnXFx4MWUnLFxuICAgICAgICAgICAgJ1xceDFmJyxcbiAgICAgICAgICAgICdAJyxcbiAgICAgICAgICAgICdcXFxcJyxcbiAgICAgICAgICAgICdeJyxcbiAgICAgICAgICAgICdfJyxcbiAgICAgICAgICAgICdgJyxcbiAgICAgICAgICAgICd8JyxcbiAgICAgICAgICAgICd+JyxcbiAgICAgICAgICAgICdcXHg3ZidcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXhlZFRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBDSEFSX01BUFtNT0RFX01JWEVEXVtTdHJpbmdVdGlscy5nZXRDaGFyQ29kZShtaXhlZFRhYmxlW2ldKV0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1bmN0VGFibGUgPSBbXG4gICAgICAgICAgICAnXFx4MDAnLFxuICAgICAgICAgICAgJ1xccicsXG4gICAgICAgICAgICAnXFx4MDAnLFxuICAgICAgICAgICAgJ1xceDAwJyxcbiAgICAgICAgICAgICdcXHgwMCcsXG4gICAgICAgICAgICAnXFx4MDAnLFxuICAgICAgICAgICAgJyEnLFxuICAgICAgICAgICAgJ1xcJycsXG4gICAgICAgICAgICAnIycsXG4gICAgICAgICAgICAnJCcsXG4gICAgICAgICAgICAnJScsXG4gICAgICAgICAgICAnJicsXG4gICAgICAgICAgICAnXFwnJyxcbiAgICAgICAgICAgICcoJyxcbiAgICAgICAgICAgICcpJyxcbiAgICAgICAgICAgICcqJyxcbiAgICAgICAgICAgICcrJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctJyxcbiAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICcvJyxcbiAgICAgICAgICAgICc6JyxcbiAgICAgICAgICAgICc7JyxcbiAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgICc9JyxcbiAgICAgICAgICAgICc+JyxcbiAgICAgICAgICAgICc/JyxcbiAgICAgICAgICAgICdbJyxcbiAgICAgICAgICAgICddJyxcbiAgICAgICAgICAgICd7JyxcbiAgICAgICAgICAgICd9J1xuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1bmN0VGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChTdHJpbmdVdGlscy5nZXRDaGFyQ29kZShwdW5jdFRhYmxlW2ldKSA+IDApIHtcbiAgICAgICAgICAgICAgICBDSEFSX01BUFtNT0RFX1BVTkNUXVtTdHJpbmdVdGlscy5nZXRDaGFyQ29kZShwdW5jdFRhYmxlW2ldKV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDSEFSX01BUDtcbiAgICB9XG4gICAgY29uc3QgQ0hBUl9NQVAgPSBzdGF0aWNfQ0hBUl9NQVAoQXJyYXlzLmNyZWF0ZUludDMyQXJyYXkoNSwgMjU2KSk7XG5cbiAgICAvKlxuICAgICAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcbiAgICAgKlxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAqXG4gICAgICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvZHVjZXMgbmVhcmx5IG9wdGltYWwgZW5jb2RpbmdzIG9mIHRleHQgaW50byB0aGUgZmlyc3QtbGV2ZWwgb2ZcbiAgICAgKiBlbmNvZGluZyB1c2VkIGJ5IEF6dGVjIGNvZGUuXG4gICAgICpcbiAgICAgKiBJdCB1c2VzIGEgZHluYW1pYyBhbGdvcml0aG0uICBGb3IgZWFjaCBwcmVmaXggb2YgdGhlIHN0cmluZywgaXQgZGV0ZXJtaW5lc1xuICAgICAqIGEgc2V0IG9mIGVuY29kaW5ncyB0aGF0IGNvdWxkIGxlYWQgdG8gdGhpcyBwcmVmaXguICBXZSByZXBlYXRlZGx5IGFkZCBhXG4gICAgICogY2hhcmFjdGVyIGFuZCBnZW5lcmF0ZSBhIG5ldyBzZXQgb2Ygb3B0aW1hbCBlbmNvZGluZ3MgdW50aWwgd2UgaGF2ZSByZWFkXG4gICAgICogdGhyb3VnaCB0aGUgZW50aXJlIGlucHV0LlxuICAgICAqXG4gICAgICogQGF1dGhvciBGcmFuayBZZWxsaW5cbiAgICAgKiBAYXV0aG9yIFJ1c3RhbSBBYmR1bGxhZXZcbiAgICAgKi9cbiAgICAvKnB1YmxpYyBmaW5hbCovIGNsYXNzIEhpZ2hMZXZlbEVuY29kZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHRleHQgcmVwcmVzZW50ZWQgYnkgdGhpcyBlbmNvZGVyIGVuY29kZWQgYXMgYSB7QGxpbmsgQml0QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBlbmNvZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFjZUNoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVCcmVha0NoYXJDb2RlID0gU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJ1xcbicpO1xuICAgICAgICAgICAgbGV0IHN0YXRlcyA9IENvbGxlY3Rpb25zLnNpbmdsZXRvbkxpc3QoU3RhdGUuSU5JVElBTF9TVEFURSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy50ZXh0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGxldCBwYWlyQ29kZTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBpbmRleCArIDEgPCB0aGlzLnRleHQubGVuZ3RoID8gdGhpcy50ZXh0W2luZGV4ICsgMV0gOiAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50ZXh0W2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCdcXHInKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDb2RlID0gbmV4dENoYXIgPT09IGxpbmVCcmVha0NoYXJDb2RlID8gMiA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTdHJpbmdVdGlscy5nZXRDaGFyQ29kZSgnLicpOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNvZGUgPSBuZXh0Q2hhciA9PT0gc3BhY2VDaGFyQ29kZSA/IDMgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUoJywnKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDb2RlID0gbmV4dENoYXIgPT09IHNwYWNlQ2hhckNvZGUgPyA0IDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFN0cmluZ1V0aWxzLmdldENoYXJDb2RlKCc6Jyk6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ29kZSA9IG5leHRDaGFyID09PSBzcGFjZUNoYXJDb2RlID8gNSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDb2RlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhaXJDb2RlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIG9uZSBvZiB0aGUgZm91ciBzcGVjaWFsIFBVTkNUIHBhaXJzLiAgVHJlYXQgdGhlbSBzcGVjaWFsbHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIG5ldyBzZXQgb2Ygc3RhdGVzIGZvciB0aGUgdHdvIG5ldyBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSBIaWdoTGV2ZWxFbmNvZGVyLnVwZGF0ZVN0YXRlTGlzdEZvclBhaXIoc3RhdGVzLCBpbmRleCwgcGFpckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IHNldCBvZiBzdGF0ZXMgZm9yIHRoZSBuZXcgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXMgPSB0aGlzLnVwZGF0ZVN0YXRlTGlzdEZvckNoYXIoc3RhdGVzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGxlZnQgd2l0aCBhIHNldCBvZiBzdGF0ZXMuICBGaW5kIHRoZSBzaG9ydGVzdCBvbmUuXG4gICAgICAgICAgICBjb25zdCBtaW5TdGF0ZSA9IENvbGxlY3Rpb25zLm1pbihzdGF0ZXMsIChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZ2V0Qml0Q291bnQoKSAtIGIuZ2V0Qml0Q291bnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ29udmVydCBpdCB0byBhIGJpdCBhcnJheSwgYW5kIHJldHVybi5cbiAgICAgICAgICAgIHJldHVybiBtaW5TdGF0ZS50b0JpdEFycmF5KHRoaXMudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgdXBkYXRlIGEgc2V0IG9mIHN0YXRlcyBmb3IgYSBuZXcgY2hhcmFjdGVyIGJ5IHVwZGF0aW5nIGVhY2ggc3RhdGVcbiAgICAgICAgLy8gZm9yIHRoZSBuZXcgY2hhcmFjdGVyLCBtZXJnaW5nIHRoZSByZXN1bHRzLCBhbmQgdGhlbiByZW1vdmluZyB0aGVcbiAgICAgICAgLy8gbm9uLW9wdGltYWwgc3RhdGVzLlxuICAgICAgICB1cGRhdGVTdGF0ZUxpc3RGb3JDaGFyKHN0YXRlcywgaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGUgLypTdGF0ZSovIG9mIHN0YXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGVGb3JDaGFyKHN0YXRlLCBpbmRleCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBIaWdoTGV2ZWxFbmNvZGVyLnNpbXBsaWZ5U3RhdGVzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGEgc2V0IG9mIHN0YXRlcyB0aGF0IHJlcHJlc2VudCB0aGUgcG9zc2libGUgd2F5cyBvZiB1cGRhdGluZyB0aGlzXG4gICAgICAgIC8vIHN0YXRlIGZvciB0aGUgbmV4dCBjaGFyYWN0ZXIuICBUaGUgcmVzdWx0aW5nIHNldCBvZiBzdGF0ZXMgYXJlIGFkZGVkIHRvXG4gICAgICAgIC8vIHRoZSBcInJlc3VsdFwiIGxpc3QuXG4gICAgICAgIHVwZGF0ZVN0YXRlRm9yQ2hhcihzdGF0ZSwgaW5kZXgsIHJlc3VsdCkge1xuICAgICAgICAgICAgbGV0IGNoID0gKHRoaXMudGV4dFtpbmRleF0gJiAweGZmKTtcbiAgICAgICAgICAgIGxldCBjaGFySW5DdXJyZW50VGFibGUgPSBDSEFSX01BUFtzdGF0ZS5nZXRNb2RlKCldW2NoXSA+IDA7XG4gICAgICAgICAgICBsZXQgc3RhdGVOb0JpbmFyeSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBtb2RlIC8qaW50Ki8gPSAwOyBtb2RlIDw9IE1PREVfUFVOQ1Q7IG1vZGUrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGFySW5Nb2RlID0gQ0hBUl9NQVBbbW9kZV1bY2hdO1xuICAgICAgICAgICAgICAgIGlmIChjaGFySW5Nb2RlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVOb0JpbmFyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBzdGF0ZU5vQmluYXJ5IHRoZSBmaXJzdCB0aW1lIGl0J3MgcmVxdWlyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZU5vQmluYXJ5ID0gc3RhdGUuZW5kQmluYXJ5U2hpZnQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBnZW5lcmF0aW5nIHRoZSBjaGFyYWN0ZXIgYnkgbGF0Y2hpbmcgdG8gaXRzIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFySW5DdXJyZW50VGFibGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT09IHN0YXRlLmdldE1vZGUoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PT0gTU9ERV9ESUdJVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBpbiB0aGUgY3VycmVudCB0YWJsZSwgd2UgZG9uJ3Qgd2FudCB0byBsYXRjaCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IG90aGVyIG1vZGUgZXhjZXB0IHBvc3NpYmx5IGRpZ2l0ICh3aGljaCB1c2VzIG9ubHkgNCBiaXRzKS4gIEFueVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXIgbGF0Y2ggd291bGQgYmUgZXF1YWxseSBzdWNjZXNzZnVsICphZnRlciogdGhpcyBjaGFyYWN0ZXIsIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd291bGRuJ3Qgc2F2ZSBhbnkgYml0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdGNoU3RhdGUgPSBzdGF0ZU5vQmluYXJ5LmxhdGNoQW5kQXBwZW5kKG1vZGUsIGNoYXJJbk1vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGF0Y2hTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGdlbmVyYXRpbmcgdGhlIGNoYXJhY3RlciBieSBzd2l0Y2hpbmcgdG8gaXRzIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hhckluQ3VycmVudFRhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBTSElGVF9UQUJMRVtzdGF0ZS5nZXRNb2RlKCldW21vZGVdID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IG5ldmVyIG1ha2VzIHNlbnNlIHRvIHRlbXBvcmFyaWx5IHNoaWZ0IHRvIGFub3RoZXIgbW9kZSBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlciBleGlzdHMgaW4gdGhlIGN1cnJlbnQgbW9kZS4gIFRoYXQgY2FuIG5ldmVyIHNhdmUgYml0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0U3RhdGUgPSBzdGF0ZU5vQmluYXJ5LnNoaWZ0QW5kQXBwZW5kKG1vZGUsIGNoYXJJbk1vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2hpZnRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ2V0QmluYXJ5U2hpZnRCeXRlQ291bnQoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICBDSEFSX01BUFtzdGF0ZS5nZXRNb2RlKCldW2NoXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgbmV2ZXIgd29ydGh3aGlsZSB0byBnbyBpbnRvIGJpbmFyeSBzaGlmdCBtb2RlIGlmIHlvdSdyZSBub3QgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIGluIGJpbmFyeSBzaGlmdCBtb2RlLCBhbmQgdGhlIGNoYXJhY3RlciBleGlzdHMgaW4geW91ciBjdXJyZW50IG1vZGUuXG4gICAgICAgICAgICAgICAgLy8gVGhhdCBjYW4gbmV2ZXIgc2F2ZSBiaXRzIG92ZXIganVzdCBvdXRwdXR0aW5nIHRoZSBjaGFyIGluIHRoZSBjdXJyZW50IG1vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGJpbmFyeVN0YXRlID0gc3RhdGUuYWRkQmluYXJ5U2hpZnRDaGFyKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaW5hcnlTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHVwZGF0ZVN0YXRlTGlzdEZvclBhaXIoc3RhdGVzLCBpbmRleCwgcGFpckNvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGUgLypTdGF0ZSovIG9mIHN0YXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGVGb3JQYWlyKHN0YXRlLCBpbmRleCwgcGFpckNvZGUsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGlmeVN0YXRlcyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB1cGRhdGVTdGF0ZUZvclBhaXIoc3RhdGUsIGluZGV4LCBwYWlyQ29kZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVOb0JpbmFyeSA9IHN0YXRlLmVuZEJpbmFyeVNoaWZ0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIFBvc3NpYmlsaXR5IDEuICBMYXRjaCB0byBDLk1PREVfUFVOQ1QsIGFuZCB0aGVuIGFwcGVuZCB0aGlzIGNvZGVcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YXRlTm9CaW5hcnkubGF0Y2hBbmRBcHBlbmQoTU9ERV9QVU5DVCwgcGFpckNvZGUpKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5nZXRNb2RlKCkgIT09IE1PREVfUFVOQ1QpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJpbGl0eSAyLiAgU2hpZnQgdG8gQy5NT0RFX1BVTkNULCBhbmQgdGhlbiBhcHBlbmQgdGhpcyBjb2RlLlxuICAgICAgICAgICAgICAgIC8vIEV2ZXJ5IHN0YXRlIGV4Y2VwdCBDLk1PREVfUFVOQ1QgKGhhbmRsZWQgYWJvdmUpIGNhbiBzaGlmdFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YXRlTm9CaW5hcnkuc2hpZnRBbmRBcHBlbmQoTU9ERV9QVU5DVCwgcGFpckNvZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWlyQ29kZSA9PT0gMyB8fCBwYWlyQ29kZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIGJvdGggY2hhcmFjdGVycyBhcmUgaW4gRElHSVRTLiAgU29tZXRpbWVzIGJldHRlciB0byBqdXN0IGFkZCB0d28gZGlnaXRzXG4gICAgICAgICAgICAgICAgbGV0IGRpZ2l0U3RhdGUgPSBzdGF0ZU5vQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgIC5sYXRjaEFuZEFwcGVuZChNT0RFX0RJR0lULCAxNiAtIHBhaXJDb2RlKSAvLyBwZXJpb2Qgb3IgY29tbWEgaW4gRElHSVRcbiAgICAgICAgICAgICAgICAgICAgLmxhdGNoQW5kQXBwZW5kKE1PREVfRElHSVQsIDEpOyAvLyBzcGFjZSBpbiBESUdJVFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRpZ2l0U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmdldEJpbmFyeVNoaWZ0Qnl0ZUNvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgb25seSBtYWtlcyBzZW5zZSB0byBkbyB0aGUgY2hhcmFjdGVycyBhcyBiaW5hcnkgaWYgd2UncmUgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIGluIGJpbmFyeSBtb2RlLlxuICAgICAgICAgICAgICAgIGxldCBiaW5hcnlTdGF0ZSA9IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC5hZGRCaW5hcnlTaGlmdENoYXIoaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRCaW5hcnlTaGlmdENoYXIoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiaW5hcnlTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHNpbXBsaWZ5U3RhdGVzKHN0YXRlcykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXdTdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9sZFN0YXRlIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuaXNCZXR0ZXJUaGFuT3JFcXVhbFRvKG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUuaXNCZXR0ZXJUaGFuT3JFcXVhbFRvKG9sZFN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKHggPT4geCAhPT0gb2xkU3RhdGUpOyAvLyByZW1vdmUgb2xkIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgICAqXG4gICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgICovXG4gICAgLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLmF6dGVjLmVuY29kZXI7XG4gICAgLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkJpdEFycmF5O1xuICAgIC8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5CaXRNYXRyaXg7XG4gICAgLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLkdlbmVyaWNHRjtcbiAgICAvLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24uUmVlZFNvbG9tb25FbmNvZGVyO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBBenRlYyAyRCBiYXJjb2Rlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgUnVzdGFtIEFiZHVsbGFldlxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgRW5jb2RlciQxIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIGdpdmVuIGJpbmFyeSBjb250ZW50IGFzIGFuIEF6dGVjIHN5bWJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSBpbnB1dCBkYXRhIHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJuIEF6dGVjIHN5bWJvbCBtYXRyaXggd2l0aCBtZXRhZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGVuY29kZUJ5dGVzKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBFbmNvZGVyJDEuZW5jb2RlKGRhdGEsIEVuY29kZXIkMS5ERUZBVUxUX0VDX1BFUkNFTlQsIEVuY29kZXIkMS5ERUZBVUxUX0FaVEVDX0xBWUVSUyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIGdpdmVuIGJpbmFyeSBjb250ZW50IGFzIGFuIEF6dGVjIHN5bWJvbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSBpbnB1dCBkYXRhIHN0cmluZ1xuICAgICAgICAgKiBAcGFyYW0gbWluRUNDUGVyY2VudCBtaW5pbWFsIHBlcmNlbnRhZ2Ugb2YgZXJyb3IgY2hlY2sgd29yZHMgKEFjY29yZGluZyB0byBJU08vSUVDIDI0Nzc4OjIwMDgsXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgIGEgbWluaW11bSBvZiAyMyUgKyAzIHdvcmRzIGlzIHJlY29tbWVuZGVkKVxuICAgICAgICAgKiBAcGFyYW0gdXNlclNwZWNpZmllZExheWVycyBpZiBub24temVybywgYSB1c2VyLXNwZWNpZmllZCB2YWx1ZSBmb3IgdGhlIG51bWJlciBvZiBsYXllcnNcbiAgICAgICAgICogQHJldHVybiBBenRlYyBzeW1ib2wgbWF0cml4IHdpdGggbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBlbmNvZGUoZGF0YSwgbWluRUNDUGVyY2VudCwgdXNlclNwZWNpZmllZExheWVycykge1xuICAgICAgICAgICAgLy8gSGlnaC1sZXZlbCBlbmNvZGVcbiAgICAgICAgICAgIGxldCBiaXRzID0gbmV3IEhpZ2hMZXZlbEVuY29kZXIoZGF0YSkuZW5jb2RlKCk7XG4gICAgICAgICAgICAvLyBzdHVmZiBiaXRzIGFuZCBjaG9vc2Ugc3ltYm9sIHNpemVcbiAgICAgICAgICAgIGxldCBlY2NCaXRzID0gSW50ZWdlci50cnVuY0RpdmlzaW9uKChiaXRzLmdldFNpemUoKSAqIG1pbkVDQ1BlcmNlbnQpLCAxMDApICsgMTE7XG4gICAgICAgICAgICBsZXQgdG90YWxTaXplQml0cyA9IGJpdHMuZ2V0U2l6ZSgpICsgZWNjQml0cztcbiAgICAgICAgICAgIGxldCBjb21wYWN0O1xuICAgICAgICAgICAgbGV0IGxheWVycztcbiAgICAgICAgICAgIGxldCB0b3RhbEJpdHNJbkxheWVyO1xuICAgICAgICAgICAgbGV0IHdvcmRTaXplO1xuICAgICAgICAgICAgbGV0IHN0dWZmZWRCaXRzO1xuICAgICAgICAgICAgaWYgKHVzZXJTcGVjaWZpZWRMYXllcnMgIT09IEVuY29kZXIkMS5ERUZBVUxUX0FaVEVDX0xBWUVSUykge1xuICAgICAgICAgICAgICAgIGNvbXBhY3QgPSB1c2VyU3BlY2lmaWVkTGF5ZXJzIDwgMDtcbiAgICAgICAgICAgICAgICBsYXllcnMgPSBNYXRoLmFicyh1c2VyU3BlY2lmaWVkTGF5ZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJzID4gKGNvbXBhY3QgPyBFbmNvZGVyJDEuTUFYX05CX0JJVFNfQ09NUEFDVCA6IEVuY29kZXIkMS5NQVhfTkJfQklUUykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihTdHJpbmdVdGlscy5mb3JtYXQoJ0lsbGVnYWwgdmFsdWUgJXMgZm9yIGxheWVycycsIHVzZXJTcGVjaWZpZWRMYXllcnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG90YWxCaXRzSW5MYXllciA9IEVuY29kZXIkMS50b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCk7XG4gICAgICAgICAgICAgICAgd29yZFNpemUgPSBFbmNvZGVyJDEuV09SRF9TSVpFW2xheWVyc107XG4gICAgICAgICAgICAgICAgbGV0IHVzYWJsZUJpdHNJbkxheWVycyA9IHRvdGFsQml0c0luTGF5ZXIgLSAodG90YWxCaXRzSW5MYXllciAlIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICBzdHVmZmVkQml0cyA9IEVuY29kZXIkMS5zdHVmZkJpdHMoYml0cywgd29yZFNpemUpO1xuICAgICAgICAgICAgICAgIGlmIChzdHVmZmVkQml0cy5nZXRTaXplKCkgKyBlY2NCaXRzID4gdXNhYmxlQml0c0luTGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0RhdGEgdG8gbGFyZ2UgZm9yIHVzZXIgc3BlY2lmaWVkIGxheWVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wYWN0ICYmIHN0dWZmZWRCaXRzLmdldFNpemUoKSA+IHdvcmRTaXplICogNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFjdCBmb3JtYXQgb25seSBhbGxvd3MgNjQgZGF0YSB3b3JkcywgdGhvdWdoIEM0IGNhbiBob2xkIG1vcmUgd29yZHMgdGhhbiB0aGF0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0RhdGEgdG8gbGFyZ2UgZm9yIHVzZXIgc3BlY2lmaWVkIGxheWVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd29yZFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBXZSBsb29rIGF0IHRoZSBwb3NzaWJsZSB0YWJsZSBzaXplcyBpbiB0aGUgb3JkZXIgQ29tcGFjdDEsIENvbXBhY3QyLCBDb21wYWN0MyxcbiAgICAgICAgICAgICAgICAvLyBDb21wYWN0NCwgTm9ybWFsNCwuLi4gIE5vcm1hbChpKSBmb3IgaSA8IDQgaXNuJ3QgdHlwaWNhbGx5IHVzZWQgc2luY2UgQ29tcGFjdChpKzEpXG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlIHNhbWUgc2l6ZSwgYnV0IGhhcyBtb3JlIGRhdGEuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IEVuY29kZXIkMS5NQVhfTkJfQklUUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRGF0YSB0b28gbGFyZ2UgZm9yIGFuIEF6dGVjIGNvZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ID0gaSA8PSAzO1xuICAgICAgICAgICAgICAgICAgICBsYXllcnMgPSBjb21wYWN0ID8gaSArIDEgOiBpO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbEJpdHNJbkxheWVyID0gRW5jb2RlciQxLnRvdGFsQml0c0luTGF5ZXIobGF5ZXJzLCBjb21wYWN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZUJpdHMgPiB0b3RhbEJpdHNJbkxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBbUmVdc3R1ZmYgdGhlIGJpdHMgaWYgdGhpcyBpcyB0aGUgZmlyc3Qgb3Bwb3J0dW5pdHksIG9yIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3JkU2l6ZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R1ZmZlZEJpdHMgPT0gbnVsbCB8fCB3b3JkU2l6ZSAhPT0gRW5jb2RlciQxLldPUkRfU0laRVtsYXllcnNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkU2l6ZSA9IEVuY29kZXIkMS5XT1JEX1NJWkVbbGF5ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0dWZmZWRCaXRzID0gRW5jb2RlciQxLnN0dWZmQml0cyhiaXRzLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHVzYWJsZUJpdHNJbkxheWVycyA9IHRvdGFsQml0c0luTGF5ZXIgLSAodG90YWxCaXRzSW5MYXllciAlIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QgJiYgc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpID4gd29yZFNpemUgKiA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFjdCBmb3JtYXQgb25seSBhbGxvd3MgNjQgZGF0YSB3b3JkcywgdGhvdWdoIEM0IGNhbiBob2xkIG1vcmUgd29yZHMgdGhhbiB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpICsgZWNjQml0cyA8PSB1c2FibGVCaXRzSW5MYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1lc3NhZ2VCaXRzID0gRW5jb2RlciQxLmdlbmVyYXRlQ2hlY2tXb3JkcyhzdHVmZmVkQml0cywgdG90YWxCaXRzSW5MYXllciwgd29yZFNpemUpO1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgbW9kZSBtZXNzYWdlXG4gICAgICAgICAgICBsZXQgbWVzc2FnZVNpemVJbldvcmRzID0gc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpIC8gd29yZFNpemU7XG4gICAgICAgICAgICBsZXQgbW9kZU1lc3NhZ2UgPSBFbmNvZGVyJDEuZ2VuZXJhdGVNb2RlTWVzc2FnZShjb21wYWN0LCBsYXllcnMsIG1lc3NhZ2VTaXplSW5Xb3Jkcyk7XG4gICAgICAgICAgICAvLyBhbGxvY2F0ZSBzeW1ib2xcbiAgICAgICAgICAgIGxldCBiYXNlTWF0cml4U2l6ZSA9IChjb21wYWN0ID8gMTEgOiAxNCkgKyBsYXllcnMgKiA0OyAvLyBub3QgaW5jbHVkaW5nIGFsaWdubWVudCBsaW5lc1xuICAgICAgICAgICAgbGV0IGFsaWdubWVudE1hcCA9IG5ldyBJbnQzMkFycmF5KGJhc2VNYXRyaXhTaXplKTtcbiAgICAgICAgICAgIGxldCBtYXRyaXhTaXplO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBhbGlnbm1lbnQgbWFya3MgaW4gY29tcGFjdCBtb2RlLCBhbGlnbm1lbnRNYXAgaXMgYSBuby1vcFxuICAgICAgICAgICAgICAgIG1hdHJpeFNpemUgPSBiYXNlTWF0cml4U2l6ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgYWxpZ25tZW50TWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4U2l6ZSA9IGJhc2VNYXRyaXhTaXplICsgMSArIDIgKiBJbnRlZ2VyLnRydW5jRGl2aXNpb24oKEludGVnZXIudHJ1bmNEaXZpc2lvbihiYXNlTWF0cml4U2l6ZSwgMikgLSAxKSwgMTUpO1xuICAgICAgICAgICAgICAgIGxldCBvcmlnQ2VudGVyID0gSW50ZWdlci50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKTtcbiAgICAgICAgICAgICAgICBsZXQgY2VudGVyID0gSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDA7IGkgPCBvcmlnQ2VudGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld09mZnNldCA9IGkgKyBJbnRlZ2VyLnRydW5jRGl2aXNpb24oaSwgMTUpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbb3JpZ0NlbnRlciAtIGkgLSAxXSA9IGNlbnRlciAtIG5ld09mZnNldCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudE1hcFtvcmlnQ2VudGVyICsgaV0gPSBjZW50ZXIgKyBuZXdPZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtYXRyaXggPSBuZXcgQml0TWF0cml4KG1hdHJpeFNpemUpO1xuICAgICAgICAgICAgLy8gZHJhdyBkYXRhIGJpdHNcbiAgICAgICAgICAgIGZvciAobGV0IGkgLyppbnQqLyA9IDAsIHJvd09mZnNldCA9IDA7IGkgPCBsYXllcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByb3dTaXplID0gKGxheWVycyAtIGkpICogNCArIChjb21wYWN0ID8gOSA6IDEyKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqIC8qaW50Ki8gPSAwOyBqIDwgcm93U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2x1bW5PZmZzZXQgPSBqICogMjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayAvKmludCovID0gMDsgayA8IDI7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VCaXRzLmdldChyb3dPZmZzZXQgKyBjb2x1bW5PZmZzZXQgKyBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoYWxpZ25tZW50TWFwW2kgKiAyICsga10sIGFsaWdubWVudE1hcFtpICogMiArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlQml0cy5nZXQocm93T2Zmc2V0ICsgcm93U2l6ZSAqIDIgKyBjb2x1bW5PZmZzZXQgKyBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoYWxpZ25tZW50TWFwW2kgKiAyICsgal0sIGFsaWdubWVudE1hcFtiYXNlTWF0cml4U2l6ZSAtIDEgLSBpICogMiAtIGtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlQml0cy5nZXQocm93T2Zmc2V0ICsgcm93U2l6ZSAqIDQgKyBjb2x1bW5PZmZzZXQgKyBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0ga10sIGFsaWdubWVudE1hcFtiYXNlTWF0cml4U2l6ZSAtIDEgLSBpICogMiAtIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlQml0cy5nZXQocm93T2Zmc2V0ICsgcm93U2l6ZSAqIDYgKyBjb2x1bW5PZmZzZXQgKyBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoYWxpZ25tZW50TWFwW2Jhc2VNYXRyaXhTaXplIC0gMSAtIGkgKiAyIC0gal0sIGFsaWdubWVudE1hcFtpICogMiArIGtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gcm93U2l6ZSAqIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkcmF3IG1vZGUgbWVzc2FnZVxuICAgICAgICAgICAgRW5jb2RlciQxLmRyYXdNb2RlTWVzc2FnZShtYXRyaXgsIGNvbXBhY3QsIG1hdHJpeFNpemUsIG1vZGVNZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIGRyYXcgYWxpZ25tZW50IG1hcmtzXG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIEVuY29kZXIkMS5kcmF3QnVsbHNFeWUobWF0cml4LCBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMiksIDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRW5jb2RlciQxLmRyYXdCdWxsc0V5ZShtYXRyaXgsIEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSwgNyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMCwgaiA9IDA7IGkgPCBJbnRlZ2VyLnRydW5jRGl2aXNpb24oYmFzZU1hdHJpeFNpemUsIDIpIC0gMTsgaSArPSAxNSwgaiArPSAxNikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrIC8qaW50Ki8gPSBJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMikgJiAxOyBrIDwgbWF0cml4U2l6ZTsgayArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSAtIGosIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChJbnRlZ2VyLnRydW5jRGl2aXNpb24obWF0cml4U2l6ZSwgMikgKyBqLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaywgSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpIC0gaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGssIEludGVnZXIudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKSArIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF6dGVjID0gbmV3IEF6dGVjQ29kZSgpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0Q29tcGFjdChjb21wYWN0KTtcbiAgICAgICAgICAgIGF6dGVjLnNldFNpemUobWF0cml4U2l6ZSk7XG4gICAgICAgICAgICBhenRlYy5zZXRMYXllcnMobGF5ZXJzKTtcbiAgICAgICAgICAgIGF6dGVjLnNldENvZGVXb3JkcyhtZXNzYWdlU2l6ZUluV29yZHMpO1xuICAgICAgICAgICAgYXp0ZWMuc2V0TWF0cml4KG1hdHJpeCk7XG4gICAgICAgICAgICByZXR1cm4gYXp0ZWM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRyYXdCdWxsc0V5ZShtYXRyaXgsIGNlbnRlciwgc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IGNlbnRlciAtIGk7IGogPD0gY2VudGVyICsgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaiwgY2VudGVyIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaiwgY2VudGVyICsgaSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgaSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBzaXplLCBjZW50ZXIgLSBzaXplKTtcbiAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gc2l6ZSArIDEsIGNlbnRlciAtIHNpemUpO1xuICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgLSBzaXplLCBjZW50ZXIgLSBzaXplICsgMSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciArIHNpemUsIGNlbnRlciAtIHNpemUpO1xuICAgICAgICAgICAgbWF0cml4LnNldChjZW50ZXIgKyBzaXplLCBjZW50ZXIgLSBzaXplICsgMSk7XG4gICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciArIHNpemUsIGNlbnRlciArIHNpemUgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2VuZXJhdGVNb2RlTWVzc2FnZShjb21wYWN0LCBsYXllcnMsIG1lc3NhZ2VTaXplSW5Xb3Jkcykge1xuICAgICAgICAgICAgbGV0IG1vZGVNZXNzYWdlID0gbmV3IEJpdEFycmF5KCk7XG4gICAgICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgICAgIG1vZGVNZXNzYWdlLmFwcGVuZEJpdHMobGF5ZXJzIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhtZXNzYWdlU2l6ZUluV29yZHMgLSAxLCA2KTtcbiAgICAgICAgICAgICAgICBtb2RlTWVzc2FnZSA9IEVuY29kZXIkMS5nZW5lcmF0ZUNoZWNrV29yZHMobW9kZU1lc3NhZ2UsIDI4LCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVNZXNzYWdlLmFwcGVuZEJpdHMobGF5ZXJzIC0gMSwgNSk7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UuYXBwZW5kQml0cyhtZXNzYWdlU2l6ZUluV29yZHMgLSAxLCAxMSk7XG4gICAgICAgICAgICAgICAgbW9kZU1lc3NhZ2UgPSBFbmNvZGVyJDEuZ2VuZXJhdGVDaGVja1dvcmRzKG1vZGVNZXNzYWdlLCA0MCwgNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kZU1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGRyYXdNb2RlTWVzc2FnZShtYXRyaXgsIGNvbXBhY3QsIG1hdHJpeFNpemUsIG1vZGVNZXNzYWdlKSB7XG4gICAgICAgICAgICBsZXQgY2VudGVyID0gSW50ZWdlci50cnVuY0RpdmlzaW9uKG1hdHJpeFNpemUsIDIpO1xuICAgICAgICAgICAgaWYgKGNvbXBhY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBjZW50ZXIgLSAzICsgaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LnNldChvZmZzZXQsIGNlbnRlciAtIDUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoaSArIDcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciArIDUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldCgyMCAtIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KG9mZnNldCwgY2VudGVyICsgNSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVNZXNzYWdlLmdldCgyNyAtIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGNlbnRlciAtIDUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gY2VudGVyIC0gNSArIGkgKyBJbnRlZ2VyLnRydW5jRGl2aXNpb24oaSwgNSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlTWVzc2FnZS5nZXQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgLSA3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KGkgKyAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyICsgNywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDI5IC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQob2Zmc2V0LCBjZW50ZXIgKyA3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZU1lc3NhZ2UuZ2V0KDM5IC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoY2VudGVyIC0gNywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2VuZXJhdGVDaGVja1dvcmRzKGJpdEFycmF5LCB0b3RhbEJpdHMsIHdvcmRTaXplKSB7XG4gICAgICAgICAgICAvLyBiaXRBcnJheSBpcyBndWFyYW50ZWVkIHRvIGJlIGEgbXVsdGlwbGUgb2YgdGhlIHdvcmRTaXplLCBzbyBubyBwYWRkaW5nIG5lZWRlZFxuICAgICAgICAgICAgbGV0IG1lc3NhZ2VTaXplSW5Xb3JkcyA9IGJpdEFycmF5LmdldFNpemUoKSAvIHdvcmRTaXplO1xuICAgICAgICAgICAgbGV0IHJzID0gbmV3IFJlZWRTb2xvbW9uRW5jb2RlcihFbmNvZGVyJDEuZ2V0R0Yod29yZFNpemUpKTtcbiAgICAgICAgICAgIGxldCB0b3RhbFdvcmRzID0gSW50ZWdlci50cnVuY0RpdmlzaW9uKHRvdGFsQml0cywgd29yZFNpemUpO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2VXb3JkcyA9IEVuY29kZXIkMS5iaXRzVG9Xb3JkcyhiaXRBcnJheSwgd29yZFNpemUsIHRvdGFsV29yZHMpO1xuICAgICAgICAgICAgcnMuZW5jb2RlKG1lc3NhZ2VXb3JkcywgdG90YWxXb3JkcyAtIG1lc3NhZ2VTaXplSW5Xb3Jkcyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRQYWQgPSB0b3RhbEJpdHMgJSB3b3JkU2l6ZTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlQml0cyA9IG5ldyBCaXRBcnJheSgpO1xuICAgICAgICAgICAgbWVzc2FnZUJpdHMuYXBwZW5kQml0cygwLCBzdGFydFBhZCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2VXb3JkIC8qOiBpbnQqLyBvZiBBcnJheS5mcm9tKG1lc3NhZ2VXb3JkcykpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlQml0cy5hcHBlbmRCaXRzKG1lc3NhZ2VXb3JkLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZUJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGJpdHNUb1dvcmRzKHN0dWZmZWRCaXRzLCB3b3JkU2l6ZSwgdG90YWxXb3Jkcykge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBuZXcgSW50MzJBcnJheSh0b3RhbFdvcmRzKTtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gc3R1ZmZlZEJpdHMuZ2V0U2l6ZSgpIC8gd29yZFNpemU7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogLyppbnQqLyA9IDA7IGogPCB3b3JkU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIHw9IHN0dWZmZWRCaXRzLmdldChpICogd29yZFNpemUgKyBqKSA/ICgxIDw8IHdvcmRTaXplIC0gaiAtIDEpIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVzc2FnZVtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldEdGKHdvcmRTaXplKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHdvcmRTaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX1BBUkFNO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzY7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfODtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2VuZXJpY0dGLkFaVEVDX0RBVEFfMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEyO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIHdvcmQgc2l6ZSAnICsgd29yZFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBzdHVmZkJpdHMoYml0cywgd29yZFNpemUpIHtcbiAgICAgICAgICAgIGxldCBvdXQgPSBuZXcgQml0QXJyYXkoKTtcbiAgICAgICAgICAgIGxldCBuID0gYml0cy5nZXRTaXplKCk7XG4gICAgICAgICAgICBsZXQgbWFzayA9ICgxIDw8IHdvcmRTaXplKSAtIDI7XG4gICAgICAgICAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbjsgaSArPSB3b3JkU2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqIC8qaW50Ki8gPSAwOyBqIDwgd29yZFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSArIGogPj0gbiB8fCBiaXRzLmdldChpICsgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQgfD0gMSA8PCAod29yZFNpemUgLSAxIC0gaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCh3b3JkICYgbWFzaykgPT09IG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZEJpdHMod29yZCAmIG1hc2ssIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgod29yZCAmIG1hc2spID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5hcHBlbmRCaXRzKHdvcmQgfCAxLCB3b3JkU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5hcHBlbmRCaXRzKHdvcmQsIHdvcmRTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyB0b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuICgoY29tcGFjdCA/IDg4IDogMTEyKSArIDE2ICogbGF5ZXJzKSAqIGxheWVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBFbmNvZGVyJDEuREVGQVVMVF9FQ19QRVJDRU5UID0gMzM7IC8vIGRlZmF1bHQgbWluaW1hbCBwZXJjZW50YWdlIG9mIGVycm9yIGNoZWNrIHdvcmRzXG4gICAgRW5jb2RlciQxLkRFRkFVTFRfQVpURUNfTEFZRVJTID0gMDtcbiAgICBFbmNvZGVyJDEuTUFYX05CX0JJVFMgPSAzMjtcbiAgICBFbmNvZGVyJDEuTUFYX05CX0JJVFNfQ09NUEFDVCA9IDQ7XG4gICAgRW5jb2RlciQxLldPUkRfU0laRSA9IEludDMyQXJyYXkuZnJvbShbXG4gICAgICAgIDQsIDYsIDYsIDgsIDgsIDgsIDgsIDgsIDgsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCxcbiAgICAgICAgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTJcbiAgICBdKTtcblxuICAgIC8qXG4gICAgKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXG4gICAgKlxuICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICpcbiAgICAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgKlxuICAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gQXp0ZWMgY29kZSBhcyBhIHtAbGluayBCaXRNYXRyaXh9LlxuICAgICAqL1xuICAgIC8qcHVibGljIGZpbmFsKi8gY2xhc3MgQXp0ZWNXcml0ZXIge1xuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZVdpdGhIaW50cyhjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAT3ZlcnJpZGVcbiAgICAgICAgZW5jb2RlV2l0aEhpbnRzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGhpbnRzKSB7XG4gICAgICAgICAgICBsZXQgY2hhcnNldCA9IFN0YW5kYXJkQ2hhcnNldHMuSVNPXzg4NTlfMTtcbiAgICAgICAgICAgIGxldCBlY2NQZXJjZW50ID0gRW5jb2RlciQxLkRFRkFVTFRfRUNfUEVSQ0VOVDtcbiAgICAgICAgICAgIGxldCBsYXllcnMgPSBFbmNvZGVyJDEuREVGQVVMVF9BWlRFQ19MQVlFUlM7XG4gICAgICAgICAgICBpZiAoaGludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChoaW50cy5oYXMoRW5jb2RlSGludFR5cGUkMS5DSEFSQUNURVJfU0VUKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gQ2hhcnNldC5mb3JOYW1lKGhpbnRzLmdldChFbmNvZGVIaW50VHlwZSQxLkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGludHMuaGFzKEVuY29kZUhpbnRUeXBlJDEuRVJST1JfQ09SUkVDVElPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgZWNjUGVyY2VudCA9IEludGVnZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuRVJST1JfQ09SUkVDVElPTikudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaW50cy5oYXMoRW5jb2RlSGludFR5cGUkMS5BWlRFQ19MQVlFUlMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IEludGVnZXIucGFyc2VJbnQoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlJDEuQVpURUNfTEFZRVJTKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQXp0ZWNXcml0ZXIuZW5jb2RlTGF5ZXJzKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGNoYXJzZXQsIGVjY1BlcmNlbnQsIGxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGVuY29kZUxheWVycyhjb250ZW50cywgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBjaGFyc2V0LCBlY2NQZXJjZW50LCBsYXllcnMpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IEJhcmNvZGVGb3JtYXQkMS5BWlRFQykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0NhbiBvbmx5IGVuY29kZSBBWlRFQywgYnV0IGdvdCAnICsgZm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhenRlYyA9IEVuY29kZXIkMS5lbmNvZGUoU3RyaW5nVXRpbHMuZ2V0Qnl0ZXMoY29udGVudHMsIGNoYXJzZXQpLCBlY2NQZXJjZW50LCBsYXllcnMpO1xuICAgICAgICAgICAgcmV0dXJuIEF6dGVjV3JpdGVyLnJlbmRlclJlc3VsdChhenRlYywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBjb2RlLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5wdXRXaWR0aCA9IGlucHV0LmdldFdpZHRoKCk7XG4gICAgICAgICAgICBsZXQgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRXaWR0aCA9IE1hdGgubWF4KHdpZHRoLCBpbnB1dFdpZHRoKTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGlucHV0SGVpZ2h0KTtcbiAgICAgICAgICAgIGxldCBtdWx0aXBsZSA9IE1hdGgubWluKG91dHB1dFdpZHRoIC8gaW5wdXRXaWR0aCwgb3V0cHV0SGVpZ2h0IC8gaW5wdXRIZWlnaHQpO1xuICAgICAgICAgICAgbGV0IGxlZnRQYWRkaW5nID0gKG91dHB1dFdpZHRoIC0gKGlucHV0V2lkdGggKiBtdWx0aXBsZSkpIC8gMjtcbiAgICAgICAgICAgIGxldCB0b3BQYWRkaW5nID0gKG91dHB1dEhlaWdodCAtIChpbnB1dEhlaWdodCAqIG11bHRpcGxlKSkgLyAyO1xuICAgICAgICAgICAgbGV0IG91dHB1dCA9IG5ldyBCaXRNYXRyaXgob3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbnB1dFkgLyppbnQqLyA9IDAsIG91dHB1dFkgPSB0b3BQYWRkaW5nOyBpbnB1dFkgPCBpbnB1dEhlaWdodDsgaW5wdXRZKyssIG91dHB1dFkgKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgY29udGVudHMgb2YgdGhpcyByb3cgb2YgdGhlIGJhcmNvZGVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbnB1dFggLyppbnQqLyA9IDAsIG91dHB1dFggPSBsZWZ0UGFkZGluZzsgaW5wdXRYIDwgaW5wdXRXaWR0aDsgaW5wdXRYKyssIG91dHB1dFggKz0gbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldChpbnB1dFgsIGlucHV0WSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRSZWdpb24ob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLkFic3RyYWN0RXhwYW5kZWREZWNvZGVyID0gQWJzdHJhY3RFeHBhbmRlZERlY29kZXI7XG4gICAgZXhwb3J0cy5Bcmd1bWVudEV4Y2VwdGlvbiA9IEFyZ3VtZW50RXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuQXJpdGhtZXRpY0V4Y2VwdGlvbiA9IEFyaXRobWV0aWNFeGNlcHRpb247XG4gICAgZXhwb3J0cy5BenRlY0NvZGUgPSBBenRlY0NvZGU7XG4gICAgZXhwb3J0cy5BenRlY0NvZGVSZWFkZXIgPSBBenRlY1JlYWRlcjtcbiAgICBleHBvcnRzLkF6dGVjQ29kZVdyaXRlciA9IEF6dGVjV3JpdGVyO1xuICAgIGV4cG9ydHMuQXp0ZWNEZWNvZGVyID0gRGVjb2RlcjtcbiAgICBleHBvcnRzLkF6dGVjRGV0ZWN0b3IgPSBEZXRlY3RvcjtcbiAgICBleHBvcnRzLkF6dGVjRGV0ZWN0b3JSZXN1bHQgPSBBenRlY0RldGVjdG9yUmVzdWx0O1xuICAgIGV4cG9ydHMuQXp0ZWNFbmNvZGVyID0gRW5jb2RlciQxO1xuICAgIGV4cG9ydHMuQXp0ZWNIaWdoTGV2ZWxFbmNvZGVyID0gSGlnaExldmVsRW5jb2RlcjtcbiAgICBleHBvcnRzLkF6dGVjUG9pbnQgPSBQb2ludDtcbiAgICBleHBvcnRzLkJhcmNvZGVGb3JtYXQgPSBCYXJjb2RlRm9ybWF0JDE7XG4gICAgZXhwb3J0cy5CaW5hcml6ZXIgPSBCaW5hcml6ZXI7XG4gICAgZXhwb3J0cy5CaW5hcnlCaXRtYXAgPSBCaW5hcnlCaXRtYXA7XG4gICAgZXhwb3J0cy5CaXRBcnJheSA9IEJpdEFycmF5O1xuICAgIGV4cG9ydHMuQml0TWF0cml4ID0gQml0TWF0cml4O1xuICAgIGV4cG9ydHMuQml0U291cmNlID0gQml0U291cmNlO1xuICAgIGV4cG9ydHMuQnJvd3NlckF6dGVjQ29kZVJlYWRlciA9IEJyb3dzZXJBenRlY0NvZGVSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyQmFyY29kZVJlYWRlciA9IEJyb3dzZXJCYXJjb2RlUmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlckNvZGVSZWFkZXIgPSBCcm93c2VyQ29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlciA9IEJyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlciA9IEJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlcjtcbiAgICBleHBvcnRzLkJyb3dzZXJQREY0MTdSZWFkZXIgPSBCcm93c2VyUERGNDE3UmVhZGVyO1xuICAgIGV4cG9ydHMuQnJvd3NlclFSQ29kZVJlYWRlciA9IEJyb3dzZXJRUkNvZGVSZWFkZXI7XG4gICAgZXhwb3J0cy5Ccm93c2VyUVJDb2RlU3ZnV3JpdGVyID0gQnJvd3NlclFSQ29kZVN2Z1dyaXRlcjtcbiAgICBleHBvcnRzLkNoYXJhY3RlclNldEVDSSA9IENoYXJhY3RlclNldEVDSTtcbiAgICBleHBvcnRzLkNoZWNrc3VtRXhjZXB0aW9uID0gQ2hlY2tzdW1FeGNlcHRpb247XG4gICAgZXhwb3J0cy5Db2RlMTI4UmVhZGVyID0gQ29kZTEyOFJlYWRlcjtcbiAgICBleHBvcnRzLkNvZGUzOVJlYWRlciA9IENvZGUzOVJlYWRlcjtcbiAgICBleHBvcnRzLkRhdGFNYXRyaXhEZWNvZGVkQml0U3RyZWFtUGFyc2VyID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcbiAgICBleHBvcnRzLkRhdGFNYXRyaXhSZWFkZXIgPSBEYXRhTWF0cml4UmVhZGVyO1xuICAgIGV4cG9ydHMuRGVjb2RlSGludFR5cGUgPSBEZWNvZGVIaW50VHlwZSQxO1xuICAgIGV4cG9ydHMuRGVjb2RlclJlc3VsdCA9IERlY29kZXJSZXN1bHQ7XG4gICAgZXhwb3J0cy5EZWZhdWx0R3JpZFNhbXBsZXIgPSBEZWZhdWx0R3JpZFNhbXBsZXI7XG4gICAgZXhwb3J0cy5EZXRlY3RvclJlc3VsdCA9IERldGVjdG9yUmVzdWx0O1xuICAgIGV4cG9ydHMuRUFOMTNSZWFkZXIgPSBFQU4xM1JlYWRlcjtcbiAgICBleHBvcnRzLkVuY29kZUhpbnRUeXBlID0gRW5jb2RlSGludFR5cGUkMTtcbiAgICBleHBvcnRzLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkZvcm1hdEV4Y2VwdGlvbiA9IEZvcm1hdEV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkdlbmVyaWNHRiA9IEdlbmVyaWNHRjtcbiAgICBleHBvcnRzLkdlbmVyaWNHRlBvbHkgPSBHZW5lcmljR0ZQb2x5O1xuICAgIGV4cG9ydHMuR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyO1xuICAgIGV4cG9ydHMuR3JpZFNhbXBsZXIgPSBHcmlkU2FtcGxlcjtcbiAgICBleHBvcnRzLkdyaWRTYW1wbGVySW5zdGFuY2UgPSBHcmlkU2FtcGxlckluc3RhbmNlO1xuICAgIGV4cG9ydHMuSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UgPSBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZTtcbiAgICBleHBvcnRzLkh5YnJpZEJpbmFyaXplciA9IEh5YnJpZEJpbmFyaXplcjtcbiAgICBleHBvcnRzLklURlJlYWRlciA9IElURlJlYWRlcjtcbiAgICBleHBvcnRzLklsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLklsbGVnYWxTdGF0ZUV4Y2VwdGlvbiA9IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbjtcbiAgICBleHBvcnRzLkludmVydGVkTHVtaW5hbmNlU291cmNlID0gSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2U7XG4gICAgZXhwb3J0cy5MdW1pbmFuY2VTb3VyY2UgPSBMdW1pbmFuY2VTb3VyY2U7XG4gICAgZXhwb3J0cy5NYXRoVXRpbHMgPSBNYXRoVXRpbHM7XG4gICAgZXhwb3J0cy5NdWx0aUZvcm1hdE9uZURSZWFkZXIgPSBNdWx0aUZvcm1hdE9uZURSZWFkZXI7XG4gICAgZXhwb3J0cy5NdWx0aUZvcm1hdFJlYWRlciA9IE11bHRpRm9ybWF0UmVhZGVyO1xuICAgIGV4cG9ydHMuTXVsdGlGb3JtYXRXcml0ZXIgPSBNdWx0aUZvcm1hdFdyaXRlcjtcbiAgICBleHBvcnRzLk5vdEZvdW5kRXhjZXB0aW9uID0gTm90Rm91bmRFeGNlcHRpb247XG4gICAgZXhwb3J0cy5PbmVEUmVhZGVyID0gT25lRFJlYWRlcjtcbiAgICBleHBvcnRzLlBERjQxN0RlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyJDI7XG4gICAgZXhwb3J0cy5QREY0MTdEZWNvZGVyRXJyb3JDb3JyZWN0aW9uID0gRXJyb3JDb3JyZWN0aW9uO1xuICAgIGV4cG9ydHMuUERGNDE3UmVhZGVyID0gUERGNDE3UmVhZGVyO1xuICAgIGV4cG9ydHMuUERGNDE3UmVzdWx0TWV0YWRhdGEgPSBQREY0MTdSZXN1bHRNZXRhZGF0YTtcbiAgICBleHBvcnRzLlBlcnNwZWN0aXZlVHJhbnNmb3JtID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm07XG4gICAgZXhwb3J0cy5QbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UgPSBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2U7XG4gICAgZXhwb3J0cy5RUkNvZGVCeXRlTWF0cml4ID0gQnl0ZU1hdHJpeDtcbiAgICBleHBvcnRzLlFSQ29kZURhdGFNYXNrID0gRGF0YU1hc2s7XG4gICAgZXhwb3J0cy5RUkNvZGVEZWNvZGVkQml0U3RyZWFtUGFyc2VyID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlciQxO1xuICAgIGV4cG9ydHMuUVJDb2RlRGVjb2RlckVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgZXhwb3J0cy5RUkNvZGVEZWNvZGVyRm9ybWF0SW5mb3JtYXRpb24gPSBGb3JtYXRJbmZvcm1hdGlvbjtcbiAgICBleHBvcnRzLlFSQ29kZUVuY29kZXIgPSBFbmNvZGVyO1xuICAgIGV4cG9ydHMuUVJDb2RlRW5jb2RlclFSQ29kZSA9IFFSQ29kZTtcbiAgICBleHBvcnRzLlFSQ29kZU1hc2tVdGlsID0gTWFza1V0aWw7XG4gICAgZXhwb3J0cy5RUkNvZGVNYXRyaXhVdGlsID0gTWF0cml4VXRpbDtcbiAgICBleHBvcnRzLlFSQ29kZU1vZGUgPSBNb2RlJDE7XG4gICAgZXhwb3J0cy5RUkNvZGVSZWFkZXIgPSBRUkNvZGVSZWFkZXI7XG4gICAgZXhwb3J0cy5RUkNvZGVWZXJzaW9uID0gVmVyc2lvbiQxO1xuICAgIGV4cG9ydHMuUVJDb2RlV3JpdGVyID0gUVJDb2RlV3JpdGVyO1xuICAgIGV4cG9ydHMuUkdCTHVtaW5hbmNlU291cmNlID0gUkdCTHVtaW5hbmNlU291cmNlO1xuICAgIGV4cG9ydHMuUlNTMTRSZWFkZXIgPSBSU1MxNFJlYWRlcjtcbiAgICBleHBvcnRzLlJTU0V4cGFuZGVkUmVhZGVyID0gUlNTRXhwYW5kZWRSZWFkZXI7XG4gICAgZXhwb3J0cy5SZWFkZXJFeGNlcHRpb24gPSBSZWFkZXJFeGNlcHRpb247XG4gICAgZXhwb3J0cy5SZWVkU29sb21vbkRlY29kZXIgPSBSZWVkU29sb21vbkRlY29kZXI7XG4gICAgZXhwb3J0cy5SZWVkU29sb21vbkVuY29kZXIgPSBSZWVkU29sb21vbkVuY29kZXI7XG4gICAgZXhwb3J0cy5SZWVkU29sb21vbkV4Y2VwdGlvbiA9IFJlZWRTb2xvbW9uRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuUmVzdWx0ID0gUmVzdWx0O1xuICAgIGV4cG9ydHMuUmVzdWx0TWV0YWRhdGFUeXBlID0gUmVzdWx0TWV0YWRhdGFUeXBlJDE7XG4gICAgZXhwb3J0cy5SZXN1bHRQb2ludCA9IFJlc3VsdFBvaW50O1xuICAgIGV4cG9ydHMuU3RyaW5nVXRpbHMgPSBTdHJpbmdVdGlscztcbiAgICBleHBvcnRzLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uID0gVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb247XG4gICAgZXhwb3J0cy5WaWRlb0lucHV0RGV2aWNlID0gVmlkZW9JbnB1dERldmljZTtcbiAgICBleHBvcnRzLldoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IgPSBXaGl0ZVJlY3RhbmdsZURldGVjdG9yO1xuICAgIGV4cG9ydHMuV3JpdGVyRXhjZXB0aW9uID0gV3JpdGVyRXhjZXB0aW9uO1xuICAgIGV4cG9ydHMuWlhpbmdBcnJheXMgPSBBcnJheXM7XG4gICAgZXhwb3J0cy5aWGluZ0NoYXJzZXQgPSBDaGFyc2V0O1xuICAgIGV4cG9ydHMuWlhpbmdJbnRlZ2VyID0gSW50ZWdlcjtcbiAgICBleHBvcnRzLlpYaW5nU3RhbmRhcmRDaGFyc2V0cyA9IFN0YW5kYXJkQ2hhcnNldHM7XG4gICAgZXhwb3J0cy5aWGluZ1N0cmluZ0J1aWxkZXIgPSBTdHJpbmdCdWlsZGVyO1xuICAgIGV4cG9ydHMuWlhpbmdTdHJpbmdFbmNvZGluZyA9IFN0cmluZ0VuY29kaW5nO1xuICAgIGV4cG9ydHMuWlhpbmdTeXN0ZW0gPSBTeXN0ZW07XG4gICAgZXhwb3J0cy5jcmVhdGVBYnN0cmFjdEV4cGFuZGVkRGVjb2RlciA9IGNyZWF0ZURlY29kZXI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/html5-qrcode/third_party/zxing-js.umd.js\n\n}");

/***/ })

}]);